<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2018-08-01T09:58:24.883Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三周笔记-redis</title>
    <link href="bighua.top/2018/08/01/%E7%AC%AC%E4%B8%89%E5%91%A8%E7%AC%94%E8%AE%B0-redis/"/>
    <id>bighua.top/2018/08/01/第三周笔记-redis/</id>
    <published>2018-08-01T01:40:15.000Z</published>
    <updated>2018-08-01T09:58:24.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h3><table><thead><tr><th style="text-align:left">结构类型</th><th style="text-align:left">结构存储的值</th><th style="text-align:left">结构的读写能力</th></tr></thead><tbody><tr><td style="text-align:left">STRING</td><td style="text-align:left">字符串、整数或者浮点数</td><td style="text-align:left">对整个字符串或者字符串中的一部分执行操作；整数或浮点数自增、自减操作</td></tr><tr><td style="text-align:left">LIST</td><td style="text-align:left">链表，链表上的每个节点都包含了一个字符串</td><td style="text-align:left">链表两端推入或者弹出元素；根据便宜量对链表进行修剪；读取单个或多个元素；根据指查找或着移除元素</td></tr><tr><td style="text-align:left">SET</td><td style="text-align:left">字符串的无序收集器，被包含的每个字符串都是独一无二的、各不相同的</td><td style="text-align:left">添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td style="text-align:left">HASH</td><td style="text-align:left">包含键值对的无序散列表</td><td style="text-align:left">添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td style="text-align:left">ZSET（有序集合）</td><td style="text-align:left">字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td><td style="text-align:left">添加、获取、删除单个元素；根据分值范围或者成员来获取元素</td></tr></tbody></table><h4 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h4><p>与其他编程语言或者其他键值存储提供的字符串非常相似。</p><h4 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h4><p>一个列表结构可以有序地存储多个字符串。可执行的操作与很多编程语言中的列表操作非常相似。</p><h4 id="Redis中的集合"><a href="#Redis中的集合" class="headerlink" title="Redis中的集合"></a>Redis中的集合</h4><p>存储多个字符串，不同于列表，集合使用无序方式存储元素，使用散列表保证存储的每个字符串都是不同的。</p><h4 id="Redis中的散列"><a href="#Redis中的散列" class="headerlink" title="Redis中的散列"></a>Redis中的散列</h4><p>存储多个键值对之间的映射，散列存储的值既可以是字符串也可以是数字值。类似文档数据库中的文档，关系数据库中的行，允许用户同时访问或者修改一个或多个域。</p><h4 id="Redis中的有序集合"><a href="#Redis中的有序集合" class="headerlink" title="Redis中的有序集合"></a>Redis中的有序集合</h4><p>用于存储键值对，键被称为成员，每个成员各不相同，值被称为分值，分值必须为浮点数。唯一既可以根据成员访问元素，又可以根据分值及分值的排列顺序来访问元素的结构。</p><h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Redis中的自增命令和自减命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> LNCR</td><td style="text-align:left">INCR key-name——将键存储的值加上1</td></tr><tr><td style="text-align:left"> DECR</td><td style="text-align:left">DECR key-name——将键存储的值减去1</td></tr><tr><td style="text-align:left"> INCRBY</td><td style="text-align:left">INCRBY key-name amount——将键存储的值加上amount</td></tr><tr><td style="text-align:left"> DECRBY</td><td style="text-align:left">DECRBY key-name amount——将键存储的值减去amount</td></tr><tr><td style="text-align:left"> INCRBYFLOAT</td><td style="text-align:left">INCRBYFLOAT key-name amount——将键存储的值加上浮点数amount，redis v2.6+</td></tr></tbody></table><p>存储时，若值可被解释（interpret）为十进制整数或者浮点数，则允许用户对字符串执行各种INCR*和DECR*操作。对不存在的键或者保存了空串的键执行自增或者自减操作，Redis执行操作时将键的值当作0处理。对无法解释为整数或浮点数的字符串键执行自增或自减操作，将向用户返回一个错误。</p><p>处理子串和二进制位的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> APPEND</td><td style="text-align:left">APPEND key-name value——将值value追加到给定键key-name当前存储的值的末尾</td></tr><tr><td style="text-align:left"> GETRANGE</td><td style="text-align:left">GETRANGE key-name start end——获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内。</td></tr><tr><td style="text-align:left"> SETRANGE</td><td style="text-align:left">SETRANGE key-name offset value——将start偏移量开始的子串设置为给定值</td></tr><tr><td style="text-align:left"> GETBIT</td><td style="text-align:left">GETBIT key-name offset——将子节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设置为value</td></tr><tr><td style="text-align:left"> BITCOUNT</td><td style="text-align:left">BITCOUNT key-name [start end]——统计二进制位串里面值为1的二进制位的数量，若给定偏移量start和end，则只对偏移量指定范围内的二进制位进行统计</td></tr><tr><td style="text-align:left"> BITOP</td><td style="text-align:left">BITOP operation dest-key key-name [key-name …]——对一个或多个二进制位串执行包括并（AND）、或（OR）、异或（XOR）、非（NOT）在内的任意一种按位运算操作，并将计算结果保存在dest-key键里</td></tr></tbody></table><p> 使用STRANGE或者SETBIT命令对字符串进行写入的时候，若字符串当前的长度不能满足写入的要求，Redis会自动地使用空字节（null）将字符串扩展至所需的长度，然后才执行写入或者更新操作。使用GETRANGE读取字符串，超出字符串末尾的数据会被视为是空串，使用GETBIT读取二进制位串，超出字符串末尾的二进制位会被视为0。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p> 常用的列表命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> RPUSH</td><td style="text-align:left">RPUSH key-name value [value …]——将一个或多个值推入列表的右端</td></tr><tr><td style="text-align:left"> LPUSH</td><td style="text-align:left">LPUSH key-name value [value …]——将一个或多个值推入列表的左端</td></tr><tr><td style="text-align:left"> RPOP</td><td style="text-align:left">RPOP key-name——移除并返回列表最右端的元素</td></tr><tr><td style="text-align:left"> LPOP</td><td style="text-align:left">LPOP key-name——移除并返回列表最左端的元素</td></tr><tr><td style="text-align:left"> LINDEX</td><td style="text-align:left">LINDEX key-name offset——返回列表中偏移量为offset的元素</td></tr><tr><td style="text-align:left"> LRANGE</td><td style="text-align:left">LRANGE key-name start end——返回列表从start偏移量到end偏移量范围内的所有元素，偏移量start和end的元素也会包含在被返回的元素之内</td></tr><tr><td style="text-align:left"> LTRIM</td><td style="text-align:left">LTRIM ley-name start end——对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，偏移量start和end的元素也会保留</td></tr></tbody></table><p>阻塞式的列表弹出民命令以及在列表之间移动元素的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> BLPOP</td><td style="text-align:left">BLPOP key-name [key-name …] timeout——从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left"> BRPOP</td><td style="text-align:left">BRPOP key-name [key-name …] timeout——从第一个非空列表中掏出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left"> RPOPLPUSH</td><td style="text-align:left">RPOPLPUSH source-key dest-key——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td></tr><tr><td style="text-align:left"> BRPOPLPUSH</td><td style="text-align:left">BRPOPLPUSH source-key dest-key timeout——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素，若source-key为空，则在timeout秒之内阻塞并等待可弹出的元素出现</td></tr></tbody></table><p> 应用于消息传递、任务队列。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>以无序的方式存储多个各不相同的元素。</p><p>常用集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> SADD</td><td style="text-align:left">SADD key-name item [item …]——将一个或多个元素添加到集合中，并返回被添加元素当中原本并不存在于集合里面的元素数量</td></tr><tr><td style="text-align:left"> SREM</td><td style="text-align:left">SREM key-name item [item …]——从集合里面移除一个或多个元素，并返回被移除元素的数量</td></tr><tr><td style="text-align:left"> SISMEMBER</td><td style="text-align:left">SISMEMBER key-name item——检查元素item是否存在于集合key-name里</td></tr><tr><td style="text-align:left"> SCARD</td><td style="text-align:left">SCARD key-name——返回集合包含的元素的数量</td></tr><tr><td style="text-align:left"> SMEMBERS</td><td style="text-align:left">SMEMBERS key-name——返回集合包含的所有元素</td></tr><tr><td style="text-align:left"> SRANDMEMBER</td><td style="text-align:left">SRANDMEMBER key-name [count]——从集合里面随机地返回一个或多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td></tr><tr><td style="text-align:left"> SPOP</td><td style="text-align:left">SPOP key-name——随机地移除集合中的一个元素，并返回被移除的元素</td></tr><tr><td style="text-align:left"> SMOVE</td><td style="text-align:left">SMOVE source-key dest-key item——若集合source-key包含元素item，从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；若item被成功移除，命令返回1，否则返回0</td></tr></tbody></table><p>组合和处理多个集合的redis命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述 </th></tr></thead><tbody><tr><td style="text-align:left"> SDIFF</td><td style="text-align:left">SDIFF key-name [key-name …]——返回那些存在于第一个集合、但不存在于其他集合中的元素（差集运算）</td></tr><tr><td style="text-align:left"> SDIFFSTORE</td><td style="text-align:left">SDIFFSTORE dest-key key-name [key-name …]——将存在于第一个集合但并不存在于其他集合中的元素（差集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left"> SINTER</td><td style="text-align:left">SINTER key-name [key-name …]——返回那些同时存在于所有集合中的元素（交集运算）</td></tr><tr><td style="text-align:left"> SINTERSTORE</td><td style="text-align:left">SINTERSTORE dest-key key-name [key-name …]——将同时存在于所有集合中的元素（交集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left"> SUNION</td><td style="text-align:left">SUNION key-name [key-name …]——返回至少存在于一个集合中的元素（并集运算）</td></tr><tr><td style="text-align:left"> SUNIONSTORE</td><td style="text-align:left">SUNIONSTORE desk-key key-name [key-name …]——将至少存在于一个集合中的元素（并集运算）存储到dest-key键里面</td></tr></tbody></table><h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><p>适用于将一些相关的数据存储在一起。</p><p>添加和删除键值对的散列操作：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> HMGET</td><td style="text-align:left">HMGET key-name key [key …]——从散列里面获取一个或多个键的值</td></tr><tr><td style="text-align:left"> HMSET</td><td style="text-align:left">HMSET key-name key value [key value …]——为散列里面的一个或多个键设置值</td></tr><tr><td style="text-align:left"> HDEL</td><td style="text-align:left">HDEL key-name key [key …]——删除散列里面的一个或多个键值对，返回成功找到并删除的键值对的数量</td></tr><tr><td style="text-align:left"> HLEN</td><td style="text-align:left">HLEN key-name——返回散列包含的键值对的数量</td></tr></tbody></table><p>散列的批量操作命令以及和字符串操作类似的散列命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> HEXISTS</td><td style="text-align:left">HEXISTS key-name key——检查给定键是否存在于散列中</td></tr><tr><td style="text-align:left"> HKEYS</td><td style="text-align:left">HKEYS key-name——获取散列包含的所有键</td></tr><tr><td style="text-align:left"> HVALS</td><td style="text-align:left">HVALS key-name——获取散列包含的所有值</td></tr><tr><td style="text-align:left"> HGETALL</td><td style="text-align:left">HGETALL key-name——获取散列包含的所有键值对</td></tr><tr><td style="text-align:left"> HINCRBY</td><td style="text-align:left">HINCRBY key-name key increment——将键key存储的值加上整数increment</td></tr><tr><td style="text-align:left"> HINCRBYFLOAT</td><td style="text-align:left">HINCRBYFLOAT key-name key increment——将键key存储的值加上浮点数increment </td></tr></tbody></table><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>存储着成员与分值之间的映射，提供了分值处理命令，分值在Redis中以IEEE 175双精度浮点数的格式存储。</p><p>常用的有序集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> ZADD</td><td style="text-align:left">ZADD key-name score member [score member …]——将带有给定分值的成员添加到有序集合里面</td></tr><tr><td style="text-align:left"> ZREM</td><td style="text-align:left">ZREM key-name member [member …]——从有序集合里面移除给定的成员，并返回被移除成员的数量</td></tr><tr><td style="text-align:left"> ZCARD</td><td style="text-align:left">ZCARD key-name——返回有序集合包含的成员数量</td></tr><tr><td style="text-align:left"> ZINCRBY</td><td style="text-align:left">ZINCRBY key-name increment member——将member成员的分值加上increment</td></tr><tr><td style="text-align:left"> ZCOUNT</td><td style="text-align:left">ZCOUNT key-name min max——返回分值介于min和max之间的成员数量</td></tr><tr><td style="text-align:left"> ZRANK</td><td style="text-align:left">ZRANK key-name member——返回成员member在有序集合中的排名</td></tr><tr><td style="text-align:left"> ZSCORE</td><td style="text-align:left">ZSCORE key-name member——返回成员memebr的分值</td></tr><tr><td style="text-align:left"> ZRANGE</td><td style="text-align:left">ZRANGE key-name start stop [WITHSCORES]——返回有序集合中排名介于start和stop之间的成员，若给定了可选的WITHSCORES选项，则命令会将成员的分值一并返回</td></tr></tbody></table><p>有序集合的范围型数据获取命令和范围型数据删除命令、并集命令、交集命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> ZREVRANK</td><td style="text-align:left">ZREVRANK key-name member——返回有序集合里成员member的排名，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left"> ZREVRANGE</td><td style="text-align:left">ZREVRANGE key-name start stop [WITHSCORES]——返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left"> ZRANGEBYSCORE</td><td style="text-align:left">ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]——返回有序集合中，分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left"> ZREVRANGEBYSCORE</td><td style="text-align:left">ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]——获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返回它们</td></tr><tr><td style="text-align:left"> ZREMRANGEBYRANK</td><td style="text-align:left">ZREMRANGEBYRANK key-name start stop——移除有序集合中排名介于start和stop之间的所有所有成员</td></tr><tr><td style="text-align:left"> ZREMRANGEBYSCORE</td><td style="text-align:left">ZREMRANGEBYSCORE key-name min max——移除有序集合中分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left"> ZINTERSTORE</td><td style="text-align:left">ZINTERSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的交集运算</td></tr><tr><td style="text-align:left"> ZUNIONSTORE</td><td style="text-align:left">ZUNIONSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的并集运算</td></tr></tbody></table><h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><p>发布与订阅（pub/sub）是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息。当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。</p><p>发布与订阅命令： </p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> SUBSCRIBE</td><td style="text-align:left">SUBSCRIBE channel [channel …]——订阅给定的一个或多个频道</td></tr><tr><td style="text-align:left"> UNSUBSCRIBE</td><td style="text-align:left">UNSUBSCRIBE [channel [channel …]]——退订给定的一个或多个频道，若执行时没给定频道，则退订所有频道</td></tr><tr><td style="text-align:left"> PUBLISH</td><td style="text-align:left">PUBLISH channel message——向给定频道发送消息</td></tr><tr><td style="text-align:left"> PSUBSCRIBE</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]——订阅与给定模式相匹配的所有频道</td></tr><tr><td style="text-align:left"> PUNSUBSCRIBE</td><td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]——退订给定的模式，如果执行时没有给定任何模式，则退订所有模式</td></tr></tbody></table><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>同其他编程语言的排序操作，可以根据某种比较规则对一系列元素进行有序的排列。可根据字符串、列表、集合、有序集合、散列这5种键里面存储着的数据，对列表、集合以及有序集合进行排序，相当于SQL中的order by子句。</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"> SORT</td><td style="text-align:left">SORT source-key [BY pattern][LIMIT offset count][GET pattern [GET PATTERN …]][ASC &#124; DESC][ALPHA][STORE dest-key]——根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</td></tr></tbody></table><p> 可实现的功能：根据降序而不是默认的升序来排序元素；将元素看作是数字来进行排序，或则将元素看作是数字来进行排序，或者将元素看作是二进制字符串来进行排序；使用被排序元素之外的其他值作为权重来进行排序，可从输入的列表、集合、有序集合以外的其他地方进行取值。</p><p> 对集合进行排序返回一个列表形式的排序结果。</p><h5 id="基本的Redis事务"><a href="#基本的Redis事务" class="headerlink" title="基本的Redis事务"></a>基本的Redis事务</h5><p>让用户在不被打断的情况下对多个键执行操作：WATCH、MULTI、EXEC、UNWATCH和DISCARD。</p><p>基本事务（basic transaction）使用MULTI命令和EXEC命令，让一个客户端在不被其他客户端打断的情况下执行多个命令。被MULTI命令和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。事务执行后，Redis才会处理其他客户端的命令。</p><p>Redis接收到MULTI命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送EXEC命令为止，接着Redis在不被打断的情况下，一个接一个地执行存储在队列里面的命令。</p><h5 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h5><p>指Redis会在键的过期时间到达时自动删除该键。</p><p>为键设置过期时间的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">示例和描述</th></tr></thead><tbody><tr><td style="text-align:left">  PERSIST</td><td style="text-align:left">PERSIST key-name——移除键的过期时间</td></tr><tr><td style="text-align:left">  TTL</td><td style="text-align:left">TTL key-name——查看给定键距离过期还有多少秒</td></tr><tr><td style="text-align:left">  EXPIRE</td><td style="text-align:left">EXPIRE key-name seconds——让给定键在指定的秒数之后过期</td></tr><tr><td style="text-align:left">  EXPIREAT</td><td style="text-align:left">EXPIREAT key-name timestamp——将给定键的过期时间设置为给定的UNIX时间戳</td></tr><tr><td style="text-align:left">  PTTL</td><td style="text-align:left">PTTL key-name——查看给定键距离过期时间还有多少毫秒，Redis V2.6+</td></tr><tr><td style="text-align:left">  PEXPIRE</td><td style="text-align:left">PEXPIRE key-name milliseconds——让给定键在指定的毫秒数之后过期，Redis V2.6+</td></tr><tr><td style="text-align:left">  PEXPIREAT</td><td style="text-align:left">PEXPIREAT key-name timestamp-milliseconds——将一个毫秒级精度的UNIX时间戳设置为给定键的过期时间，Redis V2.6+ </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis基本数据结构&quot;&gt;&lt;a href=&quot;#redis基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis基本数据结构&quot;&gt;&lt;/a&gt;redis基本数据结构&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>第三周笔记-Mysql</title>
    <link href="bighua.top/2018/07/30/%E7%AC%AC%E4%B8%89%E5%91%A8%E7%AC%94%E8%AE%B0-Mysql/"/>
    <id>bighua.top/2018/07/30/第三周笔记-Mysql/</id>
    <published>2018-07-30T02:24:01.000Z</published>
    <updated>2018-07-31T12:02:21.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>参考文档 ：《高性能MySql》 </p><p>其他：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程</a>.  <a href="https://www.cnblogs.com/whgk/p/6179612.html" target="_blank" rel="noopener">MySQL中的索引详讲</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构。——《高性能MySql-创建高性能的索引》</p></blockquote><blockquote><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p></blockquote><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>创建索引时，需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>索引是在存储引擎层而不是服务器层实现的，没有统一的索引标准，多半为B-Tree索引。B-Tree索引适用于全键值、键值范围或键前缀查找，键前缀查找只适用于根据最左前缀的查找。索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p><p>三星策略：索引将相关的记录放在一起为一星，索引中的数据顺序与查找中的排列顺序一致为二星，索引中的列包含了查询中需要的全部列为三星。</p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><p>修改表结构(添加索引):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>删除索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure><p>修改表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h5><pre><code>*ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。*ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。*ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。*ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</code></pre><p>待阅读了解：<a href="https://www.cnblogs.com/yank/p/4193820.html" target="_blank" rel="noopener"><code>触发器</code></a>。</p><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>参考博文：<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>、<a href="https://www.cnblogs.com/mysql-dba/p/6689597.html" target="_blank" rel="noopener">深入浅出分析MySQL索引设计背后的数据结构</a>]</p><p>上方博文主要讲解了mysql使用b+tree作为索引结构，但innoDB和MyISAM的具体实现方式也是不同的。</p><p>在mysql中还有以基于哈希表实现的哈希索引，只有Memory引擎显示支持哈希索引。</p><p>InnoDB引擎有个特殊功能“自适应哈希索引”，当InnoDB注意到某些索引值被使用得非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引。是完全自动的，内部的行为。</p><p>InnoDB中必须包含AUTO_INCREMENT类型字段的索引（建议做主键），MyISAM不需要。</p><h4 id="索引利用"><a href="#索引利用" class="headerlink" title="索引利用"></a>索引利用</h4><p>参考博文：<a href="https://www.cnblogs.com/gossip/p/5707528.html" target="_blank" rel="noopener">索引的特点及使用</a></p><p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。包含多个列，列的顺序也十分重要，MySql只能高效的使用索引的最左前缀列。  </p><p>MyISAM表支持空间索引，用作地理空间数据存储。无须前缀查询，会从所有维度来索引数据。详细省略。</p><p>在相同的列上创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p><p>索引优点：</p><ul><li>减少了服务器需要扫描的数据量。</li><li>帮助服务器避免排序和临时表（ORDER BY和GROUP BY操作）。</li><li>将随机IO变为顺序IO。</li></ul><blockquote><p>非常小的表，简单的全表扫描更高效。索引适用中到大型的表，特大型的表，建立和使用索引的代价随之增长（使用分区技术）。</p></blockquote><blockquote><p>创建自定义哈希索引：适用于类似存储大量url的场景，因url本身很长，使用B-Tree进行查找存储的内容会很大，在数据表中新增被索引url_crc列，存储url的哈希结果（使用CRC32做哈希），在where子句中手动指定哈希函数进行查找。不建议使用SHA1()和MD5()作为哈希函数，因哈希值过长浪费空间，比较时慢。</p></blockquote><h4 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h4><ul><li>独立的列：索引列不能是表达式的一部分，也不能是函数的参数。始终将索引列单独放在比较符号的一侧。</li><li>前缀索引和索引选择性：除模拟哈希索引，可以索引开始的部分字符，节约索引空间，提高索引效率。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高。<code>mysql无法使用前缀索引做ORDER BY和GROUP BY，无法使用前缀索引做覆盖扫描</code>。可考虑字符串反转后建立前缀索引实现后缀索引，通过<code>触发器</code>维护这种索引。</li><li>多列索引：若没建多列索引有单列索引，5.0以上版本会将查询条件中的每列单独索引进行扫描，并将结果进行合并，这种策略会导致消耗更多的CPU和内存资源。可以通过参数optimizer_switch关闭索引合并功能，使用IGNORE INDEX提示让优化器忽略掉某些索引。</li><li>选择合适的索引列排序：索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。正确的顺序依赖于使用该索引的查询，索引可以按照升序或者降序进行扫描，已满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询需求。将选择性最高的列放到索引最前列利于where条件的查找，注意特殊情况的对待。</li><li>聚簇索引：InnoDB通过主键聚簇数据，没定义主键将选择一个唯一的非空索引替代，若无，会隐式定义一个主键来作为聚簇索引。聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。一般使用自增列作为聚簇索引，避免随机聚簇索引，特别是对于I/O密集型应用。对于高并发场景，自增列会造成明显的争用，主键的上届会成为“热点”，导致间隙锁竞争。</li><li>覆盖索引：包含所有需要查询的字段的值，索引的叶子结点中已经包含要查询的数据，查询只需扫描索引无需回表。覆盖索引必须要存储索引列的值，使用B-Tree索引做覆盖索引。</li><li>使用索引扫描来做排序：使用同一个索引既满足排序又用于查找行，只有当索引的列顺序和ORDER BY字句顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySql才能够使用索引来对结果做排序。若查询需要关联多张表，只有当ORDER BY字句引用的字段全部为第一个表时，才能使用索引做排序。</li><li>压缩（前缀压缩）索引：MyISAM使用前缀压缩减少索引的大小，让更多的内存可以放入到内存中。默认只压缩字符串，通过参数设置也可以对整数做压缩。MyISAM查找时无法在索引快使用二分查找只能从头开始扫描。对于CPU密集型应用，压缩索引使得MyISAM在索引查找上要慢好几倍。压缩索引需要在CPU内存资源与磁盘之间做权衡。</li><li>冗余和重复索引：指在相同的列上，按照相同的顺序创建的相同类型的索引。MySql需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个进行考虑，影响性能。应避免创建重复索引。冗余索引不同于重复索引，若创建了索引（A,B）再创建索引（A）就属于冗余索引，索引（A,B）可以被当做索引(A)来使用。冗余索引通常发生在为表添加新索引的时候，应尽量拓展已有的索引而不是创建新索引。有时处于性能的考虑需要冗余索引，因拓展已有的索引导致其变得太大，从而影响其他使用该索引的查询的性能。</li><li>未使用的索引：若对数据约束及查询无意义，应该删除。</li><li>索引和锁：InnoDB访问行加锁，当其在存储引擎层能够过滤掉所有不需要的行时，索引减少InnoDB访问行的次数，减少锁的数量，5.1+V在服务器端过滤掉行后就释放锁。InnoDB在二级索引上使用共享（读）锁，访问主键索引需要排他（写）锁。</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><h5 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h5><p>count()可统计某列值的数量（不统计NULL），也可以统计行数（通配符*忽略所有的列而直接统计所有的行数）。</p><p>使用MyISAM在COUNT(*)非常快的特性优化查询，替代SUM()等。</p><h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul><li>确保ON或者USING子句中的列上有索引，创建索引时考虑关联的顺序，一般只需在关联顺序中的第二个表的相应列上创建索引。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，使MySQL有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul><h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><p>旧版本仅可能使用关联查询代替。若使用MySQL V5.6+或MariaDB，不必在意。</p><h5 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h5><p>MySQL很多场景下使用同样的的方法优化这两种查询，在内部处理时会互相转化这两类查询，使用索引优化。</p><p>当无法使用索引时，GROUP BY使用两种策略：使用临时表或者文件排序来做分组。</p><p>使用GROUP BY WITH ROLLUP对返回的分组结果再做一次超级聚合，通过EXPLAIN观察其执行计划，注意分组是否通过文件排序或者临时表实现，然后去掉WITH ROLLUP子句查看执行计划是否相同。最好的办法是尽可能的将WITH ROLLUP功能转移到应用程序中处理。</p><h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><p>针对分页查询LIMIT(1000, 20)，在页面中限制分页的数量，或优化大便宜量的性能。</p><ul><li>尽可能地使用索引覆盖扫描，而不是查询所有的列。</li><li>将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得结果。</li><li>使用书签记录上次取数据的位置，下次从书签记录的位置开始扫描，避免使用offset。</li></ul><h5 id="优化SQL-CALC-FOUND-ROWS"><a href="#优化SQL-CALC-FOUND-ROWS" class="headerlink" title="优化SQL_CALC_FOUND_ROWS"></a>优化SQL_CALC_FOUND_ROWS</h5><p>在分页的LIMIT语句中加上此参量提示，可以获取去掉LIMIT以后满足条件的行数，作为分页的总数。代价大。</p><h5 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h5><p>MySQL总是通过创建并填充临时表的方式来执行UNION查询，使得优化策略在UNION查询中无法得到很好的使用。需要手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用条件进行优化。</p><p>除非需要服务器消除重复的行，否则要使用UNION ALL，若无ALL关键字，MySQL会给临时表加上DISTINCT选型，导致对整个临时表的数据做唯一性检查。有ALL关键字，MySQL仍会使用临时表存储结果。</p><blockquote><p>事实上，MySQL总会将结果放入临时表，然后再读出，再返回给客户端。</p></blockquote><h5 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h5><p>Percona Toolkit中的pt-query-advisor。</p><h5 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h5><p>用户自定义变量是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用SET和SELECT语句来定义它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @id := 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = @id;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不能使用自定义变量场景：</p><ul><li>使用自定义变量的查询无法使用查询缓存。</li><li>不能在使用常量或标识符的地方使用自定义常量，如表名、列名和LIMIT子句中。</li><li>不能用做连接间的通信，其生命周期仅在一个连接中。</li><li>在连接池或者持久化连接中，自定义变量可能使代码间发生交互。</li><li>在不同版本间的兼容问题。</li><li>不能显示的声明自定义变量的类型。</li><li>优化器在某些场景下会将这些变量优化掉。</li><li>赋值的顺序和时间点不固定。</li><li>赋值符号:=的优先级非常低，赋值表达式应该使用明确的括号。</li><li>使用未定义的变量不会产生任何语法错误。</li></ul><p>使用：</p><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大量数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变为0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。</li></ul><h4 id="MySQL查询优化器能够处理的优化类型"><a href="#MySQL查询优化器能够处理的优化类型" class="headerlink" title="MySQL查询优化器能够处理的优化类型"></a>MySQL查询优化器能够处理的优化类型</h4><ul><li>重新定义关联表的顺序</li><li>将外链接转化为内链接</li><li>使用等价变换规则</li><li>优化COUNT()、MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul><h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h4><p>大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。</p><h5 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h5><p>查询请求超过实际需要，然后被丢弃，会给MySQL服务器带来额外的负担，增加网络开销，消耗服务器的CPU和内存资源。  </p><p>示例：</p><ul><li>查询不需要的记录。</li><li>多表关联时返回全部列。</li><li>总是取出全部列。</li><li>重复查询相同的数据。</li></ul><h5 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h5><p>衡量查询开销的指标：</p><ul><li>响应时间。</li><li>扫描的行数。</li><li>返回的行数。</li></ul><p>响应时间：服务时间与排队时间的和。</p><p>扫描行数和返回的行数：理想情况下扫描的行数和返回的行数应该是相同的，通常扫/返在1:1到10:1之间，也可能非常大。</p><p>扫描的行数和访问类型：EXPLAIN语句中的type列反应了访问类型，全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢到快，扫描行数由小到大，对应着扫描表、扫描索引、范围访问和单直访问。没办法找到合适的访问类型，增加合适的索引能以最高效、扫描行数最少的方式找到需要的记录。</p><p>MySQL应用where条件的三种方式，由好到坏为：</p><ul><li>索引中使用where条件过滤不匹配的记录。存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using Index）返回记录。直接从索引中过滤不需要的记录并返回命中结果，在MySQL服务器层完成，无需回表查询。</li><li>从数据表中返回记录，过滤不满足条件的记录（Extra列出现Using Where）。Mysql服务器层完成，MySQL从数据表中读出记录然后过滤。</li></ul><p>优化方式：</p><ul><li>使用索引覆盖扫描，把所有需要用到的列都放到索引中。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul><h4 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h4><h5 id="复杂查询和多个简单查询的选取"><a href="#复杂查询和多个简单查询的选取" class="headerlink" title="复杂查询和多个简单查询的选取"></a>复杂查询和多个简单查询的选取</h5><p>需要根据具体的情景考虑选取。</p><p>切分查询：将大查询切分为小查询，每个查询功能完全一样，只完成一小部分。</p><p>分解关联查询：对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。可以让缓存的效率更高、减少锁的竞争、利于高性能和可拓展、提升查询本身效率、减少冗余记录的查询等。</p><h3 id="innoDB存储引擎"><a href="#innoDB存储引擎" class="headerlink" title="innoDB存储引擎"></a>innoDB存储引擎</h3><p>文件系统中，MySql将每个数据库（schema）保存为数据目录下的一个子目录，创建表时，MySql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义，大小写敏感和具体平台相关，windows下不敏感，类Unix中敏感。不同的存储引擎保存数据和索引的方式时不同的，表的定义在MySql服务层统一处理。</p><p>使用<code>show table status [like &#39;tablename&#39;]\G</code>显示表的相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show table status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: migrations</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 3</span><br><span class="line"> Avg_row_length: 5461</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 52</span><br><span class="line">    Create_time: 2018-07-19 17:15:56</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_unicode_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: </span><br><span class="line">No query specified</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>InnoDB是MySql的默认事务型引擎，被设计用来处理大量的短期（short-lived），大部分能正常提交，很少会被回滚。除有非常特别的原因需要使用其他存储引擎，应该优先考虑InnoDB引擎。</p><p>InnoDB的数据存储在表空间（tablespace）中，是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。采用MVCC支持高并发，默认REPEATABLE READ（可重复读）隔离级别，通过间隙锁（next-key locking）策略防止幻读。</p><p>基于聚簇索引建立，索引结构不同于其他存储引擎，聚簇索引对主键查询有很高的性能。聚簇索引的二级索引（secondary index，非主键索引）中必须包含主列键，若表上索引较多，应保证主键尽可能的小，防止二级索引变得很大。</p><p>InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。</p><p>其内部做了很多优化，如从磁盘读取数据时采用可预测性预读，自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index）；加速插入操作的插入缓冲区。</p><p>InnoDB通过一些机制和工具支持真正的热备份，如Oracle提供的MySQL Enterprise Backup、Percona提供的开源的XtraBackup。MySQL其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，在读写混合场景中，停止写入可能也意味着停止读取。</p><p>其他博客：<a href="http://www.cnblogs.com/Aiapple/p/5689634.html" target="_blank" rel="noopener">innodb存储引擎</a></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote><p>事务是一组原子性的SQL查询，或者说一个独立的工作单元。——《高性能MySQL》</p></blockquote><p>ACID：</p><ul><li>A:atomicity，原子性，一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中的一部分操作。</li><li>C:consistency，一致性，数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li><li>I:isolation，隔离性，通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。</li><li>D:durability，持久性，一旦事务提交，其所做的修改就会永久保存到数据库中。</li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><ul><li>READ UNCOMMITED（未提交读）：事务可以读取未提交的数据，产生脏读。</li><li>READ COMMITED（提交读）：事务开始到提交，所做的修改对其他事务不可见。不可重复读，两次执行同样的查询，可能会得到不一样的结果。</li><li>REPEATABLE READ（可重复读）：mysql的默认事务隔离级别，解决脏读问题，InnoDB通过多版本并发控制解决幻读问题，保证在同一个事务中多次读取同样记录的结果是一致的。</li><li>SERIALIZABLE（可串行化）：最高级别隔离，强制事务串行执行，避免幻读。会在读取的每一行数据上加锁，导致大量的超时和锁争用问题。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个事务在同一资源上互相占用，请求锁定对方占用的资源，导致恶性循环。InnoDB将持有最少行级排他锁的事务进行回滚。</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>提高事务效率，修改表的数据时只需修改其内存拷贝，再把该修改行为持久在硬盘上的事务日志中，不用每次都将修改的数据本身持久到硬盘。事务日志持久后，内存中被修改的数据可以慢慢地刷回到磁盘。事务日志采用追加的方式，写日志的操作是磁盘上一小块区域内的顺序I/O。被称为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p><blockquote><p>存储引擎可在重启时，根据事务日志自动恢复上次没能写回磁盘被修改的数据。</p></blockquote><h4 id="MySql中的事务"><a href="#MySql中的事务" class="headerlink" title="MySql中的事务"></a>MySql中的事务</h4><p>提供了两种事务型的存储引擎：InnoDB和NDB Cluster。</p><p>自动提交（AUTOCOMMIT）：若不是显示的开始一个事务，每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>1或者ON表示已启用，0或OFF表示禁用。</p><p>修改AUTOCOMMIT对非事务型的表，如MyISAM和内存表，无任何影响，其无COMMIT和ROLLBACK的概念。</p><p>可以通过<code>SET TRANSACTION ISOLATION LEVEL</code>命令设置隔离级别。新的隔离级别在下一个事务开始时生效。</p><p>在事务中混合使用存储引擎:</p><blockquote><p>MySql服务器层不管理事务，事务由下层的存储引擎实现，在同一个事务中，使用多种存储引擎是不可靠的。<br>若事务中混合使用了事务型和非事务型的表，在事务回滚时，非事务型的表上的变更无法撤销，导致数据库处于不一致的状态，很难修复。<br>在非事务型的表上执行事务相关操作的时候，MySql通常不会发出提醒，也不会报错，只有回滚的时候才会发出一个警告，大多数情况下，不会有提示。</p></blockquote><p>隐式和显示锁定：</p><blockquote><p>InnoDB采用两阶段锁定协议（two-phase locking protocol），在事务执行过程中，随时都可以锁定，只有在COIMMIT或者ROLLBACK的时候才会释放，所有的锁在同一时刻被释放。这些锁为隐式锁，InnoDB根据隔离级别在需要的时候自动加锁。<br>InnoDB支持通过特定的语句进行显示加锁，这些语句不属于SQL规范。<br>MySql支持LOCK TABLES和UNLOCK TABLES语句，在服务器层实现，与存储引擎无关，不能替代事务。使用事务需要选择事务型存储引擎。<br><code>除事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要执行LOCK TABLES</code>，不管使用什么存储引擎。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql&quot;&gt;&lt;a href=&quot;#mysql&quot; class=&quot;headerlink&quot; title=&quot;mysql&quot;&gt;&lt;/a&gt;mysql&lt;/h3&gt;&lt;p&gt;参考文档 ：《高性能MySql》 &lt;/p&gt;
&lt;p&gt;其他：&lt;a href=&quot;http://www.runoob.com
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="索引" scheme="bighua.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="事务" scheme="bighua.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>第二周笔记-Day27</title>
    <link href="bighua.top/2018/07/27/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0-Day27/"/>
    <id>bighua.top/2018/07/27/第二周笔记-Day27/</id>
    <published>2018-07-27T01:27:31.000Z</published>
    <updated>2018-07-29T09:02:24.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/logging/1374" target="_blank" rel="noopener">日志</a>。</p><p>理解</p><blockquote><p>laravel框架使用monolog记录日志，在配置文件的channels中，可自定义通道，默认选用stack通道。通道即记录日志时选择记录的方式，通道有八种可选驱动，驱动决定了日志记录的位置、信息格式等，可参考配置文件中的其他通道配置自己业务所需的通道进行日志记录。 </p></blockquote><blockquote><p>提供了八种在<a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC 5424 specification</a>中定义的日志等级。在记录时，根据调用方法对应的等级对比选用通道中规定的最低等级，使用最低等级不高于调用方法对应等级的通道记录信息。</p></blockquote><h3 id="中间件记录sql"><a href="#中间件记录sql" class="headerlink" title="中间件记录sql"></a>中间件记录sql</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/database/1397#97d96c" target="_blank" rel="noopener">监听查询事件</a>。  </p><blockquote><p>在上方的文档中，larvel5.6提供的监听查询事件与之前版本的监听查询事件匿名函数的参数有不同，是个坑点。v5.6为一个参数带有sql、bindings、time属性，之前版本将这三个属性作为参数。</p></blockquote><p>sql查询事件可能发生在任何请求中，应将其作为全局中间件进行注册。事件监听应在用户请求开始就启动，使用前置中间件。</p><p>在log配置文件中定义sql通道，选用daily驱动将日志按日期进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;sql&apos; =&gt; [</span><br><span class="line">    &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">    &apos;path&apos; =&gt; storage_path(&apos;logs/sql/sql.log&apos;),</span><br><span class="line">    &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">    &apos;days&apos; =&gt; 7,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>中间件中逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    // 记录sql</span><br><span class="line">    DB::listen(function($query) &#123;</span><br><span class="line">        $sql = $query-&gt;sql;</span><br><span class="line">        $bindings = $query-&gt;bindings;</span><br><span class="line">        foreach ($bindings as $replace) &#123;</span><br><span class="line">            $value = is_numeric($replace) ? $replace : &quot;&apos;&quot; . $replace . &quot;&apos;&quot;;</span><br><span class="line">            $sql = preg_replace(&apos;/\?/&apos;, $value, $sql, 1);</span><br><span class="line">            Log::channel(&apos;sql&apos;)-&gt;info(&apos;SQL语句执行：&apos;.$sql.&apos;,耗时：&apos;.$query-&gt;time.&apos;ms&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件记录IO"><a href="#中间件记录IO" class="headerlink" title="中间件记录IO"></a>中间件记录IO</h3><p>实际记录请求和响应。</p><p>request和response所包含的API文档：<a href="https://laravel.com/api/5.6/index.html" target="_blank" rel="noopener">Laravel API</a>。  </p><p>对于请求考虑记录请求url、客户端ip、请求方法、请求参数，对于响应记录响应状态码、返回字节数。</p><p>新建通道io:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;io&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">            &apos;path&apos; =&gt; storage_path(&apos;logs/io/io.log&apos;),</span><br><span class="line">            &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">            &apos;days&apos; =&gt; 7,</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>中间件中调用Log记录，注意请求响记录的时期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    $data[&apos;request&apos;][&apos;url&apos;] = $request-&gt;fullUrl();</span><br><span class="line">    $data[&apos;request&apos;][&apos;ip&apos;] = $request-&gt;getClientIp();</span><br><span class="line">    $data[&apos;request&apos;][&apos;method&apos;] = $request-&gt;method();</span><br><span class="line">    $data[&apos;request&apos;][&apos;data&apos;] = $request-&gt;all();</span><br><span class="line">    $response = $next($request);</span><br><span class="line">    $data[&apos;response&apos;][&apos;status&apos;] = $response-&gt;status();</span><br><span class="line">    $data[&apos;response&apos;][&apos;contentLen&apos;] = strlen($response-&gt;content());</span><br><span class="line">    Log::channel(&apos;io&apos;)-&gt;info(serialize($data));</span><br><span class="line">    return $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录异常"><a href="#记录异常" class="headerlink" title="记录异常"></a>记录异常</h3><p>在App\Exceptions\Handler的Report 方法中记录异常到日志失败，待处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h3&gt;&lt;p&gt;文档：&lt;a href=&quot;https://laravel-china.org/docs/laravel/5.6/logging/1374&quot; t
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>第二周笔记-Day26</title>
    <link href="bighua.top/2018/07/26/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0-Day26/"/>
    <id>bighua.top/2018/07/26/第二周笔记-Day26/</id>
    <published>2018-07-26T06:00:14.000Z</published>
    <updated>2018-07-27T01:26:36.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac下laravel定时任务"><a href="#mac下laravel定时任务" class="headerlink" title="mac下laravel定时任务"></a>mac下laravel定时任务</h3><h4 id="添加Cron条目到mac（服务器）"><a href="#添加Cron条目到mac（服务器）" class="headerlink" title="添加Cron条目到mac（服务器）"></a>添加Cron条目到mac（服务器）</h4><p>文档：<a href="http://www.runoob.com/linux/linux-comm-crontab.html" target="_blank" rel="noopener">crontab</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab服务的重启关闭，开启</span><br><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure><p>将php artisan schedule:run 添加到crontab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>* * * * *</code>分别代表每小时中第几分钟、每天中第几小时、每月中第几日、每年中第几月、每周中第几天。<code>/usr/bin/php</code>为php执行路径（cli）。<code>/Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run</code>为项目artisan路径，要执行的命令。<code>&gt;&gt; /dev/null</code>表示将标准输出重定向到/dev/null（空设备文件）中（丢弃标准输出），<code>2&gt;&amp;1</code>将错误输出和标准输出绑定在一起，使用同一个文件描述符。<br>查看设置的定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h4 id="任务调度书写"><a href="#任务调度书写" class="headerlink" title="任务调度书写"></a>任务调度书写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected function schedule(Schedule $schedule)</span><br><span class="line">&#123;</span><br><span class="line">$schedule-&gt;call(function () &#123;</span><br><span class="line">            $addUserInfoIntoredis = new UserInfoController();</span><br><span class="line">           $addUserInfoIntoredis-&gt;addUsersInfo();</span><br><span class="line">        &#125;)-&gt;everyMinute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserInfoController的addUsersInfo方法中取数据库今日注册新用户添加到redis中。其中的逻辑省略。</p><h3 id="调用钉钉接口发送新用户注册通知"><a href="#调用钉钉接口发送新用户注册通知" class="headerlink" title="调用钉钉接口发送新用户注册通知"></a>调用钉钉接口发送新用户注册通知</h3><p>Guzzle文档：<a href="http://guzzle-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Guzzle中文文档</a>。</p><p>自定义钉钉机器人：<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.vcNk2y&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">自定义机器人</a>。</p><p>坑点：文档中对各种请求方式的参数未做详细说明，钉钉机器人需要以post请求发送json格式的数据，Guzzle发送请求中的第三项参数（数组）为要发送的数据，键名代表着要发送的数据的格式，键值（真正发送的数据）为发送的数据。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$client = new Client([</span><br><span class="line">            &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">        ]);</span><br><span class="line">$data = [</span><br><span class="line">       &apos;json&apos; =&gt; [</span><br><span class="line">       &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">       &apos;text&apos; =&gt; [</span><br><span class="line">              &apos;content&apos; =&gt; &apos;新注册用户：&apos;.$req-&gt;get(&apos;name&apos;).&apos;；邮箱：&apos;.$req-&gt;get(&apos;email&apos;).&apos;。&apos;,</span><br><span class="line">                ]</span><br><span class="line">       ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure></p><p>数据的json代表着以json格式发送数据。</p><h3 id="对发消息进行解偶"><a href="#对发消息进行解偶" class="headerlink" title="对发消息进行解偶"></a>对发消息进行解偶</h3><p>消息发送机制应该做成独立的模块，考虑使用事件和队列。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/events/1389" target="_blank" rel="noopener">事件系统</a>。</p><p>于EventServiceProvider的listen数组中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;App\Events\RegisterMsg&apos; =&gt;[</span><br><span class="line">     &apos;App\Listeners\SendRegisterMsgToRobot&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>生成事件和监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan event:generate</span><br></pre></td></tr></table></figure><p>于事件的构造函数中接收事件的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> * @var </span><br><span class="line"> */</span><br><span class="line">public $info;</span><br><span class="line">/**</span><br><span class="line"> * Create a new event instance.</span><br><span class="line"> *</span><br><span class="line"> * @return void</span><br><span class="line"> */</span><br><span class="line">public function __construct($info)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;info = $info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于监听器SendRegisterMsgToRobot的handle函数中书写业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$info = $event-&gt;info;</span><br><span class="line">$client = new Client([</span><br><span class="line">      &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">]);</span><br><span class="line">$data = [</span><br><span class="line">     &apos;json&apos; =&gt; [</span><br><span class="line">        &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">        &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from EventListener。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">               ]</span><br><span class="line">         ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure><p>使用enent函数触发事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event(new RegisterMsg($info));</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>事件的处理过程可能会引起用户等待。加入队列中进行处理更适合场景。</p><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/queues/1395#260f10" target="_blank" rel="noopener">队列</a>。</p><p>生成任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:job SendRegisterMsg</span><br></pre></td></tr></table></figure><p>于SendRegisterMsg的handle函数中书写业务逻辑,：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public function handle()</span><br><span class="line">&#123;</span><br><span class="line">    $info = $this-&gt;info;</span><br><span class="line">    $client = new Client([</span><br><span class="line">        &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">    ]);</span><br><span class="line">    $data = [</span><br><span class="line">        &apos;json&apos; =&gt; [</span><br><span class="line">            &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">            &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from job。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">    $client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendRegisterMsg::dispatch($info)</span><br></pre></td></tr></table></figure><h4 id="代码组织及结构调整"><a href="#代码组织及结构调整" class="headerlink" title="代码组织及结构调整"></a>代码组织及结构调整</h4><p>一个大型项目往往是慢慢集成的，添加的每一个模块应该在一个独立的子目录中，与原项目间互不影响。将所有代码文件添加父目录Login。</p><p>反思此消息发送，功能太单一，仅为text消息发送，而钉钉接口支持多种消息类型。若需要发送markdown、link、ActionCard、FeedCard等类型消息，这样写的复用率很低，因考虑进行功能的封装。其次，应该将配置相关的文件单独存放，便于管理配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mac下laravel定时任务&quot;&gt;&lt;a href=&quot;#mac下laravel定时任务&quot; class=&quot;headerlink&quot; title=&quot;mac下laravel定时任务&quot;&gt;&lt;/a&gt;mac下laravel定时任务&lt;/h3&gt;&lt;h4 id=&quot;添加Cron条目到mac（
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
      <category term="linux" scheme="bighua.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>第二周笔记-任务三</title>
    <link href="bighua.top/2018/07/25/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0-%E4%BB%BB%E5%8A%A1%E4%B8%89/"/>
    <id>bighua.top/2018/07/25/第二周笔记-任务三/</id>
    <published>2018-07-25T15:26:05.000Z</published>
    <updated>2018-07-25T16:11:26.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务：路由标准框架的理解"><a href="#任务：路由标准框架的理解" class="headerlink" title="任务：路由标准框架的理解"></a>任务：路由标准框架的理解</h3><p>详情：路由、中间件、异常处理、MVC、定时任务、配置信息，课堂实际项目开发接口和风格了解，目录结构，日志分析。</p><hr><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>M：Model，模型，数据库操作具体对象。<br>V：View，视图，渲染返回的页面。<br>C：Controller，处理业务逻辑。  </p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/scheduling/1396" target="_blank" rel="noopener">任务调度</a>。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>于app/Console/Kernel.php 文件的<code>schedule</code>方法中定义所有调度任务。</p><p>通过<code>$schedule-&gt;call()</code>设置，传递匿名函数，匿名函数中执行调度任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;call(function () &#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;)-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通过<code>$schedule-&gt;command()</code>设置，传递命令名称或者类名称调度一个 <code>Artisan</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;command(&apos;emails:send --force&apos;)-&gt;timefunction();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(EmailsCommand::class, [&apos;--force&apos;])-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通过<code>$schedule-&gt;job()</code>调度队列任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;job(new Heartbeat)-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通过<code>$schedule-&gt;exec()</code>向操作系统发出命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;exec(&apos;node /home/forge/script.js&apos;)-&gt;timefunction();</span><br></pre></td></tr></table></figure><blockquote><p><code>timefunction()</code>指代调度频率的函数，包含较广，在文档上有详细的介绍。</p></blockquote><p>使用<code>withoutOverlapping</code>方法避免任务重复。</p><p>使用 <code>onOneServer</code> 方法让计划任务只在一台服务器上运行(必须使用 memcached 或 redis 作为你应用程序的默认缓存驱动程序，所有服务器都必须与同一个中央缓存服务器进行通信。 原理是获取到该任务的第一台服务器将对该任务加上原子锁，以防止其他服务器同时运行相同的任务。)。</p><p>使用 <code>evenInMaintenanceMode</code>方法强制某个任务在维护模式下运行。</p><blockquote><p><code>使用 runInBackground 方法可使当前计划任务进入后台运行，从而不阻塞其他任务的执行。</code></p></blockquote><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>使用<code>sendOutputTo</code>方法将输出发送到单个文件上以便后续检查，参数为文件名。</p><p>使用 <code>appendOutputTo</code>方法将输出附加到指定的文件上。</p><p>使用<code>emailOutputTo</code>方法通过电子邮件将输出发送到指定的邮箱上，参数为指定邮箱地址。</p><h4 id="任务勾子"><a href="#任务勾子" class="headerlink" title="任务勾子"></a>任务勾子</h4><p>通过<code>before</code>与<code>after</code>方法，指定要在调度任务完成之前和之后执行的代码，参数为匿名函数，于匿名函数中书写逻辑。</p><h4 id="Ping-网址"><a href="#Ping-网址" class="headerlink" title="Ping 网址"></a>Ping 网址</h4><p>使用<code>pingBefore</code>与<code>thenPing</code>方法使调度器在任务完成之前或之后自动ping给定的URL，参数为给定url。<br>需要 Guzzle HTTP 函数库的支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require guzzlehttp/guzzle</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/logging/1374" target="_blank" rel="noopener">日志</a>。  </p><p>使用Log facade 记录信息到日志。日志处理程序提供了八种在<a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC 5424 specification</a>里定义的日志等级：emergency、 alert、critical、 error、 warning、 notice、 info 和 debug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Log::emergency($message);</span><br><span class="line">Log::alert($message);</span><br><span class="line">Log::critical($message);</span><br><span class="line">Log::error($message);</span><br><span class="line">Log::warning($message);</span><br><span class="line">Log::notice($message);</span><br><span class="line">Log::info($message);</span><br><span class="line">Log::debug($message);</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/configuration/1353" target="_blank" rel="noopener"> 配置信息</a>。  </p><p>检索环境配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;debug&apos; =&gt; env(&apos;APP_DEBUG&apos;, false),</span><br></pre></td></tr></table></figure><p>确定/检查当前环境:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$environment = App::environment();</span><br><span class="line"></span><br><span class="line">if (App::environment(&apos;local&apos;)) &#123;</span><br><span class="line">    // The environment is local</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (App::environment([&apos;local&apos;, &apos;staging&apos;])) &#123;</span><br><span class="line">    // The environment is either local OR staging...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问/设置配置值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$value = config(&apos;app.timezone&apos;);</span><br><span class="line">config([&apos;app.timezone&apos; =&gt; &apos;America/Chicago&apos;]);</span><br></pre></td></tr></table></figure><p>配置缓存：</p><blockquote><p>为提升速度，应该使用 Artisan 命令 <code>config:cache</code> 将所有的配置文件缓存到单个文件中。这会把你的应用程序中所有的配置选项合并成一个单一的文件，然后框架会快速加载这个文件。应该把运行 php artisan config:cache 命令作为生产环境部署常规工作的一部分。这个命令不应在本地开发环境下运行，因为配置选项在应用程序开发过程中是经常需要被更改的。</p></blockquote><p>维护模式:<br>执行 Artisan 命令 <code>down</code> 启用维护模式。<br>当应用程序处于维护模式时，所有对应用程序的请求都显示为一个自定义视图。在更新或执行维护时「关闭」应用程序。 维护模式检查包含在应用程序的默认中间件栈中。如果应用程序处于维护模式，则将抛出一个状态码为 503 的 MaintenanceModeException 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan down</span><br></pre></td></tr></table></figure><p>向<code>down</code>命令提供<code>message</code>和<code>retry</code>选项。其中<code>message</code>选项的值可用于显示或记录自定义消息，而<code>retry</code>值可用于设置<code>HTTP</code>请求头中<code>Retry-After</code>的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan down --message=&quot;Upgrading Database&quot; --retry=60</span><br></pre></td></tr></table></figure><p>关闭维护模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan up</span><br></pre></td></tr></table></figure><blockquote><p>可以通过修改 resources/views/errors/503.blade.php 模板文件来自定义默认维护模式模板。<br>当应用程序处于维护模式时，不会处理 队列任务。而这些任务会在应用程序退出维护模式后再继续处理。</p></blockquote><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/middleware/1364" target="_blank" rel="noopener">中间件</a>。  </p><p>用于过滤进入应用的 HTTP 请求。</p><p>可分为前置中间件、后置中间件，在请求之前或之后运行取决于中间件本身。  </p><p>在 app/Http/Kernel.php 中的 $middleware 属性中列出的中间件为全局中间件。  </p><p>使用 Http kernel 的 $middlewareGroups 属性，使用一个 key 把多个中间件打包成一个组，方便将他们应用到路由中。</p><p>在中间件中定义一个 terminate 方法，则会在响应发送到浏览器后自动调用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/errors/1373" target="_blank" rel="noopener">错误处理</a>。</p><p>App\Exceptions\Handler 类负责记录应用程序触发的所有异常并呈现给用户。</p><p>config/app.php 配置文件中的 debug 选项决定了对于一个错误实际上将显示多少信息给用户。默认情况下，该选项的设置将遵照存储在 .env 文件中的 APP_DEBUG 环境变量的值。</p><blockquote><p>对于本地开发，你应该将 APP_DEBUG 环境变量的值设置为 true。在生产环境中，该值应始终为 false。如果在生产中将该值设置为 true，则可能会将敏感配置值暴露给应用程序的最终用户。</p></blockquote><h4 id="report方法"><a href="#report方法" class="headerlink" title="report方法"></a>report方法</h4><p>report 方法用于记录异常或将它们发送给如 Bugsnag 或 Sentry 等外部服务。默认情况下，report 方法将异常传递给记录异常的基类。</p><p>report 辅助函数允许你使用异常处理器的 report 方法在不显示错误页面的情况下快速报告异常。</p><p>异常处理器的 \$dontReport 属性包含一组不会被记录的异常类型。例如，由 404 错误导致的异常以及其他几种类型的错误不会写入日志文件。</p><h4 id="Render方法"><a href="#Render方法" class="headerlink" title="Render方法"></a>Render方法</h4><p>Render 方法负责将给定的异常转换为将被发送回浏览器的 HTTP 响应。默认情况下，异常将传递给为你生成响应的基类。可以按自己意愿检查异常类型或返回自己的自定义响应。</p><h4 id="Reportable-amp-Renderable-异常"><a href="#Reportable-amp-Renderable-异常" class="headerlink" title="Reportable &amp; Renderable 异常"></a>Reportable &amp; Renderable 异常</h4><p>除了在异常处理器的 report 和 render 方法中检查异常类型，还可以直接在自定义异常上定义 report 和 render 方法。当定义了这些方法时，它们会被框架自动调用。</p><h4 id="HTTP异常"><a href="#HTTP异常" class="headerlink" title="HTTP异常"></a>HTTP异常</h4><p>使用 abort 辅助函数从应用程序的任何地方生成这样的响应。</p><h5 id="自定义-HTTP-错误页面"><a href="#自定义-HTTP-错误页面" class="headerlink" title="自定义 HTTP 错误页面"></a>自定义 HTTP 错误页面</h5><p>创建一个 resources/views/errors/404.blade.php 视图文件。该文件将被用于你的应用程序产生的所有 404 错误。此目录中的视图文件的命名应匹配它们对应的 HTTP 状态码。由 abort 函数引发的 HttpException 实例将作为 \$exception 变量传递给视图。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>对应文档：<a href="https://laravel-china.org/docs/laravel/5.6/routing/1363" target="_blank" rel="noopener">路由</a>。<br>文档比较详细，虽然复制粘贴，感觉对记住其主要用法还是有些作用的。</p><h4 id="基本路由："><a href="#基本路由：" class="headerlink" title="基本路由："></a>基本路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;foo&apos;, function () &#123;</span><br><span class="line">    return &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/user&apos;, &apos;UserController@index&apos;);</span><br><span class="line"></span><br><span class="line">Route::get($uri, $callback);</span><br><span class="line">Route::post($uri, $callback);</span><br><span class="line">Route::put($uri, $callback);</span><br><span class="line">Route::patch($uri, $callback);</span><br><span class="line">Route::delete($uri, $callback);</span><br><span class="line">Route::options($uri, $callback);</span><br></pre></td></tr></table></figure><h4 id="响应多个HTTP的路由或者响应所有HTTP路由："><a href="#响应多个HTTP的路由或者响应所有HTTP路由：" class="headerlink" title="响应多个HTTP的路由或者响应所有HTTP路由："></a>响应多个HTTP的路由或者响应所有HTTP路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::match([&apos;get&apos;, &apos;post&apos;], &apos;/&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::any(&apos;foo&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="重定向路由："><a href="#重定向路由：" class="headerlink" title="重定向路由："></a>重定向路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::redirect(&apos;/here&apos;, &apos;/there&apos;, 301);</span><br></pre></td></tr></table></figure><h4 id="视图路由-可带参数-："><a href="#视图路由-可带参数-：" class="headerlink" title="视图路由(可带参数)："></a>视图路由(可带参数)：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::view(&apos;/welcome&apos;, &apos;welcome&apos;);</span><br><span class="line"></span><br><span class="line">Route::view(&apos;/welcome&apos;, &apos;welcome&apos;, [&apos;name&apos; =&gt; &apos;Taylor&apos;]);</span><br></pre></td></tr></table></figure><h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><h5 id="必填参数"><a href="#必填参数" class="headerlink" title="必填参数"></a>必填参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;id&#125;&apos;, function ($id) &#123;</span><br><span class="line">    return &apos;User &apos;.$id;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;posts/&#123;post&#125;/comments/&#123;comment&#125;&apos;, function ($postId, $commentId) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="可选参数-要确保路由的相应变量有默认值"><a href="#可选参数-要确保路由的相应变量有默认值" class="headerlink" title="可选参数(要确保路由的相应变量有默认值)"></a>可选参数(要确保路由的相应变量有默认值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;name?&#125;&apos;, function ($name = null) &#123;</span><br><span class="line">    return $name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;name?&#125;&apos;, function ($name = &apos;John&apos;) &#123;</span><br><span class="line">    return $name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="正则表达式约束"><a href="#正则表达式约束" class="headerlink" title="正则表达式约束"></a>正则表达式约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;name&#125;&apos;, function ($name) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where(&apos;name&apos;, &apos;[A-Za-z]+&apos;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;&apos;, function ($id) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where(&apos;id&apos;, &apos;[0-9]+&apos;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;/&#123;name&#125;&apos;, function ($id, $name) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where([&apos;id&apos; =&gt; &apos;[0-9]+&apos;, &apos;name&apos; =&gt; &apos;[a-z]+&apos;]);</span><br></pre></td></tr></table></figure><h5 id="全局约束"><a href="#全局约束" class="headerlink" title="全局约束"></a>全局约束</h5><p>使用 pattern 方法在 RouteServiceProvider 的 boot 方法中定义这些模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    Route::pattern(&apos;id&apos;, &apos;[0-9]+&apos;);</span><br><span class="line"></span><br><span class="line">    parent::boot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由命名"><a href="#路由命名" class="headerlink" title="路由命名"></a>路由命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/profile&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;name(&apos;profile&apos;);</span><br><span class="line">Route::get(&apos;user/profile&apos;, &apos;UserController@showProfile&apos;)-&gt;name(&apos;profile&apos;);</span><br></pre></td></tr></table></figure><h5 id="生成指定路由的-URL"><a href="#生成指定路由的-URL" class="headerlink" title="生成指定路由的 URL"></a>生成指定路由的 URL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 生成 URL...</span><br><span class="line">$url = route(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line">// 生成重定向...</span><br><span class="line">return redirect()-&gt;route(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;/profile&apos;, function ($id) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;name(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line">$url = route(&apos;profile&apos;, [&apos;id&apos; =&gt; 1]);</span><br></pre></td></tr></table></figure><h4 id="检查当前路由"><a href="#检查当前路由" class="headerlink" title="检查当前路由"></a>检查当前路由</h4><p>调用路由实例上的 named 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    if ($request-&gt;route()-&gt;named(&apos;profile&apos;)) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h4><p>使大量路由间共享路由属性：中间件、命名空间。共享属性应该以数组的形式传入 Route::group 方法的第一个参数中。</p><h5 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h5><p>给路由组中所有的路由分配中间件，在group之前调用middleware方法，中间件会依照它们在数组中列出的顺序来运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware([&apos;first&apos;, &apos;second&apos;])-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/&apos;, function () &#123;</span><br><span class="line">        // 使用 first 和 second 中间件</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Route::get(&apos;user/profile&apos;, function () &#123;</span><br><span class="line">        // 使用 first 和 second 中间件</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>使用 namespace 方法将相同的 PHP 命名空间分配给路由组的中所有的控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::namespace(&apos;Admin&apos;)-&gt;group(function () &#123;</span><br><span class="line">    // 在 &quot;App\Http\Controllers\Admin&quot; 命名空间下的控制器</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>默认情况下，<code>RouteServiceProvider</code>会在命名空间组中引入你的路由文件，让你不用指定完整的 <code>App\Http\Controllers</code>命名空间前缀就能注册控制器路由。因此，你只需要指定命名空间<code>App\Http\Controllers</code>之后的部分。</p><h5 id="子域名路由"><a href="#子域名路由" class="headerlink" title="子域名路由"></a>子域名路由</h5><p>路由组也可以用来处理子域名。子域名可以像路由 URI 一样被分配路由参数，允许你获取一部分子域名作为参数给路由或控制器使用。可以在 <code>group</code> 之前调用 <code>domain</code> 方法来指定子域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::domain(&apos;&#123;account&#125;.myapp.com&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;user/&#123;id&#125;&apos;, function ($account, $id) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h5><p>用 <code>prefix</code> 方法为路由组中给定的URL增加前缀.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::prefix(&apos;admin&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;users&apos;, function () &#123;</span><br><span class="line">        // 匹配包含 &quot;/admin/users&quot; 的 URL</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="路由名称前缀"><a href="#路由名称前缀" class="headerlink" title="路由名称前缀"></a>路由名称前缀</h5><p>name 方法可以用来给路由组中的每个路由名称添加一个给定的字符串。 例如，您可能希望以 「admin」为所有分组路由的名称加前缀。 给定的字符串与指定的路由名称前缀完全相同，因此我们将确保在前缀中提供尾部的 . 字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::name(&apos;admin.&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;users&apos;, function () &#123;</span><br><span class="line">        // 路由分配名称“admin.users”...</span><br><span class="line">    &#125;)-&gt;name(&apos;users&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="路由模型绑定"><a href="#路由模型绑定" class="headerlink" title="路由模型绑定"></a>路由模型绑定</h4><p>当向路由或控制器行为注入模型 ID 时，就需要查询这个 ID 对应的模型。Laravel 为路由模型绑定提供了一个直接自动将模型实例注入到路由中的方法。例如，你可以注入与给定 ID 匹配的整个 User 模型实例，而不是注入用户的 ID。</p><h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>Laravel 会自动解析定义在路由或控制器行为中与类型提示的变量名匹配的路由段名称的 Eloquent 模型。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;api/users/&#123;user&#125;&apos;, function (App\User $user) &#123;</span><br><span class="line">    return $user-&gt;email;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>自定义键名.<br>如果你想要模型绑定在检索给定的模型类时使用除 id 之外的数据库字段，你可以在 Eloquent 模型上重写 getRouteKeyName 方法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 为路由模型获取键名。</span><br><span class="line"> *</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">public function getRouteKeyName()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;slug&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h5><p>要注册显式绑定，使用路由器的 model 方法来为给定参数指定类。在 RouteServiceProvider 类中的 boot 方法内定义这些显式模型绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    parent::boot();</span><br><span class="line"></span><br><span class="line">    Route::model(&apos;user&apos;, App\User::class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，定义一个包含 {user} 参数的路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;profile/&#123;user&#125;&apos;, function (App\User $user) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>自定义逻辑解析.<br>如果你想要使用自定义的解析逻辑，就使用 Route::bind 方法。传递到 bind 方法的 闭包 会接受 URI 中大括号对应的值，并且返回你想要在该路由中注入的类的实例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    parent::boot();</span><br><span class="line"></span><br><span class="line">    Route::bind(&apos;user&apos;, function ($value) &#123;</span><br><span class="line">        return App\User::where(&apos;name&apos;, $value)-&gt;first() ?? abort(404);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>Laravel 包含了一个 中间件 用于控制应用程序对路由的访问。如果想要使用，请将 throttle 中间件分配给一个路由或一个路由组。throttle 中间件会接收两个参数，这两个参数决定了在给定的分钟数内可以进行的最大请求数。 例如，让我们指定一个经过身份验证并且用户每分钟访问频率不超过 60 次的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware(&apos;auth:api&apos;, &apos;throttle:60,1&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/user&apos;, function () &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="动态访问控制"><a href="#动态访问控制" class="headerlink" title="动态访问控制"></a>动态访问控制</h5><p>根据已验证的 User 模型的属性指定动态请求的最大值。 例如，如果您的 User 模型包含rate_limit属性，则可以将属性名称传递给 throttle 中间件，以便它用于计算最大请求计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware(&apos;auth:api&apos;, &apos;throttle:rate_limit,1&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/user&apos;, function () &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="表单方法伪造"><a href="#表单方法伪造" class="headerlink" title="表单方法伪造"></a>表单方法伪造</h4><p>HTML表单不支持<code>PUT</code>、<code>PATCH</code>或<code>DELETE</code>行为。所以当你要从HTML表单中调用定义了PUT、PATCH或DELETE路由时，你将需要在表单中增加隐藏的_method 输入标签。使用_method字段的值作为HTTP的请求方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    @method(&apos;PUT&apos;)</span><br><span class="line">    @csrf</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="访问当前路由"><a href="#访问当前路由" class="headerlink" title="访问当前路由"></a>访问当前路由</h4><p>你可以使用Route Facade上的<code>current</code>、<code>currentRouteName</code>和<code>currentRouteAction</code>方法来访问处理传入请求的路由的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$route = Route::current();</span><br><span class="line"></span><br><span class="line">$name = Route::currentRouteName();</span><br><span class="line"></span><br><span class="line">$action = Route::currentRouteAction();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务：路由标准框架的理解&quot;&gt;&lt;a href=&quot;#任务：路由标准框架的理解&quot; class=&quot;headerlink&quot; title=&quot;任务：路由标准框架的理解&quot;&gt;&lt;/a&gt;任务：路由标准框架的理解&lt;/h3&gt;&lt;p&gt;详情：路由、中间件、异常处理、MVC、定时任务、配置信息，课
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>第二周笔记-任务二</title>
    <link href="bighua.top/2018/07/24/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0-%E4%BB%BB%E5%8A%A1%E4%BA%8C/"/>
    <id>bighua.top/2018/07/24/第二周笔记-任务二/</id>
    <published>2018-07-24T01:35:45.000Z</published>
    <updated>2018-07-24T08:20:14.274Z</updated>
    
    <content type="html"><![CDATA[<h4 id="任务：linux基础命令tail-cat-top-mkdir-vi-chmod等"><a href="#任务：linux基础命令tail-cat-top-mkdir-vi-chmod等" class="headerlink" title="任务：linux基础命令tail/cat/top/mkdir/vi/chmod等"></a>任务：linux基础命令tail/cat/top/mkdir/vi/chmod等</h4><p>linux命令使用的详细参数可以通过man command进行查询，一般比较容易忘记命令的具体作用，下面仅对这些命令的具体功能及作用进行记录，并给出相应的命令使用。</p><p>参考<a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全</a>。</p><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>作用：查看文件的尾部内容，不带参数则默认显示后十条。</p><p>查看正在改变的nginx日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f  com.access_log</span><br></pre></td></tr></table></figure><p>查看第5条开始往后信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail +5 com.access_log</span><br></pre></td></tr></table></figure><p>查看最后十个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c 10 com.access_log</span><br></pre></td></tr></table></figure><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>作用：连接文件并打印到标准输出设备上。</p><p>将nginx日志文件显示行号输入到备份文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n com.access_log backup_log</span><br></pre></td></tr></table></figure><p>将nginx日志文件cn.access_log和com.access_log加上行号（空白行不加）附加到备份文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b com.access_log cn.access_log &gt;&gt; backup_log</span><br></pre></td></tr></table></figure><p>清空日志com.access_log内容（遇到权限问题，需要sudo su到root）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; com.access_log</span><br></pre></td></tr></table></figure><p>制作镜像文件（假设软盘放好后）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure><p>把镜像写入软盘（假设软盘放好后）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat IMG_FILE &gt; /dev/fd0</span><br></pre></td></tr></table></figure><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>作用：实时显示进程状态。</p><p>mac和linux（服务器为centos7）下top的参数是有些不一致的。<br><a href="http://www.runoob.com/linux/linux-comm-top.html" target="_blank" rel="noopener">参考文档</a>上是linux下的使用。</p><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>作用：创建目录。</p><p>于TEST目录下创建test子目录，若TEST目录不存在则创建一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir TEST/test</span><br></pre></td></tr></table></figure></p><h4 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h4><p>作用：文本编辑器。</p><p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html" target="_blank" rel="noopener">Vim快捷键键位图</a>。</p><p><a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">vi/vim 的使用</a></p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>作用：修改文件权限。</p><p><a href="https://www.cnblogs.com/123-/p/4189072.html" target="_blank" rel="noopener">linux文件的权限表示</a>。</p><p><a href="http://www.runoob.com/linux/linux-comm-chmod.html" target="_blank" rel="noopener">实例</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;任务：linux基础命令tail-cat-top-mkdir-vi-chmod等&quot;&gt;&lt;a href=&quot;#任务：linux基础命令tail-cat-top-mkdir-vi-chmod等&quot; class=&quot;headerlink&quot; title=&quot;任务：linux基础命令
      
    
    </summary>
    
      <category term="linux" scheme="bighua.top/categories/linux/"/>
    
    
      <category term="shell" scheme="bighua.top/tags/shell/"/>
    
      <category term="linux" scheme="bighua.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>第二周笔记-任务一</title>
    <link href="bighua.top/2018/07/23/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0-%E4%BB%BB%E5%8A%A1%E4%B8%80/"/>
    <id>bighua.top/2018/07/23/第二周笔记-任务一/</id>
    <published>2018-07-23T01:29:09.000Z</published>
    <updated>2018-07-25T01:34:14.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间"><a href="#任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间" class="headerlink" title="任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间"></a>任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间</h4><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li><a href="https://www.kancloud.cn/wizardforcel/nginx-doc/92350" target="_blank" rel="noopener">Nginx 中文官方文档</a></li></ol><h4 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h4><p>由于使用的brew安装的nginx，配置文件目录<code>/usr/local/etc/nginx</code>。</p><p>方法一：新建server，由于我们在本地操作，ip都是127.0.0.1对应localhost，所以为区分站点可只修改listen、root及php脚本fastcgi_param。需要指定路径下有站点目录。此时重启nginx，通过localhost:端口即可访问不同的站点。</p><p>方法二：在/etc/hosts文件中新增两个域名解析到127.0.0.1，我新增的是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 bighua.com</span><br><span class="line">127.0.0.1 bighua.cn</span><br></pre></td></tr></table></figure><p>然后修改两个server的server_name、root及php脚本fastcgi_param。在指定路径下要有站点目录。此时重启nginx，通过两个域名即可正确访问两个不同的站点。</p><h4 id="nginx日志配置和查看"><a href="#nginx日志配置和查看" class="headerlink" title="nginx日志配置和查看"></a>nginx日志配置和查看</h4><p>使用brew安装的nginx默认的日志文件在目录<code>/usr/local/var/log/nginx</code>下，但是根据nginx文档可以自己在每个server中单独配置访问日志。<br>在第一个server中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/com.access_log;</span><br></pre></td></tr></table></figure><p>在第二个server中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/cn.access_log;</span><br></pre></td></tr></table></figure><p>在http外或server外新增（即全局）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log    /Users/wuhua/Desktop/nginxlog/myerror_log;</span><br></pre></td></tr></table></figure><p>errlog_log只会以第一个为准，即在两个server中定义不同的error_log只会生成第一个server中的error_log文件。<br>之后重启nginx，在桌面上的nginxlog目录下会生成三个文件分别为：com.access_log、cn.access_log、cn.error_log。访问上面配置的两个域名，将会在两个访问日志中记录访问信息，出错信息记录到myerror_log。</p><h4 id="根据日志统计访问次数、响应时间"><a href="#根据日志统计访问次数、响应时间" class="headerlink" title="根据日志统计访问次数、响应时间"></a>根据日志统计访问次数、响应时间</h4><p>可以规定记录到日志中信息的格式，并为格式命名，然后在日志尾部通过命名应用格式。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                   &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"> </span><br><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/com.access_log main;</span><br></pre></td></tr></table></figure><p>格式中的信息表示如下表：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">$remote_addr</td><td style="text-align:left">客户端地址</td><td style="text-align:left">127.0.0.1</td></tr><tr><td style="text-align:left">$remote_user</td><td style="text-align:left">客户端用户名称</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">$time_local</td><td style="text-align:left">访问时间和时区</td><td style="text-align:left">23/Jul/2018:17:23:15 +0800</td></tr><tr><td style="text-align:left">$request</td><td style="text-align:left">请求的url和http协议</td><td style="text-align:left">GET /login HTTP/1.1</td></tr><tr><td style="text-align:left">$status</td><td style="text-align:left">HTTP请求状态</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">$upstream_status</td><td style="text-align:left">upstream状态</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">$body_bytes_sent</td><td style="text-align:left">发送给客户端文件内容大小</td><td style="text-align:left">4618</td></tr><tr><td style="text-align:left">$http_referer</td><td style="text-align:left">url跳转来源</td><td style="text-align:left"><a href="http://bighua.cn/register" target="_blank" rel="noopener">http://bighua.cn/register</a></td></tr><tr><td style="text-align:left">$http_user_agent</td><td style="text-align:left">用户终端浏览器等信息</td><td style="text-align:left">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</td></tr><tr><td style="text-align:left">$http_x_forwarded_for</td><td style="text-align:left">客户端的真实ip</td><td style="text-align:left">127.0.0.1(通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加 x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端请求的服务器地址.)</td></tr><tr><td style="text-align:left">$ssl_protocol</td><td style="text-align:left">SSL协议版本</td><td style="text-align:left">TLSv1（https请求）</td></tr><tr><td style="text-align:left">$ssl_cipher</td><td style="text-align:left">交换数据中的算法</td><td style="text-align:left">RC4-SHA(https请求)</td></tr><tr><td style="text-align:left">$upstream_addr</td><td style="text-align:left">后台upstream的地址，即真正提供服务的主机地址</td><td style="text-align:left">127.0.0.1:80</td></tr><tr><td style="text-align:left">$request_time</td><td style="text-align:left">整个请求的总时间</td><td style="text-align:left">0.205</td></tr><tr><td style="text-align:left">$upstream_response_time</td><td style="text-align:left">请求过程中，upstream响应时间</td><td style="text-align:left">0.002</td></tr></tbody></table><p>未经设置默认eccess_log中的一条日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:17:23:15 +0800] &quot;GET /login HTTP/1.1&quot; 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;</span><br></pre></td></tr></table></figure><p>统计访问次数和响应时间，我们根据客户端真实IP($http_x_forwarded_for)/客户端地址($remote_addr)确定用户统计次数，然后在格式中添加$upstream_response_time和$request_time记录每一次请求的服务器响应时间和整个请求的时间。</p><p>设置log_format如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">   &apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br></pre></td></tr></table></figure><p>重启nginx再次访问页面查看最新一条日志记录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:19:49:17 +0800] &quot;GET /login HTTP/1.1&quot; 0.045 0.045 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>第一项<code>127.0.0.1</code>为用户地址，第八项和第九项0.045为整个请求的时间和服务器响应时间，统计访问次数则是统计第一项每个地址的出现次数。</p><p>配置详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">user  wuhua admin;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">error_log    /Users/wuhua/Desktop/nginxlog/myerror_log;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    </span><br><span class="line">    log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">&apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    </span><br><span class="line">   server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name bighua.com;</span><br><span class="line">        root /Users/wuhua/Desktop/TAL-practice/login/public;</span><br><span class="line">        access_log   /Users/wuhua/Desktop/nginxlog/com.access_log myfmt;</span><br><span class="line"></span><br><span class="line">        add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">        add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">        add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">        location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">                fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">                fastcgi_index   index.php;</span><br><span class="line">                fastcgi_param   SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/login/public$fastcgi_script_name;</span><br><span class="line">                include         fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ /\.(?!well-known).* &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name bighua.cn;</span><br><span class="line">        root /Users/wuhua/Desktop/TAL-practice/loginold/public;</span><br><span class="line">        access_log   /Users/wuhua/Desktop/nginxlog/cn.access_log myfmt;</span><br><span class="line"></span><br><span class="line">        add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">        add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">        add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">        location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">                fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">                fastcgi_index   index.php;</span><br><span class="line">                fastcgi_param   SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/loginold/public$fastcgi_script_name;</span><br><span class="line">                include         fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ /\.(?!well-known).* &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    include servers/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客<a href="https://www.cnblogs.com/handongyu/p/6513185.html" target="_blank" rel="noopener">Nginx 日志分析及性能排查</a>使用awk命令对日志进行处理。</p><p>另外自己的想法也可以通过php进行读文件处理，或则将awk命令处理过的日志存储数据库等等。</p><h5 id="使用awk进行日志分析"><a href="#使用awk进行日志分析" class="headerlink" title="使用awk进行日志分析"></a>使用awk进行日志分析</h5><p>根据日志格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">   &apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br></pre></td></tr></table></figure><p>第一次处理需要提取的信息有第一项、第五项、第六项，但是不加分隔符awk默认使用‘ ’空隔作为分隔符，按上方格式获取的一条日志记录如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:19:49:17 +0800] &quot;GET /login HTTP/1.1&quot; 0.045 0.045 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>使用awk对应提取第一列、第九列、第十列。<br>提取数据command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **._access_log | awk &apos;&#123;print $1,$9,$10&#125;&apos;</span><br></pre></td></tr></table></figure><p>因为有两个日志文件，命令也比较长，整理成shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat $1 | awk &apos;&#123;print( $1,$9,$10)&#125;&apos; &gt; $1.data.csv</span><br></pre></td></tr></table></figure><p>调用脚本，以日志为参数，保存结果为csv文件。</p><p>统计访问次数则根据访问ip使用uniq进行处理，command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **._access_log | awk &apos;&#123;print $1&#125;&apos; | uniq -c</span><br></pre></td></tr></table></figure><p>根据参考博客可以导出为csv文件，command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **.access_log | awk &apos;&#123;print $1&#125;&apos; | uniq -c | awk &apos;&#123;print $1,$2&#125;&apos; &gt; **.countip.csv</span><br></pre></td></tr></table></figure><p>整理成shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat $1 | awk &apos;&#123;print $1&#125;&apos; | uniq -c | awk &apos;&#123;print $1,$2&#125;&apos; &gt; $1.countip.csv</span><br></pre></td></tr></table></figure><p>调用脚本，以日志为参数，保存处理结果为csv文件。</p><h5 id="使用ngxtop统计实时数据"><a href="#使用ngxtop统计实时数据" class="headerlink" title="使用ngxtop统计实时数据"></a>使用ngxtop统计实时数据</h5><p>项目地址：<a href="https://github.com/lebinh/ngxtop" target="_blank" rel="noopener">ngxtop</a><br>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">sudo easy_install ngxtop</span><br></pre></td></tr></table></figure><p>使用文档：<a href="https://github.com/lebinh/ngxtop#usage" target="_blank" rel="noopener">Usage</a><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngxtop -c PATH/nginx.conf -t 1</span><br></pre></td></tr></table></figure><h5 id="使用php进行日志分析"><a href="#使用php进行日志分析" class="headerlink" title="使用php进行日志分析"></a>使用php进行日志分析</h5><p>这里就不在详叙了，想法就是读取文件，按行读取，按空格分割，从分隔结果的数据中取需要的数据。</p><h4 id="业务分析感悟"><a href="#业务分析感悟" class="headerlink" title="业务分析感悟"></a>业务分析感悟</h4><blockquote><p>通常我们根据日期为每天访问建立日志，同时对日志的分析，可以通过crontab设置定时任务，每天进行自动分析，可以考虑将分析结果存储到数据库等，便与查看。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间&quot;&gt;&lt;a href=&quot;#任务：nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间&quot; class=&quot;headerlink&quot; title=&quot;任务：ngi
      
    
    </summary>
    
      <category term="nginx" scheme="bighua.top/categories/nginx/"/>
    
    
      <category term="nginx" scheme="bighua.top/tags/nginx/"/>
    
      <category term="linux" scheme="bighua.top/tags/linux/"/>
    
      <category term="conf" scheme="bighua.top/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>第一周笔记</title>
    <link href="bighua.top/2018/07/17/%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
    <id>bighua.top/2018/07/17/第一周笔记/</id>
    <published>2018-07-17T09:40:15.000Z</published>
    <updated>2018-07-25T06:01:11.762Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务一：环境搭建"><a href="#任务一：环境搭建" class="headerlink" title="任务一：环境搭建"></a>任务一：环境搭建</h3><p>详情：搭建nginx/php/mysql/redis/laravel环境。<br>遇到的问题及收获见<a href="/2018/07/05/Mac搭建开发环境初体验/" title="Mac搭建开发环境初体验">Mac搭建开发环境初体验</a>。</p><hr><h3 id="任务二：登陆注册的基本功能"><a href="#任务二：登陆注册的基本功能" class="headerlink" title="任务二：登陆注册的基本功能"></a>任务二：登陆注册的基本功能</h3><p>详情：小作业，登录注册完成基本功能（注册用户信息格式验证，用户名唯一性，修改密码，用户资料，邮箱验证，手机号码验证，密码加密规则，session存储，cookie填写，前端保存密码，查询用户信息）。</p><h4 id="实践中主要参考资料"><a href="#实践中主要参考资料" class="headerlink" title="实践中主要参考资料"></a>实践中主要参考资料</h4><ol><li><a href="https://laravel-china.org/docs/laravel/5.6" target="_blank" rel="noopener">Laravel 5.6 中文文档</a>。</li><li><a href="https://github.com/kevinyan815/Learning_Laravel_Kernel" target="_blank" rel="noopener">Learning_Laravel_Kernel</a>，前人的laravel框架学习笔记。</li><li><a href="https://www.insp.top/learn-laravel-container" target="_blank" rel="noopener">laravel 学习笔记 —— 神奇的服务容器</a>，前人的学习博客。</li><li><a href="https://blog.csdn.net/tanmx219/article/details/78922770" target="_blank" rel="noopener">Laravel5.5源码详解 – Auth中间件</a>，前人总结的关于Auth中间件的博客。</li><li><a href="https://segmentfault.com/blog/lx1036" target="_blank" rel="noopener">Laravel/Angular 技术分享</a>，前人关于框架探秘博客。</li></ol><h4 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h4><p>基本完成任务进度表中这周的任务，包括：  </p><ol><li>注册登陆。</li><li>记住我。</li><li>用户资料填写、展示。</li><li>通过邮箱重置密码。</li><li>自己编写简单验证、使用框架自带认证器认证字段。</li></ol><hr><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="163反垃圾邮件导致发送邮件失败"><a href="#163反垃圾邮件导致发送邮件失败" class="headerlink" title="163反垃圾邮件导致发送邮件失败"></a>163反垃圾邮件导致发送邮件失败</h4><p>修改邮件内容，设置邮件标题（mail属性$subject）。</p><h4 id="部署到服务器上迁移数据库失败"><a href="#部署到服务器上迁移数据库失败" class="headerlink" title="部署到服务器上迁移数据库失败"></a>部署到服务器上迁移数据库失败</h4><p>详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Illuminate\Database\QueryException]</span><br><span class="line">SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))</span><br><span class="line">[PDOException]</span><br><span class="line">SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/betx/p/6544090.html" target="_blank" rel="noopener">Laravel 5.4: 特殊字段太长报错</a>。<br>laravel5.4改变了默认的数据库字符集，使用utf8mb4，支持存储emojis。如果你运行的MySQL低于v5.7.7或MariaDB版本低于10.2.2，需要对app/Providers/AppServiceProvider.php进行修改，在其boot方法中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Schema::defaultStringLength(&apos;191&apos;);</span><br></pre></td></tr></table></figure><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><h4 id="关于重置密码的考虑"><a href="#关于重置密码的考虑" class="headerlink" title="关于重置密码的考虑"></a>关于重置密码的考虑</h4><p>之前自己也实现过这部分的功能，当时的做法是生成一个字段并存储到session中，将这个字段作为url参数发送到重置邮箱，通过这个url附带的参数和session中的参数进行比对然后设置一个临时登陆状态，跳转到重置密码页面，重置成功后销毁session字段跳转到登陆页。今天的做法类似，不过加了邮箱字段存session替换上方逻辑中的临时登陆态。<br>但框架自带的重置密码是通过字段、邮箱存数据库，之后取库进行比对操作的，个人感觉这种方式在某些场景下会增大DB的IO，但是可以记录用户的密码变更记录，需要结合具体场景进行考虑和应用。</p><h4 id="cookie和session的重新认识"><a href="#cookie和session的重新认识" class="headerlink" title="cookie和session的重新认识"></a>cookie和session的重新认识</h4><p>之前有学习过相关知识，但在使用中通常直接使用框架封装好的接口，实现业务时有些细节未做关注，例如：服务器如何识别浏览器用户标识，框架对用于标识用户凭证的相关cookie的设置等等。<br>通过阅读laravel自带的登陆源码、相关文档、数据库表字段等，总结其使用session和cookie实现的业务逻辑流程大概如下。</p><blockquote><p>浏览器第一次发起请求，laravel接受请求后生成_token、_previous、_flash存储于session。_token用于防csrf，也会经过加密后存储于cookie中，之后用户的每一次经web路由的请求都需要带上这个凭证。_flash用于记录闪存数据，在下一次请求后失效。_previous用于记录请求的url。在cookie中还会存储一项APP_NAME_session，用于标识session_id。 存储于cookie的XSRF_TOKEN和APP_NAME_session存储时间为一天。 在登陆后会在session中加入一个用于标识登陆状态的字段，若提交的记住我字段为true，则在cookie中新增记录login_web_***，存储时间为5年，并将此字段值记录于对应用户表的remember_token字段中。<br>登陆逻辑先判断是否session中是否有记录登陆状态的标识和请求带的cookie是否有记住我表示，若都没有则跳到登陆页，有记住我则根据记住我值在数据库中查找对应的用户信息，设置session登陆字段。</p></blockquote><h4 id="关于laravel框架的一点收获"><a href="#关于laravel框架的一点收获" class="headerlink" title="关于laravel框架的一点收获"></a>关于laravel框架的一点收获</h4><p>在本周任务中，有个字段验证功能，要求自己书写。但是我只在注册页面使用到ajax配合自己的字段验证，在其他页面使用到框架自带的validate验证器。通过阅读相关源码和文档发现，验证的错误消息返回其实是通过路由重定向带上错误消息和表单消息，这样的逻辑功能就很好理解了。回顾自己注册页面的验证逻辑，也可以通过这样实现，重写验证，完全不使用ajax。回想这部分处理的失败，主要是由于对laravel的使用缺乏经验，把事情想复杂了。<br>之前比较熟悉tp框架(v3.2.3)，tp框架没有laravel框架这么多的设计理念，例如容器、中间件等。现在理解中间件的作用相当于tp中基类的构造函数业务逻辑，都是在请求执行前进行的一些相关处理，laravel。laravel将路由模块独立出来，对路由的使用更加灵活，可以根据请求方式设置请求的具体执行路径，命名更方便等等。<br>记得之前在面试的过程中被问到laravel和tp的区别，之后搜了一下相关的问题，有人说到laravel更适合大型项目。跟过之前的使用经验和这周导师为我们展示的线上业务系统，目前的理解是laravel更适合模块的组织，可以将各个业务模块划分的更清晰，便于维护管理。<br>回看这周实现的几百行代码，实践中写下了很多逻辑bug，反复修改。编码也很不优雅，其中把一个处理逻辑放在了构造函数中，感觉这种方式很不符合laravel的规范，在代码组织上也有点糟，需要待改进。<br>本周的任务只使用到了laravel中很少的一部分功能，根据之前的接触了解，laravel还自带有队列、定时任务等特性，本次都没有使用到。如今的主要任务是熟悉框架，适应框架，能够使用框架顺利的完成工作，但作为研发，在完成任务之后，希望自己能够抽出时间了解其底层的实现机制。</p><h4 id="关于php一些语法知识的收获"><a href="#关于php一些语法知识的收获" class="headerlink" title="关于php一些语法知识的收获"></a>关于php一些语法知识的收获</h4><p>在之前也有了解过trait复用特性，但没写过大型的业务，基本没考虑过这个特性的使用，在阅读larvel框架源码的过程中，看到了很多地方使用到trait。<br>php的匿名函数也有了解过，在中间件中看到Closure类的使用，才第一次接触到这个类，之前对匿名函数的使用多在返回结果的处理和传参的处理上。看他人博客的介绍，在中间件中此处的作用是请求的转发，继续执行原请求的业务逻辑，待细看这部分的源码自己进行理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务一：环境搭建&quot;&gt;&lt;a href=&quot;#任务一：环境搭建&quot; class=&quot;headerlink&quot; title=&quot;任务一：环境搭建&quot;&gt;&lt;/a&gt;任务一：环境搭建&lt;/h3&gt;&lt;p&gt;详情：搭建nginx/php/mysql/redis/laravel环境。&lt;br&gt;遇到的问题
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
      <category term="学习" scheme="bighua.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mac搭建开发环境初体验</title>
    <link href="bighua.top/2018/07/05/Mac%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>bighua.top/2018/07/05/Mac搭建开发环境初体验/</id>
    <published>2018-07-05T05:27:55.000Z</published>
    <updated>2018-07-25T04:25:07.763Z</updated>
    
    <content type="html"><![CDATA[<p>周一入职，已经是第4天了，这两天在配置开发环境上走了不少坑，记录下来以备后续查阅。</p><p>公司配的mac周二下午才到，全新的13.3寸256/8G的MacBookPro，希望自己的技术能力能配得上使用的工具。周一leader让在自带的电脑上配置nginx+mysql+redis+php开发环境，由于之前已经配置过很多次，所以主要是查看配置的合理性以及安装redis及相应的php拓展。redis在其官网上有相应的安装教程，phpredis找包然后下载解压缩，使用phpize生成configure文件，make &amp; make install，在php.ini中添加拓展。在检查lnmp的过程中，发现nginx是用的默认包管理工具安装的，想将这些都安装在一个地方便与使用和管理，于是卸载之自己编译安装，安装过程根据自己之前记录的一篇博客来的。最后在配置nginx时，又遇到了权限问题，昨天在Mac上搭建时也遇到了这个问题，解决办法简洁点就是将user设置为当前用户组用户，将指定的web目录从根文件开始赋予能够访问的权限。</p><p>初次使用Mac，这几天的环境搭建过程中踩坑收获如下：</p><ul><li>安装brew,mac下的包管理工具，感觉比centos的yum/rpm更好使，比自己动手编译安装的缺点是经常需要通过brew info得知安装软件的配置文件和执行文件位置，不便于管理。</li><li>自带php7.1.16，以php-fpm模式运行需要自己配置相关文件，在/etc目录下。   </li><li>在/etc/paths.d中以文件的方式添加环境变量更加方便管理，source后在另开的终端中才会生效。</li><li>编译安装nginx和使用brew安装nginx，配置web目录遇到的权限问题同上方式解决。</li><li>有mac下的mysql安装包，直接下载点点点，别忘了记下弹出的初始密码，也可使用brew安装。</li><li>使用brew安装redis，下载编译phpredis，phpize、./configure、make这三步没有问题，make install遇到<code>Operation not permitted</code>报错，查询得知Mac下的SIP机制导致的，需要在重启Mac过程中按<code>command</code>+<code>R</code>过程进入恢复模式，打开终端输入<code>csrutil disable</code>关闭SIP，再次重启电脑执行make install成功，在php.ini中添加拓展。</li></ul><p>周三晚上终于把环境搞定了，然后配置git配置node把此博客进行了迁移。书到用时方恨少，今天开始，好好学习好好工作！</p><p>在<a href="https://laravel-china.org/docs/laravel/5.6/deployment/1357#nginx" target="_blank" rel="noopener">Laravel 的部署</a>，附份nginx配置文件以备后续参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    root /Users/wuhua/Desktop/TAL-practice/login/public;</span><br><span class="line"></span><br><span class="line">    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">    add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">    add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">    location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">        fastcgi_index   index.php;</span><br><span class="line">        fastcgi_param   SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/login/public$fastcgi_script_name;</span><br><span class="line">        include         fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /\.(?!well-known).* &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mac连接linux服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@ip</span><br></pre></td></tr></table></figure><p>mac上传文件/目录到服务器：<br>上传目录到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r dir root@ip:/root/</span><br></pre></td></tr></table></figure><p>上传文件到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r file.txt root@ip:/root/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周一入职，已经是第4天了，这两天在配置开发环境上走了不少坑，记录下来以备后续查阅。&lt;/p&gt;
&lt;p&gt;公司配的mac周二下午才到，全新的13.3寸256/8G的MacBookPro，希望自己的技术能力能配得上使用的工具。周一leader让在自带的电脑上配置nginx+mysql
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="nginx" scheme="bighua.top/tags/nginx/"/>
    
      <category term="phpredis" scheme="bighua.top/tags/phpredis/"/>
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>hexo多台电脑间迁移解决方案</title>
    <link href="bighua.top/2018/07/05/hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E9%97%B4%E8%BF%81%E7%A7%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>bighua.top/2018/07/05/hexo多台电脑间迁移解决方案/</id>
    <published>2018-07-04T18:34:02.000Z</published>
    <updated>2018-07-25T16:14:04.670Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作配发了mac，之前在自己的thinkpad上搭建的博客如何迁移到mac上，并且保持博客的完整性和统一性就成了问题。</p><p>在网上搜了一下，前人已经给出了巧妙的解决方案，通过在自己的hexo项目上开一个分支，分支中保留hexo所有重要文件，在其他电脑上直接下载此分支，然后使用npm更新下载所有依赖包，这样其实就可以得到自己的hexo完整项目。通过这个克隆的分支可以写博客上传到master，也可以自更新上传到分支，保证每次使用后的完整性。</p><p>具体参考的前人博客<a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">Hexo博客从一台电脑迁移到其他电脑</a>,介绍了总体的解决思路和步骤，具体细节要根据自己的情况而定。</p><p>具体到本博客的迁移过程：</p><ul><li><p>克隆自己的hexo项目到本地，其实主要目的是获取git配置文件，作为分支的git配置文件，若本地已有git项目，可省略此步，后面直接获取git配置文件即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cocowh/cocowh.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>备份本地的hexo项目，删除依赖库和不必要的文件（多余的主题目录，生成的页面等等，根据自己配置决定），<code>修改主题中git的配置文件名，否则主题目录被当作单独的git项目无法被跟踪，无法上传</code>，有个风险是主题配置文件中的信息被暴露出来，如果不上传，在另一台电脑上克隆后又要重新下载配置主题文件，显得繁琐。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -R hexo blogbackup</span><br><span class="line">cp -R cocowh.github.io/.git blogbackup/.git</span><br><span class="line">cp cocowh.github.io/.gitignore  blogbackup</span><br><span class="line">cd blogbackup</span><br><span class="line">rm -rf public node_modules //其实在.gitignore中已经包含这些文件和目录</span><br></pre></td></tr></table></figure></li><li><p>创建一个叫blogbackup的分支并push到分支。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b blogbacku</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;备份分支&quot;</span><br><span class="line">git push --set-upstream origin blogbackup</span><br></pre></td></tr></table></figure></li><li><p>在另一台已经部署好git、node 、hexo等必须环境的电脑上克隆blogbackup分支到本地，克隆master到本地(没用hexo自带提交指令，自己编写的本地提交脚本，根据情况灵活决定)。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone -b blogbackup https://github.com/cocowh/cocowh.github.io.git</span><br><span class="line">cd coocwh.github.io</span><br><span class="line">npm update</span><br><span class="line">mkdir .deploy</span><br><span class="line">cd .deploy</span><br><span class="line">git clone https://github.com/cocowh/coocwh.github.io.git</span><br><span class="line">cd ../..</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>到这里已经基本搞定，写博客运行脚本提交到master。再次迁移到另一台电脑上，直接提交到blogbackup分支就好，更新主题要将git文件名修改回来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于工作配发了mac，之前在自己的thinkpad上搭建的博客如何迁移到mac上，并且保持博客的完整性和统一性就成了问题。&lt;/p&gt;
&lt;p&gt;在网上搜了一下，前人已经给出了巧妙的解决方案，通过在自己的hexo项目上开一个分支，分支中保留hexo所有重要文件，在其他电脑上直接下载
      
    
    </summary>
    
      <category term="git" scheme="bighua.top/categories/git/"/>
    
    
      <category term="hexo" scheme="bighua.top/tags/hexo/"/>
    
      <category term="git" scheme="bighua.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>天涯未远，江湖再见</title>
    <link href="bighua.top/2018/06/16/%E5%A4%A9%E6%B6%AF%E6%9C%AA%E8%BF%9C%EF%BC%8C%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81/"/>
    <id>bighua.top/2018/06/16/天涯未远，江湖再见/</id>
    <published>2018-06-16T06:20:04.000Z</published>
    <updated>2018-07-04T17:45:25.113Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，距离上一篇博客过去快两个月了。五月中寻毕设做的差不多了，堕落了一下，五月下旬回家陪可爱的外甥女玩了10天，六月上旬忙着写论文准备答辩，答辩后班级毕业照聚餐，然后提前回家陪家人过端午节，20号送二姐和外甥女上高铁。这篇本来打算在16号退宿走的那天记录的，想着趁年轻还想说还想写记录下。然而那天仅仅创建了文章，宿舍收拾打包东西，内心繁杂，也没太多心情想写。现在是24号凌晨4点，一直睡不着，就爬起来打开电脑，续写这篇记录。</p><h3 id="世人都晓勤奋好，贪玩懒惰忘不了"><a href="#世人都晓勤奋好，贪玩懒惰忘不了" class="headerlink" title="世人都晓勤奋好，贪玩懒惰忘不了"></a>世人都晓勤奋好，贪玩懒惰忘不了</h3><p>在今年生日的时候，已经写了篇博客，大致记录了大学四年的生活。总结这四年，应了那句话：间歇性踌躇满志，持续性混吃等死。</p><p>大学仿佛就是高中的一次循环。高一包夜上网玩游戏，夜晚被窝玩手机，成绩慢慢掉队。大一上课睡觉，课下浪玩游戏抄作业，大一下学期挂科。高二醒悟想考好点的大学开始慢慢认真学习，却发现掉队有些严重了，感谢学霸同桌带，成绩慢慢稳住，貌似那时候也是和一些同学有些矛盾，也可能是高三，直到现在在处理人际关系以及交往上还是不擅长。同样的也是在大二才开始意识到学习的重要性，有几个同班同学因为挂科严重被留级了，自己也开始上课认真听讲，慢慢的改上课睡觉的习惯，可是一学期的努力虽然成绩有所提高，但是跟那些学霸还是有些距离。摆在眼前的两条路：考研和工作，自己选择了后者，上学期末和同学一起加入了计协的web组，开始带我们的是一个大三的学姐，在下学期她就去腾讯实习了，受学姐的模范鼓励，以及一些情绪的影响，大二下学期一直默默的激励的自己去学习新的东西，虽然那些东西在现在看来真的是皮毛，学的太少太少了。大二这一年过的不太好，心情波动很大，和一些同学闹僵了。</p><p>对我来说的大学，在大二结束时就已经结束了。后面的两年都是以工作为主要目的，没任何值的纪念的生活细节。有时候总是觉得自己是不是有些心理问题，又或者说一些不成熟、幼稚的心理和想法，而自己从没有过正面的面对去解决它，就像这样将其归结为成长。直到现在仍然是复杂的思绪，我想或许有一天我会将所有的一切都找到合理的解决范本，然后再也不会像现在这样吐槽生活、记录心情。</p><p>今天是24号，到现在还没睡意，白天估计是废了，下个月2号入职，在家也呆不了几天了，总想骑车去一次老城十字街，去一次白马寺，去那些还没去过的地方，可是没有人一起的活动，显得一切都索然无味。就像大学的后两年，仅仅以找工作、不挂科以及忘记一些事情和逃避一些事情为主要内容的生活，没有任何意义，面对必须面对的所有人都保持应有的客套，还要忍受一些恶心的事情。</p><h3 id="狮山有情君有意，栀花香里话别离"><a href="#狮山有情君有意，栀花香里话别离" class="headerlink" title="狮山有情君有意，栀花香里话别离"></a>狮山有情君有意，栀花香里话别离</h3><p>就像一颗由远及近的流星，从远处慢慢飞过来，越来越快，到达最近时再以最快的速度离去，慢慢的，慢慢的消失。有些比较久远的事情，还是让他变模糊的好。我不知道现在正处在哪个阶段，或许是流星飞来的阶段。时间总觉得是越来越快了，父母老了，在过个几年就要退休了，今后的时间将大部分被工作带走，或许不觉间这几年就过去了。</p><p>大学这四年也是，总觉的不该这么快的，仿佛离别时都没意识到这就是离别，说是再见，或许是再也不见。离别可能也慢慢变成常态，慢慢的或许也没有现在的这些挢揉造作了。</p><p>无论四年如何，都是自己的人生轨迹。对学校的抱怨也好、留恋也罢，与同学的交好也好、积怨也罢，对某老师的厌恶也好、赞美也罢，所有这一切，形成了独一无二的轨迹。这几年，没仔细想过最后应有的模样，没规划过合理的路径，走一步看一步。开始准备读研，现在走上了工作的路径。开始想学吉他，现在拿起来爬格子还是很费力。总的来说，可能是不如意的。</p><p>今天是24号，昨天上午毕业典礼，下午发放毕业证和学位证，还在学校的同学，估计很多也在今天离开。天下没有不散的宴席，祝同学们前程似锦！</p><h3 id="前方不需太重的行囊，和过去和解吧"><a href="#前方不需太重的行囊，和过去和解吧" class="headerlink" title="前方不需太重的行囊，和过去和解吧"></a>前方不需太重的行囊，和过去和解吧</h3><p>一段经历，已成过去。进入社会，又是一个新的旅程！</p><p>忘记过去，规划以后的摸样，前方不需太重的行囊，和过去和解吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没有更新博客了，距离上一篇博客过去快两个月了。五月中寻毕设做的差不多了，堕落了一下，五月下旬回家陪可爱的外甥女玩了10天，六月上旬忙着写论文准备答辩，答辩后班级毕业照聚餐，然后提前回家陪家人过端午节，20号送二姐和外甥女上高铁。这篇本来打算在16号退宿走的那天记录的，想
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="毕业" scheme="bighua.top/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>服务器lnmp环境搭建配置</title>
    <link href="bighua.top/2018/05/09/%E6%9C%8D%E5%8A%A1%E5%99%A8lnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/"/>
    <id>bighua.top/2018/05/09/服务器lnmp环境搭建配置/</id>
    <published>2018-05-09T15:26:50.000Z</published>
    <updated>2018-07-25T02:46:41.201Z</updated>
    
    <content type="html"><![CDATA[<p>搭建本博客之初的原因之一，就是在搭建lnmp和其他系列环境时遇到了很多问题，今天将服务器重置了，先配置好了go环境，在<a href="/2018/04/10/Golang笔记-基础篇-一/" title="Golang笔记-基础篇(一)">Golang笔记-基础篇(一)</a>的初始部分进行了相关步骤的补充。下面记录下lnmp环境的搭建配置。</p><h2 id="nginx编译安装"><a href="#nginx编译安装" class="headerlink" title="nginx编译安装"></a>nginx编译安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>可通过<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a>选择版本，然后服务器端下载到/usr/local，此处选择最新稳定版1.14.0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z local]# wget -c https://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z local]# tar -zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="使用默认配置"><a href="#使用默认配置" class="headerlink" title="使用默认配置"></a>使用默认配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z nginx-1.14.0]# ./configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>但是报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either disable the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</span><br></pre></td></tr></table></figure><p>提示缺少pcre库，给出了解决办法忽略此项或者安装缺少的pcre库，经过搜索得知库为<code>pcre-devel</code>而不是<code>pcre</code>。安装库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z nginx-1.14.0]# yum -y install pcre-devel</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either disable the module by using --without-http_gzip_module</span><br><span class="line">option, or install the zlib library into the system, or build the zlib library</span><br><span class="line">statically from the source with nginx by using --with-zlib=&lt;path&gt; option.</span><br></pre></td></tr></table></figure><p>安装所需依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib-devel</span><br></pre></td></tr></table></figure><p>再次运行<code>./configure</code>正确。</p><h4 id="自定义配置（不推荐）"><a href="#自定义配置（不推荐）" class="headerlink" title="自定义配置（不推荐）"></a>自定义配置（不推荐）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module \  </span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf \</span><br><span class="line">--pid-path=/usr/local/nginx/conf/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure><p>将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录，另外前两两项需要先创建好用户和用户组。</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><p>可使用<code>whereis nginx</code>查看安装的路径。</p><h3 id="为nginx的启动、重启、重载配置添加脚本"><a href="#为nginx的启动、重启、重载配置添加脚本" class="headerlink" title="为nginx的启动、重启、重载配置添加脚本"></a>为nginx的启动、重启、重载配置添加脚本</h3><h4 id="直接启动方法"><a href="#直接启动方法" class="headerlink" title="直接启动方法"></a>直接启动方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><h4 id="添加脚本控制"><a href="#添加脚本控制" class="headerlink" title="添加脚本控制"></a>添加脚本控制</h4><blockquote><p>新建文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><blockquote><p>添加内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>systemctl的一些使用方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled servicename.service #查询服务是否开机启动</span><br><span class="line">systemctl enable xxx.service #开机运行服务</span><br><span class="line">systemctl disable xxx.service #取消开机运行</span><br><span class="line">systemctl start xxx.service #启动服务</span><br><span class="line">systemctl stop xxx.service #停止服务</span><br><span class="line">systemctl restart xxx.service #重启服务</span><br><span class="line">systemctl reload xxx.service #重新加载服务配置文件</span><br><span class="line">systemctl status xxx.service #查询服务运行状态</span><br><span class="line">systemctl --failed #显示启动失败的服务</span><br></pre></td></tr></table></figure><blockquote><p>添加脚本后centos7 中操作nginx的方法有</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled nginx.service #查询nginx是否开机启动</span><br><span class="line">systemctl enable nginx.service #开机运行nginx</span><br><span class="line">systemctl disable nginx.service #取消开机运行nginx</span><br><span class="line">systemctl start nginx.service #启动nginx</span><br><span class="line">systemctl stop nginx.service #停止nginx</span><br><span class="line">systemctl restart nginx.service #重启nginx</span><br><span class="line">systemctl reload nginx.service #重新加载nginx配置文件</span><br><span class="line">systemctl status nginx.service #查询nginx运行状态</span><br><span class="line">systemctl --failed #显示启动失败的服务</span><br></pre></td></tr></table></figure><blockquote><p>添加到开机自动启动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izjgheeixigi44z ~]# systemctl enable nginx.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure><p>至此以安装成功，通过IP可访问显示nginx页面。</p><hr><h2 id="mysql安装（centos7默认mariadb）"><a href="#mysql安装（centos7默认mariadb）" class="headerlink" title="mysql安装（centos7默认mariadb）"></a>mysql安装（centos7默认mariadb）</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z /]# yum -y install mariadb mariadb-server</span><br></pre></td></tr></table></figure><h3 id="启动MariaDB并加入开机启动"><a href="#启动MariaDB并加入开机启动" class="headerlink" title="启动MariaDB并加入开机启动"></a>启动MariaDB并加入开机启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z /]# systemctl start mariadb</span><br><span class="line">[root@iZjgheeixigi44Z /]# systemctl enable mariadb</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.</span><br></pre></td></tr></table></figure><p>其他命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb #启动服务</span><br><span class="line">systemctl enable mariadb #设置开机启动</span><br><span class="line">systemctl restart mariadb #重新启动</span><br><span class="line">systemctl stop mariadb.service #停止MariaDB</span><br></pre></td></tr></table></figure><h3 id="初次登陆设置密码等"><a href="#初次登陆设置密码等" class="headerlink" title="初次登陆设置密码等"></a>初次登陆设置密码等</h3><p>登陆到数据库，初次登陆密码为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z /]# mysql -uroot</span><br></pre></td></tr></table></figure><p>配置root密码，第一步密码为空，初次设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z /]# mysql_secure_installation</span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to log into MariaDB to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user.  If you&apos;ve just installed MariaDB, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line"></span><br><span class="line">Enter current password for root (enter for none): </span><br><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can log into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] y</span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">By default, a MariaDB installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MariaDB without having to have a user account created for</span><br><span class="line">them.  This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother.  You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;.  This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">By default, MariaDB comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access.  This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] y</span><br><span class="line"> - Dropping test database...</span><br><span class="line"> ... Success!</span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line"></span><br><span class="line">All done!  If you&apos;ve completed all of the above steps, your MariaDB</span><br><span class="line">installation should now be secure.</span><br><span class="line"></span><br><span class="line">Thanks for using MariaDB!</span><br></pre></td></tr></table></figure><h3 id="创建用户及设置权限"><a href="#创建用户及设置权限" class="headerlink" title="创建用户及设置权限"></a>创建用户及设置权限</h3><p>有些指令忘记了，要常用呀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z /]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 3</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create user &apos;huagege&apos;@&apos;%&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create user &apos;huagege&apos;@&apos;localhost&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to &apos;huagege&apos;@&apos;localhost&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to &apos;huagege&apos;@&apos;%&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; exit</span><br><span class="line">Bye</span><br><span class="line">[root@iZjgheeixigi44Z /]# mysql -uhuagege -p </span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 4</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases</span><br><span class="line">    -&gt; ;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; exit</span><br><span class="line">Bye</span><br><span class="line">[root@iZjgheeixigi44Z /]#</span><br></pre></td></tr></table></figure><h3 id="配置Mariadb数据库字符"><a href="#配置Mariadb数据库字符" class="headerlink" title="配置Mariadb数据库字符"></a>配置Mariadb数据库字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在/etc/my.cnf中的mysqld标签下,新增字符设置:</span><br><span class="line">init_connect=&apos;SET collation_connection = utf8_unicode_ci&apos; </span><br><span class="line">init_connect=&apos;SET NAMES utf8&apos; character-set-server=utf8</span><br><span class="line"></span><br><span class="line">// 在/etc/my.cnf.d/client.cnf中的client标签下,新增字符设:</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">//在/etc/my.cnf.d/mysql-clients.cnf下的[mysql]标签下,新增字符设置:</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p>登陆mysql输入命令:</p><blockquote><p><code>show variables like &quot;%character%&quot;;show variables like &quot;%collation%&quot;;</code></p></blockquote><hr><h2 id="PHP使用yum安装"><a href="#PHP使用yum安装" class="headerlink" title="PHP使用yum安装"></a>PHP使用yum安装</h2><p>参考<a href="https://blog.csdn.net/zhezhebie/article/details/73325663" target="_blank" rel="noopener">yum安装新版php7.0</a>、<a href="https://blog.csdn.net/hu_zhe_kan/article/details/79368169" target="_blank" rel="noopener">CentOS7yum安装PHP7.2</a>。</p><h2 id="PHP编译安装"><a href="#PHP编译安装" class="headerlink" title="PHP编译安装"></a>PHP编译安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>可以通过<a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a>查看现有的版本，然后直接在服务器端下载源码包，此处选择最新版7.2.5，此源下载很慢，建议选择其他源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z local]# wget -c http://cn2.php.net/distributions/php-7.2.5.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf php-7.2.5.tar.gz</span><br><span class="line">cd php-7.2.5</span><br></pre></td></tr></table></figure><h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><h4 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h4><p>根据之前的编译安装，centos7缺少的libmcrypt、mhash、mcrypt这三个库需要添加源才能下载到（源忘记了），使用的阿里云虚拟机可以直接下载安装。后续编译过程中根据所缺再增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z local]# yum -y install libmcrypt mhash mcrypt</span><br></pre></td></tr></table></figure><p>也可先运行直接全部安装所需库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z local]# yum -y install wget vim pcre pcre-devel openssl openssl-devel libicu-devel gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses ncurses-devel curl curl-devel krb5-devel libidn libidn-devel openldap openldap-devel nss_ldap jemalloc-devel cmake boost-devel bison automake libevent libevent-devel gd gd-devel libtool* libmcrypt libmcrypt-devel mcrypt mhash libxslt libxslt-devel readline readline-devel gmp gmp-devel libcurl libcurl-devel openjpeg-devel</span><br></pre></td></tr></table></figure><p>有些没有的话可以尝试更新源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></p><p>若源找不到对应库，也可直接将yum源更换为阿里云源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h4 id="编译配置-1"><a href="#编译配置-1" class="headerlink" title="编译配置"></a>编译配置</h4><p>可用<code>./configure --help</code>查看配置项和说明，可查阅官网<a href="http://php.net/manual/zh/install.php" target="_blank" rel="noopener">http://php.net/manual/zh/install.php</a>和<a href="http://php.net/manual/zh/configure.about.php" target="_blank" rel="noopener">http://php.net/manual/zh/configure.about.php</a>以及源码包中的INSTALL文档。参考配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/php7 \</span><br><span class="line">--with-config-file-path=/usr/local/php7/etc \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--with-fpm-user=www \</span><br><span class="line">--with-fpm-group=www \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--enable-mysqlnd-compression-support \</span><br><span class="line">--with-iconv-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--enable-xml \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--with-curl \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-intl \</span><br><span class="line">--with-mcrypt \</span><br><span class="line">--with-libmbfl \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--with-gd \</span><br><span class="line">--enable-gd-jis-conv \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--enable-zip \</span><br><span class="line">--enable-soap \</span><br><span class="line">--with-gettext \</span><br><span class="line">--disable-fileinfo \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--with-pear \</span><br><span class="line">--enable-maintainer-zts \</span><br><span class="line">--with-ldap=shared \</span><br><span class="line">--without-gdbm</span><br></pre></td></tr></table></figure><p>一般将nginx、php-fpm及网站根目录运行在nobody，不选择相应配置项默认即为nobody。创建用户用户组(自己用的默认nobody)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd www</span><br><span class="line">useradd -g www www</span><br></pre></td></tr></table></figure><p>最终配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/usr/local/php7 -with-config-file-path=/usr/local/php7/etc -with-config-file-scan-dir=/usr/local/php7/etc/conf.d -enable-fpm -enable-soap -with-openssl -with-openssl-dir -with-pcre-regex -with-zlib -with-iconv -with-bz2 -enable-calendar -with-curl -with-cdb -enable-dom -enable-exif -with-pcre-dir -enable-ftp -with-gd -with-jpeg-dir -with-png-dir -with-freetype-dir -with-gettext -with-gmp -with-mhash -enable-mbstring -with-libmbfl -with-onig -enable-pdo -with-pdo-mysql -with-zlib-dir -with-readline -enable-session -enable-shmop -enable-simplexml -enable-sockets -enable-sysvmsg -enable-sysvsem -enable-sysvshm -enable-wddx -with-libxml-dir -with-xsl -enable-zip -enable-mysqlnd -with-mysqli -enable-embedded-mysqli -enable-bcmath -enable-inline-optimization -enable-mbregex -enable-pcntl  -with-xmlrpc -enable-opcache</span><br></pre></td></tr></table></figure><p>注意：php7.2版本不支持–with-mcrypt, –enable-gd-native-ttf。在phh7.1时，官方就开始建议用openssl_*系列函数代替mcrypt_*系列的函数。7.2版本加上这两项配置无法通过的。</p><h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br><span class="line">make test</span><br></pre></td></tr></table></figure><h3 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h3><p>安装完成后直接运行<code>/usr/local/php7/sbin/php-fpm</code>会报错缺少配置的，需要进行相关的文件配置。<br>可以用编译后的配置文件复制到PHP7的配置目录（/usr/local/php7/etc/），推荐使用 github中的配置。</p><h4 id="方法一：直接使用编译后未经优化处理的配置"><a href="#方法一：直接使用编译后未经优化处理的配置" class="headerlink" title="方法一：直接使用编译后未经优化处理的配置"></a>方法一：直接使用编译后未经优化处理的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z php-7.2.5]# cp php.ini-production /usr/local/php7/etc/php.ini</span><br><span class="line">[root@iZjgheeixigi44Z php-7.2.5]# cp /usr/local/php-7.2.5/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm</span><br><span class="line">[root@iZjgheeixigi44Z php-7.2.5]# cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf</span><br><span class="line">[root@iZjgheeixigi44Z php-7.2.5]# cp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure><h4 id="方法二：使用https-github-com-lizer2014-mylnmp-tree-master-PHP文中的配置"><a href="#方法二：使用https-github-com-lizer2014-mylnmp-tree-master-PHP文中的配置" class="headerlink" title="方法二：使用https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置"></a>方法二：使用<a href="https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置" target="_blank" rel="noopener">https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置</a></h4><p>参考博客<a href="https://typecodes.com/web/php7configure.html" target="_blank" rel="noopener">PHP7中php.ini、php-fpm和www.conf的配置</a></p><h4 id="修改php-ini参数"><a href="#修改php-ini参数" class="headerlink" title="修改php.ini参数"></a>修改php.ini参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z extensions]# vi /usr/local/php7/etc/php.ini</span><br></pre></td></tr></table></figure><p>extension_dir改为自己的，设置时区，开启OPcache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/extension_dir  //vi查找extension_dir配置</span><br><span class="line">extension_dir = &quot;/usr/local/php7/lib/php/extensions/no-debug-non-zts-20170718/&quot;</span><br><span class="line">/timezone       //vi查找timezone配置</span><br><span class="line">date.timezone =  PRC</span><br><span class="line"></span><br><span class="line">zend_extension=opcache.so;</span><br></pre></td></tr></table></figure><h4 id="添加php的环境变量"><a href="#添加php的环境变量" class="headerlink" title="添加php的环境变量"></a>添加php的环境变量</h4><p>创建php.sh添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/php7/bin/:/usr/local/php7/sbin/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z etc]# vim /etc/profile.d/php.sh</span><br><span class="line">[root@iZjgheeixigi44Z etc]# source /etc/profile.d/php.sh</span><br><span class="line">[root@iZjgheeixigi44Z etc]# php -v</span><br><span class="line">PHP 7.2.5 (cli) (built: May 10 2018 14:03:12) ( NTS )</span><br><span class="line">Copyright (c) 1997-2018 The PHP Group</span><br><span class="line">Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies</span><br><span class="line">    with Zend OPcache v7.2.5, Copyright (c) 1999-2018, by Zend Technologies</span><br><span class="line">[root@iZjgheeixigi44Z etc]#</span><br></pre></td></tr></table></figure><p>此时已经启动php-fpm，可正常运行。</p><h3 id="添加到centos7开机自动启动"><a href="#添加到centos7开机自动启动" class="headerlink" title="添加到centos7开机自动启动"></a>添加到centos7开机自动启动</h3><p>在系统服务目录里创建php-fpm.service文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /lib/systemd/system/php-fpm.service</span><br></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=php-fpm</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/php7/sbin/php-fpm</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZjgheeixigi44Z lib]# systemctl enable php-fpm.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/php-fpm.service to /usr/lib/systemd/system/php-fpm.service.</span><br></pre></td></tr></table></figure><p>当php-fpm启动时使用<code>systemctl start php-fpm.service</code>启动会报错，需要先<code>pa aux | grep php</code>查找对应的pid，杀死进程后再启动。</p><hr><h2 id="nginx配置fast-cgi并测试lnmp"><a href="#nginx配置fast-cgi并测试lnmp" class="headerlink" title="nginx配置fast-cgi并测试lnmp"></a>nginx配置fast-cgi并测试lnmp</h2><p><code>mkdir /var/www</code>新建www目录，<code>cp /usr/local/nginx/html/* /var/www</code>将nginx自带web目录内文件复制到www中，即将/var/www作为web目录。新建index.php，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//echo phpinfo();</span><br><span class="line">$servername = &quot;127.0.0.1&quot;;</span><br><span class="line">$username = &quot;huagege&quot;;</span><br><span class="line">$password = &quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    $conn = new PDO(&quot;mysql:host=$servername;dbname=huagege&quot;, $username, $password);</span><br><span class="line">    echo &quot;连接成功&quot;;</span><br><span class="line">&#125;</span><br><span class="line">catch(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vi /usr/local/nginx/conf/nginx.conf</code>打开配置文件将root指令一一改为”/var/www”，注意php后缀解析的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /var/www;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">    root   /var/www;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /var/www;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /var/www$fastcgi_script_name;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试浏览器输入IP/index.php，显示成功连接数据库。由于之前将各项服务都加入到了开机启动，重启后再次访问仍然正常。至此，lnmp搭建完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建本博客之初的原因之一，就是在搭建lnmp和其他系列环境时遇到了很多问题，今天将服务器重置了，先配置好了go环境，在&lt;a href=&quot;/2018/04/10/Golang笔记-基础篇-一/&quot; title=&quot;Golang笔记-基础篇(一)&quot;&gt;Golang笔记-基础篇(一)&lt;
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="shell" scheme="bighua.top/tags/shell/"/>
    
      <category term="nginx" scheme="bighua.top/tags/nginx/"/>
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="linux" scheme="bighua.top/tags/linux/"/>
    
      <category term="php7" scheme="bighua.top/tags/php7/"/>
    
  </entry>
  
  <entry>
    <title>同IP服务器改变后导致Centos7连接服务器异常</title>
    <link href="bighua.top/2018/05/09/%E5%90%8CIP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B9%E5%8F%98%E5%90%8E%E5%AF%BC%E8%87%B4Centos7%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8/"/>
    <id>bighua.top/2018/05/09/同IP服务器改变后导致Centos7连接服务器异常/</id>
    <published>2018-05-09T05:22:18.000Z</published>
    <updated>2018-07-04T17:45:25.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前段时间跟着《Go并发编程实战 1&amp;2》和其他相关资料学习了go，现在着手进行相关的实践练习。与是把之前的服务器重置了下，重新配置go的相关运行环境。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>服务器用的阿里云的学生机，再过一个多月毕业就要到期了。一般可以直接使用ssh相关命令进行服务器的连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]# ssh root@101.200.50.5 //亦可ssh 101.200.50.5(限root权限下)</span><br><span class="line">root@101.200.50.5&apos;s password: </span><br><span class="line">Last login: Wed May  9 13:59:50 2018 from 220.249.99.148</span><br><span class="line"></span><br><span class="line">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class="line"></span><br><span class="line">[root@iZjgheeixigi44Z ~]#</span><br></pre></td></tr></table></figure></p><p>此时连接登陆成功。</p><p>但是看到Centos7有自带的连接服务器功能，于是在重置服务器之前直接尝试进行了连接。<br><code>其他位置</code>-<code>连接到服务器（S）</code>输入框输入：</p><blockquote><p><code>fstp://101.200.50.5</code></p></blockquote><p>可正常连接并且直接显示服务器中的文件。在显示的文件里右键选择<code>在本地终端打开(L)</code>和<code>在远程终端打开(R)</code>，直接建立终端连接。选择后者等同于上面的直接通过ssh命令建立终端连接，打开的终端为：</p><blockquote><p><code>[root@iZjgheeixigi44Z ~]#</code></p></blockquote><p>选择前者等同于通过本地的协议打开终端，非直接服务器终端，打开的终端为：</p><blockquote><p><code>joker@localhost sftp:host=101.200.50.5]$</code></p></blockquote><p>目前为止一切正常。但当我对服务器进行重置更换系统盘后再次使用centos7自带连接功能进行连接，报错提示主机连接失败。通过查询得知，<code>由于更换了服务器，使用了相同IP，导致公钥与服务器的私钥配对失败，无法登陆服务器。需要删除旧服务器(101.200.50.5)的公钥才行</code>，操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f &quot;/home/joker/.ssh/known_hosts&quot; -R 101.200.50.5</span><br></pre></td></tr></table></figure></p><p>此时会将原known_hosts文件（含101.200.50.5公钥）备份为known_hosts.old，删除公钥后的文件为known_hosts，文件内容私密此处不展示。</p><p>再次使用Centos7自带的进行连接报错信息为：<code>无法验证101.200.50.5（101.200.50.5）的标识。这会在您首次登陆计算机时发生。...</code>。然后需要点3次才能正确连接登陆成功。</p><p>此时使用普通用户权限运行<code>ssh 101.200.50.5</code>或者<code>ssh root@101.200.50.5</code>命令进行连接时报错为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost ~]# ssh 101.200.50.5</span><br><span class="line">The authenticity of host &apos;101.200.50.5 (101.200.50.5)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:3oG4dc22CqV2FOH1FS9ROi7yfi88y0nNN1JeBK8393g.</span><br><span class="line">ECDSA key fingerprint is MD5:7c:5d:cd:15:1a:d7:7c:28:55:53:2f:47:ec:1b:6e:2a.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes   </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>需要3次确认才通过，相当于上方的使用Centos7自带连接的报错。通过查询得到解决办法为修改/etc/ssh/ssh_config文件（或$HOME/.ssh/config）中的配置，添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictHostKeyChecking no</span><br></pre></td></tr></table></figure></p><p>执行仍提示错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost ~]$ ssh 101.200.50.5</span><br><span class="line">Failed to add the host to the list of known hosts (/home/joker/.ssh/known_hosts).</span><br><span class="line">joker@101.200.50.5&apos;s password:</span><br></pre></td></tr></table></figure></p><p>因对.ssh中的文件没有写权限，需要切换到root赋权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost ~]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@localhost joker]# chmod -R 777 .ssh</span><br></pre></td></tr></table></figure></p><p>再切换到用户权限运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost ~]$ ssh 101.200.50.5</span><br><span class="line">Warning: Permanently added &apos;101.200.50.5&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">joker@101.200.50.5&apos;s password: </span><br><span class="line">Permission denied, please try again.</span><br><span class="line">joker@101.200.50.5&apos;s password:</span><br></pre></td></tr></table></figure></p><p>提示说明已经将101.200.50.5添加到了known_hosts文件中，查看此文件可发现内容有改变。若使用普通用户权限下执行<code>ssh 101.200.50.5</code>登陆还需要其他设置，否则无法登录，但普通用户权限下执行<code>ssh root@101.200.50.5</code>可登陆。一般使用root权限进行服务器的登陆，两者都可正常登陆。</p><p>然后再回到最开始报错的Centos7自带的服务器连接，此时可正常连接登录了。但是<code>在远程终端打开（R）</code>仍然相当于在普通用户权限下的<code>ssh root@101.200.50.5</code>命令，需要其他的设置，使用<code>在本地终端打开（L）</code>无影响，恢复到最开始的状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>针对Centos7使用自带的功能连接服务器，同IP服务器改变后导致使用此自带功能连接出现无法登陆问题。实际解决步骤：  </p><p>移除known_hosts文件中的旧IP项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f &quot;/home/joker/.ssh/known_hosts&quot; -R IP</span><br></pre></td></tr></table></figure></p><p>修改/etc/ssh/ssh_config中的配置，这一步主要是去除多次的连接询问提示，之后可改回来，添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictHostKeyChecking no</span><br></pre></td></tr></table></figure></p><p>普通用户权限下执行ssh IP将IP添加到known_hosts：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 known_hosts //若有写权限此步忽略，否则切换到root赋权后再切换到普通用户</span><br><span class="line"></span><br><span class="line">ssh root@IP</span><br><span class="line">password:</span><br></pre></td></tr></table></figure></p><p>这一步主要是将IP再此添加到known_hosts中，不是为了登陆。而且普通用户权限下<code>ssh IP</code>被禁止登陆，使用<code>ssh root@IP</code>指定root用户才可以登陆，在root权限下都可正常登陆。</p><p>之后再次使用Centos7自带的连接服务可正常连接。</p><p>感觉Centos7这个自带的可使用各种协议连接服务器没啥用，多了一个服务器端文件的直接显示，即将服务器桌面化显示。还是ssh命令直接连接方便实用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;前段时间跟着《Go并发编程实战 1&amp;amp;2》和其他相关资料学习了go，现在着手进行相关的实践练习。与是把之前的服务器重置了下，重新配置g
      
    
    </summary>
    
      <category term="linux" scheme="bighua.top/categories/linux/"/>
    
    
      <category term="shell" scheme="bighua.top/tags/shell/"/>
    
      <category term="Centos" scheme="bighua.top/tags/Centos/"/>
    
      <category term="ssh登陆" scheme="bighua.top/tags/ssh%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>Golang笔记-同步</title>
    <link href="bighua.top/2018/05/05/Golang%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5/"/>
    <id>bighua.top/2018/05/05/Golang笔记-同步/</id>
    <published>2018-05-05T10:49:17.000Z</published>
    <updated>2018-07-04T17:45:25.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>传统并发程序对共享资源进行访问控制的主要手段，由标准库代码包sync中的Mutex结构体类型表示。其有两个公开的指针方法——Lock和Unlock，前者用于锁定当前的互斥量，后者用于对当前的互斥量进行解锁。</p><p>sync.Mutex类型的零值表示未锁定的互斥量。声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br></pre></td></tr></table></figure></p><p>一般在锁定互斥量后，紧接着使用defer语句保证该互斥锁的及时解锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br><span class="line"></span><br><span class="line">func write () &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    defer mutex.Unlock()</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁定操作和解锁操作应该成对出现，锁定了一个已锁定的互斥锁，进行重复锁定操作的goroutine将被阻塞，直到该互斥锁回到解锁状态。</p><p>code example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var mutex sync.Mutex</span><br><span class="line">fmt.Println(&quot;Lock the lock. (main)&quot;)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(&quot;The lock is locked. (main)&quot;)</span><br><span class="line">for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Lock the lock. (g%d)\n&quot;, i)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Printf(&quot;The lock is locked. (g%d)\n&quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(&quot;Unlock the lock. (main)&quot;)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">fmt.Println(&quot;The lock is unlocked. (main)&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lock]# go run repeatedlylock.go</span><br><span class="line">Lock the lock. (main)</span><br><span class="line">The lock is locked. (main)</span><br><span class="line">Lock the lock. (g1)</span><br><span class="line">Lock the lock. (g2)</span><br><span class="line">Lock the lock. (g3)</span><br><span class="line">Unlock the lock. (main)</span><br><span class="line">The lock is unlocked. (main)</span><br><span class="line">The lock is locked. (g1)</span><br></pre></td></tr></table></figure></p><p>对一个未锁定的互斥锁进行解锁操作，会引发一个运行时恐慌，Go 1.8之前可使用defer语句避免，Go 1.8开始此类恐慌变成不可恢复。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁即针对读写操作的互斥锁，可以针对读操作和写操作进行锁定和解锁操作。读写锁控制下的多个写操作都是互斥的，并且写操作与读操作之间也是互斥的，多个读操作之间不存在互斥关系。</p><p>读写锁由结构体sync.RWMutex表示，类型的零值已是可用的读写锁实例。包含两对方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (*RWMutex) Lock()</span><br><span class="line">func (*RWMutex) Unlock()</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (*RWMutex) RLock()</span><br><span class="line">func (*RWMutex) RUnlock()</span><br></pre></td></tr></table></figure></p><p>前一对方法的名称和签名与互斥锁的两个方法完全一致，分别代表对写操作的锁定（写锁定）和解锁（写解锁）。后一对方法表示了对读操作的锁定（读锁定）和解锁（读解锁）。</p><p>写解锁会试图唤醒所有因欲进行读操作而被阻塞的goroutine，读解锁只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写操作而被阻塞的goroutine。<code>对一个未被写锁定的读写锁进行写解锁，或者对一个未被读锁定的读写锁进行读解锁，都会引发一个不可恢复的运行时恐慌。</code></p><p>对于一个读写锁来说，施加于其上的读锁定可以有多个，只有对互斥锁进行等量的读解锁，才能够让某一个写锁定获得进行的机会，否则会使欲进行写锁定的gouroutine一直处于阻塞状态。</p><p>code example：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var rwm sync.RWMutex</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Try to lock for reading... [%d]\n&quot;, i)</span><br><span class="line">rwm.RLock()</span><br><span class="line">fmt.Printf(&quot;Locked for reading. [%d]\n&quot;, i)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">fmt.Printf(&quot;Try to unlock for reading... [%d]\n&quot;, i)</span><br><span class="line">rwm.RUnlock()</span><br><span class="line">fmt.Printf(&quot;Unlocked for reading. [%d]\n&quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * 100)</span><br><span class="line">fmt.Println(&quot;Try to lock for writing...&quot;)</span><br><span class="line">rwm.Lock()</span><br><span class="line">fmt.Println(&quot;Locked for writing.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rlock]# go run rlock.go</span><br><span class="line">Try to lock for reading... [0]</span><br><span class="line">Try to lock for reading... [2]</span><br><span class="line">Locked for reading. [2]</span><br><span class="line">Try to lock for reading... [1]</span><br><span class="line">Locked for reading. [1]</span><br><span class="line">Locked for reading. [0]</span><br><span class="line">Try to lock for writing...</span><br><span class="line">Try to unlock for reading... [0]</span><br><span class="line">Unlocked for reading. [0]</span><br><span class="line">Try to unlock for reading... [2]</span><br><span class="line">Unlocked for reading. [2]</span><br><span class="line">Try to unlock for reading... [1]</span><br><span class="line">Unlocked for reading. [1]</span><br><span class="line">Locked for writing.</span><br></pre></td></tr></table></figure></p><p>sync.RWMutex类型还拥有一个指针方法——RLocker，该方法会返回一个实现了sync.Locker接口类型的值。该接口包含两个方法：Lock和Unlock，*sync.Mutex类型和*sync.RWMutex类型都是该接口类型的实现类型。调用读写锁的RLocker方法，得到的结果值是读写锁本身，结果值的Lock方法和Unlock方法分别对应了针对读写锁的读锁定操作和读解锁操作。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>标准库sync.Cond类型代表了条件变量，不同于互斥锁和读写锁，简单的声明无法创建一个可用的条件变量，需用sync.NewCond函数。函数声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func NewCond(l Locker) *Cond</span><br><span class="line">``` </span><br><span class="line">条件变量要与互斥量组合使用，sync.NewCond函数的唯一参数是sync.Locker类型，具体的参数值既可以是一个互斥锁也可以是一个读写锁。返回一个\*sync.Cond类型的结果值，该类型有3个方法，即：Wait、Signal和Broadcast，分别代表了等待通知、单发通知和广播通知的操作。</span><br><span class="line"></span><br><span class="line">Wait方法自动对与该条件变量关联的锁进行解锁，并使它所在的goroutine阻塞，一旦接收到通知该方法所在的goroutine就会被唤醒，该方法会立即尝试锁定该锁。方法Signal和BroadCast的作用都是发送通知，以唤醒正在为此阻塞的goroutine，前者目标只有一个，后者目标是所有。</span><br><span class="line"></span><br><span class="line">在只需对一个或多个临界区进行保护的时候，使用锁往往会使程序的性能损耗更小。</span><br><span class="line"></span><br><span class="line">## 原子操作</span><br><span class="line">原子操作即执行过程不能被中断的操作，针对某个值的原子操作执行过程当中，CPU绝不会再去执行其他针对该值的操作，无论这些操作是否为原子操作。</span><br><span class="line"></span><br><span class="line">Go提供的原子操作都是非侵入式的，由标准库代码包sync/atomic中的众多函数代表，可以通过调用这些函数对几种简单类型的值执行原子操作。类型包括int32、int64、uint32、uint64、uintptr和unsafe.Pointer。这些函数提供的原子操作共有5种：增或减、比较并交换、载入、存储和交换。分别提供了不同的功能，且适用的场景也有所区别。</span><br><span class="line">### 增或减</span><br><span class="line">用于增或减的原子操作（原子增/减操作）的函数名都以 “Add”为前缀，后跟针对具体类型的名称。原子增/减操作可实现被操作值的增大或减小。被操作值的类型只能是数值类型(int32、int64、uint32、uint64和uintptr)。例如对int32类型的变量i32的值增大3：</span><br><span class="line">```code</span><br><span class="line">mewi32 := atomic.AddInt32(&amp;i32, 3)</span><br></pre></td></tr></table></figure></p><p>对于不能被取址的数值无法进行原子操作，函数第二个参数的类型与被操作值的类型总是相同的。类似函数有atomic.AddInt64、atomic.AddUint32、atomic.AddUint64和atomic.AddUintptr。因atomic.AddUint32、atomic.AddUint64的第二个参数类型分别是uint32和uint64，无法传入通过传入一个负的数值来减小被操作值。可利用二进制补码的特性解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic.AddUint32(&amp;uint32, ^uint32(-NN-1))</span><br><span class="line">atomic.AddUint64(&amp;uint64, ^uint64(-NN-1))</span><br><span class="line">//NN代表一个负整数</span><br></pre></td></tr></table></figure></p><p>负整数的补码可通过对它按位（除符号位）求反码并加一得到，一个负整数可由对它的绝对值减一并求补码后得到的数值的二进制形式表示。</p><blockquote><p>uint32(int32(NN)) = ^uint32(-NN-1)</p></blockquote><p>不存在名为atomic.AddPointer的函数，unsafe.Pointer类型的值无法被加减。</p><h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><p>Compare And Swap简称CAS，在sync/atomic包中，此类原子操作名称以“CompareAndSwap”为前缀的若干函数代表。<br>针对int32类型值的函数声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</span><br><span class="line">```  </span><br><span class="line">接受3个参数，参数一的值指向被操作值的指针值，类型为*int32。后两个参数分别代表操作的旧值和新值，类型为int32。函数被调用之后，会先判断参数addr指向的被操作值与参数old的值是否相等，判断结果为true，函数会用参数new代表的新值替换旧值，否则替换操作被忽略。函数结果swapped表示是否进行了值的替换操作。</span><br><span class="line"></span><br><span class="line">CAS操作总是假设被操作值未曾改变（即与旧值相等），并一旦确认假设的真实性就立即进行值替换。不同于锁更加谨慎的做法，总是假设会有并发的操作修改被操作值，使用锁将相关操作放入临界区中加以保护。使用锁趋于悲观，CAS趋于乐观。</span><br><span class="line"></span><br><span class="line">CAS可以在不创建互斥量和不形成临界区的情况下，完成并发安全的值替换操作。可以减少同步对程序性能的损耗。但在被操作的值频繁变更的情况下，CAS操作并不容易成功。有时需要使用for循环进行多次尝试。CAS操作不会让goroutine阻塞，但是仍可能使流程的执行暂时停滞，停滞大都极为短暂。若想并发安全的更新一些类型的值，总是优先选择CAS操作。</span><br><span class="line"></span><br><span class="line">### 载入</span><br><span class="line">sync/atomic代码包提供一系列函数可以原子地读取某个值，以“Load”为前缀。以int32类型为例：</span><br><span class="line">```code</span><br><span class="line">func addValue(delta int32) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        v := atomic.LoadInt32(&amp;value)</span><br><span class="line">        if atomic.CompareAndSwapInt32(&amp;value, v, (v + delta))&#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>atomic.LoadInt32接受一个*int32类型的指针值，返回该指针值指向的那个值。此示例原子地读取变量value的值并把它赋给变量v。在读取value时，当前计算机中的任何CPU都不会进行其他针对此值的读写操作。赋值语句和其后的if语句并不会原子地执行，在它们执行期间，CPU仍然可能进行其他针对value的读写操作，即value的值仍然能会被改变。所以if语句仍然需要CAS操作。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>对应读取操作的写入操作，sync/atomic包提供了对应的存储函数，函数名称以“Store”为前缀。</p><p>在原子地存储某个值的过程中，任何CPU都不会进行针对同一个值的读写操作。若把所有针对此值的写操作都改为原子操作，可避免出现针对此值的读操作因被并发地进行，而读到修改了一半的值的情况。</p><p>原子的值存储操作总会成功，不关心存储的值的旧值是什么。例atomic.StoreInt32接受两个参数，参数一的类型是*int32，指向被操作数的指针值，参数二是int32类型，值是欲存储的新值。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>sync/atomic代码包存在一类函数与前文的CAS操作和原子载入操作相似，称为“原子交换操作”，名称以“Swap”为前缀。</p><p>不同于CAS，原子交换操作不关心被操作值的旧值，直接设置新值，比原子存储操作多了一步：返回被操作值的旧值，比CAS操作的约束更少，比原子载入操作的功能更强。</p><p>例atomic.SwapInt32函数，接受两个参数，参数一代表被操作值的内存地址的*int32类型值，参数二表示新值。函数结果值表示该新值替换掉的旧值。该函数调用后，会把参数二的值置于参数一所表示的内存地址上，并将之前在该地址上的那个值作为结果返回。</p><p>若想以并发安全的方式操作特定的简单类型值，应首先考虑使用这些函数实现。</p><h3 id="原子值"><a href="#原子值" class="headerlink" title="原子值"></a>原子值</h3><p>sync/atomic.Value是一个结构体类型，暂且称为“原子值类型”。用于存储需要原子读写的值。不同于sync/atomic包中的其他函数，sync/atomic.Value可接受的被操作值的类型不限。简单声明即可得到一个可用的原子值实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var atomicVal atomic.Value</span><br></pre></td></tr></table></figure></p><p>该类型包含两个指针方法——Load和Store。前者用于原子地读取原子值实例中存储的值，返回一个interface{}类型的结果且不接受任何参数。后者用于原子地在原子值实例中存储一个值，接受一个interface{}类型的参数而没有返回结果。在未曾通过Store方法向原子值实例存储值之前，它的Load方法总会返回nil。</p><p>原子值实例的Store方法参数值不能为nil，参数传入该方法的值与之前传入的值（若有）的类型相同。即一旦原子值实例存储了某一个类型的值，它之后存储的值就必须是该类型的。违反上述条件会引发一个运行时恐慌。</p><p>sync/atomic.Value类型的变量一旦被声明，其值就不应该复制到它处。<code>作为源值赋给变量、作为参数值传入函数、作为结果值从函数中返回、作为元素值通过通道传递等都会造成值的复制</code>，这些变量之上不应该施加这些操作。不会造成编译错误，但标准工具go  vet会报告此类不正确（具有安全隐患）的用法。sync/atomic.Value类型的指针类型的变量不存在此问题。因结构体值的复制不但会生成该值的副本，还会生成其中字段的副本，使施加于此的并发安全保护失效。向副本存储值的操作与原值无关。</p><p>对于sync包中的Mutex、RWMutex和Cond类型，go vet命令同样检查此类复制问题，解决方案是避免使用它们而是使用它们的指针值。</p><p>原子值的读写操作必是原子的，不受操作值类型的限制，比原子函数的适用场景大，某些时候可以完美替换。</p><p><code>检测程序是否存在竞态条件，可在运行或者测试程序的时候追加-race标记。监测结果会被打印到输出中。</code></p><h2 id="只会执行一次"><a href="#只会执行一次" class="headerlink" title="只会执行一次"></a>只会执行一次</h2><p>sync提供了具有特色的结构体类型sync.Once和它的Do方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var once sync.Once</span><br><span class="line">once.Do(func()&#123;fmt.Println(&quot;Once!&quot;)&#125;)</span><br></pre></td></tr></table></figure></p><p>Do接受一个无参数、无结果的函数值作为其参数，方法一旦被调用，就会去调用作为参数的那个函数。</p><p>对同一个sync.Once类型值的Do方法的有效调用次数永远会是1。无论调用这个方法多少次，无论在多次调用时传递给它的参数值是否相同，都仅有第一次调用是有效的，值有第一次调用该方法传递给它的那个函数会执行。</p><p>典型应用场景是执行仅需执行一次的任务，这样的任务并不适合在init函数中执行。例如数据库连接池的建立、全局变量的延迟初始化等。</p><p><code>sync.Once类型提供的功能由互斥锁和原子操作实现。使用的技巧包括卫述语句、双重检查锁定，以及对共享标记的原子读写操作。</code></p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>sync.WaitGroup类型的值是并发安全的，声明后即可使用，有3个指针方法：Add、Done和Wait。</p><p>sync.WaitGroup是一个结构体类型，有一个代表计数的字节数组类型的字段，该字段用4字节表示给定的计数，另用4字节表示等待计数。当一个sync.WaitGroup类型的变量被声明之后，这两个计数都会是0。通过该值的Add方法增大或减少给定计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(3)</span><br><span class="line">wg.Add(-3)</span><br></pre></td></tr></table></figure></p><p>不能让给定计数变为负数，会引发一个运行时恐慌，意味着对sync.WaitGroup类型值的错误使用。</p><p>也可通过该值的Done方法使其中的给定计数值减一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wg.Done()</span><br><span class="line">wg.Done()</span><br><span class="line">wg.Done()</span><br></pre></td></tr></table></figure></p><p>同Add方法不能使给定计数变为负数。</p><p>当调用sync.WaitGroup类型值的Wait方法时，它会去检查给定计数，若该计数为0，该方法会立即返回，且不会对程序的运行产生任何影响。若计数大于0，该方法调用所在的goroutine会阻塞，同时等待计数会加1。直到该值的Add方法或Done方法被调用时发现给定计数变为0，该值才去区唤醒因此而阻塞的所有goroutine，同时清零等待计数。不论时Add方法还是Done方法，唤醒的goroutine是在从给定计数最近一次从0变为正整数到此时（给定计数重新变为0时）的时间段内，执行当前值的Wait方法的goroutine。</p><p><code>sync.WaitGroup类型值一般用于协调多个goroutine的运行。</code></p><p>使用规则：  </p><ul><li>对同一sync.WaitGroup类型值的Add方法的第一次调用，发生在调用该值的Done方法和Wait方法之前。</li><li>在一个sync.WaitGroup类型值的生命周期内，其中的给定计数总是由起初的0变为某个正整数（或先后变为某几个正整数），然后再归为0。把完成这样一个变化所用的时间称为一个计数周期。</li><li>给定计数的每次变化都是由对Add方法或Done方法的调用引起的。</li><li>sync.WaitGroup类型值可以复用。此类型的生命周期可以包含任意个计数周期。一个sync.WaitGroup类型值在其每个计数周期中的状态和作用都是独立的。</li></ul><p><code>对于sync.WaitGroup类型的值，也时不应该复制的，在必要时使用go vet命令检查使用此类型值的方式是否正确。</code></p><h2 id="临时对象池"><a href="#临时对象池" class="headerlink" title="临时对象池"></a>临时对象池</h2><p>可将sync.Pool类型值看作存放临时值的容器。此类容器是自动伸缩的、高效的、并发安全的。为描述方便将sync.Pool类型的值称为“临时对象池”，存于其中的值称为“对象值”。</p><p>使用符合字面量初始化一个临时对象池的时候，可以为它唯一的公开字段New赋值。该字段类型是func () interface {}，即一个函数类型。赋给该字段的值会被临时对象池用来创建对象值。该函数一般仅在池中无可用对象值的时候才被调用。把这个函数称为“对象值生成函数”。</p><p>sync.Pool类型有两个公开的指针方法——Get和Put。前者从池中获取一个interface {}类型的值，后者则是把一个interface {}类型的值放置于池中。</p><p>通过Get方法获取到的值是任意的。若一个临时对象池的Put方法未被调用过,且它的New字段也未曾被赋予一个非nil的函数值，那么它的Get方法返回的结果就一定是nil。Get方法回返的不一定就是存在于池中的值，若结果值是池中的，那么在该方法返回它之前，就一定会把它从池中删除。功能上类似一个通用的缓冲池。</p><p>临时对象池的第一个特征，临时对象池可以把其中的对象值产生的存储压力进行分摊。它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，一般会先尝试从与本地P对应的本地私有池和本地共享池中或取一个对象值。若获取失败，会尝试从其他P的本地共享池中偷取一个对象值并直接返回给调用方。若仍未获取，只能希望寄托于当前临时对象池的对象值生成函数。对象值生成函数产生的对象值永远不会被放置到池中，而是被直接返回给调用方。临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。即它们随时会被偷走。</p><p>临时对象池的第二个特征是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。即使我们永远不会显示地从临时对象池取走某个对象值,该对象也不会永远待在临时对象池中，它的声明周期取决于垃圾回收任务下一次的执行时间。</p><p>不用该对从临时对象池中获取的值有任何假设，因其可能是池中的任何一个值，也可能是对象值生成函数产生的值。</p><p><code>临时对象池的实例也不应该被复制，否则go vet命令将报告此问题。</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;h3 id=&quot;互斥锁&quot;&gt;&lt;a href=&quot;#互斥锁&quot; class=&quot;headerlink&quot; title=&quot;互斥锁&quot;&gt;&lt;/a&gt;互斥锁&lt;/h3&gt;&lt;p&gt;传统并
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="同步" scheme="bighua.top/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="锁" scheme="bighua.top/tags/%E9%94%81/"/>
    
      <category term="原子操作" scheme="bighua.top/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
      <category term="条件变量" scheme="bighua.top/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>笑话收集</title>
    <link href="bighua.top/2018/05/03/%E7%AC%91%E8%AF%9D%E6%94%B6%E9%9B%86/"/>
    <id>bighua.top/2018/05/03/笑话收集/</id>
    <published>2018-05-03T07:38:14.000Z</published>
    <updated>2018-07-04T17:45:25.114Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些有意思的笑话。</p><h3 id="一天，了先生去划船"><a href="#一天，了先生去划船" class="headerlink" title="一天，了先生去划船"></a>一天，了先生去划船</h3><p>一天，了先生去划船，</p><p>孑孓孑孓孑孓孑孓孑孓孑孓……</p><h3 id="小红和小朋友们一起玩捉迷藏"><a href="#小红和小朋友们一起玩捉迷藏" class="headerlink" title="小红和小朋友们一起玩捉迷藏"></a>小红和小朋友们一起玩捉迷藏</h3><p>小红和小朋友们一起玩捉迷藏，这次她当鬼。小红边数边喊“你们藏好了没有”，然而并没有人回答她。当她数到3.2.1时，恐怖的事情发生了，小朋友们都站在她身后：“爱就像蓝天白云，晴空万里，突然暴风雨”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;收集一些有意思的笑话。&lt;/p&gt;
&lt;h3 id=&quot;一天，了先生去划船&quot;&gt;&lt;a href=&quot;#一天，了先生去划船&quot; class=&quot;headerlink&quot; title=&quot;一天，了先生去划船&quot;&gt;&lt;/a&gt;一天，了先生去划船&lt;/h3&gt;&lt;p&gt;一天，了先生去划船，&lt;/p&gt;
&lt;p&gt;孑孓孑孓孑
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="笑话" scheme="bighua.top/tags/%E7%AC%91%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Golang笔记-channel</title>
    <link href="bighua.top/2018/05/02/Golang%E7%AC%94%E8%AE%B0-channel/"/>
    <id>bighua.top/2018/05/02/Golang笔记-channel/</id>
    <published>2018-05-02T09:03:49.000Z</published>
    <updated>2018-07-04T17:45:25.108Z</updated>
    
    <content type="html"><![CDATA[<p>channel——提倡“以通信作为手段来共享内存”最直接和最重要的体现。<br>Go使用通道类型值在不同的goroutine之间传递值。channel类似一个类型安全的通用型管道。</p><p>channel提供了一种机制，既可以同步两个并发执行的函数，又可以让这两个函数通过相互传递特定类型的值来通信。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>channel既值通道类型，指代可以传递某种类型的值的通道。通道即某一个通道类型的值，是该类型的一个实例。</p><h3 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1.类型表示法"></a>1.类型表示法</h3><p>属于引用类型。泛化的通道类型的声明：</p><blockquote><p><code>chan T</code></p></blockquote><p>声明别名类型：</p><blockquote><p><code>chan IntChan chan int</code></p></blockquote><p>声明一个chan int类型的变量：</p><blockquote><p><code>var intChan chan int</code></p></blockquote><p>通道类型是双向的，既可以向此类通道发送元素值，也可以从那里接收元素值。使用<code>&lt;-</code>接收操作符声明单向的通道类型，下面会i只能用于发送值的通道类型的泛化表示：</p><blockquote><p><code>chan &lt;- T</code>    //发送通道类型</p></blockquote><p>声明只能从其中接收元素值的通道类型：</p><blockquote><p><code>&lt;-chan T</code>     //接收通道类型</p></blockquote><h3 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2.值表示法"></a>2.值表示法</h3><p>通道类型的变量在被初始化前，值为nil。通道类型的变量是用来传递值的而不是存储值的。通道类型并没有对应的值表示法。其值具有即时性，无法准确用字面量来表达。</p><h3 id="3-操作的特性"><a href="#3-操作的特性" class="headerlink" title="3.操作的特性"></a>3.操作的特性</h3><p>通道是在多个goroutine之间传递数据和同步的重要手段，对通道操作的本身也是同步的。在同一时刻，仅有一个goroutine能向一个通道发送元素值，同时也仅有一个goroutine能从它那里接收元素值。通道中，各个元素值都是严格按照发送到此的先后顺序排列的，最早发送至通道的元素值会最先被接收。通道相当于一个FIFO的消息队列。通道中的元素具有原子性，是不可被分割的。通道中的每一个元素值都只可能被某一个goroutine接收，已被接受的值会立刻从通道中删除。</p><h3 id="4-初始化通道"><a href="#4-初始化通道" class="headerlink" title="4.初始化通道"></a>4.初始化通道</h3><p>引用类型的值都需要内建函数make来初始化。</p><blockquote><p><code>make(chan int, 10)</code></p></blockquote><p>初始化一个在同一时刻最多可以缓冲10个元素值且元素类型为int的通道类型。</p><blockquote><p><code>make(chan int)</code></p></blockquote><p>一个通道值的缓冲容量总是固定不变的，省略参数二意味着初始化的这个通道永远无法缓冲任何元素值。发送给它的元素值应该被立刻取走，否则发送方的goroutine就会暂停（阻塞），直到有接收方接收这个元素值。</p><p>将第二个参数值大于0的通道称为缓冲通道，未给定第二个参数值或给定值为0的通道称为非缓冲通道。</p><h3 id="5-接收元素值"><a href="#5-接收元素值" class="headerlink" title="5.接收元素值"></a>5.接收元素值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strChan := make(chan string, 3) //声明一个双向通道类型strChan</span><br><span class="line"></span><br><span class="line">elsm, ok := &lt;- strChan</span><br><span class="line">elem := &lt;- strChan //从该通道中接收元素值，无值时goroutine被阻塞直到有值时被唤醒</span><br></pre></td></tr></table></figure><p>从未初始化的通道中接收值会造成当前goroutine永久阻塞。</p><h3 id="6-Happens-before"><a href="#6-Happens-before" class="headerlink" title="6.Happens before"></a>6.Happens before</h3><p>对于一个缓冲通道有：  </p><ul><li>发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，则阻塞正在进行发送操作的goroutine。复制的目的地址有两种。当通道已空且有接收方在等待元素值时，它会是最早等待的那个接收方持有的内存地址，否则会是通道持有的缓冲中的内存地址。</li><li>接收操作会使通道给出一个已发送它的元素值的副本，若因通道的缓冲空间已空而无法立即给出，则阻塞正在进行接收操作的goroutine。一般情况下，接收方会从通道持有的缓冲中得到元素值。</li><li>对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道中接收它的操作完成之前完成。在通道完全复制一个元素值之前，任何goroutine都不可能从它那里接收到这个元素值的副本。</li></ul><h3 id="7-发送元素值"><a href="#7-发送元素值" class="headerlink" title="7.发送元素值"></a>7.发送元素值</h3><p>对接收操作符&lt;-两边的表达式的求值会先于发送操作执行，在对两个表达式求值完成之前，发送操作被阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var strChan = make(chan string, 3)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">syncChan1 := make(chan struct&#123;&#125;, 1)</span><br><span class="line">syncChan2 := make(chan struct&#123;&#125;, 2)</span><br><span class="line">go func() &#123; // 用于演示接收操作。</span><br><span class="line">&lt;-syncChan1</span><br><span class="line">fmt.Println(&quot;Received a sync signal and wait a second... [receiver]&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">for &#123;</span><br><span class="line">if elem, ok := &lt;-strChan; ok &#123;</span><br><span class="line">fmt.Println(&quot;Received:&quot;, elem, &quot;[receiver]&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Stopped. [receiver]&quot;)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123; // 用于演示发送操作。</span><br><span class="line">for _, elem := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; &#123;</span><br><span class="line">strChan &lt;- elem</span><br><span class="line">fmt.Println(&quot;Sent:&quot;, elem, &quot;[sender]&quot;)</span><br><span class="line">if elem == &quot;c&quot; &#123;</span><br><span class="line">syncChan1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(&quot;Sent a sync signal. [sender]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Wait 2 seconds... [sender]&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">close(strChan)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sent: a [sender]</span><br><span class="line">Sent: b [sender]</span><br><span class="line">Sent: c [sender]</span><br><span class="line">Sent a sync signal. [sender]</span><br><span class="line">Received a sync signal and wait a second... [receiver]</span><br><span class="line">Received: a [receiver]</span><br><span class="line">Received: b [receiver]</span><br><span class="line">Received: c [receiver]</span><br><span class="line">Received: d [receiver]</span><br><span class="line">Sent: d [sender]</span><br><span class="line">Wait 2 seconds... [sender]</span><br><span class="line">Stopped. [receiver]</span><br></pre></td></tr></table></figure></p><p>由于运行时系统的调度，每次运行的输出语句顺序可能不同。</p><p>syncChan通道是为了不让主goroutine过早地结束运行。一旦goroutine过早的结束运行，Go程序的运行也就结束了。main函数最后试图从syncChan接收值两次，接收完成之前主goroutine阻塞于此。两个goroutine都像syncChan发送值后，主goroutine恢复运行，随后结束运行。</p><p>syncChan1和syncChan2的元素类型都是struct{}。代表的是不包含任何字段的结构体类型，也称空结构体类型。空结构体的变量不占内存空间，并且所有该类型的变量都拥有相同的内存地址。建议用于传递“信号”的通道都用struct{}作为元素类型，除非需要传递更多的信息。</p><p>向一个值为nil的通道类型的变量发送元素值时，当前goroutine也会被永久的阻塞。若试图从一个已关闭的通道中发送元素值，会立即引发一个运行时恐慌，即使发送通道正在因通道已满而被阻塞。为避免此类流程中段可以在select代码块中执行发送操作。</p><p>若由多个goroutine向同一个已满的通道发送元素值而被阻塞，那么当该通道中有多余空间的时候，最早被阻塞的goroutine会最先被唤醒。对接收操作也是如此。运行时系统每次只会唤醒一个goroutine。</p><p>发送方向通道发送的值会被复制，接收方接收的总是该值的副本，而不是该值本身。通道的缓冲队列属于环形队列。当接收方从通道接收到一个类型的值时，对该值的修改不会影响发送方持有的源值。</p><h3 id="8-关闭通道"><a href="#8-关闭通道" class="headerlink" title="8.关闭通道"></a>8.关闭通道</h3><p>通过调用内建函数close关闭通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(strChan)</span><br></pre></td></tr></table></figure></p><blockquote><p><code>不应该在接收端关闭通道</code>，因无法判断发送端是否还会向该通道发送元素值。在发送端调用close以关闭通道不会对接收端接收该通道中已有的元素值产生任何影响。</p></blockquote><p>调用close函数的作用是告诉运行时系统不应该再允许任何针对被关闭的通道的发送操作，该通道即将被关闭。调用close函数只是让相应的通道进入关闭状态而不是立即阻止对它的一切操作。</p><blockquote><p>对同一个通道仅允许关闭一次，对通道的重复关闭会引起运行时恐慌。调用close函数时的参数值是一个值为nil的通道类型的变量也会引发运行时恐慌。</p></blockquote><h3 id="长度与容量"><a href="#长度与容量" class="headerlink" title="长度与容量"></a>长度与容量</h3><p>内建函数len和cap可作用于通道之上，分别获取当前通道中的元素值数量（长度）和通道可容纳元素值的最大数量（容量）。通道的容量再初始化时已经确定，并且之后不能改变，通道的长度会随实际情况改变。</p><p>容量为0的通道为非缓冲通道，否则为缓冲通道。</p><h2 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h2><p>单向通道可分为发送通道和接收通道，无论哪一种都不应该出现在变量的声明中。单向通道应由双向通道变换而来，可以用这种变换来约束程序对通道的使用方式。例如os/isgnal.Notify函数的声明：</p><blockquote><p><code>func Notify(c chan &lt;- os.Signal, sig ...os.Signal)</code></p></blockquote><p>第一个参数的类型是发送通道类型，调用时应该传入一个双向通道，自动把它转换为单向通道。Notify函数中的代码只能向通道c发送元素值，而不能从其中接收元素值。从该通道c中接收元素值会造成编译错误。函数之外不受此约束。但Notify函数对c进行发送操作，函数外的代码应该对其进行接收操作，函数外的发送操作会造成干扰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var strChan = make(chan string, 3)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">syncChan1 := make(chan struct&#123;&#125;, 1)</span><br><span class="line">syncChan2 := make(chan struct&#123;&#125;, 2)</span><br><span class="line">go receive(strChan, syncChan1, syncChan2) // 用于演示接收操作。</span><br><span class="line">go send(strChan, syncChan1, syncChan2)    // 用于演示发送操作。</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func receive(strChan &lt;-chan string,</span><br><span class="line">syncChan1 &lt;-chan struct&#123;&#125;,</span><br><span class="line">syncChan2 chan&lt;- struct&#123;&#125;) &#123;</span><br><span class="line">&lt;-syncChan1</span><br><span class="line">fmt.Println(&quot;Received a sync signal and wait a second... [receiver]&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">for &#123;</span><br><span class="line">if elem, ok := &lt;-strChan; ok &#123;</span><br><span class="line">fmt.Println(&quot;Received:&quot;, elem, &quot;[receiver]&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Stopped. [receiver]&quot;)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func send(strChan chan&lt;- string,</span><br><span class="line">syncChan1 chan&lt;- struct&#123;&#125;,</span><br><span class="line">syncChan2 chan&lt;- struct&#123;&#125;) &#123;</span><br><span class="line">for _, elem := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; &#123;</span><br><span class="line">strChan &lt;- elem</span><br><span class="line">fmt.Println(&quot;Sent:&quot;, elem, &quot;[sender]&quot;)</span><br><span class="line">if elem == &quot;c&quot; &#123;</span><br><span class="line">syncChan1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(&quot;Sent a sync signal. [sender]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Wait 2 seconds... [sender]&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">close(strChan)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用单向通道改进发送元素值demo，此代码对接收和发送进行了参数约束，规定了参数中通道的方向。</p><blockquote><p>通道允许的数据传递方向是其类型的一部分，对于两个通道类型而言，数据传递方向的不同，意味着它们类型的不同。利用函数声明将双向通道转换为单向通道的做法，只是一个语法糖，不能利用函数声明将一个单向通道转换成双向通道，这样做会得到一个编译错误。</p></blockquote><h2 id="for语句与channel"><a href="#for语句与channel" class="headerlink" title="for语句与channel"></a>for语句与channel</h2><p>使用for语句的range子句持续地从一个通道接收元素值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int</span><br><span class="line">//todo</span><br><span class="line">for e := range ch &#123;</span><br><span class="line">fmt.Printf(&quot;Element:%v\n&quot;, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>range子句的迭代目标不能是一个发送通道，同从发送通道中接收元素值会造成一个编译错误。</p><p>从还未初始化的通道中接收元素值会导致当前goroutine的永久阻塞，使用for语句会阻塞在range子句处。</p><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select语句是一种仅能用于通道发送和接收操作的专用语句。一条select语句执行时，会选择其中的某一个分支并执行。类似switch语句但选择分支的方法完全不同。</p><h3 id="组成和编写方法"><a href="#组成和编写方法" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h3><p>每个分支以case开始，跟在每个case后面的只能是针对某个通道的发送语句或接收语句，在select关键字后没有像switch语句那样的表达式，直接跟花括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var intChan = make(chan int, 10)</span><br><span class="line">var strChan = make(chan string, 10)</span><br><span class="line">select &#123;</span><br><span class="line">case e1 := &lt;-intChan:</span><br><span class="line">fmt.Printf(&quot;The first case was selected.e1=%v.\n&quot;, e1)</span><br><span class="line">case e2 := &lt;-strChan:</span><br><span class="line">fmt.Printf(&quot;The second case was selected.e2=%v.\n&quot;, e2)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Default!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>select语句中所有普通case都不满足选择条件，default case会被选中。</p><h3 id="分支选择规则"><a href="#分支选择规则" class="headerlink" title="分支选择规则"></a>分支选择规则</h3><p>在开始执行select语句时，所有根在case关键字后的发送语句或接收语句中的通道表达式和元素表达式都会先求值（求之顺序从左到右、自上而下），无论它们所在的case是否有可能被选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var intChan1 chan int</span><br><span class="line">var intChan2 chan int</span><br><span class="line">var channels = []chan int&#123;intChan1, intChan2&#125;</span><br><span class="line"></span><br><span class="line">var numbers = []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case getChan(0) &lt;- getNumber(0):</span><br><span class="line">fmt.Println(&quot;The 1th case is selected.&quot;)</span><br><span class="line">case getChan(1) &lt;- getNumber(1):</span><br><span class="line">fmt.Println(&quot;The 2nd case is selected.&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Default!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getNumber(i int) int &#123;</span><br><span class="line">fmt.Printf(&quot;numbers[%d]\n&quot;, i)</span><br><span class="line">return numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getChan(i int) chan int &#123;</span><br><span class="line">fmt.Printf(&quot;channels[%d]\n&quot;, i)</span><br><span class="line">return channels[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channels[0]</span><br><span class="line">numbers[0]</span><br><span class="line">channels[1]</span><br><span class="line">numbers[1]</span><br><span class="line">Default!</span><br></pre></td></tr></table></figure></p><p>因为intChan1和intChan2未被初始化，向它们发送的元素值会永久阻塞，即两个case语句被阻塞，select语句执行default case，才会有最后一行输出。</p><p>执行select语句时，运行时系统会自上而下地判断每个case中的发送或接收操作是否可以立即执行（当前goroutine不会因此操作而被阻塞    ）。需要依据通道的具体特性（缓冲或非缓冲）以及那一刻的具体情况来进行。只要发现有一个case上的判断是肯定的该case就会被选中。</p><blockquote><p>当有一个case被选中时，运行时系统就会执行该case及其包含的语句，而其他case会被忽略。若同时有多个case满足条件，那么运行时系统会通过一个伪随机数算法选中一个case。若所有case都不满足选择条件并且没有default case，那么当前goroutine就会一直被阻塞于此，直到至少有一个case中的发送或接收操作可以立即进行为止。</p></blockquote><p>一条select语句只能包含一个default case，可以放置在该语句的任何位置上。</p><h3 id="与for语句的连用"><a href="#与for语句的连用" class="headerlink" title="与for语句的连用"></a>与for语句的连用</h3><p>实际场景中常常把select语句放到一个单独的goroutine中执行，即使select语句被阻塞，也不会造成死锁。常与for语句连用以便持续操作其中的通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intChan := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">intChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(intChan)</span><br><span class="line">syncChan := make(chan struct&#123;&#125;, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">Loop:</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case e, ok := &lt;-intChan:</span><br><span class="line">if !ok &#123;</span><br><span class="line">fmt.Println(&quot;End.&quot;)</span><br><span class="line">break Loop</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Received: %v\n&quot;, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">syncChan &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-syncChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Received: 0</span><br><span class="line">Received: 1</span><br><span class="line">Received: 2</span><br><span class="line">Received: 3</span><br><span class="line">Received: 4</span><br><span class="line">Received: 5</span><br><span class="line">Received: 6</span><br><span class="line">Received: 7</span><br><span class="line">Received: 8</span><br><span class="line">Received: 9</span><br><span class="line">End.</span><br></pre></td></tr></table></figure></p><h2 id="非缓冲的channel"><a href="#非缓冲的channel" class="headerlink" title="非缓冲的channel"></a>非缓冲的channel</h2><p>初始化通道时将其容量设置为0或直接忽略对容量的设置，会使该通道成为一个非缓冲通道。不同于<code>以异步的方式传递元素值的缓冲通道</code>，非缓冲通道只能<code>同步地传递元素值</code>。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens    before"></a>happens    before</h3><p>特别之处：  </p><ul><li>向此类通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接收操作进行为止。接收操作先得到元素值的副本，在唤醒发送方的goroutine之后返回。即此时接收操作会在对应的发送操作完成之前完成。</li><li>从此类通道接收元素值的操作会被阻塞，直到至少有一个针对该通道的发送操作进行为止。发送操作直接把元素值复制给接收方，然后在唤醒接收方所在的goroutine之后返回。即此时的发送操作会在对应的接收操作完成之前完成。</li></ul><p>只有在针对非缓冲通道的发送方和接收方“握手”之后，元素值的传递才会进行，然后双方的操作才能进行。如果发送方或/和接收方有多个，需要排队握手。</p><h3 id="同步的特征"><a href="#同步的特征" class="headerlink" title="同步的特征"></a>同步的特征</h3><p>由于非缓冲通道会以同步的方式传递元素值，在其上收发元素值的速度总是与慢的一方持平。可以通过调用内建函数cap判断一个通道是否带有缓冲。若想异步地执行发送操作，但通道确实非缓冲的，需另行异步化，例如：启用额外的goroutine执行此操作。在执行接收操作时通常无需关心通道是否带有缓冲，可以依据通道的容量实施不同的接收策略。</p><h2 id="time包与channel"><a href="#time包与channel" class="headerlink" title="time包与channel"></a>time包与channel</h2><p>标准库代码包time中的一些API是用通道辅助实现的，这些API可以帮助我们对通道的收发操作进行更有效的控制。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>time包中的Timer结构体类型会被作为定时器使用，可用time.NewTimer函数和time.AfterFunc函数构建time.Timer类型的值。</p><p>传递给time.NewTimer一个time.Duration类型的值，表示从定时器被初始化的那一刻起，距到期时间需要多少纳秒（ns）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(3*time.Hour + 36*time.Minute)</span><br></pre></td></tr></table></figure></p><p>此timer是*time.Timer类型而非time.Timer类型。前者的方法集合包含了两个方法：Reset和Stop。Reset方法用于重置定时器（定时器可复用），返回一个bool类型的值。Stop方法用于停止定时器，返回bool类型值作为结果。为false说明该定时器已经过期或已经被停止，否则说明该定时器由于方法调用而被停止。Reset方法的返回值与当此重置操作是否成功无关，无论结果如何，一旦Reset方法调用完成，该定时器就已被重置。</p><p>在time.Timer类型中，对外通知定时器到期的途径是通道，由字段C代表。C代表一个chan time.Timer类型的带缓冲的接收通道，在值赋给C时由双向通道自动转换为接收通道。定时器内部仍然持有该通道，且并未被唤醒，可以向其发送元素值。一旦触及到期时间，定时器就会向它的通知通道发送一个元素值，代表该定时器的绝对到期时间。传入的time.Duration类型值是该定时器的相对到期时间。</p><p>可以通过<code>time.NewTimer(time.Duration).C</code>获取<code>绝对到期时间</code>，可用<code>time.After(time)</code>替换之，与前者等价。time.After函数会新建一个定时器，并把它的字段C作为结果返回，为超时的设定提供了一种快捷方式。</p><p>从一个被调用Stop方法停止的未到期定时器的C字段中接收元素不会有任何结果且会使当前goroutine永久阻塞。在重置定时器前不要再次对它的C字段执行接收操作。<code>若定时器到期了，未及时从其C字段接收元素值，该字段就一直缓冲着那个元素值，即使在该定时器重置之后也是如此，由于C（通知通道的容量）为1，会影响重置后的定时器再次发送到期通知。虽不造成阻塞，但后续通知会被直接丢掉。若想复用定时器，应该确保旧的通知已被接收。</code></p><p>传入的代表相对时间的值应该为一个整数，否则定时器在被初始化或重置之时就会立即到期。</p><p><code>tme.AfterFunc</code>函数是另一种新建定时器的方法，接收两个参数，第一个参数代表相对到期时间,第二个参数指定到期时间需要执行的函数。同样返回新建的定时器，在定时器到期时，并不会向它的通知通道发送元素值，取而代之的是新启用一个goroutine执行调用方传入的函数。无论它是否被重置以及被重置多少次都会是这样。</p><h3 id="断续器"><a href="#断续器" class="headerlink" title="断续器"></a>断续器</h3><p>time包的结构体类型time.Ticker表示了断续器的静态结构。包含的字段与time.Timer一致，行为不同。定时器在重置之前只会到期一次，断续器则会在到期后立即进入下一个周期并等待再次到期，周而复始直到停止。</p><p>断续器传达到期通知的默认途径也是字段C，每隔一个相对到期时间，断续器就会向此通道发送一个代表了当次的绝对到期时间的元素值。字段C的容量仍然是1。若断续器在向其通知通道发送新的元素值的时候发现旧值还未被接收，就会取消当此的发送操作。与定时器一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ticker  *time.Ticker = time.NewTicker(time.Second)</span><br></pre></td></tr></table></figure></p><p>*time.Ticker类型的方法集合中只有一个方法stop，功能是停止断续器。与定时器的stop方法功能相同。一旦断续器被停止，就不会再向其通知通道发送任何元素值了，若此时字段C中已经有了一个元素值，那么该元素值就会一直在那里，直至被接收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">go func() &#123;</span><br><span class="line">for _ = range ticker.C &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case intChan &lt;- 1:</span><br><span class="line">case intChan &lt;- 2:</span><br><span class="line">case intChan &lt;- 3:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;End. [sender]&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">var sum int</span><br><span class="line">for e := range intChan &#123;</span><br><span class="line">fmt.Printf(&quot;Received: %v\n&quot;, e)</span><br><span class="line">sum += e</span><br><span class="line">if sum &gt; 10 &#123;</span><br><span class="line">fmt.Printf(&quot;Got: %v\n&quot;, sum)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;End. [receiver]&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>某次运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Received: 3</span><br><span class="line">Received: 3</span><br><span class="line">Received: 1</span><br><span class="line">Received: 3</span><br><span class="line">Received: 3</span><br><span class="line">Got: 13</span><br><span class="line">End. [receiver]</span><br></pre></td></tr></table></figure></p><p>当累计接收的值大于10时，停止接收通道，主goroutine运行后面语句打印<code>End. [receiver]</code>然后结束主goroutine，主goroutine启动的运行匿名函数的goroutine会因主goroutine的结束而结束，不会打印出<code>End. [sender]</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;channel——提倡“以通信作为手段来共享内存”最直接和最重要的体现。&lt;br&gt;Go使用通道类型值在不同的goroutine之间传递值。channel类似一个类型安全的通用型管道。&lt;/p&gt;
&lt;p&gt;channel提供了一种机制，既可以同步两个并发执行的函数，又可以让这两个函数
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="chan" scheme="bighua.top/tags/chan/"/>
    
      <category term="通道" scheme="bighua.top/tags/%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Golang笔记-goroutine</title>
    <link href="bighua.top/2018/05/02/Golang%E7%AC%94%E8%AE%B0-goroutine/"/>
    <id>bighua.top/2018/05/02/Golang笔记-goroutine/</id>
    <published>2018-05-02T06:35:11.000Z</published>
    <updated>2018-07-04T17:45:25.108Z</updated>
    
    <content type="html"><![CDATA[<p>go语句是启用goroutine的唯一途径。</p><h2 id="go语句与Goroutine"><a href="#go语句与Goroutine" class="headerlink" title="go语句与Goroutine"></a>go语句与Goroutine</h2><p>一条go语句意味着一个函数或方法的并发执行，由go关键字和表达式组成。针对如下函数的调用表达式不能称为表达式语句：append、cap、complex、imag、len、make、new、real、unsafe.Alignof、unsafe.Offsetof和unsafe.Sizeof。前8个函数是Go语言的内建函数，后3个函数是标准库代码包unsafe中的函数。</p><blockquote><p>code example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">---</span><br><span class="line">go func()&#123;</span><br><span class="line">    println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p></blockquote><p>Go语言的运行时系统对go语句中的函数或方法（go函数）的执行是并发的，当go语言被执行的时候，其中的go函数会被单独地放入到一个goroutine中，该go函数的执行会独立于当前goroutine的运行。go函数并发执行，但执行的先后顺序不确定。</p><p>当go函数被执行完毕的时候，相应的goroutine会进入到死亡状态（Ghead）。标志着该goroutine的一次运行的完成。作为go函数的函数或方法可以有结果声明，但是返回的结果值会在它们被执行完成时被丢弃。需要用channel将go函数的结果传递给其他程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于执行的先后顺序不确定，go语句后无其他语句，main函数所在的G可能先于go函数所在的G执行结束，意味着可能go函数所在的G未来得及执行。</p><p>使用time包中的Sleep函数干预多个G的执行顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>time.Sleep函数让调用它的goroutine暂停（进入Gwaiting状态）一段时间。此种情况最好的方法时调用runtime.Gosched()函数，暂停当前的G，让其他的G有运行的机会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    names := []string&#123;&quot;Eric&quot;, &quot;Harry&quot;, &quot;Robert&quot;, &quot;Jim&quot;, &quot;Mark&quot;&#125;</span><br><span class="line">    for _, name := range names &#123;</span><br><span class="line">        go func (who string) &#123;</span><br><span class="line">            fmt.Printf(&quot;Hello, %s!\n &quot;, who)</span><br><span class="line">        &#125;(name) </span><br><span class="line">    &#125;</span><br><span class="line">    runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主goroutine的运作"><a href="#主goroutine的运作" class="headerlink" title="主goroutine的运作"></a>主goroutine的运作</h2><p>封装main函数的goroutine是Go语言运行时系统创建的第一个goroutine(主goroutine)，主Goroutine在runtime.m0上被运行。runtime.m0在运行完runtime.g0中的引导程序之后，会接着运行主goroutine。</p><p>主goroutine不仅执行main函数。它首先：设定每一个goroutine所能申请的栈空间的最大尺寸。在32位的计算机系统中此最大尺寸为250MB，在64位的计算机系统中此尺寸为1GB。若有某个goroutine的栈空间尺寸大于这个限制，运行时系统就会发出一个栈溢出（stack overflow）的运行时恐慌。随即，Go程序的运行也会被终止。</p><p>设定好goroutine的最大栈尺寸后，主goroutine会在当前M的g0上执行系统监测任务。系统监测任务的作用是调度器查缺补漏。</p><p>此后，主goroutine会进行一系列的初始化工作，涉及的工作内容大致有。  </p><ul><li>检查当前M是否为runtime.m0。若不是，说明之前的程序出现了某种问题，主goroutine会立即抛出异常，意味着Go程序的启动失败。</li><li>创建一个特殊的defer语句，用于在主goroutine退出时做必要的善后处理。因为主goroutine可能非正常的结束。</li><li>启用专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识。</li><li>执行main包中的init函数。</li></ul><p>在上述初始化工作完成之后，主goroutine就会去执行main函数。在执行main函数之后，会检查主goroutine是否引发了运行时恐慌，并进行必要的处理。最后，主goroutine会结束自己以及当前进程的运行。</p><p>main函数执行期间，运行时系统会根据Go程序中的go语句，复用或新建goroutine来封装go函数。这些goroutine都会放入相应P的可运行G队列中，然后等待调度器的调度。</p><h2 id="runtime包与goroutine"><a href="#runtime包与goroutine" class="headerlink" title="runtime包与goroutine"></a>runtime包与goroutine</h2><p>Go的标准库代码包runtime中的程序实体，提供了各种可以使用户程序与Go运行时系统交互的功能。</p><h3 id="1-runtime-GOMAXPROCS函数"><a href="#1-runtime-GOMAXPROCS函数" class="headerlink" title="1.runtime.GOMAXPROCS函数"></a>1.runtime.GOMAXPROCS函数</h3><p>用户程序在运行期间，设置常规运行时系统中的P的最大数量。调用会引起“Stop the world”，应在应用程序尽量早的调用，更好的方式是设置环境变量GOMAXPROCS。P的最大数量范围在1～256。</p><h3 id="2-runtime-Goexit函数"><a href="#2-runtime-Goexit函数" class="headerlink" title="2.runtime.Goexit函数"></a>2.runtime.Goexit函数</h3><p>立即使当前goroutine的运行终止，而其他goroutine并不会受此影响。runtime.Goexit函数在终止当前goroutine之前，会先执行该goroutine中所有还未执行的defer语句。</p><p>该函数将被终止的goroutine置于Gdead状态，并将其放入本地P的自由G列表，然后触发调度器的一轮调度流程。</p><blockquote><p>不应在主goroutine中调用此函数，否则引发运行时恐慌。</p></blockquote><h3 id="3-runtime-Gosched函数"><a href="#3-runtime-Gosched函数" class="headerlink" title="3.runtime.Gosched函数"></a>3.runtime.Gosched函数</h3><p>该函数暂停当前goroutine的运行，并将其置为Grunnable状态，放入调度器的可运行G队列。经过调度器的调度，该goroutine马上会再次运行。</p><h3 id="4-runtime-RunGoroutine函数"><a href="#4-runtime-RunGoroutine函数" class="headerlink" title="4.runtime.RunGoroutine函数"></a>4.runtime.RunGoroutine函数</h3><p>返回当前运行时系统中处于非Gdead状态的用户G的数量。这些goroutine被视为“活跃的”或者“可调度的”。返回值总会大于一（废话）。</p><h3 id="5-runtime-LockOSThread函数和runtime-UnLockOSThread函数"><a href="#5-runtime-LockOSThread函数和runtime-UnLockOSThread函数" class="headerlink" title="5.runtime.LockOSThread函数和runtime.UnLockOSThread函数"></a>5.runtime.LockOSThread函数和runtime.UnLockOSThread函数</h3><p>前者的调用使当前goroutine与当前M锁定在一起，后者的调用则会解除这样的锁定。多次调用前者不会造成问题但只有最后一次生效。没有调用前者时调用后者也不会产生任何副作用。</p><h3 id="6-runtime-debug-SetMaxStack函数"><a href="#6-runtime-debug-SetMaxStack函数" class="headerlink" title="6.runtime/debug.SetMaxStack函数"></a>6.runtime/debug.SetMaxStack函数</h3><p>约束单个goroutine所能申请栈空间的最大尺寸。主goroutine会对此值进行默认设置。</p><p>函数接收一个int类型的参数，参数为欲设定的栈空间的最大字节数。执行完毕后会把之前的设定值作为结果返回。</p><p>若运行时系统在为某个goroutine增加栈空间的时候，若其实际尺寸超过设定值，就会发起一个运行时恐慌并终止程序的运行。</p><p>此函数不会像runtime.GOMAXPROCS函数对传入的参数值进行检查和纠正。</p><h3 id="7-runtime-debug-SetMaxThreads函数"><a href="#7-runtime-debug-SetMaxThreads函数" class="headerlink" title="7.runtime/debug.SetMaxThreads函数"></a>7.runtime/debug.SetMaxThreads函数</h3><p>对Go运行时系统所时用的内核线程的数量（也为M的数量，其与内核线程一一对应）进行设置。引导程序中，该数量被设置为10000。</p><p>接收一个int类型的值，返回一个int类型的值。前者代表欲设定的新值，后者代表之前的旧值。若设定的数量小与当前正在使用的M的数量，则会引发一个运行时恐慌。函数调用后，新建M会检查当前所持M的数量，若大于M的数量的设定，运行时系统引发一个运行时恐慌。</p><h3 id="8-与垃圾回收有关的一些函数"><a href="#8-与垃圾回收有关的一些函数" class="headerlink" title="8.与垃圾回收有关的一些函数"></a>8.与垃圾回收有关的一些函数</h3><p>runtime/debug.SetGCPercent、runtime.GC和runtime/debug.FreeOSMemory。前者用于设定触发GC的条件，后两者用于手动触发GC。在后两个函数的执行期间，调度是停止的（阻塞）。runtime/debug.FreeOSMemory函数比runtime.GC多做一件事，在GC之后清扫一次堆内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go语句是启用goroutine的唯一途径。&lt;/p&gt;
&lt;h2 id=&quot;go语句与Goroutine&quot;&gt;&lt;a href=&quot;#go语句与Goroutine&quot; class=&quot;headerlink&quot; title=&quot;go语句与Goroutine&quot;&gt;&lt;/a&gt;go语句与Goroutine
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="go语句" scheme="bighua.top/tags/go%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="goroutine" scheme="bighua.top/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>Golang笔记-Go并发底层</title>
    <link href="bighua.top/2018/04/27/Golang%E7%AC%94%E8%AE%B0-Go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82/"/>
    <id>bighua.top/2018/04/27/Golang笔记-Go并发底层/</id>
    <published>2018-04-27T09:38:02.000Z</published>
    <updated>2018-07-04T17:45:25.108Z</updated>
    
    <content type="html"><![CDATA[<p>Go在操作系统提供的内核线程之上搭建了一个特有两级线程模型，称为Goroutine。其代表的含义为：</p><blockquote><p>不要用共享内存的方式来通信，作为替代，应该以通信作为手段来共享内存。</p></blockquote><p>Go不推荐以共享内存区的方式传递数据，作为替代，优先使用Channel。被用来在多个Goroutine之间传递数据，并且会保证其过程的同步。提供了一些传统的并发访问控制方式（互斥量、条件变量等）。</p><h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>Go语言的线程实现模型，有3个核心元素支撑线程实现模型的主框架：   </p><ul><li>M：Machine的缩写。一个M代表一个内核线程。</li><li>P：Processor的缩写。一个P代表了M所需的上下文环境。</li><li>G：Goroutine的缩写。一个G代表了对一段需要被并发执行的Go语言代码的封装。</li></ul><p>一个G的执行需要M和P的支持。一个M在与一个P关联之后就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列。该队列中的G会被依次传给与本P关联的M并获得运行时机。</p><p>M与KSE（内核调度实体）之间是一对一关系，一个M仅能代表一个内核线程。Go语言的运行时系统（runtime system）用其代表一个内核调度实体，在一个M的生命周期内，其仅会与一个KSE产生关联。M与P以及P与G之间的关系会在实际调度的过程中被改变。M与P之间也总是一对一的，P与G之间是一对多的。一个G最终由一个M来负责运行。</p><h3 id="1-M"><a href="#1-M" class="headerlink" title="1.M"></a>1.M</h3><p>一个M代表了一个内核线程。大多数情况下，创建一个M的原因是由于没有足够的M来关联P并运行其中的可运行的G。在运行时系统执行系统监控或垃圾回收等任务时也会导致新的M的创建。</p><p>M结构中字段众多。  </p><ul><li>curg：存放当前M正在运行的G的指针。</li><li>p：指向与当前M相关联的P。</li><li>msraerfm：M的起始函数。</li><li>nextp：暂存与当前M有潜在关联关系的P。把调度器将某个P赋给某个M的nextp字段的操作称为对M和P的预联。有时运行时系统会把被重新启用的M和已与它预联的P关联在一起。</li></ul><p>M在被创建之初会被加入到全局的M列表（runtimr.allm）中。然后它的起始函数和准备关联的P（大多数情况下是导致此M创建操作的P）会被设置。最后运行时系统会为它专门创建一个新的内核线程并与之相关联。此时新的M就为执行G做好了准备。起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。全局M列表无特殊意义，运行时系统会通过它获取到所有M的信息。可以防止M被当作垃圾回收掉。</p><p>新的M被创建完成后会先进行一些初始化工作，包括对自身所持的栈空间以及信号处理方面的初始化。初始化完成后M的起始函数会被执行（若存在）。若起始函数代表的是系统监控任务，则M会一直在那里执行而不会继续后面的流程。否则在初始化函数执行完毕后，当前M会与准备与它关联的P完成关联。此时一个并发执行环境才形成。</p><p>运行时系统管辖的M有时会被停止，例如运行时系统开始执行垃圾回收任务的时候。运行时系统停止M时，在对其属性进行必要的重置之后，把它放入调度器的空闲M列表（runtime.sched.midle）。在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。</p><p>M本身是无状态的，M是否空闲仅以它是否存在于调度器的空闲M列表中为依据。</p><p>单个Go程序所使用的M的最大数量可以被设置。<code>使用命令运行Go程序时，一个引导程序先会被启动。引导程序为Go程序的运行建立必要的环境</code>。引导程序会对M的最大数量进行初始设置，为10000，即一个Go程序最多可以使用10000个M。意味着最理想情况下，同时可以有10000个内核线程被同时运行。操作系统内核对进程的虚拟内存的布局的控制以及大小的限制，此数量级线程可能很难共存，Go语言本身对于线程数量的限制几乎可以被忽略。除此之外可以在Go程序中对该限制进行限制。调用标准库代码包runtime/debug中的SetMaxThreads函数并提供新的M最大数量。执行后会把旧的M最大数量作为结果值返回。若传入的值比当时M的实际数量小，运行时系统会发起一个运行时恐慌。若需要设置M的最大数量，越早调用此函数越好。</p><h3 id="2-P"><a href="#2-P" class="headerlink" title="2.P"></a>2.P</h3><p>P是使G能够在M中运行的关键。运行时系统会适时地让P与不同的M建立或断开关联，以使P中的可运行的G能够在需要的时候及时获得运行时机。类似操作系统内核在CPU之上实时切换不同的进程或线程。</p><p>调用runtime.GOMAXPROCS函数，可以改变单个Go程序可以间接拥有的P的最大数量。此外，可以在运行Go程序之前设置环境变量GOMAXPROCS的值来对Go程序可以拥有的P的最大数量做出预先设定。P的最大数量相当于是对可以被并发运行的用户级别的G的数量做出限制。每个P都需要关联一个M才能使其中的可运行的G得到执行，不意味着环境变量GOMAXPROCS的值会限制住M的总数量。当M因系统调用的进行而被阻塞（运行的G进入了系统调用）时，运行时系统会将M和与之关联的P分离出来。此时，这个P的可运行G队列中还有未被运行的G，则运行时系统会找到一个空闲M或创建出一个新的M，并与该P关联以满足这些G的运行需要。若Go程序中创建的大部分Goroutine中都包含了很多需要间接地进行各种系统调用的代码时，即使环境变量GOMAXPROCS的值被设定为1，也可能会有多个M被创建出来。实际的M总数量很可能会比环境变量GOMAXPROCS所指代的数量多。真正使用的内核线程的数量不会因此而环境变量受到限制。</p><p>Go程序开始被运行时，引导程序也会对P的最大数量进行设置。默认值为1。默认情况下，无论我们在程序中用go语句启用出多少Goroutine，它们都只会被塞入同一个P的可运行G的队列中。P最大数量值绝不会比引导程序中的硬性上限值大，超过时会被硬性上限值取代。</p><p>runtime.GOMAXPROCS函数的执行会暂时使所有的P都相继进入停止状态并试图阻止任何用户级别的G的运行。只有在新的P最大数量被设定完成之后，运行时系统才会开始陆续恢复它们。对程序性能损耗大。即只在Go程序的main函数的开始处调用runtime.GOMAXPROCS函数较好，最好不对其进行调用而只预先设置GOMAXPROCS。</p><p>确定P最大数量后，运行时系统会根据这个数值初始化全局P列表（runtime.allp）。包含了当前运行时系统创建的所有P。然后运行时系统把调度器的可运行G队列中的所有G均匀的放入到全局P列表中的各个P的可运行G队列中。此时，运行时系统需要用到的所有P都以就绪。</p><p>同空闲M列表，在运行时系统中存在着调度器的空闲P列表（runtime.sched.pidle）。当一个P不再与任何M关联的时候，运行时系统会把它放入到该列表，当运行时系统需要一个空闲的P关联某个M时，会从此列表中取出一个。即使P进入到空闲P列表，它的可运行G列表也不一定是空的。</p><p>P本身是有状体的：  </p><ul><li>Pidle：表明当前P未与任何M存在关联。</li><li>Prunning：表明当前P正在与某个M关联。</li><li>Psyscall：表明当前P中的被运行的那个G正在被系统调用。</li><li>Pgcstop：表明运行时系统正在进行垃圾回收。在运行时系统进行垃圾回收时，会试图把全局P列表中的都置于此状态。</li><li>Pdead：表明当前P已经不会再被使用。当在Go程序运行的过程中通过调用runtime.GOMAXPROCS函数减少P最大数量时，多余的P会被运行时系统置于此状态。</li></ul><p>P的初始状态时Pgcstop，虽然运行时系统并不会在这时进行垃圾回收。初始化和填充P中的可运行G队列之后，运行时系统会将状态设置为Pidle并放入到调度器的空闲P列表中。空闲P列表中的所有P都会由调度器根据实际情况进行取用。除了Pdead之外的其他状态的P都会在运行时系统进行垃圾回收的时候被置于Pgcstop状态，等到垃圾回收结束之后并不会恢复至原有状态，而会被统一地换为Pidle状态。意味着它们会被重新调度。除了Pgcstop状态，处于其他状态的P都有可能由于全局P列表的缩小而被认为是多余的并置于Pdead状态。P被转换为Pdead状态之前，其可运行G队列中的G都会被转移至调度器的可运行G队列中，其自由G列表中的G都会被转移到调度器的自由G列表中。</p><p>每个P中都有一个可运行G列表，还包含一个自由G列表（gfree）。自由G列表中包含一些已经被运行完成的G。随着被运行完成的G的增多，该自由列表可能会很长。若增长到一定程度，运行时系统会把其中的部分G转移到调度器的自由G列表（runtime.sched.gfree）中。当使用go语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G来封装我们提供的函数，仅当获取不到这样的一个G时才有可能区创建一个新的G。若相应P的自由G列表为空而获取不到自由G时，运行时系统若在这个过程中发现其中的自由G太少，则会先尝试从调度器的自由G列表中转移过来一些G。只有在调度器的自由G列表也为空时才会有新的G被创建。很大程度上提高了G的复用率。当一个P被运行时系统认为不会再被使用（被置于Pdead状态）的时候，其中的自由G列表中的所有G都会转移至调度器的自由G列表中。</p><p>P的结构中，可运行G队列和自由G列表是最重要的两个成员，间接的体现运行时系统对相应的G的调度情况。</p><h3 id="3-G"><a href="#3-G" class="headerlink" title="3.G"></a>3.G</h3><p>一个G就相当于一个Goroutine(或者称Go程)，对应使用go语句欲并发执行的一个匿名或命名的函数。</p><p>Go语言的编译器会把我们编写的go语句（go关键字和其后的函数的统称）变成对一个运行时系统中的函数调用，并把go语句中的函数（go函数）即其参数都作为参数传递给这个运行时系统中的函数。go语句代表了我们向运行时系统递交的一个并发任务。</p><p>运行时系统在接到这样一个调用之后，先检查go函数即其参数的合法性，然后会试图从本地P的自由G列表和调度器的自由G列表获取可用的G。没有获取到则会新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（runtime.allg）。新建的G会在第一时间被加入到该列表中。该列表的主要作用是集中存放当前运行时系统中的所有G的指针。无论将会封装当前的go函数的G是否是新的，运行时系统都会对它进行一次初始化。包括关联go函数以及设置G的状态的ID等步骤。初始化完成后，这个G被放入到本地P的可运行G队列中。时机成熟，调度会立即进行以使这个G尽快被运行。</p><p>每个G都会由运行时系统根据其实际状况设置不同的状态：  </p><ul><li>Gidle：当前G被创建但还完全未被初始化的时候。</li><li>Grunnable：表示当前G是可运行的并且正在等待被运行。</li><li>Grunning：表示当前G正在被运行。</li><li>Gsyscall：表示当前G正在进行系统调用。</li><li>Gwaiting：表示当前G正在因某个原因而等待。</li><li>Gdead：表示当前G已被运行完成。</li></ul><p>运行时系统用一个G封装我们通过go语句递交的go函数的时候，先对这个G进行初始化。其中的一步就是初始化这个G的状态为Grunnable，即一个G真正被使用是在其状态被设置为Gorunnable之后。</p><p>一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。</p><p>G在退出系统调用时，运行时系统先会尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为Grunnable状态并放入到调度器的自由G列表中。</p><p>进入死亡状态（Gdead）的G可以被重新初始化并使用。相比之下，P在进入死亡状态（Pdead）之后则只能面临被销毁的结局。Gdead与Pdead状态所表达的含义完全不同。处于Gdead状态的G会被放入本地P或调度器的自由G列表，为重用提供了条件。</p><h3 id="4-核心元素的容器"><a href="#4-核心元素的容器" class="headerlink" title="4.核心元素的容器"></a>4.核心元素的容器</h3><p>M，P和G的容器：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">源码</th><th style="text-align:center">作用域</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">全局P列表</td><td style="text-align:center">runtime.allm</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有M的列表</td></tr><tr><td style="text-align:center">全局P列表</td><td style="text-align:center">runtime.allp</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有P的列表</td></tr><tr><td style="text-align:center">全局G列表</td><td style="text-align:center">runtime.allg</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有G的列表</td></tr><tr><td style="text-align:center">调度器的空闲M列表</td><td style="text-align:center">runtime.sched.midle</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放空闲M的列表</td></tr><tr><td style="text-align:center">调度器的空闲P列表</td><td style="text-align:center">runtime.sched.pidle</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放空闲P的列表</td></tr><tr><td style="text-align:center">调度器的可运行G队列</td><td style="text-align:center">runtime.sched.runq</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放可运行G的队列</td></tr><tr><td style="text-align:center">调度器的自由G列表</td><td style="text-align:center">runtime.sched.gfree</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放自由G的列表</td></tr><tr><td style="text-align:center">P的可运行G队列</td><td style="text-align:center">runq</td><td style="text-align:center">本地P</td><td style="text-align:left">用于存放当前P中的可运行G的队列</td></tr><tr><td style="text-align:center">P的自由G列表</td><td style="text-align:center">gfree</td><td style="text-align:center">本地P</td><td style="text-align:left">用于存放当前P中的自由G的列表</td></tr></tbody></table><p>全局的3个列表存在的主要目的是为了统计运行时系统中的所有M、P或G。运行时系统创建出的任何G都会存在于全局G列表中，其于的4个与G有关的列表只会存放在当前作用域内的具有特定状态的G。调度器的可运行G队列和P的可运行G队列都拥有几乎平等的运行机会。运行时系统调度的过程中会先后对它们进行检查，并会运行第一个被发现的可运行的G。从Gsysycall状态和Ggcstop状态转出的G，会被放入调度器的可运行G队列，被运行时系统初始化的G，会被放入本地P的可运行G队列。从Gwaiting状态转出的G，除因网络I/O陷于等待的G，都会被放入到本地P的可运行G队列。调用runtime.GOMAXPROCS函数，可能会导致运行时系统清空调度器的可运行G队列。其中所有G都会被均匀地放入到全局P列表中的各个P的可运行G队列当中。在G转入Gdead状态后，先会被放入本地P的自由G列表，在运行时系统需要用自由G封装go函数时，先尝试从本地P的自由G列表中获取。调度器的自由G列表只起到一个暂存自由G的作用。</p><p>与M和P相关的非全局容器被用于存放暂时不被使用的元素的实例。在运行时系统有需要时，会从中获取相应元素的实例并重新启用它。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>两级线程模型中的一部分调度任务会由操作系统内核之外的程序承担，Go语言中，其运行时系统中的调度器会负责这一部分调度任务。调度的主要对象是M、P和G的实例，调度的辅助设施是各种容器。每个M（每个内核线程）在运行过程中都会按需执行一些调度任务。</p><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1.基本结构"></a>1.基本结构</h3><p>调度器有它自己的数据结构，这一数据结构的主要目的是为了更加方便地管理和调度各个核心元素的实例。调度器的部分字段：</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">数据类型</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center"> gcwaiting</td><td style="text-align:center">uint32</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> stopwait</td><td style="text-align:center">int32</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> stopnote</td><td style="text-align:center">Note</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> sysmonwait</td><td style="text-align:center">unit32</td><td style="text-align:left">作为系统检测任务被执行期间的停止和通知机制</td></tr><tr><td style="text-align:center"> sysmonnote</td><td style="text-align:center">Note</td><td style="text-align:left">作为系统检测任务被执行期间的停止和通知机制</td></tr></tbody></table><p>通过调度器gcwaiting的值，可知垃圾回收器是否已经开始准备或正在进行垃圾回收。stopwait字段是为了对还未被停止调度的P进行计数。当计数器为0时，说明调度工作已被完全停止，垃圾回收器会立即开始执行垃圾回收任务。stopnode字段被用来向垃圾回收器告知调度工作已经完全被停止的通知机制的重要部分。</p><p>辅助协调手段存在的意义在于保证所有的P在垃圾回收期间都处于Pgcstop状态。<code>Go语言的垃圾回收器先停止一切调度工作（包括对M和P的调度），然后进行垃圾回收，最后待垃圾回收完成之后再重启调度工作。</code>即Go语言的垃圾回收任务是在“stop the world”执行垃圾回收任务）的环境下被执行的。“Stop the world”即指运行时系统要放下手头所有工作并专心(无其它并发任务）执行垃圾回收任务。</p><p>垃圾回收器在准备执行垃圾回收任务的时候，先把调度器的gcwaiting字段的值设置为1，告诉调度器，它已经开始准备执行垃圾回收任务。垃圾回收器会利用stopnode字段将自身阻塞，以等待调度器完全停止调度。调度器在发现gcwaiting字段的值被置为1之后，会积极响应，并陆续停止正在进行的调度工作。待所有的调度工作均已停止（计数器的stopwait字段的值为0）之后，调度器回利用stopnode字段向垃圾回收器发送通知。垃圾回收器在收到通知后才会真正开始垃圾回收，通知机制在底层由信号灯实现。</p><p>垃圾回收器进行垃圾回收的时候，被持续执行的系统检测任务也需要被暂停，sysmonwait和sysmonnode的作用就是及时地暂停和恢复监测任务的执行。sysmonwait字段表示系统监测任务是否已经被暂停的标记，sysmonnode字段则是被用来向执行系统监测任务的程序发送通知。</p><p>系统监测任务是被持续执行的，即被置于无尽的循环中。在每次迭代之初，相关程序（系统监测器）会先检查调度器的gcwaiting字段的值，若其值为1，则说明垃圾回收器已经开始准备或正在执行垃圾回收任务。系统监测器会先将调度器的sysmonwait字段的值设置为1以表示系统监测任务已被暂停。然后利用sysmonnode字段阻塞自身以等待垃圾回收的完成。在调度工作被重启之后，调度器若发现其sysmonwait字段值为1则会利用sysmonnode字段向系统检测器发送通知。系统监测器在收到该通知之后会立即执行当次迭代的后续流程并继续进行之后的迭代。</p><h3 id="2-一轮调度"><a href="#2-一轮调度" class="headerlink" title="2.一轮调度"></a>2.一轮调度</h3><p>引导程序为Go程序的运行建立必要的环境。在引导程序完成工作之后，Go程序的main函数才会被真正地执行。引导程序在最后让调度器进行一轮调度，才能让main函数所在的G马上有机会被运行（封装main函数的G总是Go语言运行时系统创建的第一个G）。</p><center><p><img src="https://git-blog.oss-cn-beijing.aliyuncs.com/gfayilundiaodu.png" alt="一轮调度"><br></p></center><br>调度器的一轮调度中，有5个子流程。由标准库代码包runtime中的schedule函数代表。调度器会先从一些比较容易找到可运行G的地方入手，即全局的可运行G队列和本地的可运行G队列。若找不到，调度程序进入强力查找模式（子流程“全力查找可运行的G”）。若仍未找到可运行的G，该子流程就会暂停，直到有可运行的G出现才会继续下去。<p></p><p>在一轮调度的开始，调度器会先判断当前M是否已被锁定。M和G可以成对地锁定在一起。调度器会按照一定的策略动态地关联M、P和G，并以此高效地执行并发程序。</p><p>锁定M和G的操作是为CGO准备的，CGO代表了Go中的一种机制，时Go程序和C程序之间的一种调用机制。</p><p>若调度器在一轮调度之初发现当前M已与某个G锁定，就会停止调度并停止当前M（让其暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前M意味着相关的内核线程并不能再去做其他事情。调度器也不会为当前M寻找可运行的G。若当前M找到一个可运行G，但G与某个M锁定，就会唤醒与之锁定的M以运行该G，并重新为当前M寻找可运行的G。</p><p>若调度器判断当前M未与任何G锁定，则一轮调度的主流程就会继续运行。调度器会检查是否有运行时串行任务正在等待执行。通过判断gcwaiting字段的值，若不为0则一轮调度流程走进另一个分支:停止并阻塞当前M以等待运行时串行任务执行完。一旦串行任务执行完成,该M就会被唤醒,一轮调度也会再次开始。</p><p>若调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的寻找G。一旦找到一个可运行的G，调度器在判断该G未与任何M绑定之后，立即让当前M运行它。</p><p>一轮调度是调度器中最核心的流程，运行时系统在调度过程中经常使用。例如，在用户程序启动时的一系列工作之后之后，一轮调度会首次启动并使封装main的G被调度运行。某个G的运行时阻塞、结束、退出系统调用、栈的增长都会使调度器进行一轮调度。用户程序对某些标准库函数的调用也会触发一轮调度流程。调用runtime.Gosched函数相当于手动让调度器进行了新一轮的调度，使其他Goroutine能够得到运行机会。调用runtime.Goexit函数会在终结调用它的那个Goroutine之后，立即开始进行新一轮调度以使其他等待运行的Goroutine获得机会。</p><h3 id="3-全力查找可运行的G"><a href="#3-全力查找可运行的G" class="headerlink" title="3.全力查找可运行的G"></a>3.全力查找可运行的G</h3><p>“全力查找可运行G”子流程会尝试从各处搜索可运行的G，甚至会从别的P（非本地P）偷取可运行的G。由runtime.findrunnable函数代表，该函数返回一个处于Grunnable状态的G。搜索流程大致分为2个阶段和10个步骤。  </p><ul><li>（1）获取执行终结器的G。一个终结器（或称终结函数）可以与一个对象关联，通过调用runtime.SetFinalizer函数产生这种关联。当一个对象变为不可达（未被其他任何对象引用）时，垃圾回收器在回收该对象之前，会执行与之关联的终结函数（若有）。所有终结函数的执行都会由一个专用的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态并放入本地P的可运行G队列。</li><li>（2）从本地P的可运行G队列获取G。</li><li>（3）从调度器的可运行G队列获取G。</li><li>（4）从网络I/O轮询器（netpoller）处获取G。若netpoller已被初始化且已有过网络I/O操作，那么调度器会试着从netpoller获取获取一个G列表，并把表头的G作为结果返回。同时把其余的G放入调度器的可运行G队列。若netpoller未初始化或还未有过网络I/O操作，这一步会跳过。这里的获取浅尝辄止，非阻塞。</li><li>（5）从其他P的可运行G队列获取G。条件允许情况下，调度器使用一种伪随机算法在全局P列表中选取P，然后试着从它们的可运行G队列中盗取（或者说转移）一半的G到本地P的可运行G队列。选取P和盗取G的过程会重复多次，成功则停止。成功会把盗取的一个G作为结果返回，否则搜索的第一阶段就结束。</li><li>（6）获取执行GC标记任务的G。搜索第二阶段，调度器会判断是否正处在GC的标记阶段，以及本地P是否可用于GC标记任务。若答案都是true，调度器会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回。</li><li>（7）从调度器的可运行G队列获取G。调度器再次尝试从该处获取一个G，并把它作为结果返回。若依然找不到可运行的G，会解除本地P与当前M的关联并把该P放入调度器的空闲P列表。</li><li>（8）从全局P列表中的每个P的可运行G队列中获取G。遍历全局P列表中的P，并检查他们的可运行G队列。只要发现某个P的可运行G队列不为空，取该iP，判定可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。若所有P可运行G队列都为空，继续后面的搜索。</li><li>（9）获取GC任务标记的G。判断是否正处于GC的标记阶段，以及GC标记任务相关的全局资源是否可用。若答案都是true，调度器就会从其空闲P列表拿出一个P。若该P持有一个GC专用标记G，关联该P与当前M，再次执行第二阶段（步骤（6）开始）。</li><li>（10）网络I/O轮询器（netpoller）获取G。若netpoller已被初始化，并且有过网络I/O操作，调度器再次试着从netpoller获取一个G列表。与步骤（4）基本相同，区别于此处是阻塞的，只有当netpoller有可用的G时阻塞才会解除。若netpoller未被初始化或者未有过网络I/O操作，跳过此步。</li></ul><p>若经过上述步骤仍未找到可运行的G，调度器就会停止当前的M。在之后的某个时刻，该M被唤醒之后，会重新进入“全力查找可运行的G”的子流程。</p><p>网络I/O轮询器（netpoller）是Go为了在操作系统提供的异步I/O基础组件之上，实现自己的阻塞式I/O而编写的一个子程序。当一个G试图在一个网络连接上进行读/写操作时，底层程序（包括基础组件）就会开始为此做准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就回返回相应的事件，让netpoller立即通知为此等待的G。从netpoller获取G意味着获取那些已经接收到通知的G。调度器让它们转入Grunnable状态并等待运行。</p><p>全力查找可运行G的子流程会想方设法去搜寻G，执行比较耗时费力，会调用多方资源来满足当前M运行G的需要。因始终未找到G而停止的M在被唤醒后，依然会执行该子流程，直到找到一个可运行的G，M才会结束它的执行。</p><h3 id="4-启用或停止M"><a href="#4-启用或停止M" class="headerlink" title="4.启用或停止M"></a>4.启用或停止M</h3><p>调度器有时会停止当前M，由如下函数负责M的启用或者停止。  </p><ul><li>stopm()。停止当前M的执行，直到因有新的G变得可运行而被唤醒。</li><li>gcstopm。为串行运行时任务的执行让路，停止当前M的执行，串行运行时任务执行完毕后会被唤醒。</li><li>stoplockedm()。停止已经与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒。</li><li>startlockedm(gp *g)。唤醒与gp绑定的那个M，并让该M去执行gp。</li><li>startm(_p_ *p, spinning bool)。唤醒或创建一个M去关联_p_并开始执行。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h3 id="5-系统监测任务"><a href="#5-系统监测任务" class="headerlink" title="5.系统监测任务"></a>5.系统监测任务</h3><p>由sysmon函数实现。监测任务主要做：  </p><ul><li>在需要时抢夺符合条件的G和P；</li><li>在需要时进行强制GC；</li><li>在需要时清扫堆；</li><li>在需要时打印调度器跟踪信息。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h3 id="6-变更P的最大数量"><a href="#6-变更P的最大数量" class="headerlink" title="6.变更P的最大数量"></a>6.变更P的最大数量</h3><p>P最大数量变更直接影响Go程序的并发性能。调用runtime.GOMAXPROC函数时，会先进行下面两项检查，确保变更合法和有效。  </p><ul><li>若传入的参数值（新值）比运行时系统为此设定的硬性上限值（256）大，前者会被后者替代。</li><li>新值不是正整数，或者与存储在运行时系统中的P最大数量值（旧值）相同，该函数或略此变更直接返回旧值。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h2 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h2><h3 id="1-g0和m0"><a href="#1-g0和m0" class="headerlink" title="1.g0和m0"></a>1.g0和m0</h3><p>运行时系统中的每个M都拥有一个特殊的G，称为M的g0。M的g0管辖的内存称为M的调度栈，对应于操作系统为相应线程创建的栈。M的调度栈也成为OS线程栈或系统栈（参runtime.systemstack函数）。</p><p>M的g0由Go运行时系统在初始化M时创建并分配给M的，一般用于执行调度、垃圾回收、栈管理等方面的工作。M还有一个专用于处理信号的G，称为<code>gsignal</code>。它的栈称为信号栈。系统栈和信号栈不会自动增长，但一定会有足够的空间执行代码。</p><p>除g0，其他由M运行的G都可以视为用户级别G，称为用户G，g0和gsignal称为系统G。g0不会被阻塞，不包含在任何G队列或列表中。栈不会在垃圾回收中被扫描。</p><p>除每个M都有属于自己的g0外，还存在一个runtime.g0。runtime.g0用于执行引导程序，运行在Go程序拥有的<code>第一个内核线程</code>中，该内核线程称为runtime.m0。runtime.m0和runtime.g0都是静态分配的，引导程序无需为它们分配内存。</p><h3 id="2-调度器锁和原子操作"><a href="#2-调度器锁和原子操作" class="headerlink" title="2.调度器锁和原子操作"></a>2.调度器锁和原子操作</h3><p>并发调度时，调度器会在读写一些全局变量以及它的字段的时候动用调度器锁进行保护。</p><p>Go运行时系统在一些需要保证并发安全的变量的存取上使用原子操作。原子操作比锁操作可以有效的节约系统资源和提升系统性能。</p><h3 id="3-调整GC"><a href="#3-调整GC" class="headerlink" title="3.调整GC"></a>3.调整GC</h3><p>目前的GC基于CMS（Concurrent Mark-Sweep，并发标记-清扫）算法，时非分代的和非压缩的。</p><p>目前的GC有3种执行模式：  </p><ul><li>gcBackgroundMode，并发地执行垃圾收集和清扫；</li><li>gcFroceMode，串行地值执行垃圾收集（即执行时停止调度），但并发地执行清扫。</li><li>gcFroceBlockMode，串行地执行垃圾收集和清扫。</li></ul><p>调度器驱使的自动GC和系统监测任务中的强制GC，都会以gcBackgroundMode模式执行。前者会检查Go程序当前的内存使用量，仅当使用量过大时才真正执行GC，后者无视此条件。</p><p>可以通过GODEBUG控制自动GC的并发性，使其值包含gcstoptheworld=1或gcstoptheworld=2，让GC的执行模式由gcBackgroundMode变为gcForceMode或gcForceBlockMode。相当于让并发的GC进入调试模式。</p><p>GC会在为Go程序分配的内存翻倍增长时被触发。Go运行时系统会在分配新内存时检查Go程序的内存使用增量。可以通过调用runtime/debug.SetGCPercent函数改变这个增量的阀值，该函数接受一个int类型的参数：在新分配的内存是上次记录的已分配的内存的百分之几时触发GC。若为负数会导致自动GC的关闭；预设值是100。SetGCPercent函数在被调用后会返回旧的增量阀值。设置环境量变量GOGC亦可，含义规则与SetGCPercent一致。将其值设置为off会关闭自动GC。对GOGC的设置需要在Go程序启动之前进行，否则不生效。</p><p>关闭自动GC意味着需要在程序中手动GC，调用runtime.GC函数可以手动触发一次GC，该函数会阻塞调用方直到GC完成。这种情况下的GC会以gcForceBlockMode模式执行。调用runtime/debug包的FreeOSMemory函数也会手动触发一次完全串行的GC，并且在GC完成之后还会做一次清除堆的操作。两者在执行时都不会检查Go程序的内存使用增量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go在操作系统提供的内核线程之上搭建了一个特有两级线程模型，称为Goroutine。其代表的含义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要用共享内存的方式来通信，作为替代，应该以通信作为手段来共享内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go不推荐以共享内存
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="并发" scheme="bighua.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="底层" scheme="bighua.top/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Git使用中发生的一些莫名错误</title>
    <link href="bighua.top/2018/04/27/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E9%94%99%E8%AF%AF/"/>
    <id>bighua.top/2018/04/27/Git使用中发生的一些莫名错误/</id>
    <published>2018-04-27T03:40:09.000Z</published>
    <updated>2018-07-05T05:21:08.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-push报错-Tags-index-master"><a href="#git-push报错-Tags-index-master" class="headerlink" title="git push报错 Tags:[index,master]"></a>git push报错 Tags:[index,master]</h3><p>背景：<code>git add</code>和<code>git commit</code>后未及时<code>git push</code>，第二天<code>git push</code>报错。<br>错误详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: index file smaller than expected</span><br><span class="line">fatal: index file smaller than expected</span><br><span class="line">error: unable to resolve reference refs/remotes/origin/master: ??</span><br><span class="line">error: Cannot lock the ref &apos;refs/remotes/origin/master&apos;.</span><br></pre></td></tr></table></figure></p><p>解决方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm .git/index</span><br><span class="line">rm .git/refs/remotes/origin/master</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>原因：查询stackoverflow得上方解决结果，直接删除相应的报错文件，然后再重新将改变的工作提交到仓库中，最后再推倒远程仓库。可能原因猜测index文件和master文件被污染，不知具体原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git-push报错-Tags-index-master&quot;&gt;&lt;a href=&quot;#git-push报错-Tags-index-master&quot; class=&quot;headerlink&quot; title=&quot;git push报错 Tags:[index,master]&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="git" scheme="bighua.top/categories/git/"/>
    
    
      <category term="Git" scheme="bighua.top/tags/Git/"/>
    
      <category term="shell" scheme="bighua.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Golang笔记-多线程编程理论</title>
    <link href="bighua.top/2018/04/25/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    <id>bighua.top/2018/04/25/Golang笔记-多线程编程理论/</id>
    <published>2018-04-25T09:08:28.000Z</published>
    <updated>2018-07-04T17:45:25.111Z</updated>
    
    <content type="html"><![CDATA[<p>Linux操作系统提供以POSIX（Portable Operating System Interface of Unix）标准中定义的线程为中心的各种系统调用，最贴近POSIX线程标准的线程实现称为NPTL（Native POSIX Threads Library），已成为Linux默认的线程实现。</p><p>Go语言的并发编程模型在底层是由操作系统所提供的线程库支撑的。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个线程可以被看作是在某个进程中的一个控制流。一个进程至少包含一个线程，进程的第一个线程随着进程的启动被创建，被称为该进程的主线程。一个进程的其他线程由当前进程中已存在的线程所执行相应的系统调用（pthread_create函数）创建，拥有多个线程的进程可以并发的执行多个任务，并且即使某个或某些任务被阻塞也不会影响到其他任务的正常执行。可以改善程序的响应时间和吞吐量。一个线程必属于某一个进程，生命周期不可逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己的线程栈，存储自己的私有数据。线程栈被包含在操作系统内核分配给其所属进程的虚拟内存地址中。一个进程中的很多资源会被其中的所有资源共享，共享资源包括在当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数，以及当前进程所持有的文件描述符等。</p><p>操作系统内核提供若干个系统调用以使应用程序能够管理当前进程中的所有线程，应用程序可以通过相应的系统功能协调这些线程的运行。系统功能由一些同步原语代表。</p><h3 id="1-线程的标识"><a href="#1-线程的标识" class="headerlink" title="1.线程的标识"></a>1.线程的标识</h3><p>同进程一样，每个线程也都有属于它自己的ID，称为线程ID或TID。线程ID在系统范围内可以不是唯一的，在其所属进程的范围内必须是唯一的。Linux操作系统的线程实现确保每个线程在系统范围内的唯一性。线程不复存在后，其线程ID可被其他线程复用。</p><p>线程的ID由操作系统内核分配。应用程序无需关注。在调试时，线程ID帮助区别不同的线程。</p><h3 id="2-线程间的控制"><a href="#2-线程间的控制" class="headerlink" title="2.线程间的控制"></a>2.线程间的控制</h3><p>同一个进程中的任意两个线程的关系都是平等的，不存在层级关系。任何线程都可以对其所属的进程中的其他线程进行有限的管理。主要有：  </p><ul><li>创建线程：主线程在其所属进程启动的时候被创建，此处针对其他线程的创建。任何线程都可以通过调用系统调用<code>pthread_create</code>来创建新的线程。创建线程时，调用线程需要给定新线程将要执行的函数以及传入该函数的参数值。代表该函数的参数被命名为start，通常称start函数。start函数可有返回值。在其他线程中通过与新线程的连接得到在该新线程中执行的start函数的返回值，若新线程创建成功，调用线程得到新线程的ID。</li><li>终止线程：线程可以通过多种方式终止其所属进程的其他线程。例如调用系统调用<code>pthread_cancel</code>。<code>pthread_cancel</code>函数取消给定的线程ID代表的线程。它会向目标线程发出一个请求，要求它立即终止执行。该函数只是发送请求并立即返回，不会等待目标线程对该请求做出响应。至于目标线程什么时候对此请求做出响应、做出怎样的响应，则取决于另外的因素（目标线程的取消状态即类型）。默认情况，目标线程总是会接收线程取消请求，等到时机成熟（执行到某个取消点）的时候目标线程才会去响应线程取消请求。</li><li>连接已终结的线程：由系统调用pthread_join代表。该函数会一直等待（阻塞）与给定的线程ID对应的线程的终止，并把该线程执行的start函数的返回值告知给调用线程。如果目标线程已经处于终止状态，该函数会立即返回。类似把调用线程放置在目标线程后面，当目标线程把流程控制权交出后，调用线程接过流程控制权并继续执行pthread_join函数调用之后的代码。如果一个线程是可被连接的，终止之时必须被连接，否则会变成一个僵尸线程。僵尸线程导致系统资源的浪费，使所属进程的可创建线程数量被无意义减少。</li><li>分离线程：将一个线程分离，意味着它不再是一个可被连接的线程。默认情况下，一个线程总是可以被其他线程连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自动进行清理和销毁工作。分离操作是不可逆的，无法使一个不可连接的线程变回到可被连接的状态。但是对于一个已处于分离状态的线程执行终止操作仍然会起作用。分离操作由系统调用pthread_detach代表，接受一个代表了线程ID的参数值。</li></ul><p>一个线程对自身也可以进行两种控制：终止和分离。线程终止自身的方式有很多种，在线程执行的start函数中执行return语句会使该i线程随着start函数的执行结束而终止。在主线程中执行了return语句，当前进程中的所有线程都会被终止。在任意线程中调用系统调用exit也会达到一样效果。另一种显示地调用系统调用pthread_exit。在主线程中调用pthread_exit函数，只有主线程自己会被终止，其他线程仍然会正常运行。线程分离自身与分离其他线程的方式一致，调用pthread_detach函数。区别在于调用线程传递给该函数的线程ID是自己的ID还是其他线程的ID。</p><h3 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3.线程的状态"></a>3.线程的状态</h3><p>线程只是进程的一个控制流，对进程的状态描述几乎都适用于线程。</p><p>线程在被创建出来之后会进入就绪状态，处于就绪状态的线程会等待被运行的时机。</p><p>一旦该线程被真正地运行，就会由就绪状态转换至运行状态。正在运行的线程可能会由于某些原因（等待未完成的I/O操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量）被阻塞，进而由运行状体转换至睡眠状态。当阻塞线程等待的事件或条件发生或满足时，线程被唤醒。从睡眠状态转出，先进入就绪状态等待运行时机。若CPU处于空闲状态则会立即运行。处于运行状态的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待下一个运行时机。操作系统内核的调度器会按照一定的算法和策略使线程在这三个状态之间状态之间转换。线程在其生命周期的大部分时间里都会处于就绪状态、运行状态或睡眠状态之中。</p><p>在当前线程自我终结或者其他线程向当前线程发出取消请求且取消时机已到之后，当前线程就会试图进入终止状态。若当前线程之前没有被分离，且此时没有其他线程与它连接，则当前线程进入僵尸状态而非终止状态。当且仅当有其他线程与之连接之后，当前进程才会从僵尸状态转换至终止状态。处于终止状态的线程才会被操作系统内核回收。在任意线程中调用exit函数以及在主线程中执行return语句，都不但会使其所属进程中的所有线程立即终止，还会结束该进程的运行，无论当前线程是否被分离。</p><h3 id="4-线程的调度"><a href="#4-线程的调度" class="headerlink" title="4.线程的调度"></a>4.线程的调度</h3><p>调度器的实时调度和切换，产生众多线程并行运行的现象。调度器把时间划分成极小的时间片并把这些时间片分配给不同的线程，以使众多线程都能有机会在CPU上运行。</p><p>线程的执行总是趋向于CPU受限或I/O受限。即线程要么需要花费一定的时间使用CPU进行计算，要么花费一些时间等待相对较慢的I/O操作的完成。一个线程的趋向性并不总是清晰的，调度器往往需要猜测它们，依据对线程的趋向性的猜测把它们进行分类，并让I/O受限的线程具有更高的动态优先级以优先使用CPU。因为I/O操作往往花费很长的时间，应让其尽早地开始执行</p><p>线程的动态优先级可以被调度器实时调整，线程的静态优先级只能由程序指定。若程序没有显示的指定一个线程的静态优先级，则将被设定为0。调度器不会改变线程的静态优先级。线程的动态优先级是调度器根据其静态优先级调整得出。线程的静态优先级决定线程单次能够在CPU上运行的最长时间，即调度器分配给它的时间片的大小。</p><p>所有等待CPU的线程会被按照动态优先级从高到低的顺序排入到与该CPU对应的运行队列中。下一个被运行的线程总是动态优先级最高的一个。每一个CPU的运行队列中都包含两个优先级阵列，其中的一个用于存放正在等待运行的线程（激活的优先级阵列），另一个用于存放已经运行过但还未完成的线程（过期的优先级阵列）。优先级阵列是一个由若干个链表组成的数组。一个链表只会包含具有相同优先级的线程，一个线程也只会被放到与它的优先级相对应的哪一个链表中。当一个线程被放入某个优先级阵列的时候，实际上是被放入与它的优先级相对应的那个链表的末尾处。</p><p>下一个被运行的线程总是会从激活的优先级阵列中选出。若调度器发现某个线程已经占用了CPU很长时间（小于或等于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器会让等待的线程在CPU上运行。被换下来线程被排入过期的优先级阵列。当激活的优先级阵列中没有待运行的线程的时候，调度器会把这两个优先级阵列的身份互换，即之前的激活的优先级阵列称为新的过期的优先级阵列，之前的过期的优先级阵列成为新的激活的优先级阵列。被放入过期的优先级阵列的线程就又有机会被运行了。</p><p>线程被阻塞进入睡眠状态会从运行队列中被移除，不能够被调度和运行。睡眠状态分为可中断的睡眠状态和不可中断的睡眠状态，同多进程篇释意。</p><p>线程因等待某个事件或条件的发生而被加入到对应的等待队列中，并随即进入睡眠状态。当事件或条件发生时，内核通知对应的等待队列中的所有线程，线程被唤醒从等待队列转移至适当的运行队列中。调度器会稍稍调高被唤醒的线程动态优先级，使这类线程能够更早地被运行。</p><p>若计算机上有多个CPU，平衡它们之间的负载也是调度器的工作。调度器尽量使一个线程在一个特定的CPU上运行。有利于维护高速缓存的高命中率以及高效使用就进的内存。内核会为每个CPU都建立一个运行队列，每个队列中都保存对应CPU的负载系数。调度器根据这一系数了解并调整各个CPU的负载（还有其他因素），把在较忙碌的CPU上运行的线程迁移至其他较空闲的CPU上运行。</p><p>操作系统内核的调度器使用若干策略对众多线程在CPU上的运行进行干涉，使得操作系统中的各个任务都能够有条不紊地进行，同时兼顾效率和公平性。通过协调各个线程的状态达到调度的目的。</p><h3 id="5-线程实现模型"><a href="#5-线程实现模型" class="headerlink" title="5.线程实现模型"></a>5.线程实现模型</h3><p>线程的实现模型主要有3个：用户级线程模型、内核级线程模型和两级线程模型。差异于线程与内核调度实体（Kernel Scheduling Entity,简称KSE）之间的对应关系上。内核调度实体是可以被内核的调度器调度的对象。也被称为内核级线程，是操作系统内核的最小调度单元。  </p><ul><li>用户级线程模型：由用户级别的线程库全权管理。线程库并不是内核的一部分，只被存储在进程的用户空间之中。进程中的线程的存在对于内核来说是无法感知的，不是内核调度器的调度对象。对线程的各种管理和协调是用户级程序的自主行为，与内核无关。应用程序在对线程进行创建、终止、切换或同步等操作的时候，并不需要让CPU从用户态切换到内核态。用户线程模型在线程操作的速度上存在优势，对线程的管理不需要内核参入，程序的移植性更强。在此模型下的多线程不能够被真正地并发运行。当线程在I/O操作过程中被阻塞，其所属进程也会被阻塞，由线程无法被内核调度造成。调度器将进程看作一个无法再被分割的调度单元，无论其中存在多少个线程。即使计算机上存在多个CPU进程中的多个CPU也无法被分配给不同的CPU运行。对于CPU的负载均衡来说，进程的粒度太粗，让不同的进程在不同的CPU上运行的意义微乎其微。线程的优先级页形同虚设。同一个进程中的所有线程的优先级只能由该进程的优先级来体现。线程库对线程的调度不受内核控制，与内核为进程设定的优先级是没有关系的。现代操作系统都不是使用这种模型来实现线程的。由于包含了多个用户级线程的进程只与一个KSE相对应，这种线程实现模式也被称为多对一（M：1）的线程实现。</li><li>内核级线程模型：该模型下的线程由内核负责管理。是内核的一部分，应用程序对线程的创建、终止和同步都必须通过内核提供的系统调用来完成，进程中的每一个线程都与一个KSE相对应。内核可以分别对每一个线程进行调度。内核级线程模型又被称为一对一（1：1）的线程实现。线程完全由内核管理和调度，可以真正实现线程的并发运行。这些线程完全由内核来管理和调度，内核在极短的时间快速切换和运行各个线程使得它们看起来像正在被同时运行。即使进程中的一个线程由于某种原因进入到了阻塞状态，其他线程也不会受到影响并可以正常的运行。使得内核在多个CPU上进行负载平衡变得容易和有效。如果一个线程与被阻塞的线程之间存在同步关系，则可能受到影响。这是一种应用级别的干预，不属于线程本身的特质。内核对线程的全权接管使操作系统在库级别几乎无需为线程管理做什么事情。与用户级别线程模型形成鲜明的对比。内核线程的管理成本比用户级别线程高出很多。线程的创建会使用到内核资源。创建线程、切换线程、同步线程等操作所花费的时间也会更多。如果一个进程包含了大量的线程，会给内核的调度器造成非常大的负担，会影响到操作系统的整体性能。<code>采用内核级线程模型的操作系统对一个进程中可以创建的线程的数量有直接或间接的限制</code>。很多现代操作系统都是以内核级线程模型实现线程的，包括Linux操作系统。</li><li>两级线程模型：两极线程模型的目标是取前两种模型的精华，去二者只糟粕。被称为多对多（M：N）的线程实现。在此模型下，一个进程可以与多个KSE相关联。这与内核级线程模型是相似的。不同的是，进程中的线程（应用程序线程）并不与KSE一一对应。应用程序线程可以被映射到同一个已关联的KSL上。已被加载到进程的虚拟内存中的实现两级线程模型的线程库会通过操作系统内核创建多个内核级线程。然后，通过这些内核级线程对应用程序线程进行调度。大多数此类线程库都可以为实际运行运行的应用程序线程动态地分配若干个内核级线程。使线程的管理工作更加复杂，需要内核和线程库的共同努力和协作才能正确、有效地进行。但是内核资源的消耗得以减少，使线程管理操作的效能提高。因实现的复杂性，往往不会被操作系统内核的开发者采纳。但可以很好地在编程语言层面上实现并发挥出其应有的作用。<code>Go的并发编程模型与两级线程模型在理念上相似</code>，具体实现方式更加高级优雅些。<code>Go的并发编程模型中</code>，不受操作系统内核管理的独立控制流并不被叫作应用程序线程或者线程，而被称为Goroutine(也可称为Go程)。</li></ul><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>同步，永远是多线程编程中最核心和重要的话题之一。为多个线程更好地协同工作或者维持共享数据的一致性，以后者为目的的同步比较常见。</p><h3 id="1-共享数据的一致性"><a href="#1-共享数据的一致性" class="headerlink" title="1.共享数据的一致性"></a>1.共享数据的一致性</h3><p>包含多个线程的程序（多线程程序）多以共享数据作为在线程之间传递数据的手段。一个进程所拥有的相当一部分虚拟内存地址都可以被该进程中的所有线程所共享，这些被共享的数据大多以内存空间作为载体。共享数据的一致性代表着某种约定，在该约定成立的前提下，多线程程序中的各个线程才能够使相应的流程被正确地执行。</p><p>临界区是只能被串行化地访问或执行的某个资源或某段代码。亦被称作串行区域。保证临界区有效的最佳方式是利用同步机制，针对多线程的同步机制有：原子操作、互斥量、条件变量。</p><h3 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h3><p>在同一时刻只允许一个线程处于临界区之内的约束被称为互斥。每一线程在进入临界区之前都必须先锁定某个对象。只有成功锁定对象的线程才会被允许进入到临界区之内，否则就会被阻塞。这个对象被称为互斥对象或互斥量。</p><p>互斥量有两种可能的状态，锁定状态和未锁定状态。每次只能被锁定一次，任何线程都不能对它进行二次加锁。成功锁定互斥量的线程成为该互斥量的所有者，只有互斥量所有者才能对该互斥量进行解锁。锁定即对互斥量的获取，解锁即对互斥量的释放。</p><p>为合理、安全使用共享数据，应把操作同一个共享数据的代码都置于一个或多个临界区之内，并使用一个互斥量对它们进行保护。互斥量必须能够被使用相应的共享资源的线程访问到，因此互斥量的变量或常量一般不是局部的。为尽量少的暴露程序的实现细节，应该在满足要求的前提下最小化互斥量的访问权限。初始化互斥量应该在任何线程真正使用它之前进行。若多个线程将要执行的代码中都包含了对同一个互斥量的初始化操作，必须保证该互斥量只会被初始化一次。互斥量对每个想要锁定它的线程都是平等的。</p><blockquote><p>对互斥量的初始化必须要保证唯一性，线程在离开临界区时候必须要及时解锁互斥量，以免造成不必要的性能损耗甚至死锁。</p></blockquote><p>在一般情况下，应该尽量少地使用互斥量。每个互斥量保护的临界区应该在合理范围内并尽量地大。若多个线程频繁地进入某个较大的临界区，并且之间经常存在访问冲突，应该把这个较大的临界区切分成若干个较小的临界区，并使用不同的互斥量加以保护。目的是让等待进入同一个临界区的线程数变少，降低线程被阻塞的几率，减少处于睡眠状态的时间。从一定程度上提高程序的整体性能。若切分后不同的互斥量保护的临界区中包含了对同一个共享资源的同一种操作，则临界区的切分是不成功的。尽量不要让不同的互斥量所保护的临界区重叠，会增加<code>死锁</code>发生的几率。</p><p>当进程中的所有线程发生死锁，进程会停滞，只能重新启动，会丢失运行时数据甚至造成各种不一致的状态。</p><p>使用操作系统提供的线程库的功能，<code>试锁定和回退</code>：在执行一个代码块的时候需要先后锁定两个互斥量，在锁定其中一个互斥量成功之后使用<code>试锁定</code>的方法锁定另一个互斥量，若<code>试锁定</code>第二个互斥量不成功，就把第一个互斥量解锁，并重新对这两个互斥量进行锁定和<code>试锁定</code>。若需要需定的互斥量有多个，则总是先锁定其中一个，再按照上述流程<code>试锁定</code>其他互斥量并在必要时进行回退。<code>试锁定</code>指操作系统的线程库提供的一个函数，会尝试对一个互斥量进行锁定，锁定失败函数直接返回一个错误码，而不是阻塞在那里。</p><p><code>固定顺序锁定</code>：需要先后对多个对个互斥量进行锁定的场景下，总以固定不变的顺序锁定它们。避免因多个线程先后对多个互斥量锁定顺序不一致，导致互相等待对方释放锁并占用对方所需而造成的死锁。</p><p>互斥量的实现会使用到机器语言级别的原子操作，并仅在锁定冲突时才会涉及系统调用的执行。互斥量比其他同步方法（例如信号灯）的速度快。</p><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><p>条件变量不保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据状态发生发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥量组合使用，互斥量为共享数据的访问提供互斥支持，条件变量可以就共享数据的状态的变化向相关线程发出通知。当线程成功锁定互斥量从而访问到共享数据的时候，共享数据的状态并不一定正好满足它的要求。</p><p>条件变量在使用之前必须创建和初始化，初始化必须要保证唯一性，在被真正使用前必须要与某个互斥量进行绑定。在一个条件变量之上进行的操作有3种：  </p><ul><li>等待通知（wait）：阻塞当前线程，直至收到该条件变量发来的通知。</li><li>单发通知（signal）：让该条件变量向至少一个正在等待它的通知的线程发送通知，以表示某个共享数据的状态已经被改变。</li><li>广播通知（broadcast）：让条件变量给正在等待它的通知的所有线程都发通知，以表示某个共享数据的状态已经改变。</li></ul><p>等待通知会先解锁与该条件变量绑定在一起的互斥量，然后再使当前线程阻塞。只有在当前的共享数据的状态不满足条件时，才执行等待通知操作，检查共享数据的状态需要受到互斥量的保护，即检查共享数据状态的操作和等待通知操作都需要再相应的临界区内进行。等待通知操作所包含的解锁互斥量的操作和阻塞当前线程的操作共同形成一个原子操作。</p><p>等待通知操作因收到条件变量发送的通知而唤醒当前线程之后，会首先重新锁定与该条件变量绑定在一起的互斥量，若互斥量已经被其他线程抢先锁定，则当前线程再次进入睡眠状态。</p><p>条件变量的通知具有即时性，通知只是负责向等待线程发送一个信号以告知共享数据的状态发生了某种变化，而不会存储相关信息。在通知被发送的时候，若没有任何线程正在等待此条件变量的通知，该通知就会被无视，不会被传到在它被发送之后才开始等待它的线程。在互斥量的保护下执行单发通知操作通常会更加安全。</p><p>广播通知的发送线程无法得知有哪些线程正在等待共享数据的当前状态，不会知道在执行单发通知操作之后哪一个线程会接收到该通知，发送线程只执行广播通知操作以向所有的等待线程告知共享数据的状态已发生变化，不会关心哪些等待线程会对这一状态变化进行应答。等待线程被唤醒后会重新检查共享数据的状态，并自行决定是对此作出响应还是等待下一个通知。</p><h3 id="4-线程的安全性"><a href="#4-线程的安全性" class="headerlink" title="4.线程的安全性"></a>4.线程的安全性</h3><p>若一个代码块可以被多个线程并发地执行，并总能够产生预期的结果，则该代码块就是线程安全的（thread-safe）。例如若代码块中包含了对共享数据的更新操作，则此代码块就是非线程安全的。若该代码块中的类似操作都处于临界区之中，则此代码块是线程安全的。</p><p>常被置于线程安全问题之中的代码块是函数。函数是最常用的代码块，其线程安全性有着更多的含义。使函数具有安全性的最有效的方式是使其可重入（reentrant）。若某个进程中的所有线程都可以并发地对一个函数进行调用，并且无论它们调用该函数的实际执行情况怎样，该函数都可以产生预期的结果，则该函数是可重入的。即若多个线程并发的调用该函数与它们以任意的顺序依次地调用它所产生的效果总是相同的，则该函数的可重入的。</p><p>若一个函数把共享数据的值作为其返回的结果或者包含于其返回的结果中，则该函数不是可重入函数。为使函数可重入，杜绝在函数的返回结果中含有任何共享数据，除非共享数据是完全不可被更新的。任何内含了对共享数据进行操作的代码的函数都可以被视为不可重入函数。</p><p>为实现线程安全的函数，可将代码置于临界区之中，但低效。应从函数体中找出操作共享数据的代码并用互斥量把它门保护起来。更好的方式是将这些代码从函数体中分离出来，有利于施加保护措施。</p><p>若代码块中仅包含共享数据的访问操作而不包含对他们的更新操作，则代码块内可以不使用互斥量。但线程需要自己维护一份其需要使用道德共享数据的副本，线程会在使用共享数据之前就把它们完全复制到当前线程的线程栈之中。对于函数，副本作为其局部变量存在。某个线程对某个函数的第一次调用会致使该i函数中的局部变量陆续被创建在该线程的线程栈中。在不同线程的线程栈中，因调用相同的函数而被创建的同名局部变量之间是完全独立的，并且不会相互干扰。一般这样的函数是可重入的，即线程安全的。</p><h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><p>多线程在系统资源的利用和程序性能的提高方面具有优势，在某些情况（信号的处理、同时运行多套不同的程序以及包含多个需要超大内存支持的任务等），多进程编程更加合适。</p><h2 id="多核时代的并发编程"><a href="#多核时代的并发编程" class="headerlink" title="多核时代的并发编程"></a>多核时代的并发编程</h2><p>并发运行是指多个任务被同时发起运行，但是在同一时刻这些任务不一定都处于运行状态，取决于CPU核心或者CPU的数量。并行运行指在同一时刻可以有多个任务真正地同时运行，并行运行的必要条件是多CPU核心或多CPU的计算环境。并行运行的一个必要条件就是并发运行，是并发运行的一个更高级的层次。</p><p>提高并行程序的性能：  </p><ul><li>控制临界区的纯度。</li><li>控制临界区的粒度。</li><li>减少临界区中代码的执行耗时。</li><li>避免长时间持有互斥量。</li><li>优先使用原子操作而不是互斥量。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux操作系统提供以POSIX（Portable Operating System Interface of Unix）标准中定义的线程为中心的各种系统调用，最贴近POSIX线程标准的线程实现称为NPTL（Native POSIX Threads Library），已成
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="底层" scheme="bighua.top/tags/%E5%BA%95%E5%B1%82/"/>
    
      <category term="多线程" scheme="bighua.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="bighua.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
