<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2018-11-02T09:43:08.592Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty的核心组件</title>
    <link href="bighua.top/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>bighua.top/2018/11/02/Netty的核心组件/</id>
    <published>2018-11-02T06:42:46.000Z</published>
    <updated>2018-11-02T09:43:08.592Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《netty实战》，初识netty的一些笔记。</p><p>异步、事件驱动。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Java NIO的一个基本构造。</p><blockquote><p>代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。</p></blockquote><p>可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，链接或者断开连接。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>一个指向已经被提供给另一个方法的方法的引用。使得后者可以调用前者。</p><p>Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interface ChannelHandler的实现处理。</p><p>当一个新的连接已经被建立，ChannelHandler的channelActive()回调方法将会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>提供了另一种在操作完成时通知应用程序的方式。可以看作是一个异步操作的结果的占位符；将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK预置的interface java.util.concurrent.Future提供的实现只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供额外的方法，使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个Netty的出站I/O操作都将返回一个ChannelFuture，它们都不会阻塞。</p><p>ChannelFuture作为一个I/O操作的一部分返回。connect()方法将会直接返回，而不会阻塞，调用将会在后台完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"></span><br><span class="line">ChannelFuture future = Channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));</span><br></pre></td></tr></table></figure><p>利用ChannelFutureListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));异步连接到远程节点</span><br><span class="line">future.addListener(new ChannelFutureListener() &#123;//注册一个ChannelFutureListener，在操作完成时获得通知</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;//检查操作的状态</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="事件和ChannelHandler"><a href="#事件和ChannelHandler" class="headerlink" title="事件和ChannelHandler"></a>事件和ChannelHandler</h4><p>Netty使用不同的事件来通知状态的改变或者是操作的状态。能够基于已经发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据流转换；</li><li>流控制；</li><li><p>应用程序逻辑。</p><p>Netty的事件是按照它们与入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：</p></li><li><p>连接已被激活或者连接失活；</p></li><li>数据读取；</li><li>用户事件；</li><li><p>错误事件。</p><p>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：</p></li><li><p>打开或者关闭到远程节点的连接；</p></li><li><p>将数据写到或者冲刷到套接字。</p><p>每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法（将事件驱动范式直接转换为应用程序构件块）。</p><p>Netty的ChannelHandler为处理器提供了基本的抽象。每个ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="Future、回调和ChannelHandler"><a href="#Future、回调和ChannelHandler" class="headerlink" title="Future、回调和ChannelHandler"></a>Future、回调和ChannelHandler</h4><p>Netty异步编程模型建立在Future和回调之上，将事件派发到ChannelHandler的方法发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，需要提供回调或者利用操作所返回的Future。</p><h4 id="选择器、事件和EventLoop"><a href="#选择器、事件和EventLoop" class="headerlink" title="选择器、事件和EventLoop"></a>选择器、事件和EventLoop</h4><p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来将需要手动编写的派发代码。在内部，会为每个Channel分配一个EventLoop，用以处理所有事件，包括：</p><ul><li>注册感兴趣的事件；</li><li>将事件派发给ChannelHandler；</li><li>安排进一步的动作。</li></ul><p>EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。此设计消除了可能有的在ChannelHandler实现中需要进行同步的任何顾虑，只需专注于提供正确的逻辑，用来在感兴趣的数据要处理的时候执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读《netty实战》，初识netty的一些笔记。&lt;/p&gt;
&lt;p&gt;异步、事件驱动。&lt;/p&gt;
&lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Channel
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>awk语言</title>
    <link href="bighua.top/2018/10/23/awk%E8%AF%AD%E8%A8%80/"/>
    <id>bighua.top/2018/10/23/awk语言/</id>
    <published>2018-10-23T08:58:42.000Z</published>
    <updated>2018-10-30T11:56:56.988Z</updated>
    
    <content type="html"><![CDATA[<p>输入数据countries</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USSR8649    275Asia</span><br><span class="line">Canada3852    25North America</span><br><span class="line">China3705    1032Asia</span><br><span class="line">USA3615    237North America</span><br><span class="line">Brazil3286    134South America</span><br><span class="line">India1267    746Asia</span><br><span class="line">Mexico762     78North America</span><br></pre></td></tr></table></figure><h3 id="程序格式"><a href="#程序格式" class="headerlink" title="程序格式"></a>程序格式</h3><p>模式-动作语句，以及动作内的语句通常用换行符分割，但是若干条语句也可以出现在同一行，之间用分号分开。一个分号可以放在任何语句的末尾。动作的左花括号必须与其模式在同一行；剩下的部分，包括右花括号，可以出现在下面几行。</p><p>空行会被忽略；可以插入在语句之前或之后，提高程序可读性。</p><p>注释可以出现在任意一行的末尾，以井号（#）开始，换行符结束。</p><p>一条长语句可以拆分成多行，在断行处插入一个反斜杠。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="BEGIN与END"><a href="#BEGIN与END" class="headerlink" title="BEGIN与END"></a>BEGIN与END</h4><p>不匹配任何输入行。当awk从输入读取之前，BEGIN的语句开始执行；当所有输入数据读取完毕，END语句开始执行。BEGIN与END分别提供了一种控制初始化与扫尾的方式。BEGIN与END不能与其他模式作组合。若有多个BEGIN，与其关联的动作会按照在程序中出现的顺序执行，同样适用于END。通常将BEGIN放在程序开头，END放在程序结尾，非强制的。</p><p>BEGIN常见用于更改输入行被分割为字段的默认方式，分割字符由一个内建变量FS控制。默认情况下字段由空格或（和）制表符分割，此时FS的值被设置为一个空格符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; FS = &apos;\t&apos;  </span><br><span class="line">printf(&quot;%10s %6s %5s %s\n\n&quot;,</span><br><span class="line">&quot;COUNTRY&quot;, &quot;AREA&quot;, &quot;POP&quot;, &quot;CONTINENT&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#123; printf(&quot;%10s %6s %5s %s\n&quot;, $1, $2, $3, $4)</span><br><span class="line">area = area + $2</span><br><span class="line">pop = pop + $3</span><br><span class="line">&#125;</span><br><span class="line">END &#123;printf(&quot;\n%10s %6d %5d\n&quot;,&quot;TOTAL&quot;, area, pop)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入数据countries&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
      <category term="awk程序设计语言" scheme="bighua.top/categories/awk%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="awk" scheme="bighua.top/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>awk快速入门</title>
    <link href="bighua.top/2018/10/23/awk%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>bighua.top/2018/10/23/awk快速入门/</id>
    <published>2018-10-23T07:07:26.000Z</published>
    <updated>2018-10-30T11:56:56.973Z</updated>
    
    <content type="html"><![CDATA[<p>学习《awk程序设计语言》</p><p>记录一些平时没使过的小细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;$3 &gt; 0 &#123; print $1, $2, * $3 &#125;&apos; data.txt</span><br></pre></td></tr></table></figure><h3 id="awk程序结构"><a href="#awk程序结构" class="headerlink" title="awk程序结构"></a>awk程序结构</h3><p>单引号包围的部分是awk语言编写的程序，awk程序常由由一个或多个模式-动作语句组成。</p><p>某些语句中，模式可以不存在；动作及其包围它的花括号也可以不存在。经过awk检查后没有语法错误，就会每次读取一个输入行，对读取到的每一行，按顺序检查每一个模式。对每一个与当前行匹配的模式，对应的动作就会执行。一个缺失的模式匹配每一个输入行，只含有模式而没有动作的语句，会打印每一个匹配模式的输入行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern &#123; action &#125;</span><br></pre></td></tr></table></figure><p>可以在一行放置多个语句，语句之间用分号分开。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>$i表示匹配到的每行第i列（第i个字段）</p><blockquote><p>$0表示一整行</p></blockquote><p>任何表达式都可以出现在$的后面，用来指明一个字段的编号：表达式被求值，求出的值当作字段的编号。awk计算当前输入行的字段数量，并将它存储在一个内建的变量中，<code>NF</code>。</p><p>awk将到目前为止，读取到的行数数量保存在内建变量<code>NR</code>中。</p><p>可以使用<code>printf</code>语句进行格式化输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(format, value1, value2, value3, ...., valueN)</span><br></pre></td></tr></table></figure><blockquote><p><code>print &quot; &quot;</code>打印一个空行，单独的<code>print</code>打印当前行。</p></blockquote><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... &apos;... !($2 &lt; 4 &amp;&amp; $3 &lt; 20)   ...&apos;</span><br></pre></td></tr></table></figure><h3 id="BEGIN与END"><a href="#BEGIN与END" class="headerlink" title="BEGIN与END"></a>BEGIN与END</h3><p>BEGIN在第一个输入文件的第一行之前被匹配，END在最后一个输入文件的最后一行被处理之后匹配。</p><h3 id="用awk计算"><a href="#用awk计算" class="headerlink" title="用awk计算"></a>用awk计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;pay = pay + $2 * $3&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;names = name $1 &quot; &quot;&#125;</span><br><span class="line"></span><br><span class="line">END &#123;print names&#125;</span><br></pre></td></tr></table></figure><h3 id="打印最后一行"><a href="#打印最后一行" class="headerlink" title="打印最后一行"></a>打印最后一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;last = $0&#125;</span><br><span class="line">END &#123;print last&#125;</span><br></pre></td></tr></table></figure><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>求平方根、取对数、随机数等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;print $0, length($0)&#125;</span><br></pre></td></tr></table></figure><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>if-else、循环等，来源于C语言，只能用在动作里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$2 &gt; 6 &#123;n = n + 1; pay = pay + $2 * $3&#125;</span><br><span class="line"></span><br><span class="line">END &#123; if (n &gt; 0)</span><br><span class="line">print n, pay, pay / n</span><br><span class="line">else </span><br><span class="line">print &quot;no result&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">i = 1 </span><br><span class="line">while (i &lt;= $3) &#123;</span><br><span class="line">printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; for (i = 1;i &lt;= $3; i = i + 1)</span><br><span class="line">printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; line[NR] = $0 &#125;</span><br><span class="line">END &#123; i = NR </span><br><span class="line">while (i &gt; 0) &#123;</span><br><span class="line">print line[i]</span><br><span class="line">i = i - 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习《awk程序设计语言》&lt;/p&gt;
&lt;p&gt;记录一些平时没使过的小细节。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="awk程序设计语言" scheme="bighua.top/categories/awk%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="awk" scheme="bighua.top/tags/awk/"/>
    
      <category term="入门" scheme="bighua.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>web服务</title>
    <link href="bighua.top/2018/10/12/web%E6%9C%8D%E5%8A%A1/"/>
    <id>bighua.top/2018/10/12/web服务/</id>
    <published>2018-10-12T06:41:00.000Z</published>
    <updated>2018-10-30T11:56:56.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h3><blockquote><p>一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互操作机器间交互提供支持。每个web服务都拥有一套自己的接口，由一种名为Web服务描述语言的机器可处理格式描述。其他系统需要根据Web服务的描述，适用SOAP消息与Web服务交互。SOAP消息常被序列化为XML并通过HTTP传输。</p></blockquote><p>存在着多种不同类型的Web服务，其中包括基于SOAP的、基于REST的以及基于XML-RPC的，基于REST的和基于SOAP的Web服务最为流行。企业级系统大多数都是基于SOAP的Web服务实现，公开可访问的Web服务更青睐基于REST的Web服务。</p><p>基于SOAP的Web服务由功能驱动，基于REST的Web服务由数据驱动。基于SOAP的Web服务往往是RPC风格；基于REST的Web服务关注的是资源，HTTP方法是对这些资源执行操作的动词。</p><h3 id="基于SOAP的Web服务"><a href="#基于SOAP的Web服务" class="headerlink" title="基于SOAP的Web服务"></a>基于SOAP的Web服务</h3><p>SOAP（Simple Object Access Protocol：简单对象访问协议）是一种协议，用于交换定义在XML里面的结构化数据。能够跨越不同的网络协议并在不同的编程模式中使用，其处理的并不是对象，已经不再代表Simple Object Access Protocol。</p><p>SOAP高度结构化，需要严格地进行定义，用于传输数据的XML可能会变的非常复杂。WSDL是客户端与服务器之间的契约，定义了服务提供的功能以及提供这些功能的方式，服务的每个操作以及输入/输出都需要由WSDL明确地定义。</p><p>SOAP将报文内容放入到信封里面，信封相当于一个运输容器，并且它还能够独立于实际的数据传输方式存在。</p><p>经过简化的SOAP请求报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /GetComment HTTP/1.1</span><br><span class="line">Host: www.chitchatcom</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.chitchat.com/forum&quot;&gt;</span><br><span class="line">&lt;m:GetCommentRequest&gt;</span><br><span class="line">&lt;m:CommentId&gt;123&lt;/m:CommentID&gt;</span><br><span class="line">&lt;/m:GetCommentRequest&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>简化后的SOAP响应报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3/org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">&lt;m:GetCommentResponse&gt;</span><br><span class="line">&lt;m:Text&gt;Hello World!&lt;/m:Text&gt;</span><br><span class="line">&lt;/m:GetCommentResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:envelope&gt;</span><br></pre></td></tr></table></figure><p>SOAP 1.2允许通过HTTP的Get方法发送SOAP报文，但大多数基于SOAP的Web服务都是通过HTTP的POST方法发送SOAP报文的。</p><p>一个基于SOAP的Web服务越复杂，对应的WSDL报文就越冗长。实际中SOAP请求报文通常会由WSDL生成的SOAP客户端负责生成，SOAP响应报文通常也是由WSDL生成的SOAP服务器负责生成。</p><h3 id="基于REST的Web服务"><a href="#基于REST的Web服务" class="headerlink" title="基于REST的Web服务"></a>基于REST的Web服务</h3><p>REST（Representational State transfer，具象状态传输）是一种设计理念，用于设计通过标准的几个动作来操纵资源，并以此来进行互相交流的程序（将操纵资源的动作称为“动词”，即verb）。</p><p>REST并不把函数暴露为可调用的服务，而是以资源（resource）的名义把模型暴露出来，允许通过少数几个称为动词的动作来操纵这些资源。</p><p>使用HTTP协议实现REST服务，URL将用于表示资源，HTTP方法则会用作操纵资源的动词。如表所示：</p><table><thead><tr><th style="text-align:left">HTTP方法</th><th style="text-align:left">作用</th><th style="text-align:left">使用实例</th></tr></thead><tbody><tr><td style="text-align:left">POST</td><td style="text-align:left">在一项资源尚未存在的情况下创建该资源</td><td style="text-align:left">POST /users</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">获取一项资源</td><td style="text-align:left">GET /users/1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">重新给定URL上的资源</td><td style="text-align:left">PUT /users/1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除一项资源</td><td style="text-align:left">DELETE /users/1</td></tr></tbody></table><p>POST和PUT的区别在于，PUT需要准确地知道哪一项资源将会被替换，使用POST只会创建出一项新资源以及一个新的URL。POST用于创建一项全新的资源，PUT用于替换一项已经存在的资源。</p><p>REST不经只能通过这几个HTTP方法实现，如可以使用PATCH方法对一项资源进行部分更新。使用REST API的时候通常都是返回JSON，或者返回一些比SOAP报文要简单得多的XML，很少返回SOAP报文。</p><p>基于REST的Web服务也拥有相应的WADL（Web Applicaton Description Language，Web应用描述语言），可以对基于REST的Web服务进行描述，能够生成访问这些服务的客户端。</p><p>REST设计理念适用于只执行简单的CURD操作的应用，适用于更为复杂的服务可以通过如下两个方法对过程或者动作进行建模。</p><h4 id="将动作转化为资源"><a href="#将动作转化为资源" class="headerlink" title="将动作转化为资源"></a>将动作转化为资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /user/123/activation HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;data&quot;:&quot;2018-10-13T17:12:12Z&quot; &#125;</span><br></pre></td></tr></table></figure><p>将创建一个被激活的资源（activation resource），表示用户的激活状态，可以为激活的资源添加额外的属性。</p><h4 id="将动作转换为资源的属性"><a href="#将动作转换为资源的属性" class="headerlink" title="将动作转换为资源的属性"></a>将动作转换为资源的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH /user/123 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;active&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>把用户的active属性设置为true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web服务&quot;&gt;&lt;a href=&quot;#web服务&quot; class=&quot;headerlink&quot; title=&quot;web服务&quot;&gt;&lt;/a&gt;web服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="web服务" scheme="bighua.top/tags/web%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOAP" scheme="bighua.top/tags/SOAP/"/>
    
      <category term="REST" scheme="bighua.top/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>jenkins初探</title>
    <link href="bighua.top/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/"/>
    <id>bighua.top/2018/10/08/jenkins初探/</id>
    <published>2018-10-08T11:33:45.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档<a href="https://www.kancloud.cn/louis1986/jenkins/481896" target="_blank" rel="noopener">Jenkins学习文档</a>，<a href="https://blog.csdn.net/sms15732621690/article/details/71336224" target="_blank" rel="noopener">CentOS7Jenkins安装</a></p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget http://soft.51yuki.cn/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo vim /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_131/</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib.tools.jar</span><br><span class="line">PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  sudo sh /etc/profile.d/jdk.sh</span><br><span class="line">[wuhua@VM_0_10_centos local]$ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>浏览器中输入<code>ip:8080</code></p><p>获取登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>参考<a href="https://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文档&lt;a href=&quot;https://www.kancloud.cn/louis1986/jenkins/481896&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins学习文档&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="持续集成" scheme="bighua.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="jenkins" scheme="bighua.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>redis-整数集合</title>
    <link href="bighua.top/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>bighua.top/2018/09/13/redis-整数集合/</id>
    <published>2018-09-13T13:42:03.000Z</published>
    <updated>2018-10-30T11:56:56.983Z</updated>
    
    <content type="html"><![CDATA[<p>是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>是redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>由intset.h/intset结构表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">unint32_t encoding;//编码方式</span><br><span class="line">unint32_t length;//集合包含的元素数量</span><br><span class="line">int8_t contents[];//保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，数组中各项按值从小到大排列，且数组中不包含重复项。</p><p>length属性记录整数集合包含的元素数量，即contents数组的长度。</p><p>contents数组的真正类型取决于encoding属性的值。</p><p>根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>将新元素添加到整数集合里面且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后将新元素添加到整数集合里面。</p><p>升级过程：</p><ul><li>根据新元素的类型，拓展整数集合底层数组的空间大小，并未新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置上，在放置的过程中维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组中。</li></ul><p>引发升级的新元素的长度总是比整数集合现在所有元素的长度都大，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。前者将新元素放置在底层数组的最开头（索引0），后者将新元素放置在底层数组的最末尾（索引length-1）。</p><blockquote><p>升级策略能提升整数集合的灵活性，尽可能地节约内存。</p></blockquote><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><p>整数集合操作API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">intsetNew</td><td style="text-align:left">创建一个新的压缩列表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetAdd</td><td style="text-align:left">将给定元素添加到整数集合里</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetRemove</td><td style="text-align:left">从整数集合中移除给定元素</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetFind</td><td style="text-align:left">检查给定值是否存在于集合</td><td style="text-align:left">O(logN)，二分查找法</td></tr><tr><td style="text-align:left">intsetRandom</td><td style="text-align:left">从整数集合中随机返回一个元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetGet</td><td style="text-align:left">取出底层数组在给定索引上的元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetLen</td><td style="text-align:left">返回整数集合包含的元素的个数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetBlobLen</td><td style="text-align:left">返回整数集合占用的内存字节数</td><td style="text-align:left">O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="intset" scheme="bighua.top/tags/intset/"/>
    
  </entry>
  
  <entry>
    <title>redis-跳跃表</title>
    <link href="bighua.top/2018/09/12/redis-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>bighua.top/2018/09/12/redis-跳跃表/</id>
    <published>2018-09-12T13:37:34.000Z</published>
    <updated>2018-10-30T11:56:56.973Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。支持平均O(logN)，最坏O(N)复杂度的节点查找。可以通过顺序性操作来批量处理节点。</p><p>redis使用跳跃表作为有序集合键的底层实现之一，若有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>redis只在实现有序集合键和在集群节点用作内部数据结构用到跳跃表。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，前者用于表示跳跃表节点，后者用于保存跳跃表节点的相关信息，例如节点的数量、指向表头节点和表尾节点的指针等。</p><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>由redis.h/zskiplistNode结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">struct zskiplistLevel &#123;</span><br><span class="line">struct zskiplistNode *forward;//前进指针</span><br><span class="line">unsigned int span;//跨度</span><br><span class="line">&#125; level[];//层</span><br><span class="line">struct zskiplistNode *backward;//后退指针</span><br><span class="line">double score;//分值</span><br><span class="line">robj *obj;//成员对象</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ul><li>level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，可通过这些层加快访问其他节点的速度，一般层数量越多访问其他节点的速度越快。每创建一个新跳跃表节点的时候，程序根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小，即层的高度。</li><li>每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。</li><li>跨度用于记录两个节点之间的距离，跨度越大，节点间距离越远，指向NULL的所有前进指针的跨度都为0。实际上用来计算排位（rank），在查找某个节点的过程中，将沿途访问过的所有层的跨度累计，得到的结果就是目标节点在跳跃表中的排位。</li><li>后退指针用于从表尾向表头方向访问节点，每个节点中有一个后退节点，每次只能后退至前一个节点。</li><li>分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序，成员对象是一个指针，指向一个字符串对象，字符串对象则保存着一个SDS值。同一跳跃表中，各个节点保存的成员对象必须是唯一的，多个节点保存的分值可以相同：分值相同的节点按照成员对象在字典序中的大小进行排序，成员对象较小的节点排在前面。</li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>由redis.h/zskiplist结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">struct zskiplistNode *header, *tail;//表头节点和表尾节点</span><br><span class="line">unsigned long length;//表中节点的数量</span><br><span class="line">int level;//表中层数最大节点的层数</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h3 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h3><p>跳跃表的所有操作API:</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">zslCreate</td><td style="text-align:left">创建一个新的跳跃表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">zslFree</td><td style="text-align:left">释放给定跳跃表以及表中包含的所有节点</td><td style="text-align:left">O(N)，N为跳跃表的长度</td></tr><tr><td style="text-align:left">zslInsert</td><td style="text-align:left">将包含给定成员和分值的新节点添加到跳跃表中</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDelete</td><td style="text-align:left">删除跳跃表中包含给定成员和分值的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetRank</td><td style="text-align:left">返回包含给定成员和分值的节点在跳跃表中的排位</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetElementByRank</td><td style="text-align:left">返回跳跃表在给定排位上的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslIsInRange</td><td style="text-align:left">判断跳跃表中是否有节点的分值在给定分值范围内</td><td style="text-align:left">O(1）</td></tr><tr><td style="text-align:left">zslFirstInrange</td><td style="text-align:left">返回跳跃表中第一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslLastInrange</td><td style="text-align:left">返回跳跃表中最后一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDeleteRangeByScore</td><td style="text-align:left">删除跳跃表中所有在给定分值范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr><tr><td style="text-align:left">zslDeleteRangeByRank</td><td style="text-align:left">删除跳跃表中所有在给定排位范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。支持平均O(logN)，最坏O(N)复杂度的节点查找。可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt;redis使用跳跃表作为有序集合键的底层实现之一，若有序集合包含的元素数量
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="skiplist" scheme="bighua.top/tags/skiplist/"/>
    
  </entry>
  
  <entry>
    <title>redis-字典</title>
    <link href="bighua.top/2018/09/10/redis-%E5%AD%97%E5%85%B8/"/>
    <id>bighua.top/2018/09/10/redis-字典/</id>
    <published>2018-09-10T13:30:23.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>又称符号表、关联数组或映射，一种用于保存键值对的抽象数据结构。</p><p>一个键可以和一个值进行关联，字典中的每个键都是独一无二的，通过键查找与之关联的值、更新值或删除整个键值对。</p><p>redis构建了自己的字典实现，redis数据库使用字典作为底层实现，对数据库的增、删、改、查操作也是构建在对字典的操作之上。字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>redis字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>由dict.h/dictht结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;//哈希表数组</span><br><span class="line">unsigned long size;//哈希表大小</span><br><span class="line">unsigned long sizemask;//哈希表大小掩码，用于计算索引值，等于size-1</span><br><span class="line">unsigned long used;//该哈希表已有节点的数量</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。</p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">void *key;//键</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v; //值</span><br><span class="line">struct dictEntry *next;//指向下个哈希表节点，形成链表</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>next属性是一个指向哈希表节点的指针，可以将多个哈希表值相同的键值对链接在一起，以此来解决键冲突的问题。</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>由dict.h/dict结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">dictType *type;//类型特定函数</span><br><span class="line">void *privdata;//私有数据</span><br><span class="line">dictht ht[2];//哈希表</span><br><span class="line">int rehashidx;//rehash索引，当rehash不再进行时，值为-1  </span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">unsigned int (*hashFunction)(const void *key);//计算哈希值的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);//复制键的函数</span><br><span class="line">void *(*valDup)(void *privdata, const void *key);//复制值的函数</span><br><span class="line">int (*keyCompare)(void *privdata, const void *key1, const void *key2);对比键的函数</span><br><span class="line">void (*keyDestructor)(void *privdata, void *key);//销毁键的函数</span><br><span class="line">void (*valDestructor)(void *privdata, void *obj);//销毁值的函数</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p><p>rehashidx属性记录rehash目前的进度，若没有在进行rehash，则值为-1。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>redis计算哈希值和索引值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">//使用哈希表的sizemask属性和哈希值，计算出索引值</span><br><span class="line">//ht[x]根据情况选择ht[0]和ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算哈希值。</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量键被分配到了哈希数组的同一个索引上面时，称这些键发生了冲突。</p><p>redis的哈希表使用链表链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以使用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单项链表连接起来，解决键冲突问题。速度考虑，程序总是将新节点添加到链表的表头位置，排在其他已有节点的前面。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>为让哈希表的负载因子维持在一个合理的范围之内，哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的拓展或者收缩，通过执行rehash（重新散列）操作来完成。步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，哈希表的空间的大小取决于要执行的操作，以及ht[0]当前包含的键值对数量。</li><li>若执行的是扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2^n;<br>若执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。<br>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash重新计算键的哈希值和索引，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]表变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash作准备。</li></ol><p><code>哈希表的拓展和收缩</code>：</p><blockquote><p>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。<br>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。<br>哈希表的负载因子计算公式：<br> 负载因子 = 哈希表已保存节点数量 / ht[0].size<br> load_factor = ht[0].used / ht[0].size</p></blockquote><p>根据BGSAVE命令和BGREWRITEAOF命令是否正在执行，服务器执行拓展操作所需的负载因子并不相同。在执行BGSAVE命令或者BGREWRITEAOF命令的过程中，redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，在子进程存在期间，服务器会提高执行拓展操作所需的负载因子，尽可能地避免在子进程存在期间进行哈希表拓展操作，避免不必要的内存写入操作，节约内存。</p><p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，为避免数据量过大rehash对服务器性能造成影响，rehash动作是分多次、渐进式地完成的，当数据量过大时将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，避免了集中式rehash而带来的庞大计算量。</p><p>哈希表渐进式rehash的步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已经完成。</li></ol><p>在渐进式rehash执行期间，字典的删除、查找、更新等操作会在两个哈希表上进行，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何操作。</p><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><p>字典的主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">dictCreate</td><td style="text-align:left">创建一个新的字典</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictAdd</td><td style="text-align:left">将给定的键值对添加到字典里面</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictReplace</td><td style="text-align:left">将给定的键值对添加到字典里面，如果键已经存在于字典，用新值取代原有的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictFetchValue</td><td style="text-align:left">返回给定键的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictGetRandomKey</td><td style="text-align:left">从字典中随机返回一个键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictDelete</td><td style="text-align:left">从字典中删除给定键所对应键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictRelease</td><td style="text-align:left">释放给定字典，以及字典中包含的所有键值对</td><td style="text-align:left">O(N)，N为字典包含的键值对数量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又称符号表、关联数组或映射，一种用于保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;一个键可以和一个值进行关联，字典中的每个键都是独一无二的，通过键查找与之关联的值、更新值或删除整个键值对。&lt;/p&gt;
&lt;p&gt;redis构建了自己的字典实现，redis数据库使用字典作为底层实现，对数
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="dict" scheme="bighua.top/tags/dict/"/>
    
      <category term="字典" scheme="bighua.top/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>redis-链表</title>
    <link href="bighua.top/2018/09/09/redis-%E9%93%BE%E8%A1%A8/"/>
    <id>bighua.top/2018/09/09/redis-链表/</id>
    <published>2018-09-09T13:24:28.000Z</published>
    <updated>2018-10-30T11:56:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>redis构建了自己的链表实现。</p><p>列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。</p><p>除链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，redis服务器本身还使用链表来保存多个客户端的状态信息，使用链表来构建客户端输出缓冲区。</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>链表节点由adlist.h/listNode结构来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">struct listNode *prev;//前置节点</span><br><span class="line">struct listNode *next;//后置节点</span><br><span class="line">void *value;//节点的值</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p><p>使用多个listNode结构可组成链表，使用adlist.h/list来持有链表，操作起来更方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">listNode *head;//表头节点</span><br><span class="line">listNode *tail;//表尾节点</span><br><span class="line">unsigned long len;//链表所包含的节点的数量</span><br><span class="line">void *(*dup)(void *ptr);//节点值复制函数</span><br><span class="line">void *(*free)(void *ptr);//节点值释放函数</span><br><span class="line">int (*match)(void *ptr, void *key);//节点值对比函数</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>提供了表头指针head，表尾指针tail，链表长度计数器len，dup、free和match用于实现多态链表所需的类型特定函。</p><p>redis链表实现的特性：</p><ul><li>双端。</li><li>无环。</li><li>带表头指针和表尾指针。</li><li>带链表长度计数器。</li><li>多态：链表节点使用void*指针来保存节点值，可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，链表可用于保存各种不同类型的值。</li></ul><h3 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h3><p>链表和链表节点的API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数</td><td style="text-align:left">O(1)，可通过链表的dup属性直接获得</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数</td><td style="text-align:left">O(1)，可通过链表的free属性直接获得</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）</td><td style="text-align:left">O(1)，链表的len属性</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点</td><td style="text-align:left">O(1)，链表的head属性</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表为节点</td><td style="text-align:left">O(1)，链表的tail属性</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点</td><td style="text-align:left">O(1)，节点的prev属性</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点</td><td style="text-align:left">O(1)，节点的next属性</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值</td><td style="text-align:left">O(1)，节点的value属性</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，成为新的表头节点</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis构建了自己的链表实现。&lt;/p&gt;
&lt;p&gt;列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。&lt;/p&gt;
&lt;p&gt;除链表键之外，发布与订阅、慢查询、监视器等功能也用到了链
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="链表" scheme="bighua.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis-简单动态字符串</title>
    <link href="bighua.top/2018/09/08/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>bighua.top/2018/09/08/redis-简单动态字符串/</id>
    <published>2018-09-08T13:16:08.000Z</published>
    <updated>2018-10-30T11:56:56.986Z</updated>
    
    <content type="html"><![CDATA[<p>redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush fruits &quot;banana&quot; &quot;apple&quot; &quot;cheery&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>redis在数据库中创建一个新的键值对，其中：</p><ul><li>键是一个字符串对象，对象底层的实现是一个保存了字符串“fruits”的SDS。</li><li>值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，分别保存着字符串“banana”、“apple”、“cheery”。  </li></ul><p>SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>sds.h/sdshdr:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">int len; //buf数组中已使用字节的数量、SDS所保存字符串的长度</span><br><span class="line">int free; //buf数组中未使用字节的数量</span><br><span class="line">char buf[]; //字节数组，用于保存字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，为其分配额外的一字节空间和添加空字符到字符串末尾等操作都由SDS函数自动完成。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><p>C语言使用长度为N+1的字符数组表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。但不能满足redis对字符串安全性、效率以及功能方面的要求。</p><h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>C字符串需遍历整个字符串对字符进行计数，复杂度为O(N)，redis直接返回SDS的len属性值，复杂度O(1)。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>C字符串不记录自身长度容易造成缓冲区溢出（buffer overflow），改写其后缓冲区的内容。</p><p>SDS的空间分配策略杜绝发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，若不满足，API会自动将SDS的空间拓展至执行修改所需的大小，然后才执行修改操作。</p><h4 id="减少修改字符串时带来的内存冲分配次数"><a href="#减少修改字符串时带来的内存冲分配次数" class="headerlink" title="减少修改字符串时带来的内存冲分配次数"></a>减少修改字符串时带来的内存冲分配次数</h4><p>每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>若程序执行的是增长字符串的操作，例如拼接操作（append），执行操作之前，程序需要先通过内存重分配来拓展底层数组的空间大小——忽略此步会产生缓冲区溢出。</li><li>若程序执行的是缩短字符串的操作，例如截断操作（tirm），在执行操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——忽略会产生内存泄漏。</li></ul><p>内存重分配涉及复杂的算法，可能需要执行系统调用，通常是比较耗时的操作：</p><ul><li>一般程序中，若修改字符串长度的情况不太常出现，每次修改都执行一次内存重分配是可接受的。</li><li>redis经常用于速度要求严苛、数据被频繁修改的场合，执行内存重分配会占去修改字符串所用时间的一大部分，频繁操作影响性能。</li></ul><p>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量加一，可以包含未使用字节。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必需要的空间，还会为SDS分配额外的未使用空间，可以使redis减少连续执行字符串增长操作所需的内存重分配次数。</p><p>分配未使用空间数量：</p><ul><li>若修改之后SDS的长度小于1M，程序分配和len属性同样大小的未使用空间，SDS的len属性值将和free属性的值相同，总长度=len+free+1byte（额外的一字节用于保存空字符）。</li><li>若修改之后SDS的长度大于等于1M，程序会分配1M的未使用空间，即free=1，总长度=len+1M+1byte。</li></ul><p>拓展SDS空间之前，SDS API会先检查未使用空间是否足够，若足够，API就会直接使用未分配空间，无需执行内存重分配。</p><h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><p>SDS提供了相关的API，可以在有需要的时候，真正地释放SDS的未使用空间，不必担心惰性空间释放策略会造成内存浪费。</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C字符串中的字符必须符合某种编码（ASCII），且除字符串末尾外，字符串里面不能包含空字符。限制C字符串只能保存文本数据，而不能保存图像、音频、视频、压缩文件这样的二进制数据。</p><p>为确保redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样子，被读取时就是什么样子。</p><p>redis不是使用buf字节数组保存字符，而是保存一系列二进制数据。SDS使用len属性的值而不是空字符来判断字符串是否结束。</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>SDS的API是二进制安全的，但一样遵循C字符串以空字符结尾的惯例：这些API会将SDS保存的数据的末尾设置为空字符，并且会在为buf数组分配空间时多分配一个字节来容纳这个空字符，为了让保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数，避免了不必要的代码重复。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>C字符串和SDS之间的区别：</p><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(n)</td><td style="text-align:left">获取字符串长度的复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API是安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td style="text-align:left">只能保存文本数据</td><td style="text-align:left">可以保存文本或者二进制数据</td></tr><tr><td style="text-align:left">可以使用所有&lt;string.h&gt;库中的函数</td><td style="text-align:left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>SDS主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">sdsnew</td><td style="text-align:left">创建一个包含给定C字符串的SDS</td><td style="text-align:left">O(N)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdsempty</td><td style="text-align:left">创建一个不包含任何内容的空SDS</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">sdsfree</td><td style="text-align:left">释放给定的SDS</td><td style="text-align:left">O(N)，N为被释放SDS的长度</td></tr><tr><td style="text-align:left">sdslen</td><td style="text-align:left">返回SDS的已使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的len属性</td></tr><tr><td style="text-align:left">sdsavail</td><td style="text-align:left">返回SDS的未使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的free属性</td></tr><tr><td style="text-align:left">sdsdup</td><td style="text-align:left">创建一个给定SDS的副本（copy）</td><td style="text-align:left">O(N)，N为给定SDS的长度</td></tr><tr><td style="text-align:left">sdsclear</td><td style="text-align:left">清空SDS保存的字符串内容</td><td style="text-align:left">O(1)，惰性空间释放策略</td></tr><tr><td style="text-align:left">sdscat</td><td style="text-align:left">将给定字符串拼接到SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接的字符串的长度</td></tr><tr><td style="text-align:left">sdscatsds</td><td style="text-align:left">将给定SDS字符串拼接到另一个SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接SDS字符串的长度</td></tr><tr><td style="text-align:left">sdscpy</td><td style="text-align:left">将给定C字符串复制到SDS里面，覆盖SDS原有的字符串</td><td style="text-align:left">O(N)，N为被复制C字符串的长度</td></tr><tr><td style="text-align:left">sdsgrowzero</td><td style="text-align:left">用空字符串将SDS拓展至给定长度</td><td style="text-align:left">O(N)，N为拓展新增的字节数</td></tr><tr><td style="text-align:left">sdsrange</td><td style="text-align:left">保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除</td><td style="text-align:left">O(N)，N为被保留数据的字节数</td></tr><tr><td style="text-align:left">sdstrim</td><td style="text-align:left">接受一个SDS和C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符</td><td style="text-align:left">O(N^2)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdscmp</td><td style="text-align:left">对比两个SDS字符串是否相同</td><td style="text-align:left">O(N)，N为两个SDS中较短的那个SDS的长度</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="sds" scheme="bighua.top/tags/sds/"/>
    
  </entry>
  
  <entry>
    <title>Go模板引擎</title>
    <link href="bighua.top/2018/08/24/Go%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2018/08/24/Go模板引擎/</id>
    <published>2018-08-24T13:01:29.000Z</published>
    <updated>2018-10-30T11:56:56.980Z</updated>
    
    <content type="html"><![CDATA[<p>Go标准库text/template、html/template。</p><hr><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>可以把模板引擎划分为两种理想的类型：</p><ul><li>无逻辑模板引擎（logic-less template engine）——将模板中指定的占位符替换成相应的动态数据。只进行字符串替换，不执行任何逻辑处理。目的是完全分离程序的表现和逻辑，并将所有计算方面的工作都交给处理器完成。</li><li>嵌入逻辑的模板引擎（embedded logic template engine）——将编程语言代码嵌入模板当中，并在模板引擎渲染时，由模板引擎执行这些代码并进行相应的字符串替换工作。</li></ul><p>无逻辑模板引擎的渲染速度往往会更快一些。</p><h3 id="Go的模板引擎"><a href="#Go的模板引擎" class="headerlink" title="Go的模板引擎"></a>Go的模板引擎</h3><p>Go语言的模板引擎介于无逻辑模板引擎和嵌入逻辑模板引擎之间，由处理器负责触发。</p><p>Go的通用模板引擎库text/template可以处理任意格式的文本，模板引擎库html/template专门处理HTML格式。模板中的动作默认使用两个大括号<code>{</code>和<code>}</code>包围，也可以通过模板引擎提供的方法自行指定其他定界符（delimiter）。</p><p>使用Go的Web模板引擎需要的步骤：</p><ul><li>对文本格式的模板源进行语法分析，创建一个经过语法分析的模板结构，模板源既可以是一个字符串，也可以是模板文件中包含的内容。</li><li>执行经过语法分析的模板，将ResponseWriter和模板所需的动态数据传递给模板引擎，被调用的模板引擎会把经过语法分析的模板和传入的数据结合起来，生成最终的HTML传递给ResponseWriter。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, &quot;Hello World!)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></li></ul><h4 id="对模板进行语法分析"><a href="#对模板进行语法分析" class="headerlink" title="对模板进行语法分析"></a>对模板进行语法分析</h4><p>ParseFiles是一个独立的函数，可以对模板文件进行语法分析，并创建出一个经过语法分析的模板结构以供Execute方法执行。</p><blockquote><p>调用ParseFiles函数的时候，Go会创建出一个新的模板，并将用户给定的模板文件的名字用作这个新模板的名字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := template.New(&quot;tmpl.html&quot;)</span><br><span class="line">t, _ := t.ParseFiles(&quot;tmpl.html&quot;)</span><br></pre></td></tr></table></figure><p>ParseFiles函数和Template结构的ParseFiles方法都可以接受一个或多个文件名作为参数，但只返回一个模板。返回用户传入的第一个文件的已分析模板，模板也会根据用户传入的第一个文件的名字进行命名，其他传入文件的已分析模板会被放置到一个映射里面，可以在之后执行模板时使用。</p><blockquote><p>即，向ParseFiles传入单个文件时，ParseFiles返回的是一个模板，向ParseFiles传入多个文件时，ParseFiles返回的是一个模板集合。</p></blockquote><p>使用ParseGlob函数对模板文件进行语法分析，会对匹配给定模式的所有文件进行语法分析。</p><p>实际上，所有对模板进行语法分析的手段最终都需要调用Parse方法来执行实际的语法分析操作。</p><p>专门用于处理分析模板时出现的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := template.Must(template.ParseFiles(&quot;tmpl.html&quot;))</span><br></pre></td></tr></table></figure><p>Must函数可以包裹起一个函数，被包裹的函数会返回一个指向模板的指针和一个错误，若错误不是nil，Must函数将产生一个panic。</p><h4 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h4><p>常用方法调用模板的Execute方法，并向它传递ResponseWriter以及模板所需的数据。若对模板集合调用Execute方法，只会执行模板集合中的第一个模板。使用ExecuteTemplate方法执行其他模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;)</span><br><span class="line"></span><br><span class="line">t.Execute(w, &quot;hello world!&quot;)</span><br><span class="line"></span><br><span class="line">t.ExecuteTemplate(w, &quot;t2.html&quot;, &quot;Hello World!&quot;)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作即嵌入在模板里面的命令，使用两个大括号{和}进行包围。</p><p>主要有动作：</p><ul><li>条件动作；</li><li>迭代动作；</li><li>设置动作；</li><li>包含动作。</li></ul><p>还有<code>定义动作</code>，（ . ）也是一个动作，代表的是传递给模板的数据，其他动作和函数基本上都会对这个动作进行处理，达到格式化和内容展示的目的。</p><h4 id="条件动作"><a href="#条件动作" class="headerlink" title="条件动作"></a>条件动作</h4><p>根据参数的值决定对多条语句中的哪一条语句进行求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line"></span><br><span class="line">some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="迭代动作"><a href="#迭代动作" class="headerlink" title="迭代动作"></a>迭代动作</h4><p>迭代动作可以对数组、切片、映射或者通道进行迭代，在迭代循环的内部点(.)会被设置为当前被迭代的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range . &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content to show</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="设置动作"><a href="#设置动作" class="headerlink" title="设置动作"></a>设置动作</h4><p>允许用户在指定的范围之内为点<code>(.)</code>设置值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;the dot is already set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;Dot is set to arg</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">Fallback if arg is empty</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="包含动作"><a href="#包含动作" class="headerlink" title="包含动作"></a>包含动作</h4><p>允需用户在一个模板里面包含另一个模板，从而构建出嵌套的模板。包含动作的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template &quot;name&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p>name参数为被包含模板的名字。</p><h3 id="参数、变量和管道"><a href="#参数、变量和管道" class="headerlink" title="参数、变量和管道"></a>参数、变量和管道</h3><p>参数即模板中的值，可以是布尔值、整数、字符串等字面量，也可以是结构、结构中的一个字段或者数组中的一个键。还可以是一个变量、一个方法（该方法必须只返回一个值、或只返回一个值和一个错误）或者一个函数。参数也可以是一个点(.)，用于表示处理器向模板引擎传递的数据。</p><p>除参数外，可在工作中设置以美元符号开头的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或者使用管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; 12.3456 | printf &quot;%.2f&quot; &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go的模板引擎函数都是受限制的：函数可以接受任意多个参数作为输入，但是只能返回一个值，或者返回一个值和一个错误。</p><p>创建自定义模板函数：</p><ul><li>创建一个名为FuncMap的映射，将映射的键设置为函数的名字，映射的值设置为实际定义的函数；</li><li>将FuncMap与模板进行绑定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func formatDate(t time.Time) string &#123;</span><br><span class="line">layout := &quot;2006-01-02&quot;</span><br><span class="line">return t.Format(layout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">funcMap := template.FuncMap&#123; &quot;fdate&quot;: formatDate &#125;</span><br><span class="line">t := template.New(&quot;tmpl.html&quot;).Funcs(funcMap)</span><br><span class="line">t, _ = t.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>模板中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;The Date/Time is &#123;&#123; . | fdate &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>又或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;the Date/Time is &#123;&#123; fdate . &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>使用管道将一个函数的输出传递给另一个函数作为输入，使代码更简单易读。</p><h3 id="上下文感知"><a href="#上下文感知" class="headerlink" title="上下文感知"></a>上下文感知</h3><p>Go的模板引擎可以根据内容所处的上下文改变其显示的内容。根据内容在模板中所处的位置，模板在显示这些内容的时候将对其进行相应的修改。可对被显示的内容实施正确的转义（escape）：模板现实的是HTML格式的内容，模板对其实施HTML转义；显示的是JavaScript格式的内容，对其实施JavaScript转义。还可以识别出内容中的URl或者CSS样式。</p><p>主要用于实现自动的防御编程，防止某些明显并且低级的编程错误。</p><h3 id="防御XSS攻击"><a href="#防御XSS攻击" class="headerlink" title="防御XSS攻击"></a>防御XSS攻击</h3><p>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致。</p><p>通过模板引擎在显示用户输入时将其转换为转义之后的HTML，避免可能会出现的问题。</p><h3 id="不对HTML进行转义"><a href="#不对HTML进行转义" class="headerlink" title="不对HTML进行转义"></a>不对HTML进行转义</h3><p>使用“不转义代码机制”允许用户输入HTML代码或者JavaScript代码，并在显示内容时执行这些代码。</p><p>将不想被转义的内容传给template.HTML函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;comment)))</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>程序通过类型转换（typecast）将表单中的评价值转换成template.HTML类型。</p><blockquote><p>可通过发送一个最初由微软公司为IE浏览器创建的特殊HTTP响应首部X-XSS-Protection让浏览器关闭内置的XSS防御功能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func process (w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">w.Header().Set(&quot;X-XSS-Protection&quot;, &quot;0&quot;)</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html&quot;)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;content)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套模版"><a href="#嵌套模版" class="headerlink" title="嵌套模版"></a>嵌套模版</h3><p>布局指Web设计中可以重复应用在多个页面上的固定模式。</p><p>通过包含动作，在一个模版里面包含另一个模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; template &quot;name&quot; . &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>动作参数name为被包含的模板名字，是一个字符串常量。每个页面都拥有它们各自的布局模版文件，程序最终无法拥有任何可共用的公共布局。</p><p>可通过定义动作（define action），在模板文件里面显示地定义模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>在一个模板文件里定义多个不同模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">Hello World!</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>使用显示定义模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w, http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>可在不同的模板文件里面定义同名的模板（red_hello.html，blue_hello.html）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content&quot; &#125;&#125;</span><br><span class="line">&lt;h1 style= &quot;color: red;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt; hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用在不同模板文件中定义的同名模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *template.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red_hello.html&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layput.html&quot;, &quot;blue_hello.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.Execute(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>通过块动作定义默认模板<br>块动作（block action）允许用户定义一个模板并且立即使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>改进上方逻辑，默认展示蓝色else只对layout.html进行语法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *tempale.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="通过块动作添加默认的content模版"><a href="#通过块动作添加默认的content模版" class="headerlink" title="通过块动作添加默认的content模版"></a>通过块动作添加默认的content模版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">···</span><br><span class="line">&#123;&#123; block &quot;content&quot; . &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>块动作定义的content模板，当layout模板被执行时，若模板引擎没找到可用的content模板，就会使用块动作中定义的content模板。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go标准库text/template、html/template。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;模板引擎&quot;&gt;&lt;a href=&quot;#模板引擎&quot; class=&quot;headerlink&quot; title=&quot;模板引擎&quot;&gt;&lt;/a&gt;模板引擎&lt;/h3&gt;&lt;p&gt;可以把模板引擎划分为两种理想的类
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Go模板库" scheme="bighua.top/tags/Go%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    
      <category term="模板引擎" scheme="bighua.top/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Go与Cookie</title>
    <link href="bighua.top/2018/08/23/Go%E4%B8%8ECookie/"/>
    <id>bighua.top/2018/08/23/Go与Cookie/</id>
    <published>2018-08-23T12:57:26.000Z</published>
    <updated>2018-10-30T11:56:56.979Z</updated>
    
    <content type="html"><![CDATA[<p>大多数cookie都可以被划分为会话cookie和持久cookie两种类型。</p><hr><h3 id="Go与cookie"><a href="#Go与cookie" class="headerlink" title="Go与cookie"></a>Go与cookie</h3><p>cookie在Go语言中用Cookie结构表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Cookie struct &#123;</span><br><span class="line">Namestring</span><br><span class="line">Valuestring</span><br><span class="line">Pathstring</span><br><span class="line">Domainstring</span><br><span class="line">Expirestime.Time</span><br><span class="line">RawExpiresstring</span><br><span class="line">MaxAgeint</span><br><span class="line">Securebool</span><br><span class="line">HttpOnlybool</span><br><span class="line">Rawstring</span><br><span class="line">Unparsed[]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有设置Expires字段的cookie通常称为会话cookie或者临时cookie，这种cookie在浏览器关闭的时候就会自动被移除。设置了Expires字段的cookie通常称为持久cookie，这种cookie会一直存在，直到指定的过期时间来临或者被手动删除为止。</p><p>Expires字段和MaxAge字段都可以设置cookie的过期时间，Expires字段用于明确地指定cookie应该在什么时候过期，MaxAge字段指明cookie在被浏览器创建出来之后能够存活多少秒。</p><p>为使cookie在所有浏览器上都能够正常运行，只使用Expires，或者同时使用Expires和MaxAge。</p><h3 id="将cookie发送至浏览器"><a href="#将cookie发送至浏览器" class="headerlink" title="将cookie发送至浏览器"></a>将cookie发送至浏览器</h3><p>Cookie结构的String方法可以返回一个经过序列化处理的cookie，其中Set-Cookie响应首部的值即为这些序列化之后的cookie组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">w.Header().Set(&quot;Set-Cookie&quot;, c1.String())</span><br><span class="line">w.Header().Add(&quot;Set-Cookie&quot;, c2.String())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>除Set方法和Add方法外，还可使用net/http库中的SetCookie方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c1)</span><br><span class="line">http.SetCookie(w, &amp;c2)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用SetCookie方法设置cookie，传递给方法的是指向Cookie的指针而不是Cookie结构本身。</p><h3 id="从浏览器获取cookie"><a href="#从浏览器获取cookie" class="headerlink" title="从浏览器获取cookie"></a>从浏览器获取cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">h := r.Header[&apos;Cookie&apos;]</span><br><span class="line">fmt.Fprintln(w, h)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>语句<code>r.Header[&quot;Cookie&quot;]</code>返回一个切片，切片包含一个字符串，字符串包含了客户端发送的任意多个cookie。取得单独的键值对格式的cookie，需要对r.Header[“Cookie”]返回的字符串进行语法分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1, err := r.Cookie(&quot;first_cookie&quot;);</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;Cannot get the first cookie&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cs := r.Cookies()</span><br><span class="line">fmt.Fprintln(w, c1)</span><br><span class="line">fmt.Fprintln(w, cs)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用Request结构的Cookie方法获取指定名字的cookie，若指定的cookie不存在，则方法返回一个错误。使用Cookies方法获取多个cookie，返回一个包含了所有cookie的切片。</p><p>上方未设置cookie的过期时间，为会话cookie，完全退出浏览器并重启这些cookie会消失。</p><h3 id="使用cookie实现闪现消息"><a href="#使用cookie实现闪现消息" class="headerlink" title="使用cookie实现闪现消息"></a>使用cookie实现闪现消息</h3><p>实现闪现消息的常用方法是将这些消息存储在页面刷新时就会被移除的会话cookie里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setMessage(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">msg := []byte(&quot;Hello World!)</span><br><span class="line">c := http.Cookie&#123;</span><br><span class="line">Name:&quot;flash&quot;,</span><br><span class="line">Value:base64.URLEncoding.EncodeToString(msg),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>设置cookie时，如果cookie的值没有包含诸如空格或者百分号这样的特设字符，可不对它进行编码；由于消息本身通常包含此类字符，需要使用Base64URL编码，以此来满足响应首部对cookie值的URL编码要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func showMessage(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c, err := r.Cookie(&quot;flash&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if err == http.ErrNoCookie &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;No message found)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rc := http.Cookie&#123;</span><br><span class="line">Name: &quot;flash&quot;,</span><br><span class="line">MaxAge:-1,</span><br><span class="line">Expires:time.Unix(1, 0),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;rc)</span><br><span class="line">val, _ := base64.URLEncoding.DecodeString(c.Value)</span><br><span class="line">fmt.Fprintln(w, string(val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>获取flash消息cookie，创建同名cookie并设置MacAge值为负数、Expires值为已经过去的时间，将同名cookie发送至客户端，相当于命令浏览器删除这个cookie。将flash消息解码，通过响应返回这条消息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数cookie都可以被划分为会话cookie和持久cookie两种类型。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Go与cookie&quot;&gt;&lt;a href=&quot;#Go与cookie&quot; class=&quot;headerlink&quot; title=&quot;Go与cookie&quot;&gt;&lt;/a&gt;Go与cooki
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="cookie" scheme="bighua.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>HTTP简记</title>
    <link href="bighua.top/2018/08/21/HTTP%E7%AE%80%E8%AE%B0/"/>
    <id>bighua.top/2018/08/21/HTTP简记/</id>
    <published>2018-08-21T12:49:31.000Z</published>
    <updated>2018-10-30T11:56:56.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>请求行（request-line）；</li><li>零个或任意多个请求首部（header）；</li><li>一个空行；</li><li>可选的报文主体（body）。</li></ul><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP 1.1要求必须实现的只有GET方法和HEAD方法，其他方法（包括POST）方法是可选的。</p><ul><li>GET——命令服务器返回指定的资源。</li><li>HEAD——类似GET，不同于此方法不要求服务器返回报文的主体。用于在不获取报文主体的情况下取得相应的首部。</li><li>POST——命令服务器将报文主体中的数据传递给URI指定的资源。</li><li>PUT——命令服务器将报文主体中的数据设置为URI指定的资源，若URI指定的位置上已有数据存在，则使用报文主体中的数据去代替已有的数据，若资源未存在，则在URI指定的位置上新创建一个资源。</li><li>DELETE——命令服务器删除URI指定的资源。</li><li>TRACE——命令服务器返回请求本身，了解介于客户端和服务器之间的其他服务器是如何处理请求的。</li><li>OPTIONS——命令服务器返回它支持的HTTP方法列表。</li><li>CONNECT——命令服务器与客户端建立一个网络连接，用于设置SSL隧道以开启HTTPS功能。</li><li>PATCH——命令服务器使用报文主体中的数据对URI指定的资源进行修改。</li></ul><h4 id="常见的请求首部"><a href="#常见的请求首部" class="headerlink" title="常见的请求首部"></a>常见的请求首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">客户端在HTTP相应中能够接收的内容类型。如Accept: text/html</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">客户端要求服务器使用的字符集编码。如Accept-Charset: utf-8。</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">用于向服务器发送基本的身份验证证书</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">客户端在此首部中把服务器之前设置的所有cookie回传给服务器。如Cookie: my-first_cookie=hello; my_second_cookie=world</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">请求主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">请求包含主体的时候用于记录主体内容的类型。发送POST或GET请求时默认为x-www-form-urlen-coded，上传文件时应设置为multipart/form-data。</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">服务器的名字及端口号。无端口号表示使用80端口</td></tr><tr><td style="text-align:left">Referrer</td><td style="text-align:left">发起请求的页面所在的地址</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">对发起请求的客户端进行描述</td></tr></tbody></table><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>状态行；</li><li>零个或任意多个响应首部；</li><li>一个空行；</li><li>可选的报文主体。</li></ul><h4 id="5种类型的响应状态码"><a href="#5种类型的响应状态码" class="headerlink" title="5种类型的响应状态码"></a>5种类型的响应状态码</h4><table><thead><tr><th style="text-align:left">状态码类型</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">情报状态码。告知客户端已接收客户端发送的请求，并且已经对请求进行了处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">成功状态码。告知客户端已接收客户端发送的请求，并且已经成功地对请求进行了处理。标准响应为‘200 OK’</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">重定向状态码。告知客户端已接收客户端发送的请求，并且已经成功处理了请求，但为了完成请求指定的动作，客户端还需要再做一些其他的工作，大多用于实现URL重定向</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">客户端错误状态码。告知客户端发送的请求出现了某些问题。常见‘404 Not Found’表示服务器无法从请求指定的URL中找到客户端想要的资源</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">服务器错误状态码。当服务器因某些原因而无法正确地处理请求时，使用此类状态码告知客户端。</td></tr></tbody></table><h4 id="常见的响应首部"><a href="#常见的响应首部" class="headerlink" title="常见的响应首部"></a>常见的响应首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">告知客户端，服务器支持哪些请求方法</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">响应主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">若响应包含主体则为主体内容的类型</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">以格林尼治标准时间（GMT）格式记录的当前时间</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">仅在重定向时使用，告知客户端截下来应该向哪个URL发送请求。</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">返回响应的服务器的域名</td></tr><tr><td style="text-align:left">Set-Cookie</td><td style="text-align:left">在客户端里面设置一个Cookie，一个响应里面可以包含多个Set-Cookie首部</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">告知客户端在Authorization请求首部中应该提供哪种类型的身份验证信息。服务器常把此首部与“401 Unauthorized”状态行一同发送。此外还会向服务器许可的认证授权模式（schema）提供验证信息（challenge information） </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP请求&quot;&gt;&lt;a href=&quot;#HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求&quot;&gt;&lt;/a&gt;HTTP请求&lt;/h3&gt;&lt;p&gt;由一系列文本行组成，有顺序地进行排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求行（request-line）；&lt;/l
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="http" scheme="bighua.top/tags/http/"/>
    
      <category term="web" scheme="bighua.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>测试工具-siege</title>
    <link href="bighua.top/2018/08/03/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-siege/"/>
    <id>bighua.top/2018/08/03/测试工具-siege/</id>
    <published>2018-08-03T12:42:20.000Z</published>
    <updated>2018-10-30T11:56:56.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>mac下使用brew直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install siege</span><br></pre></td></tr></table></figure><p><code>siege -C</code>查看相关的配置参数，可以自行修改，比如是否显示log，超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">localhost:~ wuhua$ siege -C</span><br><span class="line">CURRENT  SIEGE  CONFIGURATION</span><br><span class="line">Mozilla/5.0 (apple-x86_64-darwin17.0.0) Siege/4.0.4</span><br><span class="line">Edit the resource file to change the settings.</span><br><span class="line">----------------------------------------------</span><br><span class="line">version:                        4.0.4</span><br><span class="line">verbose:                        true</span><br><span class="line">color:                          true</span><br><span class="line">quiet:                          false</span><br><span class="line">debug:                          false</span><br><span class="line">protocol:                       HTTP/1.1</span><br><span class="line">HTML parser:                    enabled</span><br><span class="line">get method:                     HEAD</span><br><span class="line">connection:                     close</span><br><span class="line">concurrent users:               25</span><br><span class="line">time to run:                    n/a</span><br><span class="line">repetitions:                    n/a</span><br><span class="line">socket timeout:                 30</span><br><span class="line">cache enabled:                  false</span><br><span class="line">accept-encoding:                gzip, deflate</span><br><span class="line">delay:                          0.000 sec</span><br><span class="line">internet simulation:            false</span><br><span class="line">benchmark mode:                 false</span><br><span class="line">failures until abort:           1024</span><br><span class="line">named URL:                      none</span><br><span class="line">URLs file:                      /usr/local/Cellar/siege/4.0.4/etc/urls.txt</span><br><span class="line">thread limit:                   10000</span><br><span class="line">logging:                        false</span><br><span class="line">log file:                       /Users/wuhua/var/siege.log</span><br><span class="line">resource file:                  /Users/wuhua/.siege/siege.conf</span><br><span class="line">timestamped output:             false</span><br><span class="line">comma separated output:         false</span><br><span class="line">allow redirects:                true</span><br><span class="line">allow zero byte data:           true</span><br><span class="line">allow chunked encoding:         true</span><br><span class="line">upload unique files:            true</span><br><span class="line">no-follow:</span><br><span class="line"> - ad.doubleclick.net</span><br><span class="line"> - pagead2.googlesyndication.com</span><br><span class="line"> - ads.pubsqrd.com</span><br><span class="line"> - ib.adnxs.com</span><br></pre></td></tr></table></figure><p>项目：<a href="https://github.com/JoeDog/siege" target="_blank" rel="noopener">siege</a></p><p>参考：<a href="https://blog.csdn.net/shangmingtao/article/details/73850292#1siege%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">siege压力测试工具安装和介绍</a>，<a href="https://www.cnblogs.com/lawlietfans/p/6873306.html" target="_blank" rel="noopener">如何使用siege测试服务器性能</a></p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>可在命令行中输入siege –help获取。</p><table><thead><tr><th style="text-align:left">输入参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:left">-V,–version</td><td style="text-align:left">打印版本号</td></tr><tr><td style="text-align:left">-h,–help</td><td style="text-align:left">打印帮助信息（输出这些命令参数及详情）</td></tr><tr><td style="text-align:left">-C,–config</td><td style="text-align:left">显示当前配置信息</td></tr><tr><td style="text-align:left">-v,–verbose</td><td style="text-align:left">将通知信息输出到屏幕</td></tr><tr><td style="text-align:left">-q,–quiet</td><td style="text-align:left">停止verbose并抑制输出</td></tr><tr><td style="text-align:left">-g,–get</td><td style="text-align:left">显示请求URL的HTTP头和返回详情，适用于调试</td></tr><tr><td style="text-align:left">-p,–print</td><td style="text-align:left">打印，类似GET一样，打印整个页面（response html）</td></tr><tr><td style="text-align:left">-c,–concurrent=NUM</td><td style="text-align:left">设置并发用户数，默认为10</td></tr><tr><td style="text-align:left">-r,-–reps=NUM</td><td style="text-align:left">设置测试次数</td></tr><tr><td style="text-align:left">-t,–time=NUMm</td><td style="text-align:left">设置测试时间，m修饰秒（S）、分（M）、时（H），例如–time=1H</td></tr><tr><td style="text-align:left">-d,-–delay=NUM</td><td style="text-align:left">时间延迟，每次请求之前的延迟随机</td></tr><tr><td style="text-align:left">-b,–benchmark</td><td style="text-align:left">基准测试，请求之间没有延迟</td></tr><tr><td style="text-align:left">-i,–internet</td><td style="text-align:left">用户模拟、随机访问url</td></tr><tr><td style="text-align:left">-f,-–file=FILE</td><td style="text-align:left">选择特定的URLS文件（读取文件选取其中的url进行访问）</td></tr><tr><td style="text-align:left">-R,–rc=FILE</td><td style="text-align:left">指定一个siegerc文件</td></tr><tr><td style="text-align:left">-l,–log[=FILE]</td><td style="text-align:left">记录测试日志到文件，如果未指定FILE，则使用默认值：PREFIX/var/siege.log</td></tr><tr><td style="text-align:left">-m,-–mark=”text”</td><td style="text-align:left">标记，用字符串标记测试日志，介于.001和NUM之间。（未计入统计数据）</td></tr><tr><td style="text-align:left">-H,-–header=”text”</td><td style="text-align:left">添加测试的请求头header，可以为多个</td></tr><tr><td style="text-align:left">-A, –user-agent=”text”</td><td style="text-align:left">在请求中设置User-Agent</td></tr><tr><td style="text-align:left">-T, –content-type=”text”</td><td style="text-align:left">在请求中设置Content-Type</td></tr><tr><td style="text-align:left">–no-parser</td><td style="text-align:left">没有PARSER，关闭HTML页面解析器</td></tr><tr><td style="text-align:left">–no-follow</td><td style="text-align:left">不遵循，不要遵循HTTP重定向</td></tr></tbody></table><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><table><thead><tr><th style="text-align:center">输出参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:center">Transactions</td><td style="text-align:left">总共测试次数</td></tr><tr><td style="text-align:center">Availability</td><td style="text-align:left">成功次数百分比</td></tr><tr><td style="text-align:center">Elapsed time</td><td style="text-align:left">总共耗时多少秒</td></tr><tr><td style="text-align:center">Data transferred</td><td style="text-align:left">总共数据传输</td></tr><tr><td style="text-align:center">Response time</td><td style="text-align:left">平均响应时间</td></tr><tr><td style="text-align:center">Transaction rate</td><td style="text-align:left">平均每秒处理请求数</td></tr><tr><td style="text-align:center">Throughput</td><td style="text-align:left">吞吐率</td></tr><tr><td style="text-align:center">Concurrency</td><td style="text-align:left">最高并发</td></tr><tr><td style="text-align:center">Successful transactions</td><td style="text-align:left">成功的请求数</td></tr><tr><td style="text-align:center">Failed transactions</td><td style="text-align:left">失败的请求数</td></tr><tr><td style="text-align:center">Longest transaction</td><td style="text-align:left">最长响应时间</td></tr><tr><td style="text-align:center">Shortest transaction</td><td style="text-align:left">最短响应时间</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>示例：</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数据</th></tr></thead><tbody><tr><td style="text-align:left"> 请求登陆接口</td><td style="text-align:left"><a href="http://bighua.com/login" target="_blank" rel="noopener">http://bighua.com/login</a></td></tr><tr><td style="text-align:left"> 请求类型</td><td style="text-align:left">POST</td></tr><tr><td style="text-align:left"> 请求参数</td><td style="text-align:left">{“_token”: “qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5”,”email”: “228944883 @qq.com”,”password”: “hualin123”,”remember”: “on”}</td></tr><tr><td style="text-align:left"> 请求次数</td><td style="text-align:left">10次</td></tr><tr><td style="text-align:left"> 请求并发数量</td><td style="text-align:left">150</td></tr></tbody></table><p>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siege &quot;http://bighua.com/login POST &#123;&quot;_token&quot;:&quot;qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5&quot;,&quot;email&quot;:&quot;228944883@qq.com&quot;,&quot;password&quot;:&quot;hualin123&quot;,&quot;remember&quot;:&quot;on&quot;&#125;&quot; -r 10 -c 150</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transactions:        1490 hits</span><br><span class="line">Availability:       99.33 %</span><br><span class="line">Elapsed time:       41.63 secs</span><br><span class="line">Data transferred:        2.16 MB</span><br><span class="line">Response time:        3.04 secs</span><br><span class="line">Transaction rate:       35.79 trans/sec</span><br><span class="line">Throughput:        0.05 MB/sec</span><br><span class="line">Concurrency:      108.82</span><br><span class="line">Successful transactions:           0</span><br><span class="line">Failed transactions:          10</span><br><span class="line">Longest transaction:       35.63</span><br><span class="line">Shortest transaction:        0.00</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>siege默认的线程数为255，与apache的默认值相对应，nginx的默认最大连接数为1024。不修改isege配置文件的话，-c的最大值只能为255。 只能测试并发量在255以下。</p><p>另外操作系统对打开文件的多少有限制，即限制socket打开的数量。可通过ulimit命令进行修改。参看博客：<a href="https://blog.csdn.net/z1134145881/article/details/52573441/" target="_blank" rel="noopener">Mac打开文件最大数限制修改</a>、<a href="https://blog.csdn.net/whereismatrix/article/details/50582919" target="_blank" rel="noopener">mac中修改系统限制量–ulimit和sysctl</a>。</p><p>对nginx设置参考<a href="https://blog.csdn.net/hjh15827475896/article/details/53442800" target="_blank" rel="noopener">单机 nginx 应对高并发处理</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;mac下使用brew直接安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="测试" scheme="bighua.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="siege" scheme="bighua.top/tags/siege/"/>
    
  </entry>
  
  <entry>
    <title>EXPLAIN[查询执行计划]</title>
    <link href="bighua.top/2018/08/02/EXPLAIN-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>bighua.top/2018/08/02/EXPLAIN-查询执行计划/</id>
    <published>2018-08-02T12:33:32.000Z</published>
    <updated>2018-10-30T11:56:56.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>通过EXPLAIN命令获取关于查询执行计划的信息，是查看查询优化器如何决定执行查询的主要方法。</p><h3 id="调用EXPLAIN"><a href="#调用EXPLAIN" class="headerlink" title="调用EXPLAIN"></a>调用EXPLAIN</h3><p>在查询中的SELECT关键字之前增加EXPLAIN，MySQL会在查询上设置一个标记，执行查询时，标记会使其返回关于在执行计划中每一步的信息，而不是执行它。返回一行或多行信息，显示出执行计划中的每一部分和执行的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p>查询中每个表在输出中只有一行，若查询为两个表的联接，输出则有两行，别名表单算为一个表，因此把一个表与自己联接，输出也有两行。表：一个子查询，一个UNION结果等等。</p><p>EXPLAIN的两个主要变种：</p><ul><li>EXPLAIN EXTENED：使服务器“逆向编译”执行计划为一个SELECT语句。通过继续运行SHOW WARNINGS查看生成的语句。语句直接来自执行计划，不是原SQL语句，此时为一个数据结构。大部分场景下与原语句不同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[mysql&gt; explain extended select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;                                                                                                      +---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |</span><br><span class="line">+---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1681 | &apos;EXTENDED&apos; is deprecated and will be removed in a future release.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |</span><br><span class="line">| Note    | 1003 | /* select#1 */ select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`email` AS `email`,`login`.`users`.`password` AS `password`,`login`.`users`.`profile_status` AS `profile_status`,`login`.`users`.`remember_token` AS `remember_token`,`login`.`users`.`last_login_ip` AS `last_login_ip`,`login`.`users`.`created_at` AS `created_at`,`login`.`users`.`updated_at` AS `updated_at` from `login`.`users` where (`login`.`users`.`remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos;) |</span><br><span class="line">+---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><ul><li>EXPLAIN PARTITIONS：若查询基于分区表，显示查询将访问的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysql&gt; explain partitions select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>若查询的from子句中包括子查询，则mysql会执行子查询并将其结果放在一个临时表中，然后完成外层查询优化。必须在可以完成外层查询优化之前处理所有类似的子查询（V5.6中被取消），意味着若语句包含开销较大的子查询或使用临时表，实际会给服务器带来大量工作。</p><p>限制：</p><ul><li>不会显示触发器、存储过程或UDF会如何影响查询。</li><li>不支持存储过程、尽管可以可以手动抽取查询并单独地对其进行EXPLAIN操作。</li><li>不会显示MySQL在查询执行中所做的特定优化。</li><li>不会显示关于查询的执行计划的所有信息。</li><li>不区分具有相同名字的事务。</li><li>可能会误导。</li></ul><h3 id="重写非SELECT查询"><a href="#重写非SELECT查询" class="headerlink" title="重写非SELECT查询"></a>重写非SELECT查询</h3><p>EXPLAIN只能解释SELECT查询，不会对存储程序调用和INSERT、UPDATE、DELETE或其他语句做解释。通过将非SELECT语句转化为一个等价的访问所有相同列的SELECT，重写这些语句以利用EXPLAIN。</p><p>显示计划时，对于写查询没有“等价”的读查询。一个SELECT查询只需要找到数据的一份副本并返回，任何修改数据的查询必须在所有索引上查找并修改其所有副本，比等价的SELECT查询的消耗要高的多。</p><h3 id="EXPLAIN中的列"><a href="#EXPLAIN中的列" class="headerlink" title="EXPLAIN中的列"></a>EXPLAIN中的列</h3><h4 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h4><p>包含一个编号，标识SELECT所属的行。若语句中没有子查询或联合，只会有唯一的SELECT，显示1。否则，内层的SELECT语句一般会顺序编号，对应于其在原始语句中的位置。</p><p>MySQL将SELECT查询分为简单和复杂类型，复杂类型分为三大类：简单子查询、所谓的派生表（在FROM子句中的子查询）、以及UNION查询。</p><h4 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h4><p>显示对应行是简单还是复杂SELECT，SIMPLE意味着查询不包括子查询和UNION，若有复杂子部分，则最外层标记为PRIMARY，其他部分标记如下。</p><ul><li><p>SUBQUERY<br>在SELECT列表中的子查询中的SELECT（不再FROM子句中）</p></li><li><p>DERIVED<br>表示包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中</p></li><li><p>UNION<br>在UNION中的第二个和随后的SELECT被标记为UNION，若UNION被FROM子句中的子查询包含，第一个SELECT会被标记为DERIVED</p></li><li><p>UNION RESULT<br>UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT</p></li></ul><p>SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。DEPENDENT意味着SELECT依赖于外层查询中发现的数据；UNCACHEABLE意味着SELECT中的某些特性阻止结果被缓存于一个Item_cache中。（Item_cache未被文档记载；不是查询缓存，可被一些相同的构件否定，例如RAND()函数。）</p><h4 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h4><p>显示对应行正在访问哪个表，为表或表的别名（若SQL中定义）。</p><p>用于观察MySQL的关联优化器为查询选择的关联顺序。</p><blockquote><p>MySQL的查询执行计划总是左侧深度优先树。</p></blockquote><p>当FROM子句中有UNION时，table列会变得复杂。在FROM子句中有子查询时，table列是形式，N是子查询的id，指向EXPLAIN输出中的后面的一行。有UNION时，UNION RESULT的table列包含一个参入UNION的id列表。</p><h4 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h4><p>显示访问类型——MySQL决定如何查找表中的行。</p><p>访问方法，从最差到最优：</p><ul><li>ALL<br>全表扫描，扫描整张表去找需要的行。（若查询中使用了LIMIT或者Extra列中显示“Using distinct/not exists”则不是）</li><li>index<br>与全表扫描一样，区别于MySQL扫描表时按索引次序进行而不是行。避免了排序，但是需要承担按索引次序读取整个表的开销。意味着若按随机次序访问，开销会很大。若Extra列为“Using index”表示MySQL使用覆盖索引，只扫描索引的数据，不按索引次序的每一行，比按索引次序全表扫描的开销小很多。</li><li>range<br>范围扫描实际上是有限制的索引扫描，开始于索引里的某一点，返回匹配这个域的行，开销跟索引类型相当。是带有BETWEEN或在WHERE子句里带有&gt;的查询。<br>当MySQL使用索引去查找一系列值时，如In()和OR列表，也会显示为范围扫描。两者其实为不同的访问类型，性能上有重要的差异。</li><li>ref<br>索引访问（索引查找），返回所有匹配某个单个值的行。查找和扫描的混合体。只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。索引要跟某个参考值相比较，参考值或者是一个常数、或者是来自多表查询前一个表里的结果值。ref_or_null是ref之上的一个变体，意味着MySQL必须在初次查找的结果里进行第二次查找以找出NULL条目。</li><li>eq_ref<br>索引查找，MySQL最多只返回一条符合条件的记录。在MySQL使用主键或者唯一性索引查找时出现，将它们与某个参考值做比较。</li><li>const，system<br>MySQL对查询的某部分进行优化并将其转换成一个常量时出现。</li><li>NULL<br>意味着MySQL能在优化阶段分解查询语句，在执行阶段用不着再访问表或者索引。</li></ul><h4 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h4><p>显示查询可以使用哪些索引，基于查询访问的列和使用的比较操作符来判断。</p><h4 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h4><p>显示MySQL决定采用哪个索引来优化对该表的访问。若该索引未出现在possible_keys列中，则MySQL选用它是出于另外的原因——如即使没有where子句却选择覆盖索引。</p><p>possible_keys显示哪一个索引能有助于高效地进行查找，key显示优化采用哪一个索引可以最小化查询成本。</p><h4 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h4><p>显示MySQL在索引里使用的字节数。通过查找表的定义而被计算出，而不是表中的数据。</p><h4 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h4><p>显示之前的表在key列记录的索引中查找值所用的列或常量。</p><h4 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h4><p>MySQL估计为了找到所需的行而要读取的行数。内嵌循环关联计划里的循环数目，不是MySQL认为它最终要从表里读取出来的行数，而是MySQL为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。是MySQL认为它要检查的行数，而不是结果集合里的行数。</p><h4 id="filtered列"><a href="#filtered列" class="headerlink" title="filtered列"></a>filtered列</h4><p>使用EXPLAIN EXTENDED时出现，显示针对表里符合某个条件（WHERE子句或联接条件）的记录数的百分比所做的一个悲观估算。将rows列乘此值，为MySQL估算它将和查询计划里前一个表关联的行数。</p><h4 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h4><p>包含不适合在其他列显示的额外信息。</p><p>常见的最重要的值有；</p><ul><li>“Using index”<br>表示MySQL将使用覆盖索引，以避免访问表。</li><li>“Using where”<br>意味着MySQL服务器将在存储引擎检索行后再进行过滤。有时代表着查询可受益于不同的索引。</li><li>“Using temporary”<br>意味着MySQL在对查询结果排序时会使用一个临时表。</li><li>“Using filesort”<br>意味着MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。有两种文件排序算法，两种方式都可在内存或磁盘上完成，不会显示将会使用哪一种文件排序，也不会显示是在内存里还是磁盘上完成。</li><li>“Range checked for each record（index map：N）”<br>意味着没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_key列中索引的位图，并且是冗余的。</li></ul><h3 id="MySQL-5-6中的改进"><a href="#MySQL-5-6中的改进" class="headerlink" title="MySQL 5.6中的改进"></a>MySQL 5.6中的改进</h3><p>能对类似UPDATE、INSERT等查询进行解释。</p><p>对查询优化和执行引擎的改进，允许临时表尽可能晚地被具体化，而不总是在优化和执行使用到此临时表的部分查询时创建并填充它们。允许MySQL可以直接解释带子查询的查询语句，而不需要先实际地执行子查询。</p><p>通过在服务器中增加优化跟踪功能的方式改进优化器的相关部分。允许用户查看优化器做出选择，以及输入和抉择的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;EXPLAIN&quot;&gt;&lt;a href=&quot;#EXPLAIN&quot; class=&quot;headerlink&quot; title=&quot;EXPLAIN&quot;&gt;&lt;/a&gt;EXPLAIN&lt;/h3&gt;&lt;p&gt;通过EXPLAIN命令获取关于查询执行计划的信息，是查看查询优化器如何决定执行查询的主要方法。&lt;/p
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="explain" scheme="bighua.top/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>git命令</title>
    <link href="bighua.top/2018/08/01/git%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2018/08/01/git命令/</id>
    <published>2018-08-01T12:04:27.000Z</published>
    <updated>2018-10-30T11:56:56.985Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些不常用到或者易遗忘的git命令。</p><hr><p>参考：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Book</a></p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>参考：Book</p><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --short</span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>通过文件补丁的格式显示具体哪些行发生了改变:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h4 id="查看已暂存的将要添加到下次提交里的内容"><a href="#查看已暂存的将要添加到下次提交里的内容" class="headerlink" title="查看已暂存的将要添加到下次提交里的内容:"></a>查看已暂存的将要添加到下次提交里的内容:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &apos;description message&apos;</span><br></pre></td></tr></table></figure><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>从已跟踪文件清单中移除（确切地说，是从暂存区域移除，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br></pre></td></tr></table></figure><p>若删除之前修改过并且已经放到暂存区域，用强制删除选项 -f（译注：即 force 的首字母）,不能被 Git 恢复.</p><p>让文件保留在磁盘，不让 Git 继续跟踪:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>在 Git 中对文件改名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv filename new_filename</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv filename new_filename</span><br><span class="line">git rm filename</span><br><span class="line">git add new_filename</span><br></pre></td></tr></table></figure><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>回顾下提交历史:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>不用任何参数，按提交时间列出所有的更新，最近的更新排在最上面。加参数-p，用来显示每次提交的内容差异，加上-2来仅显示最近两次提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure><p>使用–stat参数查看每次提交的简略的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>参数–pretty指定使用不同于默认格式的方式展示提交历史，有一些内建的子选项供使用。如参数oneline将每个提交放在一行显示，参数format定制要显示的记录格式，还有short，full和fuller可用，展示的信息或多或少有些不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure><p>format<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rpretty_format" target="_blank" rel="noopener">常用的选项</a>。</p><p>oneline或format与log选项–graph结合使用,添加一些ASCII字符串来形象地展示分支、合并历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h %s&quot; --graph</span><br></pre></td></tr></table></figure><p>git log<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlog_options" target="_blank" rel="noopener">常用选项</a></p><p>–since和–until按照时间作限制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure><p>限制git log<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlimit_options" target="_blank" rel="noopener">输出的选项</a></p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>尝试重新提交，覆盖上一次的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>将文件还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>实际上是拷贝了另一个文件来覆盖。</p><blockquote><p>Git中任何已提交的东西几乎总是可以恢复的，任何未提交的东西丢失后很可能无法恢复。</p></blockquote><h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>运行<code>git remote</code>命令，列出指定的每一个远程服务器的简写。<br>指定选项 -v，显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个可以轻松引用的简写。</p><p>运行<code>git fetch shortname</code>拉取url所指仓库中有但自己没有的信息。</p><h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>若有一个分支设置为跟踪一个远程分支，使用<code>git pull</code>命令来自动的抓取然后合并远程分支到当前分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p><code>git push [remote-name] [branch-name]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p><code>git remote show [remote-name]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p><code>git remote rename</code>修改远程仓库的简写名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename oldshortname newshortname</span><br></pre></td></tr></table></figure><p>git remote rm移除一个远程仓库.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm shortname</span><br></pre></td></tr></table></figure><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>给历史中的某一个提交打上标签，以示重要。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p><code>git tag</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &apos;v1.8.5*&apos;</span><br></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>运行 tag 命令时指定 -a 选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a tagname -m &apos;description in tag&apos;</span><br></pre></td></tr></table></figure><p>-m 选项指定了一条将会存储在标签中的信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag tagname</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看提交日志</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">//使用显示的校验打标签</span><br><span class="line">git tag -a tagname  部分或完整校验和</span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行<code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin tagname</span><br></pre></td></tr></table></figure><p>一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>使用<code>git checkout -b [branchname] [tagname]</code>在特定的标签上创建一个新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newbranchshartname tagname.</span><br></pre></td></tr></table></figure><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>通过git config文件为命令设置别名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p><code>git branch</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch branchname</span><br></pre></td></tr></table></figure><p><code>git log --oneline --decorate</code>查看各个分支当前所指的对象</p><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p><code>git checkout</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branchname</span><br></pre></td></tr></table></figure><p><code>git log --oneline --decorate --graph --all</code>查看分叉历史</p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>基于master的紧急分支的创建、合并、删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b iss53</span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git branch -d hotfix</span><br><span class="line">git checkout iss53</span><br><span class="line">git checkout master</span><br><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>在两个分支中对同一个文件的同一个部分进行了不同的更改，Git没法干净的合并</p><p>使用<code>git status</code>命令查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p><p>可以打开这些包含冲突的文件然后手动解决冲突</p><p>包含特殊区段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行<code>git mergetool</code>，命令启动一个合适的可视化合并工具</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>不加任何参数运行，得到当前所有分支的一个列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch</span><br><span class="line">  iss21</span><br><span class="line">* master</span><br><span class="line">  test</span><br></pre></td></tr></table></figure><p>运行<code>git branch -v</code>查看每一个分支的最后一次提交:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch -v</span><br><span class="line">  iss21  49dba1c sort</span><br><span class="line">* master 49dba1c sort</span><br><span class="line">  test   49dba1c sort</span><br></pre></td></tr></table></figure><p>运行<code>git branch --merged</code>查看哪些分支已经合并到当前分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch --merged</span><br><span class="line">  iss21</span><br><span class="line">* master</span><br><span class="line">  test</span><br></pre></td></tr></table></figure><p>运行<code>git branch --no-merged</code>查看所有包含未合并工作的分支:</p><p>使用<code>git branch -d</code>命令删除还未合并的分支会失败。</p><h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>只在master分支上保留完全稳定的代码，在名为develop或者next的平行分支上做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入master分支了。</p><h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>特性分支是一种短期分支，它被用来实现单一特性或其相关工作，在合并完成后即可被删除。例如bug的修改，功能的新增等。</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。</p><p>通过<code>git ls-remote (remote)</code>显式地获得远程引用的完整列表，通过<code>git remote show (remote)</code>获得远程分支的更多信息。 更常见利用远程跟踪分支。远程跟踪分支是远程分支状态的引用。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。以<code>(remote)/(branch)</code>形式命名。</p><blockquote><p>“origin” 并无特殊含义。远程仓库名字“origin”与分支名字“master”一样，在Git中并没有任何特别的含义一样。 同时“master”是运行<code>git init</code>时默认的起始分支名字，原因仅仅是它的广泛使用，“origin”是当运行<code>git clone</code>时默认的远程仓库名字。如果运行<code>git clone -o booyah</code>，则默认的远程分支名字将会是<code>booyah/master</code>。</p></blockquote><p>运行<code>git fetch origin</code>命令，查找 “origin” 是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动<code>origin/master</code>指针指向新的、更新后的位置。</p><p>运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目。</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>运行<code>git push (remote) (branch)</code>推送到分支。</p><p>抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝），即不会有一个新的brach分支 - 只有一个不可以修改的<code>origin/branch</code>指针。</p><p>运行<code>git merge origin/serverfix</code>将工作合并到当前所在的分支。</p><p>运行<code>git checkout -b branch origin/branch</code>将自己的分支建立在远程跟踪分支之上，及本地新建本地分支branch并且起点位于<code>origin/serverfix</code>。</p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>克隆一个仓库通常会自动地创建一个跟踪<code>origin/master</code>的master分支。运行<code>git checkout -b [branch] [remotename]/[branch]</code>设置其他的跟踪分支。可使用<code>--track</code>快捷方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track [remotename]/[branch]</span><br></pre></td></tr></table></figure><p>使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>显式地设置已有的本地分支跟踪一个刚刚拉取下来的远程分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u [remotename]/[branch]</span><br></pre></td></tr></table></figure><p>使用<code>git branch</code>的<code>-vv</code>选项查看设置的所有跟踪分支。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p><code>git fetch</code>命令从服务器上抓取本地没有的数据，不会修改工作目录中的内容，只获取数据然后自己合并。命令<code>git pull</code>在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。若有跟踪分支，不管它是显式地设置还是通过<code>clone</code>或<code>checkout</code>命令创建，<code>git pull</code>会查找当前分支所跟踪的服务器分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>通常单独显式地使用<code>fetch</code>与<code>merge</code>命令会更好一些。</p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>运行带有<code>--delete</code>选项的<code>git push</code>命令删除一个远程分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete branchname</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>使用<code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上。原理是首先找到这两个分支（即当前分支、变基操作的目标基底分支）的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底, 最后以此将之前另存为临时文件的修改依序应用。</p><p>目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。在这种情况下，首先在自己的分支里进行开发，当开发完成时需要先将自己的代码变基到<code>origin/master</code>上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><p>使用<code>git rebase</code>命令的<code>--onto</code>选项截取分支的分支变基到其他分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master branch sonbranch</span><br></pre></td></tr></table></figure><p>取sonbranch分支，找到处于分支branch和分支的分支sonbranch的共同祖先之后的修改，然后把它们在master分支上重放一遍。之后合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge sonbranch</span><br></pre></td></tr></table></figure><p>使用<code>git rebase [basebranch] [topicbranch]</code>命令直接将特性分支变基到目标分支上。省去先切换到topicbranch分支，再对其执行变基命令的多个步骤:</p><p>使用<code>git pull --rebase</code>命令而不是直接<code>git pull</code>，或者先<code>git fetch</code>，再<code>git rebase origin/master</code>。防变基已提交造成的混乱。</p><blockquote><p>不要对在仓库外有副本的分支执行变基。只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令。</p></blockquote><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>远程版本库就是硬盘内的另一个目录。若使用用共享文件系统，可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone /opt/git/project.git</span><br><span class="line"></span><br><span class="line">git clone file:///opt/git/project.git</span><br><span class="line"></span><br><span class="line">git remote add local_proj /opt/git/project.git</span><br></pre></td></tr></table></figure><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>新版本(V1.6.6+)的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。</p><h4 id="智能（Smart）-HTTP-协议"><a href="#智能（Smart）-HTTP-协议" class="headerlink" title="智能（Smart） HTTP 协议"></a>智能（Smart） HTTP 协议</h4><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">智能（Smart） HTTP 协议</a></p><h4 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">哑（Dumb） HTTP 协议</a></p><h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SSH 协议</a></p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">Git 协议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些不常用到或者易遗忘的git命令。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Book&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;记录每次更新到仓
      
    
    </summary>
    
      <category term="git" scheme="bighua.top/categories/git/"/>
    
    
      <category term="shell" scheme="bighua.top/tags/shell/"/>
    
      <category term="git" scheme="bighua.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构及命令</title>
    <link href="bighua.top/2018/08/01/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2018/08/01/redis基本数据结构及命令/</id>
    <published>2018-08-01T11:46:12.000Z</published>
    <updated>2018-10-30T11:56:56.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h3><table><thead><tr><th style="text-align:left">结构类型</th><th style="text-align:left">结构存储的值</th><th style="text-align:left">结构的读写能力</th></tr></thead><tbody><tr><td style="text-align:left">STRING</td><td style="text-align:left">字符串、整数或者浮点数</td><td style="text-align:left">对整个字符串或者字符串中的一部分执行操作；整数或浮点数自增、自减操作</td></tr><tr><td style="text-align:left">LIST</td><td style="text-align:left">链表，链表上的每个节点都包含了一个字符</td><td style="text-align:left">链表两端推入或者弹出元素；根据偏移量对链表进行修剪；读取单个或多个元素；根据指查找或着移除元素</td></tr><tr><td style="text-align:left">SET</td><td style="text-align:left">字符串的无序收集器，被包含的每个字符串都是独一无二的、各不相同的</td><td style="text-align:left">添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td style="text-align:left">HASH</td><td style="text-align:left">包含键值对的无序散列表</td><td style="text-align:left">添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td style="text-align:left">ZSET(有序集合)</td><td style="text-align:left">字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td><td style="text-align:left">添加、获取、删除单个元素；根据分值范围或者成员来获取元素</td></tr></tbody></table><h4 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h4><p>与其他编程语言或者其他键值存储提供的字符串非常相似。</p><h4 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h4><p>一个列表结构可以有序地存储多个字符串。可执行的操作与很多编程语言中的列表操作非常相似。</p><h4 id="Redis中的集合"><a href="#Redis中的集合" class="headerlink" title="Redis中的集合"></a>Redis中的集合</h4><p>存储多个字符串，不同于列表，集合使用无序方式存储元素，使用散列表保证存储的每个字符串都是不同的。</p><h4 id="Redis中的散列"><a href="#Redis中的散列" class="headerlink" title="Redis中的散列"></a>Redis中的散列</h4><p>存储多个键值对之间的映射，散列存储的值既可以是字符串也可以是数字值。类似文档数据库中的文档，关系数据库中的行，允许用户同时访问或者修改一个或多个域。</p><h4 id="Redis中的有序集合"><a href="#Redis中的有序集合" class="headerlink" title="Redis中的有序集合"></a>Redis中的有序集合</h4><p>用于存储键值对，键被称为成员，每个成员各不相同，值被称为分值，分值必须为浮点数。唯一既可以根据成员访问元素，又可以根据分值及分值的排列顺序来访问元素的结构。</p><h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Redis中的自增命令和自减命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">LNCR</td><td style="text-align:left">INCR key-name——将键存储的值加上1</td></tr><tr><td style="text-align:left">DECR</td><td style="text-align:left">DECR key-name——将键存储的值减去1</td></tr><tr><td style="text-align:left">INCRBY</td><td style="text-align:left">INCRBY key-name amount——将键存储的值加上amount</td></tr><tr><td style="text-align:left">DECRBY</td><td style="text-align:left">DECRBY key-name amount——将键存储的值减去amount</td></tr><tr><td style="text-align:left">INCRBYFLOAT</td><td style="text-align:left">INCRBYFLOAT key-name amount——将键存储的值加上浮点数amount，redis v2.6+</td></tr></tbody></table><p>存储时，若值可被解释（interpret）为十进制整数或者浮点数，则允许用户对字符串执行各种INCR*和DECR*操作。对不存在的键或者保存了空串的键执行自增或者自减操作，Redis执行操作时将键的值当作0处理。对无法解释为整数或浮点数的字符串键执行自增或自减操作，将向用户返回一个错误。</p><p>处理子串和二进制位的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">APPEND</td><td style="text-align:left">APPEND key-name value——将值value追加到给定键key-name当前存储的值的末尾</td></tr><tr><td style="text-align:left">GETRANGE</td><td style="text-align:left">GETRANGE key-name start end——获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内。</td></tr><tr><td style="text-align:left">SETRANGE</td><td style="text-align:left">SETRANGE key-name offset value——将start偏移量开始的子串设置为给定值</td></tr><tr><td style="text-align:left">GETBIT</td><td style="text-align:left">GETBIT key-name offset——将子节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设置为value</td></tr><tr><td style="text-align:left">BITCOUNT</td><td style="text-align:left">BITCOUNT key-name [start end]——统计二进制位串里面值为1的二进制位的数量，若给定偏移量start和end，则只对偏移量指定范围内的二进制位进行统计</td></tr><tr><td style="text-align:left">BITOP</td><td style="text-align:left">BITOP operation dest-key key-name [key-name …]——对一个或多个二进制位串执行包括并（AND）、或（OR）、异或（XOR）、非（NOT）在内的任意一种按位运算操作，并将计算结果保存在dest-key键里</td></tr></tbody></table><p>使用STRANGE或者SETBIT命令对字符串进行写入的时候，若字符串当前的长度不能满足写入的要求，Redis会自动地使用空字节（null）将字符串扩展至所需的长度，然后才执行写入或者更新操作。使用GETRANGE读取字符串，超出字符串末尾的数据会被视为是空串，使用GETBIT读取二进制位串，超出字符串末尾的二进制位会被视为0。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>常用的列表命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">RPUSH</td><td style="text-align:left">RPUSH key-name value [value …]——将一个或多个值推入列表的右端</td></tr><tr><td style="text-align:left">LPUSH</td><td style="text-align:left">LPUSH key-name value [value …]——将一个或多个值推入列表的左端</td></tr><tr><td style="text-align:left">RPOP</td><td style="text-align:left">RPOP key-name——移除并返回列表最右端的元素</td></tr><tr><td style="text-align:left">LPOP</td><td style="text-align:left">LPOP key-name——移除并返回列表最左端的元素</td></tr><tr><td style="text-align:left">LINDEX</td><td style="text-align:left">LINDEX key-name offset——返回列表中偏移量为offset的元素</td></tr><tr><td style="text-align:left">LRANGE</td><td style="text-align:left">LRANGE key-name start end——返回列表从start偏移量到end偏移量范围内的所有元素，偏移量start和end的元素也会包含在被返回的元素之内</td></tr><tr><td style="text-align:left">LTRIM</td><td style="text-align:left">LTRIM ley-name start end——对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，偏移量start和end的元素也会保留</td></tr></tbody></table><p>阻塞式的列表弹出民命令以及在列表之间移动元素的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">BLPOP</td><td style="text-align:left">BLPOP key-name [key-name …] timeout——从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left">BRPOP</td><td style="text-align:left">BRPOP key-name [key-name …] timeout——从第一个非空列表中掏出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left">RPOPLPUSH</td><td style="text-align:left">RPOPLPUSH source-key dest-key——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td></tr><tr><td style="text-align:left">BRPOPLPUSH</td><td style="text-align:left">BRPOPLPUSH source-key dest-key timeout——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素，若source-key为空，则在timeout秒之内阻塞并等待可弹出的元素出现</td></tr></tbody></table><p>应用于消息传递、任务队列。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>以无序的方式存储多个各不相同的元素。</p><p>常用集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SADD</td><td style="text-align:left">SADD key-name item [item …]——将一个或多个元素添加到集合中，并返回被添加元素当中原本并不存在于集合里面的元素数量</td></tr><tr><td style="text-align:left">SREM</td><td style="text-align:left">SREM key-name item [item …]——从集合里面移除一个或多个元素，并返回被移除元素的数量</td></tr><tr><td style="text-align:left">SISMEMBER</td><td style="text-align:left">SISMEMBER key-name item——检查元素item是否存在于集合key-name里</td></tr><tr><td style="text-align:left">SCARD</td><td style="text-align:left">SCARD key-name——返回集合包含的元素的数量</td></tr><tr><td style="text-align:left">SMEMBERS</td><td style="text-align:left">SMEMBERS key-name——返回集合包含的所有元素</td></tr><tr><td style="text-align:left">SRANDMEMBER</td><td style="text-align:left">SRANDMEMBER key-name [count]——从集合里面随机地返回一个或多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td></tr><tr><td style="text-align:left">SPOP</td><td style="text-align:left">SPOP key-name——随机地移除集合中的一个元素，并返回被移除的元素</td></tr><tr><td style="text-align:left">SMOVE</td><td style="text-align:left">SMOVE source-key dest-key item——若集合source-key包含元素item，从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；若item被成功移除，命令返回1，否则返回0</td></tr></tbody></table><p>组合和处理多个集合的redis命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SDIFF</td><td style="text-align:left">SDIFF key-name [key-name …]——返回那些存在于第一个集合、但不存在于其他集合中的元素（差集运算）</td></tr><tr><td style="text-align:left">SDIFFSTORE</td><td style="text-align:left">SDIFFSTORE dest-key key-name [key-name …]——将存在于第一个集合但并不存在于其他集合中的元素（差集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left">SINTER</td><td style="text-align:left">SINTER key-name [key-name …]——返回那些同时存在于所有集合中的元素（交集运算）</td></tr><tr><td style="text-align:left">SINTERSTORE</td><td style="text-align:left">SINTERSTORE dest-key key-name [key-name …]——将同时存在于所有集合中的元素（交集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left">SUNION</td><td style="text-align:left">SUNION key-name [key-name …]——返回至少存在于一个集合中的元素（并集运算）</td></tr><tr><td style="text-align:left">SUNIONSTORE</td><td style="text-align:left">SUNIONSTORE desk-key key-name [key-name …]——将至少存在于一个集合中的元素（并集运算）存储到dest-key键里面</td></tr></tbody></table><h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><p>适用于将一些相关的数据存储在一起。</p><p>添加和删除键值对的散列操作：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">HMGET</td><td style="text-align:left">HMGET key-name key [key …]——从散列里面获取一个或多个键的值</td></tr><tr><td style="text-align:left">HMSET</td><td style="text-align:left">HMSET key-name key value [key value …]——为散列里面的一个或多个键设置值</td></tr><tr><td style="text-align:left">HDEL</td><td style="text-align:left">HDEL key-name key [key …]——删除散列里面的一个或多个键值对，返回成功找到并删除的键值对的数量</td></tr><tr><td style="text-align:left">HLEN</td><td style="text-align:left">HLEN key-name——返回散列包含的键值对的数量</td></tr></tbody></table><p>散列的批量操作命令以及和字符串操作类似的散列命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">HEXISTS</td><td style="text-align:left">HEXISTS key-name key——检查给定键是否存在于散列中</td></tr><tr><td style="text-align:left">HKEYS</td><td style="text-align:left">HKEYS key-name——获取散列包含的所有键</td></tr><tr><td style="text-align:left">HVALS</td><td style="text-align:left">HVALS key-name——获取散列包含的所有值</td></tr><tr><td style="text-align:left">HGETALL</td><td style="text-align:left">HGETALL key-name——获取散列包含的所有键值对</td></tr><tr><td style="text-align:left">HINCRBY</td><td style="text-align:left">HINCRBY key-name key increment——将键key存储的值加上整数increment</td></tr><tr><td style="text-align:left">HINCRBYFLOAT</td><td style="text-align:left">HINCRBYFLOAT key-name key increment——将键key存储的值加上浮点数increment</td></tr></tbody></table><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>存储着成员与分值之间的映射，提供了分值处理命令，分值在Redis中以IEEE 175双精度浮点数的格式存储。</p><p>常用的有序集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">ZADD</td><td style="text-align:left">ZADD key-name score member [score member …]——将带有给定分值的成员添加到有序集合里面</td></tr><tr><td style="text-align:left">ZREM</td><td style="text-align:left">ZREM key-name member [member …]——从有序集合里面移除给定的成员，并返回被移除成员的数量</td></tr><tr><td style="text-align:left">ZCARD</td><td style="text-align:left">ZCARD key-name——返回有序集合包含的成员数量</td></tr><tr><td style="text-align:left">ZINCRBY</td><td style="text-align:left">ZINCRBY key-name increment member——将member成员的分值加上increment</td></tr><tr><td style="text-align:left">ZCOUNT</td><td style="text-align:left">ZCOUNT key-name min max——返回分值介于min和max之间的成员数量</td></tr><tr><td style="text-align:left">ZRANK</td><td style="text-align:left">ZRANK key-name member——返回成员member在有序集合中的排名</td></tr><tr><td style="text-align:left">ZSCORE</td><td style="text-align:left">ZSCORE key-name member——返回成员memebr的分值</td></tr><tr><td style="text-align:left">ZRANGE</td><td style="text-align:left">ZRANGE key-name start stop [WITHSCORES]——返回有序集合中排名介于start和stop之间的成员，若给定了可选的WITHSCORES选项，则命令会将成员的分值一并返回</td></tr></tbody></table><p>有序集合的范围型数据获取命令和范围型数据删除命令、并集命令、交集命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">ZREVRANK</td><td style="text-align:left">ZREVRANK key-name member——返回有序集合里成员member的排名，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left">ZREVRANGE</td><td style="text-align:left">ZREVRANGE key-name start stop [WITHSCORES]——返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left">ZRANGEBYSCORE</td><td style="text-align:left">ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]——返回有序集合中，分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left">ZREVRANGEBYSCORE</td><td style="text-align:left">ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]——获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返回它们</td></tr><tr><td style="text-align:left">ZREMRANGEBYRANK</td><td style="text-align:left">ZREMRANGEBYRANK key-name start stop——移除有序集合中排名介于start和stop之间的所有所有成员</td></tr><tr><td style="text-align:left">ZREMRANGEBYSCORE</td><td style="text-align:left">ZREMRANGEBYSCORE key-name min max——移除有序集合中分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left">ZINTERSTORE</td><td style="text-align:left">ZINTERSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的交集运算</td></tr><tr><td style="text-align:left">ZUNIONSTORE</td><td style="text-align:left">ZUNIONSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的并集运算</td></tr></tbody></table><h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><p>发布与订阅（pub/sub）是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息。当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。</p><p>发布与订阅命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SUBSCRIBE</td><td style="text-align:left">SUBSCRIBE channel [channel …]——订阅给定的一个或多个频道</td></tr><tr><td style="text-align:left">UNSUBSCRIBE</td><td style="text-align:left">UNSUBSCRIBE [channel [channel …]]——退订给定的一个或多个频道，若执行时没给定频道，则退订所有频道</td></tr><tr><td style="text-align:left">PUBLISH</td><td style="text-align:left">PUBLISH channel message——向给定频道发送消息</td></tr><tr><td style="text-align:left">PSUBSCRIBE</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]——订阅与给定模式相匹配的所有频道</td></tr><tr><td style="text-align:left">PUNSUBSCRIBE</td><td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]——退订给定的模式，如果执行时没有给定任何模式，则退订所有模式</td></tr></tbody></table><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>同其他编程语言的排序操作，可以根据某种比较规则对一系列元素进行有序的排列。可根据字符串、列表、集合、有序集合、散列这5种键里面存储着的数据，对列表、集合以及有序集合进行排序，相当于SQL中的order by子句。</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SORT</td><td style="text-align:left">SORT source-key [BY pattern][LIMIT offset count][GET pattern [GET PATTERN …]][ASC &#124; DESC][ALPHA][STORE dest-key]——根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</td></tr></tbody></table><p>可实现的功能：根据降序而不是默认的升序来排序元素；将元素看作是数字来进行排序，或则将元素看作是数字来进行排序，或者将元素看作是二进制字符串来进行排序；使用被排序元素之外的其他值作为权重来进行排序，可从输入的列表、集合、有序集合以外的其他地方进行取值。</p><p>对集合进行排序返回一个列表形式的排序结果。</p><h5 id="基本的Redis事务"><a href="#基本的Redis事务" class="headerlink" title="基本的Redis事务"></a>基本的Redis事务</h5><p>让用户在不被打断的情况下对多个键执行操作：WATCH、MULTI、EXEC、UNWATCH和DISCARD。</p><p>基本事务（basic transaction）使用MULTI命令和EXEC命令，让一个客户端在不被其他客户端打断的情况下执行多个命令。被MULTI命令和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。事务执行后，Redis才会处理其他客户端的命令。</p><p>Redis接收到MULTI命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送EXEC命令为止，接着Redis在不被打断的情况下，一个接一个地执行存储在队列里面的命令。</p><p>使用WATCH命令对键进行监视之后，直到用户执行EXEC命令的这段时间里，如果有其他客户端抢先对键进行了替换、更新或删除等操作，当用户尝试执行EXEC命令时，事务将失败并返回一个错误。UNWATCH命令可以在WATCH命令执行以后、MULTI命令执行之前对连接进行重置；DISCARD命令在MULTI命令执行之后、EXEC命令执行之前对连接进行重置。即在用户使用WATCH监视一个或多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已入队命令。</p><h5 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h5><p>指Redis会在键的过期时间到达时自动删除该键。</p><p>为键设置过期时间的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">示例和描述</th></tr></thead><tbody><tr><td style="text-align:left">PERSIST</td><td style="text-align:left">PERSIST key-name——移除键的过期时间</td></tr><tr><td style="text-align:left">TTL</td><td style="text-align:left">TTL key-name——查看给定键距离过期还有多少秒</td></tr><tr><td style="text-align:left">EXPIRE</td><td style="text-align:left">EXPIRE key-name seconds——让给定键在指定的秒数之后过期</td></tr><tr><td style="text-align:left">EXPIREAT</td><td style="text-align:left">EXPIREAT key-name timestamp——将给定键的过期时间设置为给定的UNIX时间戳</td></tr><tr><td style="text-align:left">PTTL</td><td style="text-align:left">PTTL key-name——查看给定键距离过期时间还有多少毫秒，Redis V2.6+</td></tr><tr><td style="text-align:left">PEXPIRE</td><td style="text-align:left">PEXPIRE key-name milliseconds——让给定键在指定的毫秒数之后过期，Redis V2.6+</td></tr><tr><td style="text-align:left">PEXPIREAT</td><td style="text-align:left">PEXPIREAT key-name timestamp-milliseconds——将一个毫秒级精度的UNIX时间戳设置为给定键的过期时间，Redis V2.6+</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis基本数据结构&quot;&gt;&lt;a href=&quot;#redis基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis基本数据结构&quot;&gt;&lt;/a&gt;redis基本数据结构&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="cli" scheme="bighua.top/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引及优化</title>
    <link href="bighua.top/2018/07/30/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>bighua.top/2018/07/30/Mysql索引及优化/</id>
    <published>2018-07-30T11:21:46.000Z</published>
    <updated>2018-10-30T11:56:56.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>参考文档 ：《高性能MySql》</p><p>其他：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程</a>. <a href="https://www.cnblogs.com/whgk/p/6179612.html" target="_blank" rel="noopener">MySQL中的索引详讲</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构。——《高性能MySql-创建高性能的索引》</p></blockquote><blockquote><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p></blockquote><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>创建索引时，需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>索引是在存储引擎层而不是服务器层实现的，没有统一的索引标准，多半为B-Tree索引。B-Tree索引适用于全键值、键值范围或键前缀查找，键前缀查找只适用于根据最左前缀的查找。索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p><p>三星策略：索引将相关的记录放在一起为一星，索引中的数据顺序与查找中的排列顺序一致为二星，索引中的列包含了查询中需要的全部列为三星。</p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><p>修改表结构(添加索引):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>删除索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure><p>修改表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">*ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</span><br><span class="line">*ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。</span><br><span class="line">*ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure><p>待阅读了解：<a href="https://www.cnblogs.com/yank/p/4193820.html" target="_blank" rel="noopener"><code>触发器</code></a>。</p><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>参考博文：<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>、<a href="https://www.cnblogs.com/mysql-dba/p/6689597.html" target="_blank" rel="noopener">深入浅出分析MySQL索引设计背后的数据结构</a></p><p>上方博文主要讲解了mysql使用b+tree作为索引结构，但innoDB和MyISAM的具体实现方式也是不同的。</p><p>在mysql中还有以基于哈希表实现的哈希索引，只有Memory引擎显示支持哈希索引。</p><p>InnoDB引擎有个特殊功能“自适应哈希索引”，当InnoDB注意到某些索引值被使用得非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引。是完全自动的，内部的行为。</p><p>InnoDB中必须包含AUTO_INCREMENT类型字段的索引（建议做主键），MyISAM不需要。</p><h4 id="索引利用"><a href="#索引利用" class="headerlink" title="索引利用"></a>索引利用</h4><p>参考博文：<a href="https://www.cnblogs.com/gossip/p/5707528.html" target="_blank" rel="noopener">索引的特点及使用</a></p><p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。包含多个列，列的顺序也十分重要，MySql只能高效的使用索引的最左前缀列。</p><p>MyISAM表支持空间索引，用作地理空间数据存储。无须前缀查询，会从所有维度来索引数据。详细省略。</p><p>在相同的列上创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p><p>索引优点：</p><ul><li>减少了服务器需要扫描的数据量。</li><li>帮助服务器避免排序和临时表（ORDER BY和GROUP BY操作）。</li><li>将随机IO变为顺序IO。</li></ul><blockquote><p>非常小的表，简单的全表扫描更高效。索引适用中到大型的表，特大型的表，建立和使用索引的代价随之增长（使用分区技术）。</p></blockquote><blockquote><p>创建自定义哈希索引：适用于类似存储大量url的场景，因url本身很长，使用B-Tree进行查找存储的内容会很大，在数据表中新增被索引url_crc列，存储url的哈希结果（使用CRC32做哈希），在where子句中手动指定哈希函数进行查找。不建议使用SHA1()和MD5()作为哈希函数，因哈希值过长浪费空间，比较时慢。</p></blockquote><h4 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h4><ul><li>独立的列：索引列不能是表达式的一部分，也不能是函数的参数。始终将索引列单独放在比较符号的一侧。</li><li>前缀索引和索引选择性：除模拟哈希索引，可以索引开始的部分字符，节约索引空间，提高索引效率。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高。<code>mysql无法使用前缀索引做ORDER BY和GROUP BY，无法使用前缀索引做覆盖扫描。</code>可考虑字符串反转后建立前缀索引实现后缀索引，通过触发器维护这种索引。</li><li>多列索引：若没建多列索引有单列索引，5.0以上版本会将查询条件中的每列单独索引进行扫描，并将结果进行合并，这种策略会导致消耗更多的CPU和内存资源。可以通过参数optimizer_switch关闭索引合并功能，使用IGNORE INDEX提示让优化器忽略掉某些索引。</li><li>选择合适的索引列排序：索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。正确的顺序依赖于使用该索引的查询，索引可以按照升序或者降序进行扫描，已满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询需求。将选择性最高的列放到索引最前列利于where条件的查找，注意特殊情况的对待。</li><li>聚簇索引：InnoDB通过主键聚簇数据，没定义主键将选择一个唯一的非空索引替代，若无，会隐式定义一个主键来作为聚簇索引。聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。一般使用自增列作为聚簇索引，避免随机聚簇索引，特别是对于I/O密集型应用。对于高并发场景，自增列会造成明显的争用，主键的上届会成为“热点”，导致间隙锁竞争。</li><li>覆盖索引：包含所有需要查询的字段的值，索引的叶子结点中已经包含要查询的数据，查询只需扫描索引无需回表。覆盖索引必须要存储索引列的值，使用B-Tree索引做覆盖索引。</li><li>使用索引扫描来做排序：使用同一个索引既满足排序又用于查找行，只有当索引的列顺序和ORDER BY字句顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySql才能够使用索引来对结果做排序。若查询需要关联多张表，只有当ORDER BY字句引用的字段全部为第一个表时，才能使用索引做排序。</li><li>压缩（前缀压缩）索引：MyISAM使用前缀压缩减少索引的大小，让更多的内存可以放入到内存中。默认只压缩字符串，通过参数设置也可以对整数做压缩。MyISAM查找时无法在索引快使用二分查找只能从头开始扫描。对于CPU密集型应用，压缩索引使得MyISAM在索引查找上要慢好几倍。压缩索引需要在CPU内存资源与磁盘之间做权衡。</li><li>冗余和重复索引：指在相同的列上，按照相同的顺序创建的相同类型的索引。MySql需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个进行考虑，影响性能。应避免创建重复索引。冗余索引不同于重复索引，若创建了索引（A,B）再创建索引（A）就属于冗余索引，索引（A,B）可以被当做索引(A)来使用。冗余索引通常发生在为表添加新索引的时候，应尽量拓展已有的索引而不是创建新索引。有时处于性能的考虑需要冗余索引，因拓展已有的索引导致其变得太大，从而影响其他使用该索引的查询的性能。</li><li>未使用的索引：若对数据约束及查询无意义，应该删除。</li><li>索引和锁：InnoDB访问行加锁，当其在存储引擎层能够过滤掉所有不需要的行时，索引减少InnoDB访问行的次数，减少锁的数量，5.1+V在服务器端过滤掉行后就释放锁。InnoDB在二级索引上使用共享（读）锁，访问主键索引需要排他（写）锁。</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><h5 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h5><p>count()可统计某列值的数量（不统计NULL），也可以统计行数（通配符*忽略所有的列而直接统计所有的行数）。</p><p>使用MyISAM在COUNT(*)非常快的特性优化查询，替代SUM()等。</p><h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul><li>确保ON或者USING子句中的列上有索引，创建索引时考虑关联的顺序，一般只需在关联顺序中的第二个表的相应列上创建索引。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，使MySQL有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul><h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><p>旧版本仅可能使用关联查询代替。若使用MySQL V5.6+或MariaDB，不必在意。</p><h5 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h5><p>MySQL很多场景下使用同样的的方法优化这两种查询，在内部处理时会互相转化这两类查询，使用索引优化。</p><p>当无法使用索引时，GROUP BY使用两种策略：使用临时表或者文件排序来做分组。</p><p>使用GROUP BY WITH ROLLUP对返回的分组结果再做一次超级聚合，通过EXPLAIN观察其执行计划，注意分组是否通过文件排序或者临时表实现，然后去掉WITH ROLLUP子句查看执行计划是否相同。最好的办法是尽可能的将WITH ROLLUP功能转移到应用程序中处理。</p><h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><p>针对分页查询LIMIT(1000, 20)，在页面中限制分页的数量，或优化大便宜量的性能。</p><p>尽可能地使用索引覆盖扫描，而不是查询所有的列。<br>将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得结果。<br>使用书签记录上次取数据的位置，下次从书签记录的位置开始扫描，避免使用offset。</p><h5 id="优化SQL-CALC-FOUND-ROWS"><a href="#优化SQL-CALC-FOUND-ROWS" class="headerlink" title="优化SQL_CALC_FOUND_ROWS"></a>优化SQL_CALC_FOUND_ROWS</h5><p>在分页的LIMIT语句中加上此参量提示，可以获取去掉LIMIT以后满足条件的行数，作为分页的总数。代价大。</p><h5 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h5><p>MySQL总是通过创建并填充临时表的方式来执行UNION查询，使得优化策略在UNION查询中无法得到很好的使用。需要手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用条件进行优化。</p><p>除非需要服务器消除重复的行，否则要使用UNION ALL，若无ALL关键字，MySQL会给临时表加上DISTINCT选型，导致对整个临时表的数据做唯一性检查。有ALL关键字，MySQL仍会使用临时表存储结果。</p><blockquote><p>事实上，MySQL总会将结果放入临时表，然后再读出，再返回给客户端。</p></blockquote><h5 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h5><p>Percona Toolkit中的pt-query-advisor。</p><h5 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h5><p>用户自定义变量是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用SET和SELECT语句来定义它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @id := 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = @id;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不能使用自定义变量场景：</p><ul><li>使用自定义变量的查询无法使用查询缓存。</li><li>不能在使用常量或标识符的地方使用自定义常量，如表名、列名和LIMIT子句中。</li><li>不能用做连接间的通信，其生命周期仅在一个连接中。</li><li>在连接池或者持久化连接中，自定义变量可能使代码间发生交互。</li><li>在不同版本间的兼容问题。</li><li>不能显示的声明自定义变量的类型。</li><li>优化器在某些场景下会将这些变量优化掉。</li><li>赋值的顺序和时间点不固定。</li><li>赋值符号:=的优先级非常低，赋值表达式应该使用明确的括号。</li><li>使用未定义的变量不会产生任何语法错误。</li></ul><p>使用：</p><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大量数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变为0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。</li></ul><h4 id="MySQL查询优化器能够处理的优化类型"><a href="#MySQL查询优化器能够处理的优化类型" class="headerlink" title="MySQL查询优化器能够处理的优化类型"></a>MySQL查询优化器能够处理的优化类型</h4><ul><li>重新定义关联表的顺序</li><li>将外链接转化为内链接</li><li>使用等价变换规则</li><li>优化COUNT()、MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul><h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h4><p>大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。</p><h5 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h5><p>查询请求超过实际需要，然后被丢弃，会给MySQL服务器带来额外的负担，增加网络开销，消耗服务器的CPU和内存资源。</p><p>示例：</p><ul><li>查询不需要的记录。</li><li>多表关联时返回全部列。</li><li>总是取出全部列。</li><li>重复查询相同的数据。</li></ul><h5 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h5><p>衡量查询开销的指标：</p><ul><li>响应时间。</li><li>扫描的行数。</li><li>返回的行数。  </li></ul><p>响应时间：服务时间与排队时间的和。</p><p>扫描行数和返回的行数：理想情况下扫描的行数和返回的行数应该是相同的，通常扫/返在1:1到10:1之间，也可能非常大。</p><p>扫描的行数和访问类型：EXPLAIN语句中的type列反应了访问类型，全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢到快，扫描行数由小到大，对应着扫描表、扫描索引、范围访问和单直访问。没办法找到合适的访问类型，增加合适的索引能以最高效、扫描行数最少的方式找到需要的记录。</p><p>MySQL应用where条件的三种方式，由好到坏为：</p><ul><li>索引中使用where条件过滤不匹配的记录。存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using Index）返回记录。直接从索引中过滤不需要的记录并返回命中结果，在MySQL服务器层完成，无需回表查询。</li><li>从数据表中返回记录，过滤不满足条件的记录（Extra列出现Using Where）。Mysql服务器层完成，MySQL从数据表中读出记录然后过滤。</li></ul><p>优化方式：</p><ul><li>使用索引覆盖扫描，把所有需要用到的列都放到索引中。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul><h4 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h4><h5 id="复杂查询和多个简单查询的选取"><a href="#复杂查询和多个简单查询的选取" class="headerlink" title="复杂查询和多个简单查询的选取"></a>复杂查询和多个简单查询的选取</h5><p>需要根据具体的情景考虑选取。</p><p>切分查询：将大查询切分为小查询，每个查询功能完全一样，只完成一小部分。</p><p>分解关联查询：对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。可以让缓存的效率更高、减少锁的竞争、利于高性能和可拓展、提升查询本身效率、减少冗余记录的查询等。</p><h3 id="innoDB存储引擎"><a href="#innoDB存储引擎" class="headerlink" title="innoDB存储引擎"></a>innoDB存储引擎</h3><p>文件系统中，MySql将每个数据库（schema）保存为数据目录下的一个子目录，创建表时，MySql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义，大小写敏感和具体平台相关，windows下不敏感，类Unix中敏感。不同的存储引擎保存数据和索引的方式时不同的，表的定义在MySql服务层统一处理。</p><p>使用<code>show table status [like &#39;tablename&#39;]\G</code>显示表的相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: migrations</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 3</span><br><span class="line"> Avg_row_length: 5461</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 52</span><br><span class="line">    Create_time: 2018-07-19 17:15:56</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_unicode_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: </span><br><span class="line">No query specified</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>InnoDB是MySql的默认事务型引擎，被设计用来处理大量的短期（short-lived），大部分能正常提交，很少会被回滚。除有非常特别的原因需要使用其他存储引擎，应该优先考虑InnoDB引擎。</p><p>InnoDB的数据存储在表空间（tablespace）中，是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。采用MVCC支持高并发，默认REPEATABLE READ（可重复读）隔离级别，通过间隙锁（next-key locking）策略防止幻读。</p><p>基于聚簇索引建立，索引结构不同于其他存储引擎，聚簇索引对主键查询有很高的性能。聚簇索引的二级索引（secondary index，非主键索引）中必须包含主列键，若表上索引较多，应保证主键尽可能的小，防止二级索引变得很大。</p><p>InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。</p><p>其内部做了很多优化，如从磁盘读取数据时采用可预测性预读，自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index）；加速插入操作的插入缓冲区。</p><p>InnoDB通过一些机制和工具支持真正的热备份，如Oracle提供的MySQL Enterprise Backup、Percona提供的开源的XtraBackup。MySQL其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，在读写混合场景中，停止写入可能也意味着停止读取。<br>其他博客：<a href="http://www.cnblogs.com/Aiapple/p/5689634.html" target="_blank" rel="noopener">innodb存储引擎</a></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组原子性的SQL查询，或者说一个独立的工作单元。——《高性能MySQL》</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>A:atomicity，原子性，一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中的一部分操作。</li><li>C:consistency，一致性，数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li><li>I:isolation，隔离性，通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。</li><li>D:durability，持久性，一旦事务提交，其所做的修改就会永久保存到数据库中。</li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><ul><li>READ UNCOMMITED（未提交读）：事务可以读取未提交的数据，产生脏读。</li><li>READ COMMITED（提交读）：事务开始到提交，所做的修改对其他事务不可见。不可重复读，两次执行同样的查询，可能会得到不一样的结果。</li><li>REPEATABLE READ（可重复读）：mysql的默认事务隔离级别，解决脏读问题，InnoDB通过多版本并发控制解决幻读问题，保证在同一个事务中多次读取同样记录的结果是一致的。</li><li>SERIALIZABLE（可串行化）：最高级别隔离，强制事务串行执行，避免幻读。会在读取的每一行数据上加锁，导致大量的超时和锁争用问题。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个事务在同一资源上互相占用，请求锁定对方占用的资源，导致恶性循环。InnoDB将持有最少行级排他锁的事务进行回滚。</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>提高事务效率，修改表的数据时只需修改其内存拷贝，再把该修改行为持久在硬盘上的事务日志中，不用每次都将修改的数据本身持久到硬盘。事务日志持久后，内存中被修改的数据可以慢慢地刷回到磁盘。事务日志采用追加的方式，写日志的操作是磁盘上一小块区域内的顺序I/O。被称为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p><blockquote><p>存储引擎可在重启时，根据事务日志自动恢复上次没能写回磁盘被修改的数据。</p></blockquote><h4 id="MySql中的事务"><a href="#MySql中的事务" class="headerlink" title="MySql中的事务"></a>MySql中的事务</h4><p>提供了两种事务型的存储引擎：InnoDB和NDB Cluster。</p><p>自动提交（AUTOCOMMIT）：若不是显示的开始一个事务，每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>1或者ON表示已启用，0或OFF表示禁用。</p><p>修改AUTOCOMMIT对非事务型的表，如MyISAM和内存表，无任何影响，其无COMMIT和ROLLBACK的概念。</p><p>可以通过<code>SET TRANSACTION ISOLATION LEVEL</code>命令设置隔离级别。新的隔离级别在下一个事务开始时生效。<br>在事务中混合使用存储引擎:</p><blockquote><p>MySql服务器层不管理事务，事务由下层的存储引擎实现，在同一个事务中，使用多种存储引擎是不可靠的。<br>若事务中混合使用了事务型和非事务型的表，在事务回滚时，非事务型的表上的变更无法撤销，导致数据库处于不一致的状态，很难修复。<br>在非事务型的表上执行事务相关操作的时候，MySql通常不会发出提醒，也不会报错，只有回滚的时候才会发出一个警告，大多数情况下，不会有提示。</p></blockquote><p>隐式和显示锁定：</p><blockquote><p>InnoDB采用两阶段锁定协议（two-phase locking protocol），在事务执行过程中，随时都可以锁定，只有在COIMMIT或者ROLLBACK的时候才会释放，所有的锁在同一时刻被释放。这些锁为隐式锁，InnoDB根据隔离级别在需要的时候自动加锁。<br>InnoDB支持通过特定的语句进行显示加锁，这些语句不属于SQL规范。<br>MySql支持LOCK TABLES和UNLOCK TABLES语句，在服务器层实现，与存储引擎无关，不能替代事务。使用事务需要选择事务型存储引擎。<br><code>除事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要执行LOCK TABLES</code>，不管使用什么存储引擎。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql&quot;&gt;&lt;a href=&quot;#mysql&quot; class=&quot;headerlink&quot; title=&quot;mysql&quot;&gt;&lt;/a&gt;mysql&lt;/h3&gt;&lt;p&gt;参考文档 ：《高性能MySql》&lt;/p&gt;
&lt;p&gt;其他：&lt;a href=&quot;http://www.runoob.com/
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="索引" scheme="bighua.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="事务" scheme="bighua.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>laravel日志</title>
    <link href="bighua.top/2018/07/27/laravel%E6%97%A5%E5%BF%97/"/>
    <id>bighua.top/2018/07/27/laravel日志/</id>
    <published>2018-07-27T11:16:30.000Z</published>
    <updated>2018-10-30T11:56:56.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/logging/1374" target="_blank" rel="noopener">日志</a>。</p><p>理解</p><blockquote><p>laravel框架使用monolog记录日志，在配置文件的channels中，可自定义通道，默认选用stack通道。通道即记录日志时选择记录的方式，通道有八种可选驱动，驱动决定了日志记录的位置、信息格式等，可参考配置文件中的其他通道配置自己业务所需的通道进行日志记录。  </p></blockquote><blockquote><p>提供了八种在<a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC 5424 specification</a>中定义的日志等级。在记录时，根据调用方法对应的等级对比选用通道中规定的最低等级，使用最低等级不高于调用方法对应等级的通道记录信息。</p></blockquote><h3 id="中间件记录sql"><a href="#中间件记录sql" class="headerlink" title="中间件记录sql"></a>中间件记录sql</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/database/1397#97d96c" target="_blank" rel="noopener">监听查询事件</a>。</p><blockquote><p>在上方的文档中，larvel5.6提供的监听查询事件与之前版本的监听查询事件匿名函数的参数有不同，是个坑点。v5.6为一个参数带有sql、bindings、time属性，之前版本将这三个属性作为参数。</p></blockquote><p>sql查询事件可能发生在任何请求中，应将其作为全局中间件进行注册。事件监听应在用户请求开始就启动，使用前置中间件。</p><p>在log配置文件中定义sql通道，选用daily驱动将日志按日期进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;sql&apos; =&gt; [</span><br><span class="line">    &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">    &apos;path&apos; =&gt; storage_path(&apos;logs/sql/sql.log&apos;),</span><br><span class="line">    &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">    &apos;days&apos; =&gt; 7,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>中间件中逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    // 记录sql</span><br><span class="line">    DB::listen(function($query) &#123;</span><br><span class="line">        $sql = $query-&gt;sql;</span><br><span class="line">        $bindings = $query-&gt;bindings;</span><br><span class="line">        foreach ($bindings as $replace) &#123;</span><br><span class="line">            $value = is_numeric($replace) ? $replace : &quot;&apos;&quot; . $replace . &quot;&apos;&quot;;</span><br><span class="line">            $sql = preg_replace(&apos;/\?/&apos;, $value, $sql, 1);</span><br><span class="line">            Log::channel(&apos;sql&apos;)-&gt;info(&apos;SQL语句执行：&apos;.$sql.&apos;,耗时：&apos;.$query-&gt;time.&apos;ms&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件记录IO"><a href="#中间件记录IO" class="headerlink" title="中间件记录IO"></a>中间件记录IO</h3><p>实际记录请求和响应。</p><p>request和response所包含的API文档：<a href="https://laravel.com/api/5.6/index.html" target="_blank" rel="noopener">Laravel API</a>。</p><p>对于请求考虑记录请求url、客户端ip、请求方法、请求参数，对于响应记录响应状态码、返回字节数。</p><p>新建通道io:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;io&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">            &apos;path&apos; =&gt; storage_path(&apos;logs/io/io.log&apos;),</span><br><span class="line">            &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">            &apos;days&apos; =&gt; 7,</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>中间件中调用Log记录，注意请求响记录的时期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    $data[&apos;request&apos;][&apos;url&apos;] = $request-&gt;fullUrl();</span><br><span class="line">    $data[&apos;request&apos;][&apos;ip&apos;] = $request-&gt;getClientIp();</span><br><span class="line">    $data[&apos;request&apos;][&apos;method&apos;] = $request-&gt;method();</span><br><span class="line">    $data[&apos;request&apos;][&apos;data&apos;] = $request-&gt;all();</span><br><span class="line">    $response = $next($request);</span><br><span class="line">    $data[&apos;response&apos;][&apos;status&apos;] = $response-&gt;status();</span><br><span class="line">    $data[&apos;response&apos;][&apos;contentLen&apos;] = strlen($response-&gt;content());</span><br><span class="line">    Log::channel(&apos;io&apos;)-&gt;info(serialize($data));</span><br><span class="line">    return $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录异常"><a href="#记录异常" class="headerlink" title="记录异常"></a>记录异常</h3><p>在App\Exceptions\Handler的report 方法中记录异常到日志。可在render方法中将异常消息作为response响应返回。</p><p>report function example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public function report(Exception $exception)</span><br><span class="line">   &#123;</span><br><span class="line">       $data =  $exception-&gt;getMessage().PHP_EOL;</span><br><span class="line">       $data .= &apos;file:&apos;.$exception-&gt;getFile();</span><br><span class="line">       $data .= &apos;(line&apos;.$exception-&gt;getLine().&apos;)&apos;.PHP_EOL;</span><br><span class="line">       $data .= $exception-&gt;getTraceAsString();</span><br><span class="line">       Log::channel(&apos;myLog&apos;)-&gt;error($data);</span><br><span class="line">       parent::report($exception);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>render function example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public function render($request, Exception $e)</span><br><span class="line">  &#123;</span><br><span class="line">      if ($e instanceof ModelNotFoundException) &#123;</span><br><span class="line">          $e = new NotFoundHttpException($e-&gt;getMessage(), $e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ($e instanceof ExceptionBiz) &#123;</span><br><span class="line">          $result = [</span><br><span class="line">              &apos;errcode&apos;   =&gt; $e-&gt;getCode(),</span><br><span class="line">              &apos;errmsg&apos;    =&gt; $e-&gt;getMessage(),</span><br><span class="line">              &apos;data&apos;      =&gt; [],</span><br><span class="line">          ];</span><br><span class="line">          if (!empty($e-&gt;getExtInfo())) &#123;</span><br><span class="line">              $result[&apos;data&apos;] = $e-&gt;getExtInfo();</span><br><span class="line">          &#125;</span><br><span class="line">          return response()-&gt;json($result);</span><br><span class="line">      &#125;</span><br><span class="line">      return parent::render($request, $e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h3&gt;&lt;p&gt;文档：&lt;a href=&quot;https://laravel-china.org/docs/laravel/5.6/logging/1374&quot; t
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel定时任务</title>
    <link href="bighua.top/2018/07/26/laravel%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>bighua.top/2018/07/26/laravel定时任务/</id>
    <published>2018-07-26T11:05:44.000Z</published>
    <updated>2018-10-30T11:56:56.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac下laravel定时任务"><a href="#mac下laravel定时任务" class="headerlink" title="mac下laravel定时任务"></a>mac下laravel定时任务</h3><h4 id="添加Cron条目到mac（服务器）"><a href="#添加Cron条目到mac（服务器）" class="headerlink" title="添加Cron条目到mac（服务器）"></a>添加Cron条目到mac（服务器）</h4><p>文档：<a href="http://www.runoob.com/linux/linux-comm-crontab.html" target="_blank" rel="noopener">crontab</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab服务的重启关闭，开启</span><br><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure><p>将php artisan schedule:run 添加到crontab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>* * * * *</code>分别代表每小时中第几分钟、每天中第几小时、每月中第几日、每年中第几月、每周中第几天。<code>/usr/bin/php</code>为php执行路径（cli）。<code>/Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run</code>为项目<code>artisan</code>路径，要执行的命令。<code>&gt;&gt; /dev/null</code>表示将标准输出重定向到<code>/dev/null</code>（空设备文件）中（丢弃标准输出），<code>2&gt;&amp;1</code>将错误输出和标准输出绑定在一起，使用同一个文件描述符。</p><p>查看设置的定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h4 id="任务调度书写"><a href="#任务调度书写" class="headerlink" title="任务调度书写"></a>任务调度书写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected function schedule(Schedule $schedule)</span><br><span class="line">&#123;</span><br><span class="line">$schedule-&gt;call(function () &#123;</span><br><span class="line">            $addUserInfoIntoredis = new UserInfoController();</span><br><span class="line">           $addUserInfoIntoredis-&gt;addUsersInfo();</span><br><span class="line">        &#125;)-&gt;everyMinute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserInfoController的addUsersInfo方法中取数据库今日注册新用户添加到redis中。其中的逻辑省略。</p><h3 id="调用钉钉接口发送新用户注册通知"><a href="#调用钉钉接口发送新用户注册通知" class="headerlink" title="调用钉钉接口发送新用户注册通知"></a>调用钉钉接口发送新用户注册通知</h3><p>Guzzle文档：<a href="http://guzzle-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Guzzle中文文档</a>。</p><p>自定义钉钉机器人：<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.vcNk2y&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">自定义机器人</a>。</p><p>坑点：文档中对各种请求方式的参数未做详细说明，钉钉机器人需要以post请求发送json格式的数据，Guzzle发送请求中的第三项参数（数组）为要发送的数据，键名代表着要发送的数据的格式，键值（真正发送的数据）为发送的数据。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$client = new Client([</span><br><span class="line">            &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">        ]);</span><br><span class="line">$data = [</span><br><span class="line">       &apos;json&apos; =&gt; [</span><br><span class="line">       &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">       &apos;text&apos; =&gt; [</span><br><span class="line">              &apos;content&apos; =&gt; &apos;新注册用户：&apos;.$req-&gt;get(&apos;name&apos;).&apos;；邮箱：&apos;.$req-&gt;get(&apos;email&apos;).&apos;。&apos;,</span><br><span class="line">                ]</span><br><span class="line">       ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure><p>数据的json代表着以json格式发送数据。</p><h3 id="对发消息进行解偶"><a href="#对发消息进行解偶" class="headerlink" title="对发消息进行解偶"></a>对发消息进行解偶</h3><p>消息发送机制应该做成独立的模块，考虑使用事件和队列。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/events/1389" target="_blank" rel="noopener">事件系统</a>。</p><p>于EventServiceProvider的listen数组中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;App\Events\RegisterMsg&apos; =&gt;[</span><br><span class="line">     &apos;App\Listeners\SendRegisterMsgToRobot&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>生成事件和监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan event:generate</span><br></pre></td></tr></table></figure><p>于事件的构造函数中接收事件的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> * @var </span><br><span class="line"> */</span><br><span class="line">public $info;</span><br><span class="line">/**</span><br><span class="line"> * Create a new event instance.</span><br><span class="line"> *</span><br><span class="line"> * @return void</span><br><span class="line"> */</span><br><span class="line">public function __construct($info)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;info = $info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于监听器SendRegisterMsgToRobot的handle函数中书写业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$info = $event-&gt;info;</span><br><span class="line">$client = new Client([</span><br><span class="line">      &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">]);</span><br><span class="line">$data = [</span><br><span class="line">     &apos;json&apos; =&gt; [</span><br><span class="line">        &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">        &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from EventListener。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">               ]</span><br><span class="line">         ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure><p>使用enent函数触发事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event(new RegisterMsg($info));</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>事件的处理过程可能会引起用户等待。加入队列中进行处理更适合场景。</p><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/queues/1395#260f10" target="_blank" rel="noopener">队列</a>。</p><p>生成任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:job SendRegisterMsg</span><br></pre></td></tr></table></figure><p>于SendRegisterMsg的handle函数中书写业务逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public function handle()</span><br><span class="line">&#123;</span><br><span class="line">    $info = $this-&gt;info;</span><br><span class="line">    $client = new Client([</span><br><span class="line">        &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">    ]);</span><br><span class="line">    $data = [</span><br><span class="line">        &apos;json&apos; =&gt; [</span><br><span class="line">            &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">            &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from job。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">    $client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendRegisterMsg::dispatch($info)</span><br></pre></td></tr></table></figure><h4 id="代码组织及结构调整"><a href="#代码组织及结构调整" class="headerlink" title="代码组织及结构调整"></a>代码组织及结构调整</h4><p>一个大型项目往往是慢慢集成的，添加的每一个模块应该在一个独立的子目录中，与原项目间互不影响。将所有代码文件添加父目录Login。</p><p>反思此消息发送，功能太单一，仅为text消息发送，而钉钉接口支持多种消息类型。若需要发送markdown、link、ActionCard、FeedCard等类型消息，这样写的复用率很低，因考虑进行功能的封装。其次，应该将配置相关的文件单独存放，便于管理配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mac下laravel定时任务&quot;&gt;&lt;a href=&quot;#mac下laravel定时任务&quot; class=&quot;headerlink&quot; title=&quot;mac下laravel定时任务&quot;&gt;&lt;/a&gt;mac下laravel定时任务&lt;/h3&gt;&lt;h4 id=&quot;添加Cron条目到mac（
      
    
    </summary>
    
      <category term="php" scheme="bighua.top/categories/php/"/>
    
    
      <category term="php" scheme="bighua.top/tags/php/"/>
    
      <category term="laravel" scheme="bighua.top/tags/laravel/"/>
    
      <category term="linux" scheme="bighua.top/tags/linux/"/>
    
  </entry>
  
</feed>
