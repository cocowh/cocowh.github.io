<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2020-02-03T10:27:25.628Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pomelo起步</title>
    <link href="bighua.top/2020/02/02/pomelo%E8%B5%B7%E6%AD%A5/"/>
    <id>bighua.top/2020/02/02/pomelo起步/</id>
    <published>2020-02-02T03:23:43.000Z</published>
    <updated>2020-02-03T10:27:25.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考<a href="https://github.com/NetEase/pomelo/wiki/%E5%AE%89%E8%A3%85pomelo" target="_blank" rel="noopener">安装pomelo</a></p><p>按部就班，注意相关版本号，没啥问题</p><h3 id="运行demo"><a href="#运行demo" class="headerlink" title="运行demo"></a>运行demo</h3><p>参考<a href="https://github.com/NetEase/pomelo/wiki/pomelo%E7%9A%84HelloWorld" target="_blank" rel="noopener">pomelo的HelloWorld</a></p><p>按部就班，文档更新有点过时。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>按部就班，根据输出日志可了解大概启动流程。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>运行客户端提示了一些语法问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wuhua:web-server wuhua$ node app </span><br><span class="line">Warning: express.createServer() is deprecated, express</span><br><span class="line">applications no longer inherit from http.Server,</span><br><span class="line">please use:</span><br><span class="line"></span><br><span class="line">  var express = require(&quot;express&quot;);</span><br><span class="line">  var app = express();</span><br><span class="line"></span><br><span class="line">connect.multipart() will be removed in connect 3.0</span><br><span class="line">visit https://github.com/senchalabs/connect/wiki/Connect-3.0 for alternatives</span><br><span class="line">connect.limit() will be removed in connect 3.0</span><br><span class="line">Web server has started.</span><br><span class="line">Please log on http://127.0.0.1:3001/index.html</span><br><span class="line">(node:68041) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated</span><br></pre></td></tr></table></figure><p>根据提示修正找到文件web-server/app.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express.createServer();</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br></pre></td></tr></table></figure><p>再运行无语法提示。</p><p>此依赖的还是express 3.4.8版本，比较旧。</p><h3 id="pomelo命令"><a href="#pomelo命令" class="headerlink" title="pomelo命令"></a>pomelo命令</h3><p>参考<a href="https://github.com/NetEase/pomelo/wiki/pomelo%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">Pomelo命令行工具使用</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">wuhua:web-server wuhua$ which pomelo</span><br><span class="line">/usr/local/bin/pomelo</span><br><span class="line">wuhua:web-server wuhua$ pomelo --help</span><br><span class="line"></span><br><span class="line">  Usage: pomelo [options] [command]</span><br><span class="line"></span><br><span class="line">  Commands:</span><br><span class="line"></span><br><span class="line">    init [path]            create a new application</span><br><span class="line">    start [options]        start the application</span><br><span class="line">    list [options]         list the servers</span><br><span class="line">    add [options]          add a new server</span><br><span class="line">    stop [options]         stop the servers, for multiple servers, use `pomelo stop server-id-1 server-id-2`</span><br><span class="line">    kill [options]         kill the application</span><br><span class="line">    restart [options]      restart the servers, for multiple servers, use `pomelo restart server-id-1 server-id-2`</span><br><span class="line">    masterha [options]     start all the slaves of the master</span><br><span class="line">    *                     </span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --help     output usage information</span><br><span class="line">    -V, --version  output the version number</span><br><span class="line">    </span><br><span class="line">wuhua:web-server wuhua$ pomelo -V</span><br><span class="line">2.2.7</span><br><span class="line">wuhua:web-server wuhua$ pomelo list</span><br><span class="line">try to connect 127.0.0.1:3005</span><br><span class="line">serverId           serverType pid   rss(M) heapTotal(M) heapUsed(M) uptime(m) </span><br><span class="line">connector-server-1 connector  68757 25.46  15.69        14.04       26.30     </span><br><span class="line">master-server-1    master     68756 23.34  13.56        12.07       26.31</span><br></pre></td></tr></table></figure><h4 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h4><p><code>pomelo start</code>可追加可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pomelo start [-e,--env &lt;env&gt;] [-d,--directory &lt;code directory&gt;]</span><br><span class="line">             [-D,--daemon]</span><br></pre></td></tr></table></figure><p>可在&lt;project_dir&gt;/game-server/config/servers.json中为不同的服务器中添加不同参数(node和v8支持的参数)，用来指定和影响node及v8的行为的。例如，当我们想对某一个服务器开启调试的时候，就可以在服务器配置中，增加args配置项，并在args中配置开启调试的端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;connector&quot;:[&#123;&quot;id&quot;:&quot;connector-server-1&quot;, &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:4050, </span><br><span class="line">&quot;clientPort&quot;:3050, &quot;args&quot;:&quot;--debug=[port]&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>practice example：</p><figure class="highlight plain"><figcaption><span>change</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;development&quot;:&#123;</span><br><span class="line">  &quot;connector&quot;: [</span><br><span class="line">  &#123;&quot;id&quot;: &quot;connector-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 3150, &quot;clientHost&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3010, &quot;args&quot;:&quot;--debug=[port]&quot;, &quot;frontend&quot;: true&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>run cli:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wuhua:HelloWorld wuhua$ pwd</span><br><span class="line">/Users/wuhua/Desktop/pomelo/HelloWorld</span><br><span class="line">wuhua:HelloWorld wuhua$ pomelo start -d ./game-server -e development  -D</span><br><span class="line">The application is running in the background now.</span><br><span class="line"></span><br><span class="line">wuhua:HelloWorld wuhua$ pomelo list -h 127.0.0.1 -P 3005 -u admin -p admin</span><br><span class="line">try to connect 127.0.0.1:3005</span><br><span class="line">serverId        serverType pid   rss(M) heapTotal(M) heapUsed(M) uptime(m) </span><br><span class="line">master-server-1 master     70166 38.36  14.06        11.49       0.25</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h3&gt;&lt;p&gt;参考&lt;a href=&quot;https://github.com/NetEase/pomelo/wiki/%E5%AE%89%E8
      
    
    </summary>
    
      <category term="pomelo" scheme="bighua.top/categories/pomelo/"/>
    
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="pomelo" scheme="bighua.top/tags/pomelo/"/>
    
      <category term="nodejs" scheme="bighua.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>简介</title>
    <link href="bighua.top/2019/12/16/%E7%AE%80%E4%BB%8B/"/>
    <id>bighua.top/2019/12/16/简介/</id>
    <published>2019-12-16T11:09:32.000Z</published>
    <updated>2019-12-16T11:11:16.013Z</updated>
    
    <content type="html"><![CDATA[<p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;/p&gt;

      
    
    </summary>
    
      <category term="UNIX网络编程-卷一：套接字联网API" scheme="bighua.top/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8D%B7%E4%B8%80%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97%E8%81%94%E7%BD%91API/"/>
    
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="UNIX" scheme="bighua.top/tags/UNIX/"/>
    
      <category term="TCP/IP" scheme="bighua.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>redis-哨兵</title>
    <link href="bighua.top/2019/09/26/redis-%E5%93%A8%E5%85%B5/"/>
    <id>bighua.top/2019/09/26/redis-哨兵/</id>
    <published>2019-09-26T08:59:08.000Z</published>
    <updated>2019-09-26T09:07:57.962Z</updated>
    
    <content type="html"><![CDATA[<p>Sentinel（哨兵）：由一个或多个Sentinel实例组成Sentinel系统，监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。已下线的主服务器会被继续监视，并在上线时将其设置为新主服务器的从服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sentinel（哨兵）：由一个或多个Sentinel实例组成Sentinel系统，监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="Sentinel" scheme="bighua.top/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>redis-服务器</title>
    <link href="bighua.top/2019/09/24/redis-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>bighua.top/2019/09/24/redis-服务器/</id>
    <published>2019-09-24T14:13:59.000Z</published>
    <updated>2019-09-25T13:51:41.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>经networking网络事件请求解析后调用server.c/processCommand执行命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">/* If this function gets called we already read a whole</span><br><span class="line"> * command, arguments are in the client argv/argc fields.</span><br><span class="line"> * processCommand() execute the command or prepare the</span><br><span class="line"> * server for a bulk read from the client.</span><br><span class="line"> *</span><br><span class="line"> * If C_OK is returned the client is still alive and valid and</span><br><span class="line"> * other operations can be performed by the caller. Otherwise</span><br><span class="line"> * if C_ERR is returned the client was destroyed (i.e. after QUIT). */</span><br><span class="line">int processCommand(client *c) &#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"></span><br><span class="line">    /* The QUIT command is handled separately. Normal command procs will</span><br><span class="line">     * go through checking for replication and QUIT will cause trouble</span><br><span class="line">     * when FORCE_REPLICATION is enabled and would be implemented in</span><br><span class="line">     * a regular command proc. */</span><br><span class="line">    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;quit&quot;)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Now lookup the command and check ASAP about trivial error conditions</span><br><span class="line">     * such as wrong arity, bad command name and so forth. */</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</span><br><span class="line">    if (!c-&gt;cmd) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        sds args = sdsempty();</span><br><span class="line">        int i;</span><br><span class="line">        for (i=1; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; 128; i++)</span><br><span class="line">            args = sdscatprintf(args, &quot;`%.*s`, &quot;, 128-(int)sdslen(args), (char*)c-&gt;argv[i]-&gt;ptr);</span><br><span class="line">        addReplyErrorFormat(c,&quot;unknown command `%s`, with args beginning with: %s&quot;,</span><br><span class="line">            (char*)c-&gt;argv[0]-&gt;ptr, args);</span><br><span class="line">        sdsfree(args);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125; else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplyErrorFormat(c,&quot;wrong number of arguments for &apos;%s&apos; command&quot;,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if the user is authenticated. This check is skipped in case</span><br><span class="line">     * the default user is flagged as &quot;nopass&quot; and is active. */</span><br><span class="line">    int auth_required = !(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    if (auth_required || DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED) &#123;</span><br><span class="line">        /* AUTH and HELLO are valid even in non authenticated state. */</span><br><span class="line">        if (c-&gt;cmd-&gt;proc != authCommand || c-&gt;cmd-&gt;proc == helloCommand) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            addReply(c,shared.noautherr);</span><br><span class="line">            return C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if the user can run this command according to the current</span><br><span class="line">     * ACLs. */</span><br><span class="line">    int acl_retval = ACLCheckCommandPerm(c);</span><br><span class="line">    if (acl_retval != ACL_OK) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        if (acl_retval == ACL_DENIED_CMD)</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                &quot;-NOPERM this user has no permissions to run &quot;</span><br><span class="line">                &quot;the &apos;%s&apos; command or its subcommand&quot;, c-&gt;cmd-&gt;name);</span><br><span class="line">        else</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                &quot;-NOPERM this user has no permissions to access &quot;</span><br><span class="line">                &quot;one of the keys used as arguments&quot;);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If cluster is enabled perform the cluster redirection here.</span><br><span class="line">     * However we don&apos;t perform the redirection if:</span><br><span class="line">     * 1) The sender of this command is our master.</span><br><span class="line">     * 2) The command has no key arguments. */</span><br><span class="line">    if (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        int hashslot;</span><br><span class="line">        int error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">        if (n == NULL || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            if (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            return C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Handle the maxmemory directive.</span><br><span class="line">     *</span><br><span class="line">     * Note that we do not want to reclaim memory if we are here re-entering</span><br><span class="line">     * the event loop since there is a busy Lua script running in timeout</span><br><span class="line">     * condition, to avoid mixing the propagation of scripts with the</span><br><span class="line">     * propagation of DELs due to eviction. */</span><br><span class="line">    if (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;</span><br><span class="line">        /* freeMemoryIfNeeded may flush slave output buffers. This may result</span><br><span class="line">         * into a slave, that may be the active client, to be freed. */</span><br><span class="line">        if (server.current_client == NULL) return C_ERR;</span><br><span class="line"></span><br><span class="line">        /* It was impossible to free enough memory, and the command the client</span><br><span class="line">         * is trying to execute is denied during OOM conditions or the client</span><br><span class="line">         * is in MULTI/EXEC context? Error. */</span><br><span class="line">        if (out_of_memory &amp;&amp;</span><br><span class="line">            (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM ||</span><br><span class="line">             (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp; c-&gt;cmd-&gt;proc != execCommand))) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            addReply(c, shared.oomerr);</span><br><span class="line">            return C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Make sure to use a reasonable amount of memory for client side</span><br><span class="line">     * caching metadata. */</span><br><span class="line">    if (server.tracking_clients) trackingLimitUsedSlots();</span><br><span class="line"></span><br><span class="line">    /* Don&apos;t accept write commands if there are problems persisting on disk</span><br><span class="line">     * and if this is a master instance. */</span><br><span class="line">    int deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">    if (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span><br><span class="line">        server.masterhost == NULL &amp;&amp;</span><br><span class="line">        (c-&gt;cmd-&gt;flags &amp; CMD_WRITE ||</span><br><span class="line">         c-&gt;cmd-&gt;proc == pingCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        if (deny_write_type == DISK_ERROR_TYPE_RDB)</span><br><span class="line">            addReply(c, shared.bgsaveerr);</span><br><span class="line">        else</span><br><span class="line">            addReplySds(c,</span><br><span class="line">                sdscatprintf(sdsempty(),</span><br><span class="line">                &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,</span><br><span class="line">                strerror(server.aof_last_write_errno)));</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Don&apos;t accept write commands if there are not enough good slaves and</span><br><span class="line">     * user configured the min-slaves-to-write option. */</span><br><span class="line">    if (server.masterhost == NULL &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_to_write &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_max_lag &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE &amp;&amp;</span><br><span class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span><br><span class="line">    &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReply(c, shared.noreplicaserr);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Don&apos;t accept write commands if this is a read only slave. But</span><br><span class="line">     * accept write commands if this is our master. */</span><br><span class="line">    if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;flags &amp; CMD_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, shared.roslaveerr);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Only allow a subset of commands in the context of Pub/Sub if the</span><br><span class="line">     * connection is in RESP2 mode. With RESP3 there are no limits. */</span><br><span class="line">    if ((c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp; c-&gt;resp == 2) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</span><br><span class="line">        addReplyError(c,&quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context&quot;);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Only allow commands with flag &quot;t&quot;, such as INFO, SLAVEOF and so on,</span><br><span class="line">     * when slave-serve-stale-data is no and we are a slave with a broken</span><br><span class="line">     * link with master. */</span><br><span class="line">    if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        server.repl_serve_stale_data == 0 &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; CMD_STALE))</span><br><span class="line">    &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReply(c, shared.masterdownerr);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Loading DB? Return an error if the command has not the</span><br><span class="line">     * CMD_LOADING flag. */</span><br><span class="line">    if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING)) &#123;</span><br><span class="line">        addReply(c, shared.loadingerr);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Lua script too slow? Only allow a limited number of commands. */</span><br><span class="line">    if (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == 2 &amp;&amp;</span><br><span class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;n&apos;) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == 2 &amp;&amp;</span><br><span class="line">          tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == &apos;k&apos;))</span><br><span class="line">    &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReply(c, shared.slowscripterr);</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Exec the command */</span><br><span class="line">    if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        if (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p>客户端讲命令请求转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><h4 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h4><p>套接字可读，服务器调用命令请求处理器：</p><ul><li>读取协议格式命令请求，保存到客户端输入缓冲区</li><li>解析输入缓冲区命令请求，提取命令参数、命令、命令个数，server.h/redisServer.clients.argc、redisServer.clients.argv</li><li>调用命令执行器，执行客户端指定的指令</li></ul><p>读取解析部分在网络IO请求networking.c。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/* Parse the flags string description &apos;strflags&apos; and set them to the</span><br><span class="line"> * command &apos;c&apos;. If the flags are all valid C_OK is returned, otherwise</span><br><span class="line"> * C_ERR is returned (yet the recognized flags are set in the command). */</span><br><span class="line">int populateCommandTableParseFlags(struct redisCommand *c, char *strflags) &#123;</span><br><span class="line">    int argc;</span><br><span class="line">    sds *argv;</span><br><span class="line"></span><br><span class="line">    /* Split the line into arguments for processing. */</span><br><span class="line">    argv = sdssplitargs(strflags,&amp;argc);</span><br><span class="line">    if (argv == NULL) return C_ERR;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; argc; j++) &#123;</span><br><span class="line">        char *flag = argv[j];</span><br><span class="line">        if (!strcasecmp(flag,&quot;write&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_WRITE|CMD_CATEGORY_WRITE;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;read-only&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_READONLY|CMD_CATEGORY_READ;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;use-memory&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_DENYOOM;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;admin&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_ADMIN|CMD_CATEGORY_ADMIN|CMD_CATEGORY_DANGEROUS;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;pub-sub&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_PUBSUB|CMD_CATEGORY_PUBSUB;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;no-script&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_NOSCRIPT;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;random&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_RANDOM;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;to-sort&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_SORT_FOR_SCRIPT;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;ok-loading&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_LOADING;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;ok-stale&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_STALE;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;no-monitor&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_SKIP_MONITOR;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;no-slowlog&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_SKIP_SLOWLOG;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;cluster-asking&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_ASKING;</span><br><span class="line">        &#125; else if (!strcasecmp(flag,&quot;fast&quot;)) &#123;</span><br><span class="line">            c-&gt;flags |= CMD_FAST | CMD_CATEGORY_FAST;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* Parse ACL categories here if the flag name starts with @. */</span><br><span class="line">            uint64_t catflag;</span><br><span class="line">            if (flag[0] == &apos;@&apos; &amp;&amp;</span><br><span class="line">                (catflag = ACLGetCommandCategoryFlagByName(flag+1)) != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                c-&gt;flags |= catflag;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sdsfreesplitres(argv,argc);</span><br><span class="line">                return C_ERR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /* If it&apos;s not @fast is @slow in this binary world. */</span><br><span class="line">    if (!(c-&gt;flags &amp; CMD_CATEGORY_FAST)) c-&gt;flags |= CMD_CATEGORY_SLOW;</span><br><span class="line"></span><br><span class="line">    sdsfreesplitres(argv,argc);</span><br><span class="line">    return C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Populates the Redis Command Table starting from the hard coded list</span><br><span class="line"> * we have on top of redis.c file. */</span><br><span class="line">void populateCommandTable(void) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt; numcommands; j++) &#123;</span><br><span class="line">        struct redisCommand *c = redisCommandTable+j;</span><br><span class="line">        int retval1, retval2;</span><br><span class="line"></span><br><span class="line">        /* Translate the command string flags description into an actual</span><br><span class="line">         * set of flags. */</span><br><span class="line">        if (populateCommandTableParseFlags(c,c-&gt;sflags) == C_ERR)</span><br><span class="line">            serverPanic(&quot;Unsupported command flag&quot;);</span><br><span class="line"></span><br><span class="line">        c-&gt;id = ACLGetCommandID(c-&gt;name); /* Assign the ID used for ACL. */</span><br><span class="line">        retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</span><br><span class="line">        /* Populate an additional dictionary that will be unaffected</span><br><span class="line">         * by rename-command statements in redis.conf. */</span><br><span class="line">        retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</span><br><span class="line">        serverAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令执行器查找命令实现"><a href="#命令执行器查找命令实现" class="headerlink" title="命令执行器查找命令实现"></a>命令执行器查找命令实现</h4><p>在server.c/redisCommandTable中查找argv[0]所指定命令，将找到的命令保存到客户端状态的server.h/redisServer.clients.cmd属性中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    int arity;</span><br><span class="line">    char *sflags;   /* Flags as string representation, one char per flag. */</span><br><span class="line">    uint64_t flags; /* The actual flags, obtained from the &apos;sflags&apos; field. */</span><br><span class="line">    /* Use a function to determine keys arguments in a command line.</span><br><span class="line">     * Used for Redis Cluster redirect. */</span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    /* What keys should be loaded in background when calling this command? */</span><br><span class="line">    int firstkey; /* The first argument that&apos;s a key (0 = no keys) */</span><br><span class="line">    int lastkey;  /* The last argument that&apos;s a key */</span><br><span class="line">    int keystep;  /* The step between first and last key */</span><br><span class="line">    long long microseconds, calls;</span><br><span class="line">    int id;     /* Command ID. This is a progressive ID starting from 0 that</span><br><span class="line">                   is assigned at runtime, and is used in order to check</span><br><span class="line">                   ACLs. A connection is able to execute a given command if</span><br><span class="line">                   the user associated to the connection has this command</span><br><span class="line">                   bit set in the bitmap of allowed commands. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="命令执行器执行预备操作"><a href="#命令执行器执行预备操作" class="headerlink" title="命令执行器执行预备操作"></a>命令执行器执行预备操作</h4><h4 id="命令执行器调用命令执行函数"><a href="#命令执行器调用命令执行函数" class="headerlink" title="命令执行器调用命令执行函数"></a>命令执行器调用命令执行函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">/* Call() is the core of Redis execution of a command.</span><br><span class="line"> *</span><br><span class="line"> * The following flags can be passed:</span><br><span class="line"> * CMD_CALL_NONE        No flags.</span><br><span class="line"> * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.</span><br><span class="line"> * CMD_CALL_STATS       Populate command stats.</span><br><span class="line"> * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset</span><br><span class="line"> *                          or if the client flags are forcing propagation.</span><br><span class="line"> * CMD_CALL_PROPAGATE_REPL  Send command to salves if it modified the dataset</span><br><span class="line"> *                          or if the client flags are forcing propagation.</span><br><span class="line"> * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.</span><br><span class="line"> * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.</span><br><span class="line"> *</span><br><span class="line"> * The exact propagation behavior depends on the client flags.</span><br><span class="line"> * Specifically:</span><br><span class="line"> *</span><br><span class="line"> * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set</span><br><span class="line"> *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set</span><br><span class="line"> *    in the call flags, then the command is propagated even if the</span><br><span class="line"> *    dataset was not affected by the command.</span><br><span class="line"> * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP</span><br><span class="line"> *    are set, the propagation into AOF or to slaves is not performed even</span><br><span class="line"> *    if the command modified the dataset.</span><br><span class="line"> *</span><br><span class="line"> * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF</span><br><span class="line"> * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or</span><br><span class="line"> * slaves propagation will never occur.</span><br><span class="line"> *</span><br><span class="line"> * Client flags are modified by the implementation of a given command</span><br><span class="line"> * using the following API:</span><br><span class="line"> *</span><br><span class="line"> * forceCommandPropagation(client *c, int flags);</span><br><span class="line"> * preventCommandPropagation(client *c);</span><br><span class="line"> * preventCommandAOF(client *c);</span><br><span class="line"> * preventCommandReplication(client *c);</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">void call(client *c, int flags) &#123;</span><br><span class="line">    long long dirty, start, duration;</span><br><span class="line">    int client_old_flags = c-&gt;flags;</span><br><span class="line">    struct redisCommand *real_cmd = c-&gt;cmd;</span><br><span class="line"></span><br><span class="line">    /* Sent the command to clients in MONITOR mode, only if the commands are</span><br><span class="line">     * not generated from reading an AOF. */</span><br><span class="line">    if (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Initialization: clear the flags that must be set by the command on</span><br><span class="line">     * demand, and initialize the array for additional commands propagation. */</span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    redisOpArray prev_also_propagate = server.also_propagate;</span><br><span class="line">    redisOpArrayInit(&amp;server.also_propagate);</span><br><span class="line"></span><br><span class="line">    /* Call the command. */</span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    start = ustime();</span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">    duration = ustime()-start;</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">    if (dirty &lt; 0) dirty = 0;</span><br><span class="line"></span><br><span class="line">    /* When EVAL is called loading the AOF we don&apos;t want commands called</span><br><span class="line">     * from Lua to go into the slowlog or to populate statistics. */</span><br><span class="line">    if (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span><br><span class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span><br><span class="line"></span><br><span class="line">    /* If the caller is Lua, we want to force the EVAL caller to propagate</span><br><span class="line">     * the script if the command flag or client flag are forcing the</span><br><span class="line">     * propagation. */</span><br><span class="line">    if (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Log the command into the Slow log if needed, and populate the</span><br><span class="line">     * per-command statistics that we show in INFO commandstats. */</span><br><span class="line">    if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_SKIP_SLOWLOG)) &#123;</span><br><span class="line">        char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              &quot;fast-command&quot; : &quot;command&quot;;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/1000);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (flags &amp; CMD_CALL_STATS) &#123;</span><br><span class="line">        /* use the real command that was executed (cmd and lastamc) may be</span><br><span class="line">         * different, in case of MULTI-EXEC or re-written commands such as</span><br><span class="line">         * EXPIRE, GEOADD, etc. */</span><br><span class="line">        real_cmd-&gt;microseconds += duration;</span><br><span class="line">        real_cmd-&gt;calls++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Propagate the command into the AOF and replication link */</span><br><span class="line">    if (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        int propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        /* Check if the command operated changes in the data set. If so</span><br><span class="line">         * set for replication / AOF propagation. */</span><br><span class="line">        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        /* If the client forced AOF / replication of the command, set</span><br><span class="line">         * the flags regardless of the command effects on the data set. */</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        /* However prevent AOF / replication propagation if the command</span><br><span class="line">         * implementations called preventCommandPropagation() or similar,</span><br><span class="line">         * or if we don&apos;t have the call() flags to do so. */</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        if (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        /* Call propagate() only if at least one of AOF / replication</span><br><span class="line">         * propagation is needed. Note that modules commands handle replication</span><br><span class="line">         * in an explicit way, so we never replicate them automatically. */</span><br><span class="line">        if (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Restore the old replication flags, since call() can be executed</span><br><span class="line">     * recursively. */</span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line"></span><br><span class="line">    /* Handle the alsoPropagate() API to handle commands that want to propagate</span><br><span class="line">     * multiple separated commands. Note that alsoPropagate() is not affected</span><br><span class="line">     * by CLIENT_PREVENT_PROP flag. */</span><br><span class="line">    if (server.also_propagate.numops) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        redisOp *rop;</span><br><span class="line"></span><br><span class="line">        if (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">            for (j = 0; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">                rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">                int target = rop-&gt;target;</span><br><span class="line">                /* Whatever the command wish is, we honor the call() flags. */</span><br><span class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">                if (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">                if (target)</span><br><span class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line">    &#125;</span><br><span class="line">    server.also_propagate = prev_also_propagate;</span><br><span class="line"></span><br><span class="line">    /* If the client has keys tracking enabled for client side caching,</span><br><span class="line">     * make sure to remember the keys it fetched via this command. */</span><br><span class="line">    if (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">        client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                            server.lua_caller : c;</span><br><span class="line">        if (caller-&gt;flags &amp; CLIENT_TRACKING)</span><br><span class="line">            trackingRememberKeys(caller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令执行器执行后续工作"><a href="#命令执行器执行后续工作" class="headerlink" title="命令执行器执行后续工作"></a>命令执行器执行后续工作</h4><p>慢日志查询、AOF、主从复制等。</p><h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>networking.c中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Write event handler. Just send data to the client. */</span><br><span class="line">void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) &#123;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    writeToClient(fd,privdata,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>例如redis-cli，cliReadReply将回复命令回复格式化后写入标准输出。</p><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>每隔100毫秒运行一次，负责管理服务器的资源，保持服务器自身的良好运转。</p><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>redisServer.unixtime和redisServer.mstime，不精准，只在打印日志、更新服务器的LRU时钟、决定是否持久化、计算服务器上线时间等对精度要求不高时使用。对键设置过期时间、添加慢日志等高精度服务器再次执行系统调用。</p><h4 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h4><p>redisServer.lruclock，INFO server的lru_clock值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info server</span><br><span class="line"># Server</span><br><span class="line">redis_version:4.0.10</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:ea14acb2d1b3b56f</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Darwin 18.7.0 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:kqueue</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:4.2.1</span><br><span class="line">process_id:440</span><br><span class="line">run_id:cdd4befae14640bdb75dd1ed60c3880aadd8e9d1</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:247596</span><br><span class="line">uptime_in_days:2</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:9135224</span><br><span class="line">executable:/usr/local/opt/redis/bin/redis-server</span><br><span class="line">config_file:/usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure><p>每个Redis对象都有一个时钟保存对象最后一次被命令访问的时间。</p><p>server.h/redisObject.lru。、</p><p>redisServer.lruclock - redisObject.lru即为对象空转时间。</p><h4 id="更新服务器每秒执行次数"><a href="#更新服务器每秒执行次数" class="headerlink" title="更新服务器每秒执行次数"></a>更新服务器每秒执行次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run_with_period(100) &#123;</span><br><span class="line">     trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</span><br><span class="line">     trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</span><br><span class="line">             server.stat_net_input_bytes);</span><br><span class="line">     trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</span><br><span class="line">             server.stat_net_output_bytes);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>serverCron的trackInstantaneousMetric函数没100毫秒执行一次，估算并记录服务器最近一秒钟处理命令请求数量。</p><p>INFO stats的instantaneous_ops_per_sec值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info stats</span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:2</span><br><span class="line">total_commands_processed:6</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">total_net_input_bytes:162</span><br><span class="line">total_net_output_bytes:21919</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">expired_stale_perc:0.00</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:27954</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br></pre></td></tr></table></figure><h4 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h4><p>redisServer.stat_peak_memory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Record the max memory used since the server was started. */</span><br><span class="line">if (zmalloc_used_memory() &gt; server.stat_peak_memory)</span><br><span class="line">    server.stat_peak_memory = zmalloc_used_memory();</span><br></pre></td></tr></table></figure><h4 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h4><p>启动服务器时，为服务器进程的SIGTERM信号关联处理器sigShutdownHandler函数，该函数负责在服务器接到SIGTERM信号时，设置服务器状态的shutdown_asap标识。</p><p>根据redisServer.shutdown_asap属性决定是否关闭服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* We received a SIGTERM, shutting down here in a safe way, as it is</span><br><span class="line">   * not ok doing so inside the signal handler. */</span><br><span class="line">  if (server.shutdown_asap) &#123;</span><br><span class="line">      if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);</span><br><span class="line">      serverLog(LL_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);</span><br><span class="line">      server.shutdown_asap = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* We need to do a few operations on clients asynchronously. */</span><br><span class="line">clientsCron();</span><br></pre></td></tr></table></figure><p>serverCron函数调用clientsCron函数，对一定数量的客户端进行检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* This function is called by serverCron() and is used in order to perform</span><br><span class="line"> * operations on clients that are important to perform constantly. For instance</span><br><span class="line"> * we use this function in order to disconnect clients after a timeout, including</span><br><span class="line"> * clients blocked in some blocking command with a non-zero timeout.</span><br><span class="line"> *</span><br><span class="line"> * The function makes some effort to process all the clients every second, even</span><br><span class="line"> * if this cannot be strictly guaranteed, since serverCron() may be called with</span><br><span class="line"> * an actual frequency lower than server.hz in case of latency events like slow</span><br><span class="line"> * commands.</span><br><span class="line"> *</span><br><span class="line"> * It is very important for this function, and the functions it calls, to be</span><br><span class="line"> * very fast: sometimes Redis has tens of hundreds of connected clients, and the</span><br><span class="line"> * default server.hz value is 10, so sometimes here we need to process thousands</span><br><span class="line"> * of clients per second, turning this function into a source of latency.</span><br><span class="line"> */</span><br><span class="line">#define CLIENTS_CRON_MIN_ITERATIONS 5</span><br><span class="line">void clientsCron(void) &#123;</span><br><span class="line">    /* Try to process at least numclients/server.hz of clients</span><br><span class="line">     * per call. Since normally (if there are no big latency events) this</span><br><span class="line">     * function is called server.hz times per second, in the average case we</span><br><span class="line">     * process all the clients in 1 second. */</span><br><span class="line">    int numclients = listLength(server.clients);</span><br><span class="line">    int iterations = numclients/server.hz;</span><br><span class="line">    mstime_t now = mstime();</span><br><span class="line"></span><br><span class="line">    /* Process at least a few clients while we are at it, even if we need</span><br><span class="line">     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract</span><br><span class="line">     * of processing each client once per second. */</span><br><span class="line">    if (iterations &lt; CLIENTS_CRON_MIN_ITERATIONS)</span><br><span class="line">        iterations = (numclients &lt; CLIENTS_CRON_MIN_ITERATIONS) ?</span><br><span class="line">                     numclients : CLIENTS_CRON_MIN_ITERATIONS;</span><br><span class="line"></span><br><span class="line">    while(listLength(server.clients) &amp;&amp; iterations--) &#123;</span><br><span class="line">        client *c;</span><br><span class="line">        listNode *head;</span><br><span class="line"></span><br><span class="line">        /* Rotate the list, take the current head, process.</span><br><span class="line">         * This way if the client must be removed from the list it&apos;s the</span><br><span class="line">         * first element and we don&apos;t incur into O(N) computation. */</span><br><span class="line">        listRotate(server.clients);</span><br><span class="line">        head = listFirst(server.clients);</span><br><span class="line">        c = listNodeValue(head);</span><br><span class="line">        /* The following functions do different service checks on the client.</span><br><span class="line">         * The protocol is that they return non-zero if the client was</span><br><span class="line">         * terminated. */</span><br><span class="line">        if (clientsCronHandleTimeout(c,now)) continue;</span><br><span class="line">        if (clientsCronResizeQueryBuffer(c)) continue;</span><br><span class="line">        if (clientsCronTrackExpansiveClients(c)) continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>连接超时，释放客户端。</li><li>输入缓冲区超限重新创建扩容。</li></ul><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Handle background operations on Redis databases. */</span><br><span class="line">  databasesCron();</span><br></pre></td></tr></table></figure><p>对服务器中的一部分数据库进行检查，删除其中的过期键，在有需要时对字典进行收缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* This function handles &apos;background&apos; operations we are required to do</span><br><span class="line"> * incrementally in Redis databases, such as active key expiring, resizing,</span><br><span class="line"> * rehashing. */</span><br><span class="line">void databasesCron(void) &#123;</span><br><span class="line">    /* Expire keys by random sampling. Not required for slaves</span><br><span class="line">     * as master will synthesize DELs for us. */</span><br><span class="line">    if (server.active_expire_enabled) &#123;</span><br><span class="line">        if (server.masterhost == NULL) &#123;</span><br><span class="line">            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            expireSlaveKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Defrag keys gradually. */</span><br><span class="line">    if (server.active_defrag_enabled)</span><br><span class="line">        activeDefragCycle();</span><br><span class="line"></span><br><span class="line">    /* Perform hash tables rehashing if needed, but only if there are no</span><br><span class="line">     * other processes saving the DB on disk. Otherwise rehashing is bad</span><br><span class="line">     * as will cause a lot of copy-on-write of memory pages. */</span><br><span class="line">    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) &#123;</span><br><span class="line">        /* We use global counters so if we stop the computation at a given</span><br><span class="line">         * DB we&apos;ll be able to start from the successive in the next</span><br><span class="line">         * cron loop iteration. */</span><br><span class="line">        static unsigned int resize_db = 0;</span><br><span class="line">        static unsigned int rehash_db = 0;</span><br><span class="line">        int dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        /* Don&apos;t test more DBs than we have. */</span><br><span class="line">        if (dbs_per_call &gt; server.dbnum) dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">        /* Resize */</span><br><span class="line">        for (j = 0; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum);</span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Rehash */</span><br><span class="line">        if (server.activerehashing) &#123;</span><br><span class="line">            for (j = 0; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                int work_done = incrementallyRehash(rehash_db);</span><br><span class="line">                if (work_done) &#123;</span><br><span class="line">                    /* If the function did some work, stop here, we&apos;ll do</span><br><span class="line">                     * more at the next cron loop. */</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    /* If this db didn&apos;t need rehash, we&apos;ll try the next one. */</span><br><span class="line">                    rehash_db++;</span><br><span class="line">                    rehash_db %= server.dbnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Start a scheduled AOF rewrite if this was requested by the user while</span><br><span class="line"> * a BGSAVE was in progress. */</span><br><span class="line">if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</span><br><span class="line">    server.aof_rewrite_scheduled)</span><br><span class="line">&#123;</span><br><span class="line">    rewriteAppendOnlyFileBackground();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>seerver.c-&gt;main调用initServerConfig初始化server变量：</p><ul><li>设置服务器的运行ID</li><li>设置服务器的默认运行频率</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件</li><li>初始化服务器的LRU时钟</li><li>创建命令表</li></ul><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><ul><li>若为属性的相应选项指定新的值，服务器使用指定值更新相应的属性</li><li>若没有为属性的相应选项设置新的值，沿用initServerConfig函数为属性设置的默认值</li></ul><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>调用initServer函数，为server.clients、server.db、server.pubsub_channels、server.lua、server.slowlog等分配内存或者关联初始化值。</p><p>initServerConfig主要初始化一般属性、initServer主要负责初始化数据结构。</p><p>还进行：</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象。</li><li>打开服务器的监听端口，为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</li><li>若AOF持久化功能已打开，则打开现有的AOF文件，若AOF文件不存在则创建并打开一个新的AOF文件，为AOF写入做好准备。</li><li>初始化服务器的后台I/O模块（bio），为I/O操作做准备。</li></ul><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>完成对服务器server变量的初始化后，服务器载入RDB文件或AOF文件，根据文件记录的内容来还原服务器的数据库状态。</p><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>执行服务器的事件循环（loop），服务器可接受客户端的连接请求，并处理客户端发来的命令请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;命令请求的执行过程&quot;&gt;&lt;a href=&quot;#命令请求的执行过程&quot; class=&quot;headerlink&quot; title=&quot;命令请求的执行过程&quot;&gt;&lt;/a&gt;命令请求的执行过程&lt;/h3&gt;&lt;p&gt;经networking网络事件请求解析后调用server.c/processComm
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="server" scheme="bighua.top/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>redis-客户端</title>
    <link href="bighua.top/2019/09/24/redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>bighua.top/2019/09/24/redis-客户端/</id>
    <published>2019-09-24T11:25:51.000Z</published>
    <updated>2019-09-24T14:10:53.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>redis服务器通过I/O多路复用技术实现的文件事件处理器，使用单线程单进程处理命令请求，并与多个客户端进行网络通信。为客户端建立相应的server.h/client结构，保存客户端当前的状态信息，以及执行相关功能时需要用到的数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/* With multiplexing we need to take per-client state.</span><br><span class="line"> * Clients are taken in a linked list. */</span><br><span class="line">typedef struct client &#123;</span><br><span class="line">    uint64_t id;            /* Client incremental unique ID. */</span><br><span class="line">    int fd;                 /* Client socket. */</span><br><span class="line">    int resp;               /* RESP protocol version. Can be 2 or 3. */</span><br><span class="line">    redisDb *db;            /* Pointer to currently SELECTed DB. */</span><br><span class="line">    robj *name;             /* As set by CLIENT SETNAME. */</span><br><span class="line">    sds querybuf;           /* Buffer we use to accumulate client queries. */</span><br><span class="line">    size_t qb_pos;          /* The position we have read in querybuf. */</span><br><span class="line">    sds pending_querybuf;   /* If this client is flagged as master, this buffer</span><br><span class="line">                               represents the yet not applied portion of the</span><br><span class="line">                               replication stream that we are receiving from</span><br><span class="line">                               the master. */</span><br><span class="line">    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */</span><br><span class="line">    int argc;               /* Num of arguments of current command. */</span><br><span class="line">    robj **argv;            /* Arguments of current command. */</span><br><span class="line">    struct redisCommand *cmd, *lastcmd;  /* Last command executed. */</span><br><span class="line">    user *user;             /* User associated with this connection. If the</span><br><span class="line">                               user is set to NULL the connection can do</span><br><span class="line">                               anything (admin). */</span><br><span class="line">    int reqtype;            /* Request protocol type: PROTO_REQ_* */</span><br><span class="line">    int multibulklen;       /* Number of multi bulk arguments left to read. */</span><br><span class="line">    long bulklen;           /* Length of bulk argument in multi bulk request. */</span><br><span class="line">    list *reply;            /* List of reply objects to send to the client. */</span><br><span class="line">    unsigned long long reply_bytes; /* Tot bytes of objects in reply list. */</span><br><span class="line">    size_t sentlen;         /* Amount of bytes already sent in the current</span><br><span class="line">                               buffer or object being sent. */</span><br><span class="line">    time_t ctime;           /* Client creation time. */</span><br><span class="line">    time_t lastinteraction; /* Time of the last interaction, used for timeout */</span><br><span class="line">    time_t obuf_soft_limit_reached_time;</span><br><span class="line">    uint64_t flags;         /* Client flags: CLIENT_* macros. */</span><br><span class="line">    int authenticated;      /* Needed when the default user requires auth. */</span><br><span class="line">    int replstate;          /* Replication state if this is a slave. */</span><br><span class="line">    int repl_put_online_on_ack; /* Install slave write handler on first ACK. */</span><br><span class="line">    int repldbfd;           /* Replication DB file descriptor. */</span><br><span class="line">    off_t repldboff;        /* Replication DB file offset. */</span><br><span class="line">    off_t repldbsize;       /* Replication DB file size. */</span><br><span class="line">    sds replpreamble;       /* Replication DB preamble. */</span><br><span class="line">    long long read_reploff; /* Read replication offset if this is a master. */</span><br><span class="line">    long long reploff;      /* Applied replication offset if this is a master. */</span><br><span class="line">    long long repl_ack_off; /* Replication ack offset, if this is a slave. */</span><br><span class="line">    long long repl_ack_time;/* Replication ack time, if this is a slave. */</span><br><span class="line">    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves</span><br><span class="line">                                       copying this slave output buffer</span><br><span class="line">                                       should use. */</span><br><span class="line">    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */</span><br><span class="line">    int slave_listening_port; /* As configured with: SLAVECONF listening-port */</span><br><span class="line">    char slave_ip[NET_IP_STR_LEN]; /* Optionally given by REPLCONF ip-address */</span><br><span class="line">    int slave_capa;         /* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span><br><span class="line">    multiState mstate;      /* MULTI/EXEC state */</span><br><span class="line">    int btype;              /* Type of blocking op if CLIENT_BLOCKED. */</span><br><span class="line">    blockingState bpop;     /* blocking state */</span><br><span class="line">    long long woff;         /* Last write global replication offset. */</span><br><span class="line">    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */</span><br><span class="line">    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */</span><br><span class="line">    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */</span><br><span class="line">    sds peerid;             /* Cached peer ID. */</span><br><span class="line">    listNode *client_list_node; /* list node in client list */</span><br><span class="line"></span><br><span class="line">    /* If this client is in tracking mode and this field is non zero,</span><br><span class="line">     * invalidation messages for keys fetched by this client will be send to</span><br><span class="line">     * the specified client ID. */</span><br><span class="line">    uint64_t client_tracking_redirection;</span><br><span class="line"></span><br><span class="line">    /* Response buffer */</span><br><span class="line">    int bufpos;</span><br><span class="line">    char buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>redisServer.clients是一个保存了所有与服务器连接的客户端的状态结构。</p><p>客户端套接字描述符fd为-1（伪客户端，载入AOF或执行Lua脚本）或大于-1的整数，CLIENT list列出所有客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=3 addr=127.0.0.1:61374 fd=9 name= age=21 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">id=4 addr=127.0.0.1:61378 fd=10 name= age=2 idle=2 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=command</span><br></pre></td></tr></table></figure><p>可使用CLIENT setname为客户端设置名字。</p><p>client.flags记录客户端的角色，以及客户端目前所处的状态。</p><p>client.querybuf为客户端的输入缓冲区，用于保存客户端发送的命令请求。</p><p>对命令请求进行分析，将得出的命令参数以及命令参数的个数分别保存到client.argv和client.argc中。argv[0]是要执行的命令，之后的项是传给命令的参数。</p><p>在命令表server.c/redisCommandTable中查找命令对应的实现函数，找到后将client.cmd指针指向这个结构。然后服务器可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息。</p><p>执行命令所得回复保存在客户端状态的输出缓冲区，一个固定大小的缓冲区（client.buf：字节数组、client.bufpos：已使用字节数量）用于保存长度较小的回复，可变大小缓冲区（client.reply：链表连接多个字符串对象）用于保存长度比较大的回复。</p><p>client.authenticated属性记录客户端是否通过了身份验证，0表示未通过，1表示通过。仅在服务器启用了身份验证功能时使用，未通过时除了auth命令所有的命令被拒绝。server.c：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* If this function gets called we already read a whole</span><br><span class="line"> * command, arguments are in the client argv/argc fields.</span><br><span class="line"> * processCommand() execute the command or prepare the</span><br><span class="line"> * server for a bulk read from the client.</span><br><span class="line"> *</span><br><span class="line"> * If C_OK is returned the client is still alive and valid and</span><br><span class="line"> * other operations can be performed by the caller. Otherwise</span><br><span class="line"> * if C_ERR is returned the client was destroyed (i.e. after QUIT). */</span><br><span class="line">int processCommand(client *c) &#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"> ...</span><br><span class="line">    /* Check if the user is authenticated. This check is skipped in case</span><br><span class="line">     * the default user is flagged as &quot;nopass&quot; and is active. */</span><br><span class="line">    int auth_required = !(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    if (auth_required || DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED) &#123;</span><br><span class="line">        /* AUTH and HELLO are valid even in non authenticated state. */</span><br><span class="line">        if (c-&gt;cmd-&gt;proc != authCommand || c-&gt;cmd-&gt;proc == helloCommand) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            addReply(c,shared.noautherr);</span><br><span class="line">            return C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.ctime记录创建客户端的时间，可用来计算客户端与服务器已经连接了多少秒，CLIENT list的age域记录该值。client.lastinteraction记录客户端与服务器最后一次进行互动的时间，可用于计算客户端的空转时间，CLIENT list的idle域记录该值。client.obuf_soft_limit_reached_time记录输出缓冲区第一次到达软性限制（soft limit）的时间。</p><h3 id="客户端创建与关闭"><a href="#客户端创建与关闭" class="headerlink" title="客户端创建与关闭"></a>客户端创建与关闭</h3><p>若是通过网络连接与服务器进行连接的普通客户端，在客户端使用connect函数连接服务器时，服务器调用连接事件处理器，为客户端创建相应的客户端状态，并将新的客户端状态添加到服务器状态的clients链表末尾。</p><p>特殊情况如：发送的命令请求或命令回复超过了输入/输出缓冲区的限制大小被服务器关闭，设置了timeout配置选项后空转时长超过该值被服务器关闭（订阅发布或主从阻塞除外）。</p><p>限制客户端输出缓冲区的大小：</p><ul><li>硬性限制：超过硬性限制大小服务器立即关闭客户端。</li><li>软性限制：超过软性限制（client.obuf_soft_limit_reached_time记录起始时间）但未超过硬性限制持续时间达到服务器设定的时长，则服务器关闭客户端，持续时间为超过则清零client.obuf_soft_limit_reached_time。</li></ul><h4 id="Lua脚本伪客户端"><a href="#Lua脚本伪客户端" class="headerlink" title="Lua脚本伪客户端"></a>Lua脚本伪客户端</h4><p>服务器初始化时创建执行Lua脚本中包含Redis命令的伪客户端，并将伪客户端关联在服务器状态结构的lua_client属性中。在服务器运行的整个生命期中一直存在，只有服务器被关闭时才会被关闭。</p><h4 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h4><p>服务器在载入AOF文件时，创建用于执行AOF文件包含的Redis命令的伪客户端，在载入完成后关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户端属性&quot;&gt;&lt;a href=&quot;#客户端属性&quot; class=&quot;headerlink&quot; title=&quot;客户端属性&quot;&gt;&lt;/a&gt;客户端属性&lt;/h3&gt;&lt;p&gt;redis服务器通过I/O多路复用技术实现的文件事件处理器，使用单线程单进程处理命令请求，并与多个客户端进行网络通信
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="client" scheme="bighua.top/tags/client/"/>
    
  </entry>
  
  <entry>
    <title>redis-事件</title>
    <link href="bighua.top/2019/09/23/redis-%E4%BA%8B%E4%BB%B6/"/>
    <id>bighua.top/2019/09/23/redis-事件/</id>
    <published>2019-09-23T09:35:53.000Z</published>
    <updated>2019-09-24T11:22:31.429Z</updated>
    
    <content type="html"><![CDATA[<ul><li>文件事件，服务器对套接字操作的抽象，通过监听并处理这些事件完成一系列的网络通信操作。</li><li>时间事件：对定时操作的抽象。</li></ul><p>ae*系列文件，ae.h定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define AE_FILE_EVENTS 1</span><br><span class="line">#define AE_TIME_EVENTS 2</span><br></pre></td></tr></table></figure><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>基于<a href="https://www.jianshu.com/p/eef7ebe28673" target="_blank" rel="noopener">Reactor</a>模式开发的网络事件处理器，被称为文件事件处理器：</p><ul><li>使用I/O多路复用程序同监听多个套接字，根据套接字目前执行的任务为套接字关联不同的事件处理器。</li><li>被监听套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相应的文件事件就会产生，文件事件处理器调用套接字之前关联好的事件处理器处理这些事件。</li></ul><p>单线程方式运行。包含四个组成部分：</p><ul><li>套接字：根据操作产生相应的文件事件。</li><li>I/O多路复用程序：监听多个套接字并将所有产生事件的套接字放入队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字，上个套接字产生的事件处理完毕后才派发下一个套接字。</li><li>文件事件分派器：接收I/O多路复用程序传来的套接字，根据套接字产生的事件的类型，调用相应的事件处理器。</li><li>事件处理器：一个个函数，定义某个事件发生时，服务器应该执行的动作。</li></ul><p>多路复用程序包装select(ae_select.c)、epoll(ae_epoll.c)、evport(ae_evport.c)、kqueue(ae_kqueue.c)等I/O多路复用函数实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Include the best multiplexing layer supported by this system.</span><br><span class="line"> * The following should be ordered by performances, descending. */</span><br><span class="line">#ifdef HAVE_EVPORT</span><br><span class="line">#include &quot;ae_evport.c&quot;</span><br><span class="line">#else</span><br><span class="line">    #ifdef HAVE_EPOLL</span><br><span class="line">    #include &quot;ae_epoll.c&quot;</span><br><span class="line">    #else</span><br><span class="line">        #ifdef HAVE_KQUEUE</span><br><span class="line">        #include &quot;ae_kqueue.c&quot;</span><br><span class="line">        #else</span><br><span class="line">        #include &quot;ae_select.c&quot;</span><br><span class="line">        #endif</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>选择系统中能提供的，性能最高的I/O多路复用函数库，有优先级次序。</p><p>事件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define AE_NONE 0       /* No events registered. */</span><br><span class="line">#define AE_READABLE 1   /* Fire when descriptor is readable. */</span><br><span class="line">#define AE_WRITABLE 2   /* Fire when descriptor is writable. */</span><br><span class="line">#define AE_BARRIER 4    /* With WRITABLE, never fire the event if the</span><br><span class="line">                           READABLE event already fired in the same event</span><br><span class="line">                           loop iteration. Useful when you want to persist</span><br><span class="line">                           things to disk before sending replies, and want</span><br><span class="line">                           to do that in a group fashion. */</span><br></pre></td></tr></table></figure><p>文件事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* File event structure */</span><br><span class="line">typedef struct aeFileEvent &#123;</span><br><span class="line">    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */</span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    void *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul><li>连接应答处理器：networking.c/acceptTcpHandler</li><li>命令请求处理器：networking.c/readQueryFromClient</li><li>命令回复处理器：networking.c/sendReplyToClient</li></ul><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><ul><li>定时事件</li><li>周期性事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Time event structure */</span><br><span class="line">typedef struct aeTimeEvent &#123;</span><br><span class="line">    long long id; /* time event identifier. */</span><br><span class="line">    long when_sec; /* seconds */</span><br><span class="line">    long when_ms; /* milliseconds */</span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    void *clientData;</span><br><span class="line">    struct aeTimeEvent *prev;</span><br><span class="line">    struct aeTimeEvent *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>将时间事件放在一个无序链表中，时间事件执行器运行时遍历整个链表，查找所有已到达的时间事件，调用相应的事件处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;文件事件，服务器对套接字操作的抽象，通过监听并处理这些事件完成一系列的网络通信操作。&lt;/li&gt;
&lt;li&gt;时间事件：对定时操作的抽象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ae*系列文件，ae.h定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="reids" scheme="bighua.top/tags/reids/"/>
    
      <category term="event" scheme="bighua.top/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>redis-AOF持久化</title>
    <link href="bighua.top/2019/09/19/redis-AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>bighua.top/2019/09/19/redis-AOF持久化/</id>
    <published>2019-09-19T08:57:17.000Z</published>
    <updated>2019-09-23T09:32:44.735Z</updated>
    
    <content type="html"><![CDATA[<p>RDB持久化通过保存数据库中的键值对来记录数据库状态的不同，AOF持久化通过保存Redis服务器所执行的写命令来记录数据状态。</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>redis.conf的APPEND ONLY MODE决定是否开启AOF持久化，位于redis.conf的dir选项目录下默认名appendonly.aof。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wuhua:redis wuhua$ cat appendonly.aof</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ redis-cli </span><br><span class="line">127.0.0.1:6379&gt; set aofkey aofvalue</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wuhua:redis wuhua$ cat appendonly.aof </span><br><span class="line">*2</span><br><span class="line">$6</span><br><span class="line">SELECT</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$6</span><br><span class="line">aofkey</span><br><span class="line">$8</span><br><span class="line">aofvalue</span><br><span class="line">wuhua:redis wuhua$</span><br></pre></td></tr></table></figure><p>分文件追加、文件写入、文件同步三个步骤。</p><p>服务器执行完一个写命令后，以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">struct redisServer &#123;</span><br><span class="line"> ...</span><br><span class="line"> /* AOF persistence */</span><br><span class="line">    int aof_enabled;                /* AOF configuration */</span><br><span class="line">    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */</span><br><span class="line">    int aof_fsync;                  /* Kind of fsync() policy */</span><br><span class="line">    char *aof_filename;             /* Name of the AOF file */</span><br><span class="line">    int aof_no_fsync_on_rewrite;    /* Don&apos;t fsync if a rewrite is in prog. */</span><br><span class="line">    int aof_rewrite_perc;           /* Rewrite AOF if % growth is &gt; M and... */</span><br><span class="line">    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */</span><br><span class="line">    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */</span><br><span class="line">    off_t aof_current_size;         /* AOF current size. */</span><br><span class="line">    off_t aof_fsync_offset;         /* AOF offset which is already synced to disk. */</span><br><span class="line">    int aof_rewrite_scheduled;      /* Rewrite once BGSAVE terminates. */</span><br><span class="line">    pid_t aof_child_pid;            /* PID if rewriting process */</span><br><span class="line">    list *aof_rewrite_buf_blocks;   /* Hold changes during an AOF rewrite. */</span><br><span class="line">    sds aof_buf;      /* AOF buffer, written before entering the event loop */</span><br><span class="line">    int aof_fd;       /* File descriptor of currently selected AOF file */</span><br><span class="line">    int aof_selected_db; /* Currently selected DB in AOF */</span><br><span class="line">    time_t aof_flush_postponed_start; /* UNIX time of postponed AOF flush */</span><br><span class="line">    time_t aof_last_fsync;            /* UNIX time of last fsync() */</span><br><span class="line">    time_t aof_rewrite_time_last;   /* Time used by last AOF rewrite run. */</span><br><span class="line">    time_t aof_rewrite_time_start;  /* Current AOF rewrite start time. */</span><br><span class="line">    int aof_lastbgrewrite_status;   /* C_OK or C_ERR */</span><br><span class="line">    unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */</span><br><span class="line">    int aof_rewrite_incremental_fsync;/* fsync incrementally while aof rewriting? */</span><br><span class="line">    int rdb_save_incremental_fsync;   /* fsync incrementally while rdb saving? */</span><br><span class="line">    int aof_last_write_status;      /* C_OK or C_ERR */</span><br><span class="line">    int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */</span><br><span class="line">    int aof_load_truncated;         /* Don&apos;t stop on unexpected AOF EOF. */</span><br><span class="line">    int aof_use_rdb_preamble;       /* Use RDB preamble on AOF rewrites. */</span><br><span class="line">    /* AOF pipes used to communicate between parent and child during rewrite. */</span><br><span class="line">    int aof_pipe_write_data_to_child;</span><br><span class="line">    int aof_pipe_read_data_from_parent;</span><br><span class="line">    int aof_pipe_write_ack_to_parent;</span><br><span class="line">    int aof_pipe_read_ack_from_child;</span><br><span class="line">    int aof_pipe_write_ack_to_child;</span><br><span class="line">    int aof_pipe_read_ack_from_parent;</span><br><span class="line">    int aof_stop_sending_diff;     /* If true stop sending accumulated diffs</span><br><span class="line">                                      to child process. */</span><br><span class="line">    sds aof_child_diff;             /* AOF diff accumulator child side. */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Redis服务进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，时间事件负责执行serverCron这类需要定时运行的函数。</p><p>服务每结束结束一个事件循环之前，调用flushAppendOnlyFile函数，决定是否将aof_buf缓冲区中的内容写入保存到AOF文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* This is our timer interrupt, called server.hz times per second.</span><br><span class="line"> * Here is where we do a number of things that need to be done asynchronously.</span><br><span class="line"> * For instance:</span><br><span class="line"> *</span><br><span class="line"> * - Active expired keys collection (it is also performed in a lazy way on</span><br><span class="line"> *   lookup).</span><br><span class="line"> * - Software watchdog.</span><br><span class="line"> * - Update some statistic.flushAppendOnlyFile</span><br><span class="line"> * - Incremental rehashing of the DBs hash tables.</span><br><span class="line"> * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.</span><br><span class="line"> * - Clients timeout of different kinds.</span><br><span class="line"> * - Replication reconnection.</span><br><span class="line"> * - Many more...</span><br><span class="line"> *</span><br><span class="line"> * Everything directly called here will be called server.hz times per second,</span><br><span class="line"> * so in order to throttle execution of things we want to do less frequently</span><br><span class="line"> * a macro is used: run_with_period(milliseconds) &#123; .... &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</span><br><span class="line">...</span><br><span class="line"> /* AOF postponed flush: Try at every cron cycle if the slow fsync</span><br><span class="line">     * completed. */</span><br><span class="line">    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);</span><br><span class="line"></span><br><span class="line">    /* AOF write errors: in this case we have a buffer to flush as well and</span><br><span class="line">     * clear the AOF error in case of success to make the DB writable again,</span><br><span class="line">     * however to try every second is enough in case of &apos;hz&apos; is set to</span><br><span class="line">     * an higher frequency. */</span><br><span class="line">    run_with_period(1000) &#123;</span><br><span class="line">        if (server.aof_last_write_status == C_ERR)</span><br><span class="line">            flushAppendOnlyFile(0);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This function gets called every time Redis is entering the</span><br><span class="line"> * main loop of the event driven library, that is, before to sleep</span><br><span class="line"> * for ready file descriptors. */</span><br><span class="line">void beforeSleep(struct aeEventLoop *eventLoop) &#123;</span><br><span class="line"> ...</span><br><span class="line">    /* Write the AOF buffer on disk */</span><br><span class="line"> flushAppendOnlyFile(0);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int prepareForShutdown(int flags) &#123;</span><br><span class="line">...</span><br><span class="line">/* Append only file: flush buffers and fsync() the AOF at exit */</span><br><span class="line">serverLog(LL_NOTICE,&quot;Calling fsync() on the AOF file.&quot;);</span><br><span class="line">flushAppendOnlyFile(1);</span><br><span class="line">redis_fsync(server.aof_fd);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appendfsync选项决定flushAppendOnlyFile函数的行为：</p><table><thead><tr><th style="text-align:center">appendfsync选项值</th><th style="text-align:center">flushAppendOnlyFile函数行为</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">将aof_buf缓冲区中的所有内容写入并同步到AOF文件，最安全但效率最慢</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">默认值，将aof_buf缓冲区中的所有内容写入到AOF文件，若上次同步AOF文件的时间距离现在超过1s，则再次对AOF文件进行同步，且同步操作由一个线程专门负责，效率快但最多丢失1s内数据风险</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">将aof_buf缓冲区中的内容写入到AOF文件，但并不对AOF文件进行同步，同步由操作系统决定</td></tr></tbody></table><p>调用write函数将数据写入文件，通常将其保存在一个内存缓冲区中，待其被填满或超过指定时限，才真正将缓冲区中的数据写入到磁盘。可通过fsync和fdatasync两个同步函数，强制让操作系统立即将缓冲区中的数据写入硬盘。</p><h3 id="AOF文件的载入和还原"><a href="#AOF文件的载入和还原" class="headerlink" title="AOF文件的载入和还原"></a>AOF文件的载入和还原</h3><p>Redis命令只能在客户端上下文中执行，创建不带网络连接的伪客户端执行AOF文件保存的写命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* ----------------------------------------------------------------------------</span><br><span class="line"> * AOF loading</span><br><span class="line"> * ------------------------------------------------------------------------- */</span><br><span class="line"></span><br><span class="line">/* In Redis commands are always executed in the context of a client, so in</span><br><span class="line"> * order to load the append only file we need to create a fake client. */</span><br><span class="line">struct client *createFakeClient(void) &#123;</span><br><span class="line">    struct client *c = zmalloc(sizeof(*c));</span><br><span class="line"></span><br><span class="line">    selectDb(c,0);</span><br><span class="line">    c-&gt;fd = -1;</span><br><span class="line">    c-&gt;name = NULL;</span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    c-&gt;querybuf_peak = 0;</span><br><span class="line">    c-&gt;argc = 0;</span><br><span class="line">    c-&gt;argv = NULL;</span><br><span class="line">    c-&gt;bufpos = 0;</span><br><span class="line">    c-&gt;flags = 0;</span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    /* We set the fake client as a slave waiting for the synchronization</span><br><span class="line">     * so that Redis will not try to send replies to this client. */</span><br><span class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    c-&gt;reply_bytes = 0;</span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = 0;</span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    c-&gt;peerid = NULL;</span><br><span class="line">    c-&gt;resp = 2;</span><br><span class="line">    c-&gt;user = NULL;</span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>解决AOF文件体积膨胀问题，创建一个新的AOF文件替代现有的AOF文件，新旧文件保存的数据库状态相同，新AOF文件不包含任何浪费的冗余命令，实际不需要对现有的AOF文件进行任何读取、分析或者写入操作，读取服务器当前的数据库状态实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/* ----------------------------------------------------------------------------</span><br><span class="line"> * AOF background rewrite</span><br><span class="line"> * ------------------------------------------------------------------------- */</span><br><span class="line"></span><br><span class="line">/* This is how rewriting of the append only file in background works:</span><br><span class="line"> *</span><br><span class="line"> * 1) The user calls BGREWRITEAOF</span><br><span class="line"> * 2) Redis calls this function, that forks():</span><br><span class="line"> *    2a) the child rewrite the append only file in a temp file.</span><br><span class="line"> *    2b) the parent accumulates differences in server.aof_rewrite_buf.</span><br><span class="line"> * 3) When the child finished &apos;2a&apos; exists.</span><br><span class="line"> * 4) The parent will trap the exit code, if it&apos;s OK, will append the</span><br><span class="line"> *    data accumulated into server.aof_rewrite_buf into the temp file, and</span><br><span class="line"> *    finally will rename(2) the temp file in the actual file name.</span><br><span class="line"> *    The the new file is reopened as the new append only file. Profit!</span><br><span class="line"> */</span><br><span class="line">int rewriteAppendOnlyFileBackground(void) &#123;</span><br><span class="line">    pid_t childpid;</span><br><span class="line">    long long start;</span><br><span class="line"></span><br><span class="line">    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;</span><br><span class="line">    if (aofCreatePipes() != C_OK) return C_ERR;</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    start = ustime();</span><br><span class="line">    if ((childpid = fork()) == 0) &#123;</span><br><span class="line">        char tmpfile[256];</span><br><span class="line"></span><br><span class="line">        /* Child */</span><br><span class="line">        closeListeningSockets(0);</span><br><span class="line">        redisSetProcTitle(&quot;redis-aof-rewrite&quot;);</span><br><span class="line">        snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;, (int) getpid());</span><br><span class="line">        if (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            size_t private_dirty = zmalloc_get_private_dirty(-1);</span><br><span class="line"></span><br><span class="line">            if (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    &quot;AOF rewrite: %zu MB of memory used by copy-on-write&quot;,</span><br><span class="line">                    private_dirty/(1024*1024));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server.child_info_data.cow_size = private_dirty;</span><br><span class="line">            sendChildInfo(CHILD_INFO_TYPE_AOF);</span><br><span class="line">            exitFromChild(0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            exitFromChild(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Parent */</span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;fork&quot;,server.stat_fork_time/1000);</span><br><span class="line">        if (childpid == -1) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Can&apos;t rewrite append only file in background: fork: %s&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            return C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            &quot;Background append only file rewriting started by pid %d&quot;,childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = 0;</span><br><span class="line">        server.aof_rewrite_time_start = time(NULL);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        /* We set appendseldb to -1 in order to force the next call to the</span><br><span class="line">         * feedAppendOnlyFile() to issue a SELECT command, so the differences</span><br><span class="line">         * accumulated by the parent into server.aof_rewrite_buf will start</span><br><span class="line">         * with a SELECT statement and it will be safe to merge. */</span><br><span class="line">        server.aof_selected_db = -1;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK; /* unreached */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程进行“重写”，根据数据类型调用不同的重写规则。子进程带有服务器进程的数据副本，可在避免使用锁的情况下，保证数据的安全性。</p><p>设置AOF重写缓冲区，在服务器创建重写子进程后使用，当redis服务器执行完一个写命令后，会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。子进程完成重写后向父进程发送一个信号，父进车收到信号后，调用信号处理函数将AOF重写缓冲区中的所有内容写入到新的AOF文件中并对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">/* A background append only file rewriting (BGREWRITEAOF) terminated its work.</span><br><span class="line"> * Handle this. */</span><br><span class="line">void backgroundRewriteDoneHandler(int exitcode, int bysignal) &#123;</span><br><span class="line">    if (!bysignal &amp;&amp; exitcode == 0) &#123;</span><br><span class="line">        int newfd, oldfd;</span><br><span class="line">        char tmpfile[256];</span><br><span class="line">        long long now = ustime();</span><br><span class="line">        mstime_t latency;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            &quot;Background AOF rewrite terminated with success&quot;);</span><br><span class="line"></span><br><span class="line">        /* Flush the differences accumulated by the parent to the</span><br><span class="line">         * rewritten AOF. */</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;,</span><br><span class="line">            (int)server.aof_child_pid);</span><br><span class="line">        newfd = open(tmpfile,O_WRONLY|O_APPEND);</span><br><span class="line">        if (newfd == -1) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Unable to open the temporary AOF produced by the child: %s&quot;, strerror(errno));</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (aofRewriteBufferWrite(newfd) == -1) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Error trying to flush the parent diff to the rewritten AOF: %s&quot;, strerror(errno));</span><br><span class="line">            close(newfd);</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;aof-rewrite-diff-write&quot;,latency);</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            &quot;Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)&quot;, (double) aofRewriteBufferSize() / (1024*1024));</span><br><span class="line"></span><br><span class="line">        /* The only remaining thing to do is to rename the temporary file to</span><br><span class="line">         * the configured file and switch the file descriptor used to do AOF</span><br><span class="line">         * writes. We don&apos;t want close(2) or rename(2) calls to block the</span><br><span class="line">         * server on old file deletion.</span><br><span class="line">         *</span><br><span class="line">         * There are two possible scenarios:</span><br><span class="line">         *</span><br><span class="line">         * 1) AOF is DISABLED and this was a one time rewrite. The temporary</span><br><span class="line">         * file will be renamed to the configured file. When this file already</span><br><span class="line">         * exists, it will be unlinked, which may block the server.</span><br><span class="line">         *</span><br><span class="line">         * 2) AOF is ENABLED and the rewritten AOF will immediately start</span><br><span class="line">         * receiving writes. After the temporary file is renamed to the</span><br><span class="line">         * configured file, the original AOF file descriptor will be closed.</span><br><span class="line">         * Since this will be the last reference to that file, closing it</span><br><span class="line">         * causes the underlying file to be unlinked, which may block the</span><br><span class="line">         * server.</span><br><span class="line">         *</span><br><span class="line">         * To mitigate the blocking effect of the unlink operation (either</span><br><span class="line">         * caused by rename(2) in scenario 1, or by close(2) in scenario 2), we</span><br><span class="line">         * use a background thread to take care of this. First, we</span><br><span class="line">         * make scenario 1 identical to scenario 2 by opening the target file</span><br><span class="line">         * when it exists. The unlink operation after the rename(2) will then</span><br><span class="line">         * be executed upon calling close(2) for its descriptor. Everything to</span><br><span class="line">         * guarantee atomicity for this switch has already happened by then, so</span><br><span class="line">         * we don&apos;t care what the outcome or duration of that close operation</span><br><span class="line">         * is, as long as the file descriptor is released again. */</span><br><span class="line">        if (server.aof_fd == -1) &#123;</span><br><span class="line">            /* AOF disabled */</span><br><span class="line"></span><br><span class="line">            /* Don&apos;t care if this fails: oldfd will be -1 and we handle that.</span><br><span class="line">             * One notable case of -1 return is if the old file does</span><br><span class="line">             * not exist. */</span><br><span class="line">            oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* AOF enabled */</span><br><span class="line">            oldfd = -1; /* We&apos;ll set this to the current AOF filedes later. */</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Rename the temporary file. This will not unlink the target file if</span><br><span class="line">         * it exists, because we reference it with &quot;oldfd&quot;. */</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        if (rename(tmpfile,server.aof_filename) == -1) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Error trying to rename the temporary AOF file %s into %s: %s&quot;,</span><br><span class="line">                tmpfile,</span><br><span class="line">                server.aof_filename,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            close(newfd);</span><br><span class="line">            if (oldfd != -1) close(oldfd);</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;aof-rename&quot;,latency);</span><br><span class="line"></span><br><span class="line">        if (server.aof_fd == -1) &#123;</span><br><span class="line">            /* AOF disabled, we don&apos;t need to set the AOF file descriptor</span><br><span class="line">             * to this new file, so we can close it. */</span><br><span class="line">            close(newfd);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* AOF enabled, replace the old fd with the new one. */</span><br><span class="line">            oldfd = server.aof_fd;</span><br><span class="line">            server.aof_fd = newfd;</span><br><span class="line">            if (server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">                redis_fsync(newfd);</span><br><span class="line">            else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">                aof_background_fsync(newfd);</span><br><span class="line">            server.aof_selected_db = -1; /* Make sure SELECT is re-issued */</span><br><span class="line">            aofUpdateCurrentSize();</span><br><span class="line">            server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">            server.aof_current_size = server.aof_current_size;</span><br><span class="line"></span><br><span class="line">            /* Clear regular AOF buffer since its contents was just written to</span><br><span class="line">             * the new AOF from the background rewrite buffer. */</span><br><span class="line">            sdsfree(server.aof_buf);</span><br><span class="line">            server.aof_buf = sdsempty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.aof_lastbgrewrite_status = C_OK;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE, &quot;Background AOF rewrite finished successfully&quot;);</span><br><span class="line">        /* Change state from WAIT_REWRITE to ON if needed */</span><br><span class="line">        if (server.aof_state == AOF_WAIT_REWRITE)</span><br><span class="line">            server.aof_state = AOF_ON;</span><br><span class="line"></span><br><span class="line">        /* Asynchronously close the overwritten AOF. */</span><br><span class="line">        if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);</span><br><span class="line"></span><br><span class="line">        serverLog(LL_VERBOSE,</span><br><span class="line">            &quot;Background AOF rewrite signal handler took %lldus&quot;, ustime()-now);</span><br><span class="line">    &#125; else if (!bysignal &amp;&amp; exitcode != 0) &#123;</span><br><span class="line">        /* SIGUSR1 is whitelisted, so we have a way to kill a child without</span><br><span class="line">         * tirggering an error condition. */</span><br><span class="line">        if (bysignal != SIGUSR1)</span><br><span class="line">            server.aof_lastbgrewrite_status = C_ERR;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Background AOF rewrite terminated with error&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        server.aof_lastbgrewrite_status = C_ERR;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Background AOF rewrite terminated by signal %d&quot;, bysignal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    aofClosePipes();</span><br><span class="line">    aofRewriteBufferReset();</span><br><span class="line">    aofRemoveTempFile(server.aof_child_pid);</span><br><span class="line">    server.aof_child_pid = -1;</span><br><span class="line">    server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;</span><br><span class="line">    server.aof_rewrite_time_start = -1;</span><br><span class="line">    /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */</span><br><span class="line">    if (server.aof_state == AOF_WAIT_REWRITE)</span><br><span class="line">        server.aof_rewrite_scheduled = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RDB持久化通过保存数据库中的键值对来记录数据库状态的不同，AOF持久化通过保存Redis服务器所执行的写命令来记录数据状态。&lt;/p&gt;
&lt;h3 id=&quot;AOF持久化&quot;&gt;&lt;a href=&quot;#AOF持久化&quot; class=&quot;headerlink&quot; title=&quot;AOF持久化&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="AOF" scheme="bighua.top/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>redis-RDB持久化</title>
    <link href="bighua.top/2019/09/18/redis-RDB%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>bighua.top/2019/09/18/redis-RDB持久化/</id>
    <published>2019-09-18T12:47:08.000Z</published>
    <updated>2019-09-19T08:58:05.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RDB文件的创建和载入"><a href="#RDB文件的创建和载入" class="headerlink" title="RDB文件的创建和载入"></a>RDB文件的创建和载入</h3><p>SAVE阻塞Redis服务器进程，直到RDB文件创建完毕，阻塞期间不能处理任何命令请求。BGSAVE派生一个子进程，由子进程负责创建RDB文件，服务器进程继续处理命令请求。</p><p>rdb.c：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">/* Save the DB on disk. Return C_ERR on error, C_OK on success. */</span><br><span class="line">int rdbSave(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    char tmpfile[256];</span><br><span class="line">    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    int error = 0;</span><br><span class="line"></span><br><span class="line">    snprintf(tmpfile,256,&quot;temp-%d.rdb&quot;, (int) getpid());</span><br><span class="line">    fp = fopen(tmpfile,&quot;w&quot;);</span><br><span class="line">    if (!fp) &#123;</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span><br><span class="line">            &quot;for saving: %s&quot;,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line"></span><br><span class="line">    if (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    if (rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        goto werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Make sure data will not remain on the OS&apos;s output buffers */</span><br><span class="line">    if (fflush(fp) == EOF) goto werr;</span><br><span class="line">    if (fsync(fileno(fp)) == -1) goto werr;</span><br><span class="line">    if (fclose(fp) == EOF) goto werr;</span><br><span class="line"></span><br><span class="line">    /* Use RENAME to make sure the DB file is changed atomically only</span><br><span class="line">     * if the generate DB file is ok. */</span><br><span class="line">    if (rename(tmpfile,filename) == -1) &#123;</span><br><span class="line">        char *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Error moving temp DB file %s on the final &quot;</span><br><span class="line">            &quot;destination %s (in server root dir %s): %s&quot;,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : &quot;unknown&quot;,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,&quot;DB saved on disk&quot;);</span><br><span class="line">    server.dirty = 0;</span><br><span class="line">    server.lastsave = time(NULL);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    return C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,&quot;Write error saving DB on disk: %s&quot;, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    return C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    pid_t childpid;</span><br><span class="line">    long long start;</span><br><span class="line"></span><br><span class="line">    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = time(NULL);</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line"></span><br><span class="line">    start = ustime();</span><br><span class="line">    if ((childpid = fork()) == 0) &#123;</span><br><span class="line">        int retval;</span><br><span class="line"></span><br><span class="line">        /* Child */</span><br><span class="line">        closeListeningSockets(0);</span><br><span class="line">        redisSetProcTitle(&quot;redis-rdb-bgsave&quot;);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        if (retval == C_OK) &#123;</span><br><span class="line">            size_t private_dirty = zmalloc_get_private_dirty(-1);</span><br><span class="line"></span><br><span class="line">            if (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    &quot;RDB: %zu MB of memory used by copy-on-write&quot;,</span><br><span class="line">                    private_dirty/(1024*1024));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server.child_info_data.cow_size = private_dirty;</span><br><span class="line">            sendChildInfo(CHILD_INFO_TYPE_RDB);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? 0 : 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* Parent */</span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */</span><br><span class="line">        latencyAddSampleIfNeeded(&quot;fork&quot;,server.stat_fork_time/1000);</span><br><span class="line">        if (childpid == -1) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            serverLog(LL_WARNING,&quot;Can&apos;t save in background: fork: %s&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            return C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,&quot;Background saving started by pid %d&quot;,childpid);</span><br><span class="line">        server.rdb_save_time_start = time(NULL);</span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        return C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return C_OK; /* unreached */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">void saveCommand(client *c) &#123;</span><br><span class="line">    if (server.rdb_child_pid != -1) &#123;</span><br><span class="line">        addReplyError(c,&quot;Background save already in progress&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">    if (rdbSave(server.rdb_filename,rsiptr) == C_OK) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* BGSAVE [SCHEDULE] */</span><br><span class="line">void bgsaveCommand(client *c) &#123;</span><br><span class="line">    int schedule = 0;</span><br><span class="line"></span><br><span class="line">    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite</span><br><span class="line">     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */</span><br><span class="line">    if (c-&gt;argc &gt; 1) &#123;</span><br><span class="line">        if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;schedule&quot;)) &#123;</span><br><span class="line">            schedule = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line"></span><br><span class="line">    if (server.rdb_child_pid != -1) &#123;</span><br><span class="line">        addReplyError(c,&quot;Background save already in progress&quot;);</span><br><span class="line">    &#125; else if (server.aof_child_pid != -1) &#123;</span><br><span class="line">        if (schedule) &#123;</span><br><span class="line">            server.rdb_bgsave_scheduled = 1;</span><br><span class="line">            addReplyStatus(c,&quot;Background saving scheduled&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                &quot;An AOF log rewriting in progress: can&apos;t BGSAVE right now. &quot;</span><br><span class="line">                &quot;Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever &quot;</span><br><span class="line">                &quot;possible.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,&quot;Background saving started&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释即文档，很清楚。不会同时执行SAVE和BGSAVE命令以及多个BGSAVE命令，不会同时执行BGSAVE和BGREWRITEAOF。若正在执行BGSAVE，则BGREWRITEAOF延迟到BGSAVE命令执行完毕后执行，若正在执行BGREWRITEAOF命令，则BGSAVE被拒绝。</p><p>服务启动时，检测到RDB文件存在，就会自动载入RDB文件。若开启AOF持久化功能，会优先使用AOF文件来还原数据库状态，AOF持久化功能关闭时，才使用RDB文件还原数据库状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Like rdbLoadRio() but takes a filename instead of a rio stream. The</span><br><span class="line"> * filename is open for reading and a rio stream object created in order</span><br><span class="line"> * to do the actual loading. Moreover the ETA displayed in the INFO</span><br><span class="line"> * output is initialized and finalized.</span><br><span class="line"> *</span><br><span class="line"> * If you pass an &apos;rsi&apos; structure initialied with RDB_SAVE_OPTION_INIT, the</span><br><span class="line"> * loading code will fiil the information fields in the structure. */</span><br><span class="line">int rdbLoad(char *filename, rdbSaveInfo *rsi) &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    if ((fp = fopen(filename,&quot;r&quot;)) == NULL) return C_ERR;</span><br><span class="line">    startLoadingFile(fp, filename);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rsi,0);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading();</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis.conf中设置save，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>启动时根据save选项设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct saveparam &#123;</span><br><span class="line">    time_t seconds;</span><br><span class="line">    int changes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct redisServer &#123;</span><br><span class="line"> ...</span><br><span class="line"> struct saveparam *saveparams;   /* Save points array for RDB */</span><br><span class="line"> ...</span><br><span class="line"> /* RDB persistence */</span><br><span class="line">    long long dirty;                /* Changes to DB from the last save */</span><br><span class="line">    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */</span><br><span class="line">    pid_t rdb_child_pid;            /* PID of RDB saving child */</span><br><span class="line">    struct saveparam *saveparams;   /* Save points array for RDB */</span><br><span class="line">    int saveparamslen;              /* Number of saving points */</span><br><span class="line">    char *rdb_filename;             /* Name of RDB file */</span><br><span class="line">    int rdb_compression;            /* Use compression in RDB? */</span><br><span class="line">    int rdb_checksum;               /* Use RDB checksum? */</span><br><span class="line">    time_t lastsave;                /* Unix time of last successful save */</span><br><span class="line">    time_t lastbgsave_try;          /* Unix time of last attempted bgsave */</span><br><span class="line">    time_t rdb_save_time_last;      /* Time used by last RDB save run. */</span><br><span class="line">    time_t rdb_save_time_start;     /* Current RDB save start time. */</span><br><span class="line">    int rdb_bgsave_scheduled;       /* BGSAVE when possible if true. */</span><br><span class="line">    int rdb_child_type;             /* Type of save by active child. */</span><br><span class="line">    int lastbgsave_status;          /* C_OK or C_ERR */</span><br><span class="line">    int stop_writes_on_bgsave_err;  /* Don&apos;t allow writes if can&apos;t BGSAVE */</span><br><span class="line">    int rdb_pipe_write_result_to_parent; /* RDB pipes used to return the state*/</span><br><span class="line">    int rdb_pipe_read_result_from_child; /* of each slave in diskless SYNC. */</span><br><span class="line">    int rdb_key_save_delay;         /* Delay in microseconds between keys while</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>位于redis.conf下dir配置的文件目录下，默认名dump.rdb，<a href="https://blog.csdn.net/yuanya/article/details/24406357" target="_blank" rel="noopener">vi二进制转码</a>或是用od命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">00000000: 5245 4449 5330 3030 38fa 0972 6564 6973  REDIS0008..redis</span><br><span class="line">00000010: 2d76 6572 0634 2e30 2e31 30fa 0a72 6564  -ver.4.0.10..red</span><br><span class="line">00000020: 6973 2d62 6974 73c0 40fa 0563 7469 6d65  is-bits.@..ctime </span><br><span class="line">00000030: c272 3083 5dfa 0875 7365 642d 6d65 6dc2  .r0.]..used-mem.</span><br><span class="line">00000040: 4045 1000 fa0c 616f 662d 7072 6561 6d62  @E....aof-preamb</span><br><span class="line">00000050: 6c65 c000 fe00 fb08 000e 0b6d 6169 6c65  le.........maile</span><br><span class="line">00000060: 723a 6c69 7374 01c3 40fa 4699 0499 0600  r:list..@.F.....</span><br><span class="line">00000070: 0023 2003 1f0e 0000 4075 7b22 7375 626a  .# .....@u&#123;&quot;subj</span><br><span class="line">00000080: 6563 7422 3a22 e998 bfe6 b3a2 e7bd 97e7  ect&quot;:&quot;..........</span><br><span class="line">00000090: 99bb e69c 8814 e8ae a1e5 8892 222c 2265  ............&quot;,&quot;e</span><br><span class="line">000000a0: 6d61 696c 4164 6472 6573 7320 260f 3630  mailAddress &amp;.60</span><br><span class="line">000000b0: 3936 3639 3938 3340 7171 2e63 6f6d 2021  9669983@qq.com !</span><br><span class="line">000000c0: 0362 6f64 7920 190e e688 91e4 b88d e7ae  .body ..........</span><br><span class="line">000000d0: a12c e7be a4e4 b820 4406 80e5 b885 2e20  .,..... D...... </span><br><span class="line">000000e0: 2d40 000b 6279 2063 6f63 6f77 6822 7d78  -@..by cocowh&quot;&#125;x</span><br><span class="line">000000f0: e02c 7706 3232 3839 3434 38e0 3477 0076  .,w.2289448.4w.v</span><br><span class="line">00000100: e02a ef09 3234 3939 3436 3638 3134 e030  .*..2499466814.0</span><br><span class="line">00000110: f000 79e0 2cf0 0439 3633 3737 20f2 0037  ..y.,..96377 ..7</span><br><span class="line">00000120: e030 77e1 2d68 0833 3134 3836 3534 3031  .0w.-h.314865401</span><br><span class="line">00000130: e032 77e1 2b68 0631 3130 3738 3930 216e  .2w.+h.1107890!n</span><br><span class="line">00000140: e030 7802 7940 72e1 2ae1 8297 e030 7400  .0x.y@r.*....0t.</span><br><span class="line">00000150: 75e1 2cdd e3ff 46e4 2237 e3ff 46e5 159f  u.,...F.&quot;7..F...</span><br><span class="line">00000160: e3ae 4601 7dff 0c08 7a73 6574 7465 7374  ..F.&#125;...zsettest</span><br><span class="line">00000170: 1717 0000 0013 0000 0002 0000 076d 656d  .............mem</span><br><span class="line">00000180: 6265 7231 09fe 64ff 0009 7374 7269 6e67  ber1..d...string</span><br><span class="line">00000190: 6b65 79c1 9001 0c08 7465 7374 7a73 6574  key.....testzset</span><br><span class="line">000001a0: c333 3b04 3b00 0000 3820 030a 0c00 0004  .3;.;...8 ......</span><br><span class="line">000001b0: 6d65 6d36 06f6 0240 0702 3506 f760 0702  mem6...@..5..`..</span><br><span class="line">000001c0: 3406 f860 0702 3306 f960 0702 3206 fa60  4..`..3..`..2..`</span><br><span class="line">000001d0: 0703 3106 fbff 0002 6869 c26a 0401 000e  ..1.....hi.j....</span><br><span class="line">000001e0: 046c 6973 7401 1111 0000 000e 0000 0003  .list...........</span><br><span class="line">000001f0: 0000 f402 f302 f2ff 0e03 6c73 7401 2525  ..........lst.%%</span><br><span class="line">00000200: 0000 001b 0000 0006 0000 f202 f402 f602  ................</span><br><span class="line">00000210: c066 2704 0577 7568 7561 0707 6c69 7765  .f&apos;..wuhua..liwe</span><br><span class="line">00000220: 6e71 69ff 0d08 6874 6573 746b 6579 2323  nqi...htestkey##</span><br><span class="line">00000230: 0000 0020 0000 0004 0000 0666 696c 6564  ... .......filed</span><br><span class="line">00000240: 3108 0476 616c 3106 066b 6579 6164 6408  1..val1..keyadd.</span><br><span class="line">00000250: f4ff ff18 8e2b 7151 f9f0 680a            .....+qQ..h.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">wuhua:redis wuhua$ od -c dump.rdb </span><br><span class="line">0000000    R   E   D   I   S   0   0   0   8 372  \t   r   e   d   i   s</span><br><span class="line">0000020    -   v   e   r 006   4   .   0   .   1   0 372  \n   r   e   d</span><br><span class="line">0000040    i   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e</span><br><span class="line">0000060  302   r   0 203   ] 372  \b   u   s   e   d   -   m   e   m 100</span><br><span class="line">0000100    @   E 020  \0 372  \f   a   o   f   -   p   r   e   a   m   b</span><br><span class="line">0000120    l   e 300  \0 376  \0 373  \b  \0 016  \v   m   a   i   l   e</span><br><span class="line">0000140    r   :   l   i   s   t 001 303   @ 372   F 231 004 231 006  \0</span><br><span class="line">0000160   \0   #     003 037 016  \0  \0   @   u   &#123;   &quot;   s   u   b   j</span><br><span class="line">0000200    e   c   t   &quot;   :   &quot;  阿  **  **  波  **  **  罗  **  **  登</span><br><span class="line">0000220   **  **  月  **  ** 024  计  **  **  划  **  **   &quot;   ,   &quot;   e</span><br><span class="line">0000240    m   a   i   l   A   d   d   r   e   s   s       &amp; 017   6   0</span><br><span class="line">0000260    9   6   6   9   9   8   3   @   q   q   .   c   o   m       !</span><br><span class="line">0000300  003   b   o   d   y     031 016  我  **  **  不  **  **  管  **</span><br><span class="line">0000320   **   ,  群  **  ** 344 270       D 006 200  帅  **  **   .    </span><br><span class="line">0000340    -   @  \0  \v   b   y       c   o   c   o   w   h   &quot;   &#125;   x</span><br><span class="line">0000360  340   ,   w 006   2   2   8   9   4   4   8 340   4   w  \0   v</span><br><span class="line">0000400  340   * 357  \t   2   4   9   9   4   6   6   8   1   4 340   0</span><br><span class="line">0000420  360  \0   y 340   , 360 004   9   6   3   7   7     362  \0   7</span><br><span class="line">0000440  340   0   w 341   -   h  \b   3   1   4   8   6   5   4   0   1</span><br><span class="line">0000460  340   2   w 341   +   h 006   1   1   0   7   8   9   0   !   n</span><br><span class="line">0000500  340   0   x 002   y   @   r 341   * 341 202 227 340   0   t  \0</span><br><span class="line">0000520    u 341   , 335 343 377   F 344   &quot;   7 343 377   F 345 025 237</span><br><span class="line">0000540  343 256   F 001   &#125; 377  \f  \b   z   s   e   t   t   e   s   t</span><br><span class="line">0000560  027 027  \0  \0  \0 023  \0  \0  \0 002  \0  \0  \a   m   e   m</span><br><span class="line">0000600    b   e   r   1  \t 376   d 377  \0  \t   s   t   r   i   n   g</span><br><span class="line">0000620    k   e   y 301 220 001  \f  \b   t   e   s   t   z   s   e   t</span><br><span class="line">0000640  303   3   ; 004   ;  \0  \0  \0   8     003  \n  \f  \0  \0 004</span><br><span class="line">0000660    m   e   m   6 006 366 002   @  \a 002   5 006 367   `  \a 002</span><br><span class="line">0000700    4 006 370   `  \a 002   3 006 371   `  \a 002   2 006 372   `</span><br><span class="line">0000720   \a 003   1 006 373 377  \0 002   h   i 302   j 004 001  \0 016</span><br><span class="line">0000740  004   l   i   s   t 001 021 021  \0  \0  \0 016  \0  \0  \0 003</span><br><span class="line">0000760   \0  \0 364 002 363 002 362 377 016 003   l   s   t 001   %   %</span><br><span class="line">0001000   \0  \0  \0 033  \0  \0  \0 006  \0  \0 362 002 364 002 366 002</span><br><span class="line">0001020  300   f   &apos; 004 005   w   u   h   u   a  \a  \a   l   i   w   e</span><br><span class="line">0001040    n   q   i 377  \r  \b   h   t   e   s   t   k   e   y   #   #</span><br><span class="line">0001060   \0  \0  \0      \0  \0  \0 004  \0  \0 006   f   i   l   e   d</span><br><span class="line">0001100    1  \b 004   v   a   l   1 006 006   k   e   y   a   d   d  \b</span><br><span class="line">0001120  364 377 377 030 216   +   q   Q 371 360   h                    </span><br><span class="line">0001133</span><br></pre></td></tr></table></figure><p>直接使用redis-check-rdb快照检查工具(已编译进redis，直接使用)查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wuhua:redis wuhua$ redis-check-rdb dump.rdb</span><br><span class="line">[offset 0] Checking RDB file dump.rdb              </span><br><span class="line">[offset 27] AUX FIELD redis-ver = &apos;4.0.10&apos;     //redis事例版本</span><br><span class="line">[offset 41] AUX FIELD redis-bits = &apos;64&apos;        //redis事例主机架构</span><br><span class="line">[offset 53] AUX FIELD ctime = &apos;1568878706&apos;     //rdb创建时unix时间戳</span><br><span class="line">[offset 68] AUX FIELD used-mem = &apos;1066304&apos;     //转存时使用的内存大小</span><br><span class="line">[offset 84] AUX FIELD aof-preamble = &apos;0&apos;       //是否在AOF文件头放置RDB快照（开启混合持久化）   </span><br><span class="line">[offset 86] Selecting DB ID 0                  //DB索引</span><br><span class="line">[offset 603] Checksum OK                       //检验信息</span><br><span class="line">[offset 603] \o/ RDB looks OK! \o/</span><br><span class="line">[info] 8 keys read</span><br><span class="line">[info] 0 expires</span><br><span class="line">[info] 0 already expired</span><br></pre></td></tr></table></figure><p>使用<a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener">redis-rdb-tools</a>工具查看内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wuhua:redis wuhua$ rdb --command json dump.rdb </span><br><span class="line">[&#123;</span><br><span class="line">&quot;mailer:list&quot;:[&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;609669983@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;228944883@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;2499466814@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;963779447@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;314865401@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;1107890499@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;cocowh@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;609669983@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;228944883@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;2499466814@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;963779447@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;314865401@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;1107890499@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;,&quot;&#123;\&quot;subject\&quot;:\&quot;\u963f\u6ce2\u7f57\u767b\u6708\u8ba1\u5212\&quot;,\&quot;emailAddress\&quot;:\&quot;cocowh@qq.com\&quot;,\&quot;body\&quot;:\&quot;\u6211\u4e0d\u7ba1,\u7fa4\u4e3b\u6700\u5e05. -----by cocowh\&quot;&#125;&quot;],</span><br><span class="line">&quot;zsettest&quot;:&#123;&quot;member1&quot;:&quot;100&quot;&#125;,</span><br><span class="line">&quot;stringkey&quot;:&quot;400&quot;,</span><br><span class="line">&quot;testzset&quot;:&#123;&quot;mem6&quot;:&quot;5&quot;,&quot;mem5&quot;:&quot;6&quot;,&quot;mem4&quot;:&quot;7&quot;,&quot;mem3&quot;:&quot;8&quot;,&quot;mem2&quot;:&quot;9&quot;,&quot;mem1&quot;:&quot;10&quot;&#125;,</span><br><span class="line">&quot;hi&quot;:&quot;66666&quot;,</span><br><span class="line">&quot;list&quot;:[&quot;3&quot;,&quot;2&quot;,&quot;1&quot;],</span><br><span class="line">&quot;lst&quot;:[&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;10086&quot;,&quot;wuhua&quot;,&quot;liwenqi&quot;],</span><br><span class="line">&quot;htestkey&quot;:&#123;&quot;filed1&quot;:&quot;val1&quot;,&quot;keyadd&quot;:&quot;3&quot;&#125;&#125;]wuhua:redis wuhua$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RDB文件的创建和载入&quot;&gt;&lt;a href=&quot;#RDB文件的创建和载入&quot; class=&quot;headerlink&quot; title=&quot;RDB文件的创建和载入&quot;&gt;&lt;/a&gt;RDB文件的创建和载入&lt;/h3&gt;&lt;p&gt;SAVE阻塞Redis服务器进程，直到RDB文件创建完毕，阻塞期间不
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="RDB" scheme="bighua.top/tags/RDB/"/>
    
  </entry>
  
  <entry>
    <title>redis-数据库</title>
    <link href="bighua.top/2019/09/18/redis-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>bighua.top/2019/09/18/redis-数据库/</id>
    <published>2019-09-18T08:30:49.000Z</published>
    <updated>2019-09-18T12:43:56.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>保存于服务器状态server.h/redisServer结构db数组中。每一项都是一个server.h/redisDb结构，代表一个数据库。初始化服务时根据服务器状态的dbnum属性决定创建多少个数据库，改值由服务器配置的database选项决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line"> ...</span><br><span class="line">    redisDb *db;</span><br><span class="line">    ...</span><br><span class="line">    int dbnum;                      /* Total number of configured DBs */</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Redis database representation. There are multiple databases identified</span><br><span class="line"> * by integers from 0 (the default database) up to the max configured</span><br><span class="line"> * database. The database number is the &apos;id&apos; field in the structure. */</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &apos;databases&apos;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p><code>SELECT</code>命令切换，server.h/redisClient结构的db属性记录了客户端当前的目标数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* With multiplexing we need to take per-client state.</span><br><span class="line"> * Clients are taken in a linked list. */</span><br><span class="line">typedef struct client &#123;</span><br><span class="line"> ...</span><br><span class="line">    redisDb *db;            /* Pointer to currently SELECTed DB. */</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>每个数据库由server.h/redisDb结构表示，redisDb结构的dict字典保存了数据库中的所有键值对，成为键空间（keyspace）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Redis database representation. There are multiple databases identified</span><br><span class="line"> * by integers from 0 (the default database) up to the max configured</span><br><span class="line"> * database. The database number is the &apos;id&apos; field in the structure. */</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>针对数据库的操作，实际是通过键空间字典进行操作实现。</p><p>对数据库进行读写操作时，除对键空间执行指定的读写操作外（读操作和写操作都要对键进行读取），还会执行一些的维护操作：</p><ul><li>根据键是否存在更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，可在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>更新键的LRU（最后一次使用时间），用于计算键的闲置时间。</li><li>发现键过期则删除过期键，然后执行余下的其他操作。</li><li>若有客户端使用WATCH命令监视某个键，则对被监视的键修改之后，会将键标记为脏（dirty），让事务程序注意到键已经被修改。</li><li>每次修改一个键都会对脏（dirty）键计数器的值增1，计数器触发服务器的持久化以及复制操作。</li><li>若服务器开启数据库通知功能，则在对键进行修改之后，按配置发送相应的数据库通知。</li></ul><h3 id="设置键的生存时间和过期时间"><a href="#设置键的生存时间和过期时间" class="headerlink" title="设置键的生存时间和过期时间"></a>设置键的生存时间和过期时间</h3><p><code>EXPIRE</code>和<code>PEXPIRE</code>命令，以秒或毫秒为数据库中的某个键设置生存时间（Time To Live，TTL），指定时间过后，服务器自动删除生存时间为0的键。</p><p><code>EXPIREAT</code>和<code>PEXPIREAT</code>命令，以秒或毫秒给数据库中的某个键设置过期时间（expire），过期时间是unix时间戳，过期时间来临时，服务器自动删除键。</p><p><code>SETEX</code>命令可为一个字符串键设置值的同时设置过期时间，原理同<code>EXPIRE</code>。</p><p><code>TTL</code>和<code>PTTL</code>接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间。</p><p>实际上<code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIREAT</code>命令底层实现统一。<br>server.h中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void expireCommand(client *c);</span><br><span class="line">void expireatCommand(client *c);</span><br><span class="line">void pexpireCommand(client *c);</span><br><span class="line">void pexpireatCommand(client *c);</span><br></pre></td></tr></table></figure><p>server.c/redisCommandTable中命令注册绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"> &#123;&quot;expire&quot;,expireCommand,3,</span><br><span class="line"> &quot;write fast @keyspace&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br><span class="line"></span><br><span class="line">&#123;&quot;expireat&quot;,expireatCommand,3,</span><br><span class="line"> &quot;write fast @keyspace&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br><span class="line"></span><br><span class="line">&#123;&quot;pexpire&quot;,pexpireCommand,3,</span><br><span class="line"> &quot;write fast @keyspace&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br><span class="line"></span><br><span class="line">&#123;&quot;pexpireat&quot;,pexpireatCommand,3,</span><br><span class="line"> &quot;write fast @keyspace&quot;,</span><br><span class="line"> 0,NULL,1,1,1,0,0,0&#125;,</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>expire.c中实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*-----------------------------------------------------------------------------</span><br><span class="line"> * Expires Commands</span><br><span class="line"> *----------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/* This is the generic command implementation for EXPIRE, PEXPIRE, EXPIREAT</span><br><span class="line"> * and PEXPIREAT. Because the commad second argument may be relative or absolute</span><br><span class="line"> * the &quot;basetime&quot; argument is used to signal what the base time is (either 0</span><br><span class="line"> * for *AT variants of the command, or the current time for relative expires).</span><br><span class="line"> *</span><br><span class="line"> * unit is either UNIT_SECONDS or UNIT_MILLISECONDS, and is only used for</span><br><span class="line"> * the argv[2] parameter. The basetime is always specified in milliseconds. */</span><br><span class="line">void expireGenericCommand(client *c, long long basetime, int unit) &#123;</span><br><span class="line">    robj *key = c-&gt;argv[1], *param = c-&gt;argv[2];</span><br><span class="line">    long long when; /* unix time in milliseconds when the key will expire. */</span><br><span class="line"></span><br><span class="line">    if (getLongLongFromObjectOrReply(c, param, &amp;when, NULL) != C_OK)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (unit == UNIT_SECONDS) when *= 1000;</span><br><span class="line">    when += basetime;</span><br><span class="line"></span><br><span class="line">    /* No key, return zero. */</span><br><span class="line">    if (lookupKeyWrite(c-&gt;db,key) == NULL) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past</span><br><span class="line">     * should never be executed as a DEL when load the AOF or in the context</span><br><span class="line">     * of a slave instance.</span><br><span class="line">     *</span><br><span class="line">     * Instead we take the other branch of the IF statement setting an expire</span><br><span class="line">     * (possibly in the past) and wait for an explicit DEL from the master. */</span><br><span class="line">    if (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">        robj *aux;</span><br><span class="line"></span><br><span class="line">        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) :</span><br><span class="line">                                                    dbSyncDelete(c-&gt;db,key);</span><br><span class="line">        serverAssertWithInfo(c,key,deleted);</span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">        /* Replicate/AOF this as an explicit DEL or UNLINK. */</span><br><span class="line">        aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;</span><br><span class="line">        rewriteClientCommandVector(c,2,aux,key);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setExpire(c,c-&gt;db,key,when);</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;expire&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* EXPIRE key seconds */</span><br><span class="line">void expireCommand(client *c) &#123;</span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* EXPIREAT key time */</span><br><span class="line">void expireatCommand(client *c) &#123;</span><br><span class="line">    expireGenericCommand(c,0,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* PEXPIRE key milliseconds */</span><br><span class="line">void pexpireCommand(client *c) &#123;</span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* PEXPIREAT key ms_time */</span><br><span class="line">void pexpireatCommand(client *c) &#123;</span><br><span class="line">    expireGenericCommand(c,0,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存-移除过期时间"><a href="#保存-移除过期时间" class="headerlink" title="保存/移除过期时间"></a>保存/移除过期时间</h3><p>redisDb结构的expires字典保存数据库中所有键的过期时间，过期字典：</p><ul><li>过期字典的键是一个指针，指向键空间中的某个键对象；</li><li>过期字典的值是为long long int型，保存键所指向的数据库键的过期时间——毫秒精度的UNIX时间戳。</li></ul><p>设置过期时间时，会在过期字典中关联给定的数据库键和过期时间。使用PERSIST命令移除过期时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl hi</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; expire hi 1000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hi</span><br><span class="line">(integer) 998</span><br><span class="line">127.0.0.1:6379&gt; persist hi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl hi</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><p>PERSIST命令是PEXPIREAT命令的反操作，在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* PERSIST key */</span><br><span class="line">void persistCommand(client *c) &#123;</span><br><span class="line">    if (lookupKeyWrite(c-&gt;db,c-&gt;argv[1])) &#123;</span><br><span class="line">        if (removeExpire(c-&gt;db,c-&gt;argv[1])) &#123;</span><br><span class="line">            addReply(c,shared.cone);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h3><p>TTL和PTTL都是通过计算键的过期时间和当前时间之间的差来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* Implements TTL and PTTL */</span><br><span class="line">void ttlGenericCommand(client *c, int output_ms) &#123;</span><br><span class="line">    long long expire, ttl = -1;</span><br><span class="line"></span><br><span class="line">    /* If the key does not exist at all, return -2 */</span><br><span class="line">    if (lookupKeyReadWithFlags(c-&gt;db,c-&gt;argv[1],LOOKUP_NOTOUCH) == NULL) &#123;</span><br><span class="line">        addReplyLongLong(c,-2);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* The key exists. Return -1 if it has no expire, or the actual</span><br><span class="line">     * TTL value otherwise. */</span><br><span class="line">    expire = getExpire(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line">    if (expire != -1) &#123;</span><br><span class="line">        ttl = expire-mstime();</span><br><span class="line">        if (ttl &lt; 0) ttl = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ttl == -1) &#123;</span><br><span class="line">        addReplyLongLong(c,-1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* TTL key */</span><br><span class="line">void ttlCommand(client *c) &#123;</span><br><span class="line">    ttlGenericCommand(c, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* PTTL key */</span><br><span class="line">void pttlCommand(client *c) &#123;</span><br><span class="line">    ttlGenericCommand(c, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h3><p>通过过期字典，检查：</p><ul><li>检查给定键是否存在于过期字典：若存在，取得键的过期时间。</li><li>检查当前UNIX时间戳是否大于键的过期时间：若是，则键已经过期，否则未过期。</li></ul><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><ul><li>定时删除。设置键的过期时间的同时，创建一个定时器，定时器在过期时间到来时，立即执行对键的删除操作。</li><li>惰性删除。每次从键空间获取键时，检查键是否过期，若是则删除该键。</li><li>定期删除。每个一段时间，对数据库进行一次检查，删除里面的过期键。</li></ul><p>创建定时器会用到时间事件，实现方式为无序链表，查找时间复杂度为O(N)，不能高效处理大量时间事件。</p><p>惰性删除会导致不被访问的键永远无法被删除，导致内存泄漏，除非用户手动执行FLUSHDB。</p><p>Redis使用惰性删除和定期删除两种策略。惰性删除策略由db.c/expireIfNeeded函数实现，见注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* This function is called when we are going to perform some operation</span><br><span class="line"> * in a given key, but such key may be already logically expired even if</span><br><span class="line"> * it still exists in the database. The main way this function is called</span><br><span class="line"> * is via lookupKey*() family of functions.</span><br><span class="line"> *</span><br><span class="line"> * The behavior of the function depends on the replication role of the</span><br><span class="line"> * instance, because slave instances do not expire keys, they wait</span><br><span class="line"> * for DELs from the master for consistency matters. However even</span><br><span class="line"> * slaves will try to have a coherent return value for the function,</span><br><span class="line"> * so that read commands executed in the slave side will be able to</span><br><span class="line"> * behave like if the key is expired even if still present (because the</span><br><span class="line"> * master has yet to propagate the DEL).</span><br><span class="line"> *</span><br><span class="line"> * In masters as a side effect of finding a key which is expired, such</span><br><span class="line"> * key will be evicted from the database. Also this may trigger the</span><br><span class="line"> * propagation of a DEL/UNLINK command in AOF / replication stream.</span><br><span class="line"> *</span><br><span class="line"> * The return value of the function is 0 if the key is still valid,</span><br><span class="line"> * otherwise the function returns 1 if the key is expired. */</span><br><span class="line">int expireIfNeeded(redisDb *db, robj *key) &#123;</span><br><span class="line">    if (!keyIsExpired(db,key)) return 0;</span><br><span class="line"></span><br><span class="line">    /* If we are running in the context of a slave, instead of</span><br><span class="line">     * evicting the expired key from the database, we return ASAP:</span><br><span class="line">     * the slave key expiration is controlled by the master that will</span><br><span class="line">     * send us synthesized DEL operations for expired keys.</span><br><span class="line">     *</span><br><span class="line">     * Still we try to return the right information to the caller,</span><br><span class="line">     * that is, 0 if we think the key should be still valid, 1 if</span><br><span class="line">     * we think the key is expired at this time. */</span><br><span class="line">    if (server.masterhost != NULL) return 1;</span><br><span class="line"></span><br><span class="line">    /* Delete the key */</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        &quot;expired&quot;,key,db-&gt;id);</span><br><span class="line">    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过期键定时删除策略由redis.h中定义，expire.c中实现，每当redis的服务器周期性操作redis.c/serverCron函数执行时，在其内部调用的databasesCron函数调用activeExpireCycle函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">/* Try to expire a few timed out keys. The algorithm used is adaptive and</span><br><span class="line"> * will use few CPU cycles if there are few expiring keys, otherwise</span><br><span class="line"> * it will get more aggressive to avoid that too much memory is used by</span><br><span class="line"> * keys that can be removed from the keyspace.</span><br><span class="line"> *</span><br><span class="line"> * No more than CRON_DBS_PER_CALL databases are tested at every</span><br><span class="line"> * iteration.</span><br><span class="line"> *</span><br><span class="line"> * This kind of call is used when Redis detects that timelimit_exit is</span><br><span class="line"> * true, so there is more work to do, and we do it more incrementally from</span><br><span class="line"> * the beforeSleep() function of the event loop.</span><br><span class="line"> *</span><br><span class="line"> * Expire cycle type:</span><br><span class="line"> *</span><br><span class="line"> * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a</span><br><span class="line"> * &quot;fast&quot; expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION</span><br><span class="line"> * microseconds, and is not repeated again before the same amount of time.</span><br><span class="line"> *</span><br><span class="line"> * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is</span><br><span class="line"> * executed, where the time limit is a percentage of the REDIS_HZ period</span><br><span class="line"> * as specified by the ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC define. */</span><br><span class="line"></span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    /* This function has some global state in order to continue the work</span><br><span class="line">     * incrementally across calls. */</span><br><span class="line">    static unsigned int current_db = 0; /* Last DB tested. */</span><br><span class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</span><br><span class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</span><br><span class="line"></span><br><span class="line">    int j, iteration = 0;</span><br><span class="line">    int dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    long long start = ustime(), timelimit, elapsed;</span><br><span class="line"></span><br><span class="line">    /* When clients are paused the dataset should be static not just from the</span><br><span class="line">     * POV of clients not being able to write, but also from the POV of</span><br><span class="line">     * expires and evictions of keys not being performed. */</span><br><span class="line">    if (clientsArePaused()) return;</span><br><span class="line"></span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exit</span><br><span class="line">         * for time limit. Also don&apos;t repeat a fast cycle for the same period</span><br><span class="line">         * as the fast cycle total duration itself. */</span><br><span class="line">        if (!timelimit_exit) return;</span><br><span class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We usually should test CRON_DBS_PER_CALL per iteration, with</span><br><span class="line">     * two exceptions:</span><br><span class="line">     *</span><br><span class="line">     * 1) Don&apos;t test more DBs than we have.</span><br><span class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</span><br><span class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</span><br><span class="line">     * expired keys to use memory for too much time. */</span><br><span class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span><br><span class="line">     * per iteration. Since this function gets called with a frequency of</span><br><span class="line">     * server.hz times per second, the following is the max amount of</span><br><span class="line">     * microseconds we can spend in this function. */</span><br><span class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</span><br><span class="line">    timelimit_exit = 0;</span><br><span class="line">    if (timelimit &lt;= 0) timelimit = 1;</span><br><span class="line"></span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</span><br><span class="line"></span><br><span class="line">    /* Accumulate some global stats as we expire keys, to have some idea</span><br><span class="line">     * about the number of keys that are already logically expired, but still</span><br><span class="line">     * existing inside the database. */</span><br><span class="line">    long total_sampled = 0;</span><br><span class="line">    long total_expired = 0;</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit == 0; j++) &#123;</span><br><span class="line">        int expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        /* Increment the DB now so we are sure if we run out of time</span><br><span class="line">         * in the current DB we&apos;ll restart from the next. This allows to</span><br><span class="line">         * distribute the time evenly across DBs. */</span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        /* Continue to expire if at the end of the cycle more than 25%</span><br><span class="line">         * of the keys were expired. */</span><br><span class="line">        do &#123;</span><br><span class="line">            unsigned long num, slots;</span><br><span class="line">            long long now, ttl_sum;</span><br><span class="line">            int ttl_samples;</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            /* If there is nothing to expire try next DB ASAP. */</span><br><span class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</span><br><span class="line">                db-&gt;avg_ttl = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            /* When there are less than 1% filled slots getting random</span><br><span class="line">             * keys is expensive, so stop here waiting for better times...</span><br><span class="line">             * The dictionary will be resized asap. */</span><br><span class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*100/slots &lt; 1)) break;</span><br><span class="line"></span><br><span class="line">            /* The main collection cycle. Sample random keys among keys</span><br><span class="line">             * with an expire set, checking for expired ones. */</span><br><span class="line">            expired = 0;</span><br><span class="line">            ttl_sum = 0;</span><br><span class="line">            ttl_samples = 0;</span><br><span class="line"></span><br><span class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            while (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                long long ttl;</span><br><span class="line"></span><br><span class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                if (ttl &gt; 0) &#123;</span><br><span class="line">                    /* We want the average TTL of keys yet not expired. */</span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line"></span><br><span class="line">            /* Update the average TTL stats for this database. */</span><br><span class="line">            if (ttl_samples) &#123;</span><br><span class="line">                long long avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"></span><br><span class="line">                /* Do a simple running average with a few samples.</span><br><span class="line">                 * We just use the current estimate with a weight of 2%</span><br><span class="line">                 * and the previous estimate with a weight of 98%. */</span><br><span class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/50)*49 + (avg_ttl/50);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can&apos;t block forever here even if there are many keys to</span><br><span class="line">             * expire. So after a given amount of milliseconds return to the</span><br><span class="line">             * caller waiting for the other active expire cycle. */</span><br><span class="line">            if ((iteration &amp; 0xf) == 0) &#123; /* check once every 16 iterations. */</span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                if (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = 1;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</span><br><span class="line">             * found expired in the current DB. */</span><br><span class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed = ustime()-start;</span><br><span class="line">    latencyAddSampleIfNeeded(&quot;expire-cycle&quot;,elapsed/1000);</span><br><span class="line"></span><br><span class="line">    /* Update our estimate of keys existing but yet to be expired.</span><br><span class="line">     * Running average with this sample accounting for 5%. */</span><br><span class="line">    double current_perc;</span><br><span class="line">    if (total_sampled) &#123;</span><br><span class="line">        current_perc = (double)total_expired/total_sampled;</span><br><span class="line">    &#125; else</span><br><span class="line">        current_perc = 0;</span><br><span class="line">    server.stat_expired_stale_perc = (current_perc*0.05)+</span><br><span class="line">                                     (server.stat_expired_stale_perc*0.95);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><h4 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h4><p>执行SAVE命令或BGSAVE命令创建一个新的RDB文件时，对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件。</p><h4 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h4><ul><li>若服务器已主服务器模式运行，载入RDB文件时，对文件中保存的键进行检查，未过期的键载入数据库中，过期的被忽略。</li><li>以从服务器模式运行，载入RDB文件时，保存的所有键，不存是否过期，都载入到数据库中。主从同步时会清空从服务器。</li></ul><h4 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h4><p>若以AOF持久化模式运行，若键已过期，但未被删除，仍会记录到AOF文件中，当键删除时，会向AOF文件追加一条DEL命令，显示记录该键已经被删除。</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>执行AOF重写时会键进行检查，已过期的键被忽略。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>复制模式下，从服务器过期键删除动作由主服务器控制：</p><ul><li>主服务器删除过期键后，显示地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器执行客户端发送的读命令时，遇到过期键也不会将其删除，继续像处理未过期的键一样处理过期键，将实际已过期键值返回给客户端。</li><li>从服务器只有在接到主服务器发来的DEL命令后，才删除过期键。</li></ul><h3 id="数据库通知-订阅-发布"><a href="#数据库通知-订阅-发布" class="headerlink" title="数据库通知(订阅/发布)"></a>数据库通知(订阅/发布)</h3><p>客户端通过订阅给定的频道或者模式，获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>通过配置选项notify-keyspace-events确定发送通知的类型。</p><p>发送通知功能在notify.c/notifyKeyspaceEvent函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/* The API provided to the rest of the Redis core is a simple function:</span><br><span class="line"> *</span><br><span class="line"> * notifyKeyspaceEvent(char *event, robj *key, int dbid);</span><br><span class="line"> *</span><br><span class="line"> * &apos;event&apos; is a C string representing the event name.</span><br><span class="line"> * &apos;key&apos; is a Redis object representing the key name.</span><br><span class="line"> * &apos;dbid&apos; is the database ID where the key lives.  */</span><br><span class="line">void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) &#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    int len = -1;</span><br><span class="line">    char buf[24];</span><br><span class="line"></span><br><span class="line">    /* If any modules are interested in events, notify the module system now.</span><br><span class="line">     * This bypasses the notifications configuration, but the module engine</span><br><span class="line">     * will only call event subscribers if the event type matches the types</span><br><span class="line">     * they are interested in. */</span><br><span class="line">     moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    /* If notifications for this class of events are off, return ASAP. */</span><br><span class="line">    if (!(server.notify_keyspace_events &amp; type)) return;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,strlen(event));</span><br><span class="line"></span><br><span class="line">    /* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span><br><span class="line">    if (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(&quot;__keyspace@&quot;,11);</span><br><span class="line">        len = ll2string(buf,sizeof(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, &quot;__:&quot;, 3);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span><br><span class="line">    if (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(&quot;__keyevent@&quot;,11);</span><br><span class="line">        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, &quot;__:&quot;, 3);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布订阅消息由pubsub.c/pubsubPublishMessage函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/* Publish a message */</span><br><span class="line">int pubsubPublishMessage(robj *channel, robj *message) &#123;</span><br><span class="line">    int receivers = 0;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    /* Send to clients listening for that channel */</span><br><span class="line">    de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        list *list = dictGetVal(de);</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        listRewind(list,&amp;li);</span><br><span class="line">        while ((ln = listNext(&amp;li)) != NULL) &#123;</span><br><span class="line">            client *c = ln-&gt;value;</span><br><span class="line">            addReplyPubsubMessage(c,channel,message);</span><br><span class="line">            receivers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Send to clients listening to matching channels */</span><br><span class="line">    if (listLength(server.pubsub_patterns)) &#123;</span><br><span class="line">        listRewind(server.pubsub_patterns,&amp;li);</span><br><span class="line">        channel = getDecodedObject(channel);</span><br><span class="line">        while ((ln = listNext(&amp;li)) != NULL) &#123;</span><br><span class="line">            pubsubPattern *pat = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            if (stringmatchlen((char*)pat-&gt;pattern-&gt;ptr,</span><br><span class="line">                                sdslen(pat-&gt;pattern-&gt;ptr),</span><br><span class="line">                                (char*)channel-&gt;ptr,</span><br><span class="line">                                sdslen(channel-&gt;ptr),0))</span><br><span class="line">            &#123;</span><br><span class="line">                addReplyPubsubPatMessage(pat-&gt;client,</span><br><span class="line">                    pat-&gt;pattern,channel,message);</span><br><span class="line">                receivers++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    return receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;headerlink&quot; title=&quot;服务器中的数据库&quot;&gt;&lt;/a&gt;服务器中的数据库&lt;/h3&gt;&lt;p&gt;保存于服务器状态server.h/redisServer结构db数组中。每一项都是一个ser
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="db" scheme="bighua.top/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎源代码的编译和调试</title>
    <link href="bighua.top/2019/09/18/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>bighua.top/2019/09/18/InnoDB存储引擎源代码的编译和调试/</id>
    <published>2019-09-18T06:30:31.000Z</published>
    <updated>2019-09-14T12:33:02.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">源码</a></p><h3 id="InnoDB源码结构"><a href="#InnoDB源码结构" class="headerlink" title="InnoDB源码结构"></a>InnoDB源码结构</h3><p>MySQL源码目录下storage文件夹下，文件夹名即为存储引擎名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:storage wuhua$ pwd</span><br><span class="line">/Users/wuhua/Downloads/mysql-8.0.17/storage</span><br><span class="line">wuhua:storage wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── archive</span><br><span class="line">├── blackhole</span><br><span class="line">├── csv</span><br><span class="line">├── example</span><br><span class="line">├── federated</span><br><span class="line">├── heap</span><br><span class="line">├── innobase</span><br><span class="line">├── myisam</span><br><span class="line">├── myisammrg</span><br><span class="line">├── ndb</span><br><span class="line">├── perfschema</span><br><span class="line">├── secondary_engine_mock</span><br><span class="line">└── temptable</span><br><span class="line"></span><br><span class="line">13 directories, 0 files</span><br></pre></td></tr></table></figure><p>InnoDB源码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">wuhua:innobase wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt   </span><br><span class="line">├── COPYING.Google</span><br><span class="line">├── COPYING.Percona</span><br><span class="line">├── Doxyfile</span><br><span class="line">├── api</span><br><span class="line">├── arch</span><br><span class="line">├── btr            //B+ tree的实现</span><br><span class="line">├── buf            //缓冲池的实现，包括LRU算法，Flush刷新算法</span><br><span class="line">├── clone</span><br><span class="line">├── data</span><br><span class="line">├── dict//InnoDB存储引擎中内存数据字典的实现</span><br><span class="line">├── eval</span><br><span class="line">├── fil//InnoDB存储引擎中文件数据结构及对文件的一些操作</span><br><span class="line">├── fsp//file space，对InnoDB engine物理文件的管理，如页、区、段等</span><br><span class="line">├── fts</span><br><span class="line">├── fut</span><br><span class="line">├── gis</span><br><span class="line">├── ha//哈希算法的实现</span><br><span class="line">├── handler//继承MySQL的handler，插件式存储引擎的实现</span><br><span class="line">├── ibuf//插入缓冲的实现</span><br><span class="line">├── include//头文件（.h，.ic）</span><br><span class="line">├── innodb.cmake</span><br><span class="line">├── lob</span><br><span class="line">├── lock//锁的实现，如S锁、X锁，以及定义锁的一系列算法</span><br><span class="line">├── log//日志缓冲和重做日志文件的实现</span><br><span class="line">├── mach</span><br><span class="line">├── mem//辅助缓冲池的实现，用来申请一些数据结构的内存</span><br><span class="line">├── mtr//事务的底层实现</span><br><span class="line">├── os//封装一些对于操作系统的操作</span><br><span class="line">├── page//页的实现</span><br><span class="line">├── pars</span><br><span class="line">├── que</span><br><span class="line">├── read</span><br><span class="line">├── rem</span><br><span class="line">├── row//对于各种类型行数据的操作</span><br><span class="line">├── srv//对于InnoDB engine参数的设计</span><br><span class="line">├── sync//InnoDB engine互斥量（Mutex）的实现</span><br><span class="line">├── trx//事务的实现</span><br><span class="line">├── usr</span><br><span class="line">└── ut//工具类</span><br></pre></td></tr></table></figure><h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>源码中及各存储引擎中README文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;InnoDB源码结构&quot;&gt;&lt;a href=&quot;#InnoDB源码结构&quot; clas
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>性能调优</title>
    <link href="bighua.top/2019/09/17/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>bighua.top/2019/09/17/性能调优/</id>
    <published>2019-09-17T06:27:16.000Z</published>
    <updated>2019-09-14T12:01:07.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择合适的CPU"><a href="#选择合适的CPU" class="headerlink" title="选择合适的CPU"></a>选择合适的CPU</h3><p>InnoDB eigine一般应用OLTP数据库应用，特点：</p><ul><li>用户操作并发量大</li><li>事务处理的时间一般比较短</li><li>查询的语句较为简单，一般都走索引</li><li>复杂的查询较少</li></ul><p>对CPU要求不是很高，复杂的查询操作如比较、排序、连接等消耗CPU的操作较少发生。OLAP是CPU密集型的操作，OLTP是IO密集型的操作。需注意提高IO。</p><p>未获得更多内存的支持，CPU必须是64位的。InnoDB设计架构，主要的后台操作在一个单独的master thread中完成，不能很好的支持多核的应用。多核CPU应选取InnoDB v1.1或更高版本。可通过参数<code>innodb_read_io_threads</code>和<code>innodb_write_io_threads</code>增大IO的线程，更有效地利用CPU的多核性能。</p><p>当前MySQl版本中，一条SQL语句只能在一个CPU中工作，不支持多CPU的处理。</p><h3 id="内存的重要性"><a href="#内存的重要性" class="headerlink" title="内存的重要性"></a>内存的重要性</h3><p>内存的大小最能直接反映数据库的性能。开发前应预估“活跃”数据库的大小，以此确定数据库服务器内存的大小。通过查看当前服务器的状态，比较物理磁盘的读取和内存读取的比例判断缓冲池的命中率，通常InnoDB engine的缓冲池命中率不应小于99%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show  global status like &apos;innodb%read%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_rnd</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_evicted</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_requests</span><br><span class="line">        Value: 5373</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_reads</span><br><span class="line">        Value: 488</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: Innodb_data_pending_reads</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: Innodb_data_read</span><br><span class="line">        Value: 8065536</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: Innodb_data_reads</span><br><span class="line">        Value: 549</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: Innodb_pages_read</span><br><span class="line">        Value: 487</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">Variable_name: Innodb_rows_read</span><br><span class="line">        Value: 120</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当前服务器的状态参数：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">Innodb_buffer_pool_reads</td><td style="text-align:center">表示从物理磁盘读取页的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead</td><td style="text-align:center">预读的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead_evicted</td><td style="text-align:center">预读的页，一般用于判断预读的效率</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_requests</td><td style="text-align:center">从缓冲池中读取页的次数</td></tr><tr><td style="text-align:center">Innodb_data_read</td><td style="text-align:center">总共读入的字节数</td></tr><tr><td style="text-align:center">Innodb_data_reads</td><td style="text-align:center">发起读取请求的次数，每次读取可能需要读取多个页</td></tr></tbody></table><p>缓冲池命中率 = Innodb_buffer_pool_read_requests / (Innodb_buffer_pool_read_requests +  Innodb_buffer_pool_read_ahead + Innodb_data_reads)</p><p>平均每次读取的字节数=Innodb_data_read /  Innodb_data_reads</p><h3 id="磁盘对数据库性能的影响"><a href="#磁盘对数据库性能的影响" class="headerlink" title="磁盘对数据库性能的影响"></a>磁盘对数据库性能的影响</h3><h4 id="传统机械硬盘"><a href="#传统机械硬盘" class="headerlink" title="传统机械硬盘"></a>传统机械硬盘</h4><p>服务器领域一般使用SAS或SATA接口的硬盘，服务器机械硬盘向小型化转型。</p><p>重要指标：寻道时间、转速。</p><p>通常可将多块机械硬盘组成RAID提高数据库的性能，也可将数据文件分布在不同的磁盘上来达到访问负载的均衡。</p><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><p>基于闪存的硬盘，内部由山村（Flash Memory）组成。具有低延时性、低功耗、防震性等。企业级应用一般使用固态硬盘，通过并联多块闪存进一步提高数据传输的吞吐量。</p><p>闪存是一个完全的电子设备，没有传统机械硬盘的读写磁盘。不需要耗费大量的时间进行磁头旋转和定位来查找数据。固态硬盘可以提供一致的随机访问时间。闪存中的数据是不可更新的，只能通过扇区的覆盖重写，在覆盖重写之前，需要执行耗时的擦除操作。擦除操作不能在所含扇区上完成，需要在删除整个被称为擦除块的基础上完成，擦除块的尺寸大于扇区的大小，通常为128KB或者256KB。每个擦除块有擦写次数限制（已有算法解决）。需要考虑固态硬盘在写入方面存在的问题。</p><p>闪存提供的读写速度是非对称的，读取速度远快于写入的速度。通过增加通道数量，可线性提高固态硬盘的性能。固态硬盘的访问延时一般小于0.1ms左右。</p><p>可通过增加参数<code>innodb_io_capacity</code>的值，充分利用固态硬盘带来高的IOPS特性。InnoSQL及InnoDB  v1.2可选择关闭邻接页的刷新，为数据库带来一定效果的提升。</p><p>可利用InnoSQL开发的L2 Cache解决方案，在内存缓冲池和传统存储层之间建立一层基于闪存固态硬盘的二级缓冲池，以此扩充缓冲池的容量，充分利用固态硬盘的超高速随机读写性能，提高数据库的性能。</p><h3 id="合理地设置RAID"><a href="#合理地设置RAID" class="headerlink" title="合理地设置RAID"></a>合理地设置RAID</h3><h4 id="RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"><a href="#RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。" class="headerlink" title="RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"></a>RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。</h4><p>RAID作用：</p><ul><li>增强数据集成度</li><li>增强容错功能</li><li>增加处理量或容量</li></ul><p>RAID组合方式：</p><ul><li>RAID 0:将多个磁盘合并成一个大的磁盘，不会有冗余，并行I/O，速度最快。也称为带区集，将多个磁盘并列起来，使之成为一个大磁盘，存放数据时，将数据按照磁盘的个数进行分段，同时将这些数据写进这些盘中。没有冗余功能，若一个磁盘损坏，所有的数据都会丢失。多磁盘效能受限于总I/O瓶颈，RAID效能随边际递减。</li><li>RAID 1:两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，写入速度略降低。除非拥有相同数据的主磁盘与镜像同时损坏，否则只要有一个磁盘正常的工作即可维持工作，可靠性最高，利用率最低。</li><li>RAID 5:兼顾存储性能、数据安全和存储成本。使用Disk Strping（硬盘分区）技术。至少需要三个磁盘，不对存储的数据进行备份，把数据和相对应的奇偶校验信息存储到组成RAID 5的各个磁盘上，奇偶校验信息和相应的数据分别存储于不同的磁盘上，有一个磁盘损坏后，利用剩下额数据相应的奇偶校验信息恢复被损坏的数据。</li><li>RAID 10和RAID 01:RAID 10先镜像再分区数据，将所有磁盘分为两组，视为RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 01于RAID 10程序相反，先分区再将数据镜射到两组硬盘。</li><li>RAID 50:镜像阵列条带，至少由六块硬盘组成，同RAID 0一样，数据被分区称条带，在同一时间内向多块磁盘写入；同RAID 5一样，以数据的校验保证数据的安全，校验条带均匀分布在各个磁盘上，目的在于提高RAID 5的读写性能。</li></ul><p>对数据库，RAID 10是最好的选择，同时兼顾RAID 1和RAID 0的特性。</p><h4 id="RAID-Write-Back功能"><a href="#RAID-Write-Back功能" class="headerlink" title="RAID Write Back功能"></a>RAID Write Back功能</h4><p>指RAID控制器能够将写入的数据放入自身的缓存中，并把他们安排到后面再执行。不同等待物理磁盘实际写入的完成，写入更快。</p><p>数据库或操作系统关机时，Write Back功能可能会破坏数据库的数据。因写入可能还在RAID卡的缓存中，没有完全写入磁盘。为解决此问题大部分硬件RAID卡提供电池备份单元。</p><p>没有启用Write Back功能，则RAID卡设置中显示为Write Through，没有缓冲写入。Write Through模式下，可通过参数<code>innodb_flush_log_at_trx_commit</code>设置为0提高执行存储过程的性能。</p><h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><ul><li>sysbench<a href="https://www.jianshu.com/p/4a37a6a452d9" target="_blank" rel="noopener">基准测试工具Sysbench</a></li><li>mysql-tpcc<a href="https://www.hi-linux.com/posts/38534.html" target="_blank" rel="noopener">TPCC-MySQL 的安装与使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;选择合适的CPU&quot;&gt;&lt;a href=&quot;#选择合适的CPU&quot; class=&quot;headerlink&quot; title=&quot;选择合适的CPU&quot;&gt;&lt;/a&gt;选择合适的CPU&lt;/h3&gt;&lt;p&gt;InnoDB eigine一般应用OLTP数据库应用，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="majorization" scheme="bighua.top/tags/majorization/"/>
    
  </entry>
  
  <entry>
    <title>备份与恢复</title>
    <link href="bighua.top/2019/09/17/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>bighua.top/2019/09/17/备份与恢复/</id>
    <published>2019-09-17T06:26:59.000Z</published>
    <updated>2019-09-14T10:45:20.148Z</updated>
    
    <content type="html"><![CDATA[<p>备份工具：mysqldump、ibbackup、replication、xtrabackup、LVM快照备份等。</p><h3 id="备份与恢复概述"><a href="#备份与恢复概述" class="headerlink" title="备份与恢复概述"></a>备份与恢复概述</h3><p>根据备份方法分：</p><ul><li>Hot Backup（热备份）：数据库运行中直接备份，对正在运行的数据库操作无任何影响，也称为Online Backup（在线备份）。</li><li>Cold Backup（冷备份）：数据库停止时备份，一般只需要复制相关的数据库物理文件，也称为Offline Backup（离线备份）。</li><li>Warm Backup（温备份）：数据库运行中进行备份，会对当前数据库操作有所影响，例如需要加全局读锁以保证备份数据的一致性。</li></ul><p>按备份后文件的内容分：</p><ul><li>逻辑备份：备份的文件可读，一般是文本文件，内容一般由一条条SQL语句或者是表内实际数据组成。可观察到出文件的内容，一般适用于数据库的升级、迁移等工作。恢复时间较长。</li><li>裸文件备份：复制数据库的物理文件，既可以是数据库运行中的复制，也可以是数据库停止运行时直接的数据文件复制，恢复时间较短。</li></ul><p>按备份数据的内容：</p><ul><li>完全备份：对数据库进行一个完成的备份。</li><li>增量备份：在上次完全备份的基础上，对于更改的数据进行备份。</li><li>日志备份：针对MySQL DB二进制日志的备份，通过对一个完全备份进行二进制日志的重做（replay）来完成数据库的point-in-time的恢复工作。</li></ul><p>MySQl数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave/standby）数据库。MySQL未提供真正的增量备份方法，大部分通过二进制日志完成增量备份的工作。效率较真正的增量备份低。</p><p>增量备份只需要记录当前每页最后的检查点的LSN，若大于之前全备份时的LSN，则备份该页，否则不用备份，是xtrabackup工具增量备份的原理。</p><p>数据库备份的一致性要求在备份的时间数据在这一时间点上是一致的。InnoDB engine支持MVCC，实现一致的备份比较简单。可先开启一个事务，然后导出一组相关的表，最后提交，事务的隔离级别必须设置为REPEATABLE READ。</p><p>mysqldump备份工具，可通过添加–single-transaction选项获得InnoDB存储引擎的一致性备份（必i 加选项）。</p><h3 id="冷备"><a href="#冷备" class="headerlink" title="冷备"></a>冷备</h3><p>InnoDB engine冷备需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.idb），重做日志文件。定期备份MySQL数据库的配置文件my.cnf，有利于恢复的操作。</p><p>优点：</p><ul><li>备份简单，只要复制相关文件即可。</li><li>备份文件易于在不同操作系统，不同MySQL版本上进行恢复。</li><li>恢复简单，只需要把文件恢复到指定位置。</li><li>恢复速度快，不需要执行任何SQL语句，不需要重建索引。</li></ul><p>缺点：</p><ul><li>冷备文件通常比逻辑文件大很大，表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。</li><li>不总是可以轻易跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式会成为问题。</li></ul><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>开始用于完成转存数据库备份及不同数据库之间的移植。</p><p>语法：</p><p><code>mysqldump [arguments] &gt; file_name</code></p><p>参数可通过mysqldump –help查看：</p><ul><li>–single-transaction：保证备份的一致性。备份开始前先执行START TRANSACTION命令，一次获得备份的一致性，只对InnoDB engine有效。启用该参数时需确保没有任何其他任何的DDL语句执行，一致性读并不能隔离DDL操作。</li><li>–lock-tables（-l）：备份过程中依次锁住每个架构下的所有表，一般用于MyISAM engine，当备份时只能对数据库进行读取操作，备份依然可以保证一致性。InnoDB engine不需要使用此参数，用–single-transaction， –lock-tables和–single-transaction互斥，不能同时使用。</li><li>–lock-all-tables（-x）：备份过程中对所有表上锁，避免–lock-tables不能同时锁住所有表的问题。</li><li>–add-drop-database：在CREATE DATABASE前先运行DROP DATABASE。需与–all-databases或–databases选型一起使用。默认情况下到处的文本文件中并不会有CREATE DATABASE，除非指定该参数。</li><li>–master-data [=value]：产生的备份转存文件主要用来建立一个replication。value为1时，转存文件中记录CHANGE MASTER语句，值为2时，CHANGE MASTER语句被写出SQL注释。默认值为空。会自动忽略–lock-tables选项，若没有选用–single-transaction则自动使用–lock-all-tables选项。</li><li>–enents（-E）：备份事件调度器。</li><li>–routines（-R）：备份存储过程和函数。</li><li>–triggers：备份触发器。</li><li>–hex-blob：将BINARY、VARBINARY、BLOG和BIT列类型备份为十六进制的格式。mysqldump文件导出的文本文件上述类型在文本文件模式下可能有些字符不可见，添加此选型会以十六进制的方式显示。</li><li>–tab=path（-T path）：产生TAB分割的数据文件。每张表，mysqldump创建一个包含CREATE TABLE语句的table_name.sql文件，和包含数据的tbl_name.txt文件。可使用–fields-terminated=…，–fields-enclosed-by=…，–fields-optionally-enclosed-by=…，–fields-escaped-by=…，–lines-terminated-by=…来改变默认的分隔符、换行符等。</li><li>–where=’where_condition’ (-w ‘where_condition’)：导出给定条件的数据。</li><li>–all-databases: 备份所有数据库</li><li>–databases： 备份指定数据库</li></ul><h4 id="SELECT…INTO-OUTFILE"><a href="#SELECT…INTO-OUTFILE" class="headerlink" title="SELECT…INTO OUTFILE"></a>SELECT…INTO OUTFILE</h4><p>逻辑备份方法，道出一张表中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT [column 1],[column 2] ...</span><br><span class="line">INTO</span><br><span class="line">OUTFILE &apos;file_name&apos;</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINES</span><br><span class="line">[SATRTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">FROM TABLE WHERE ...</span><br></pre></td></tr></table></figure><p>FIELDS[TERMINATED BY ‘string’]表示每个列的分隔符，[[OPTIONALLY] ENCLOSED BY ‘char’]表示对于字符串的包含符，[ESCAPED BY ‘char’]表示转义符。[STARTING BY ‘string’]表示每行的开始符号，[TERMINATED BY ‘string’]表示每行的结束符号。没指定FIELDS和LINES选型时的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLELDS TERMINATED BY &apos;\t&apos; ENCLOSED BY &apos;&apos; ESCAPED BY &apos;\\&apos;</span><br><span class="line">LINES TERMINATED BY &apos;\n&apos; STARTING BY &apos;&apos;</span><br></pre></td></tr></table></figure><p>file_name表示导出的文件，路径权限必须是mysql：mysql的。</p><h4 id="逻辑备份的恢复"><a href="#逻辑备份的恢复" class="headerlink" title="逻辑备份的恢复"></a>逻辑备份的恢复</h4><p>mysqldump只需执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p &lt; test_backup.sql</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>导入时包含了创建和删除数据库的SQL语句，须确保删除架构时，架构目录下没有其他与数据相关的文件。</p><p>mysqldump可导出存储过程、导出触发器、导出事件、导出数据，不能导出视图。需导出视图定义或备份视图定义的frm文件，在恢复时进行导入。</p><h4 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a>LOAD DATA INFILE</h4><p>通过mysqldump-tab或者SELECT INTO OUTFILE导出的数据，可通过命令LOAD DATA INFILE进行导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[REPLACE | IGNORE] </span><br><span class="line">INTO TABLE tbl_name</span><br><span class="line">[CHARACTER SET charset_name]</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINE </span><br><span class="line">[STARTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">[IGNORE number LINES]</span><br><span class="line">[(col_name_or_user_var,...)]</span><br><span class="line">[SET col_name=expr,...]</span><br></pre></td></tr></table></figure><p>需拥有INFILE权限。导入格式的选项同SELECT INTO OUTFILE命令一致。IGNORE number LINES可忽略导入的前几行。</p><h4 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h4><p>MySQL DB提供的命令行程序，时LOAD DATA INFILE的命令接口，大多数选项与LOAD DATA INFILE语法相同。</p><p><code>mysqlimport [option] db_name textfile1 [textfile2 ...]</code></p><p>该命令可用来导入多张表，通过–user-thread参数并发导入不同的文件。</p><h3 id="二进制日志备份与恢复"><a href="#二进制日志备份与恢复" class="headerlink" title="二进制日志备份与恢复"></a>二进制日志备份与恢复</h3><p>可通过二进制日志完成point-in-time的恢复工作。MySQL DB replication同样需要二进制日志。默认并不启用二进制日志，需先启用。在配置文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">sync-binlog=1</span><br><span class="line">innodb_support_xa=1</span><br></pre></td></tr></table></figure><p>备份二进制日志文件前，可通过FLUSH LOGS命令生成一个新的二进制日志文件，然后备份之前的二进制日志文件。</p><p>恢复二进制日志，通过mysqlbinlog：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log_file | mysql -u root -p</span><br></pre></td></tr></table></figure><p>恢复多个二进制日志文件应该同时恢复，而不是一个一个地恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.[0-10]* | mysql -u root -p</span><br></pre></td></tr></table></figure><p>可通过mysqlbinlog导入到一个文件再通过SOURCE命令导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog_file1 &gt; binglog_file</span><br><span class="line">mysqlbinlog binlog_file2 &gt;&gt; binlog_file</span><br><span class="line">mysql -u root -p -e &quot;scorce binlog_file&quot;</span><br></pre></td></tr></table></figure><p>–start-position和–stop-position选项可指定二进制日志的某个偏移量来进行恢复，可跳过某些不正确的语句。–start-datetime和–stop-datetime选项可用来指定从二进制的某个时间点进行恢复。用法一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinglog --start-position=199512 binlog_file | mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="热备"><a href="#热备" class="headerlink" title="热备"></a>热备</h3><h4 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h4><p>InnoDB engine提供的热备份工具，可同时备份MyISAM engine和InnoDB engine。</p><p>对InnoDB engine table备份工作原理：</p><ul><li>记录备份开始时，InnoDB engine重做日志文件检查点的LSN。</li><li>复制共享表空间文件以及独立表空间文件。</li><li>记录复制完成表空间文件后，InnoDB engine重做日志文件检查点的LSN。</li><li>复制在备份时产生的重做日志</li></ul><p>优点：</p><ul><li>在线备份，不阻塞任何SQL语句。</li><li>备份性能好，实质是复制数据库文件和重做日志文件。</li><li>支持压缩备份，通过选项，可支持不同级别的压缩。</li><li>跨平台支持，ibbackup可运行在Linux、Windows以及主流的Unix系统平台上。</li></ul><p>ibbackup恢复InnoDB engine table：</p><ul><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ul><p>xtrabackup实现了ibbackup的功能，拓展支持了真正的增量备份功能。</p><h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>网址：<a href="https://launchpad.net/percona-xtrabackup" target="_blank" rel="noopener">xtrabackup</a>。</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --backup | --prepare [OPTIONS]</span><br></pre></td></tr></table></figure><p>开始备份时，首先记录重做日志的位置，然后对备份的InnoDB engine table的物理文件，即共享表空间文件和独立表空间文件进行复制，最后记录备份完成后的重做日志位置。</p><h4 id="xtrabackup实现增量备份"><a href="#xtrabackup实现增量备份" class="headerlink" title="xtrabackup实现增量备份"></a>xtrabackup实现增量备份</h4><p>原理：</p><ol><li>先完成一个全备，记录下此时额检查点LSN。</li><li>增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，是则备份该页，同时记录当前检查点的LSN。</li></ol><h3 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h3><p>通过文件系统支持的快照功能对数据库进行备份。前提是将所有数据库文件放在同一文件分区中，然后对分区进行快照操作。支持快照功能的文件系统和设备有FreeBSD的UFS文件系统，Solaris的ZFS文件系统，GUN/Linux的逻辑管理器（Logical Volume Manager，LVM）等。UFS和ZFS的快照实现大致和LVM相似。</p><p>LVM使用写时复制（Copy-on-write）技术创建快照。</p><p>参阅<a href="https://www.cnblogs.com/kevingrace/p/6129660.html" target="_blank" rel="noopener">Mysql备份系列（4）–lvm-snapshot备份mysql数据(全量+增量）操作记录</a>。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制（replication）是MySQL DB提供的一种高可用高性能解决方案，一般用于建立大型应用。步骤：</p><ul><li>主服务器（master）把数据更改记录到二进制日志（binlog）中。</li><li>从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</li><li>从服务器重做中继日志中的重做日志，把更改应用到自己的数据库上，以达到数据的最终一致。</li></ul><p>实质是一个完全备份加上二进制日志备份的还原。复制是异步实时的，存在主动服务器之间的执行延时。可通过SHOW SLAVE STATUS和SHOW MASTE STATUS查看当前的延时。</p><p>主要变量：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Slave_IO_State</td><td style="text-align:center">当前IO线程的状态</td></tr><tr><td style="text-align:center">Master_Log_File</td><td style="text-align:center">当前同步的主服务器的二进制日志</td></tr><tr><td style="text-align:center">Read_Master_Log_Pos</td><td style="text-align:center">显示当前同步到主服务器上二进制日志的偏移量位置，单位字节。</td></tr><tr><td style="text-align:center">Relay_Master_Log_File</td><td style="text-align:center">当前中继日志同步的二进制日志</td></tr><tr><td style="text-align:center">Relay_Log_File</td><td style="text-align:center">显示当前写入的中继日志</td></tr><tr><td style="text-align:center">Relay_Log_Log</td><td style="text-align:center">显示当前执行到中继日志的便宜量位置</td></tr><tr><td style="text-align:center">Slave_IO_Running</td><td style="text-align:center">从服务器中IO线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Slave_SQL_Running</td><td style="text-align:center">从服务器中SQL线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Exec_Master_Log_Pos</td><td style="text-align:center">表示同步到主服务器的二进制日志偏移量的位置，Read_Master_Log_Pos-Exec_Master_Log_Pos可表示当前SQL线程运行的延时，单位是字节。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;备份工具：mysqldump、ibbackup、replication、xtrabackup、LVM快照备份等。&lt;/p&gt;
&lt;h3 id=&quot;备份与恢复概述&quot;&gt;&lt;a href=&quot;#备份与恢复概述&quot; class=&quot;headerlink&quot; title=&quot;备份与恢复概述&quot;&gt;&lt;/a&gt;备
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="backup" scheme="bighua.top/tags/backup/"/>
    
      <category term="recovery" scheme="bighua.top/tags/recovery/"/>
    
  </entry>
  
  <entry>
    <title>redis-对象</title>
    <link href="bighua.top/2019/09/17/redis-%E5%AF%B9%E8%B1%A1/"/>
    <id>bighua.top/2019/09/17/redis-对象/</id>
    <published>2019-09-17T03:26:38.000Z</published>
    <updated>2019-09-18T08:26:36.843Z</updated>
    
    <content type="html"><![CDATA[<p>基于数据结构创建对象系统，执行命令前根据对象的类型判断一个对象是否可以执行给定的命令。基于引用计数的内存回收机制，对象共享机制。带有访问时间信息，用于计算数据库键的空转时长，启用maxmemory功能下，空转时长较大的优先被服务器删除。</p><h3 id="对象类型和编码"><a href="#对象类型和编码" class="headerlink" title="对象类型和编码"></a>对象类型和编码</h3><p>注：参考的最新代码redis v5.x.x</p><p>使用对象表示数据库中的键和值，创建新键值对时，至少创建两个对象，一个对象用作键值对的键（键对象），一个对象用作键值对的值（值对象）。</p><p>结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* A redis object, that is a type able to hold a string / list / set */</span><br><span class="line"></span><br><span class="line">/* The actual Redis Object */</span><br><span class="line">/*</span><br><span class="line"> * Redis 对象</span><br><span class="line"> */</span><br><span class="line">#define REDIS_LRU_BITS 24</span><br><span class="line">#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */</span><br><span class="line">#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    // 对象最后一次被访问的时间</span><br><span class="line">    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). */</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // 指向实际值的指针</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------------------------------------</span><br><span class="line"> * Data types</span><br><span class="line"> *----------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/* A redis object, that is a type able to hold a string / list / set */</span><br><span class="line"></span><br><span class="line">/* The actual Redis Object */</span><br><span class="line">#define OBJ_STRING 0    /* String object.字符串对象 */</span><br><span class="line">#define OBJ_LIST 1      /* List object. 列表对象*/</span><br><span class="line">#define OBJ_SET 2       /* Set object. 集合对象*/</span><br><span class="line">#define OBJ_ZSET 3      /* Sorted set object. 有序集合对象*/</span><br><span class="line">#define OBJ_HASH 4      /* Hash object. 哈希对象*/</span><br><span class="line"></span><br><span class="line">/* The &quot;module&quot; object type is a special one that signals that the object</span><br><span class="line"> * is one directly managed by a Redis module. In this case the value points</span><br><span class="line"> * to a moduleValue struct, which contains the object value (which is only</span><br><span class="line"> * handled by the module itself) and the RedisModuleType struct which lists</span><br><span class="line"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span><br><span class="line"> * free the object.</span><br><span class="line"> *</span><br><span class="line"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span><br><span class="line"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span><br><span class="line"> * in order to dispatch the loading to the right module, plus a 10 bits</span><br><span class="line"> * encoding version. */</span><br><span class="line">#define OBJ_MODULE 5    /* Module object. 直接由模块管理*/</span><br><span class="line">#define OBJ_STREAM 6    /* Stream object. */</span><br></pre></td></tr></table></figure><p>stream类型参考<a href="http://xiaorui.cc/2018/06/07/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAredis5-0%E7%9A%84streams%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">浅入浅出Redis5.0的stream数据结构</a></p><p>编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span><br><span class="line"> * internally represented in multiple ways. The &apos;encoding&apos; field of the object</span><br><span class="line"> * is set to one of this fields for this object. */</span><br><span class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation 简单动态字符串*/</span><br><span class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer long类型整数*/</span><br><span class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table 字典*/</span><br><span class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap 压缩map*/</span><br><span class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. 不在使用，旧列表编码*/</span><br><span class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist 压缩列表*/</span><br><span class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset 整数集合*/</span><br><span class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist 跳跃表*/</span><br><span class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding embstr实现的动态字符串*/</span><br><span class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists 压缩列表实现的快速列表*/</span><br><span class="line">#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */</span><br></pre></td></tr></table></figure><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>编码可为int、raw或者embstr。保存的是整数值，且可用long类型表示，字符编码设置为int；若保存的是一个字符串值且长度小于等于39字节，使用embstr编码方式，超过使用row编码方式。</p><p>row调用两次内存分配函数分别创建redisObject结构和sdshdr结构，embstr通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。</p><p>对int编码或embstr编码的字符串追加，编码都会转变为row，没为这写编码的字符串编写相应的修改程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hi 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; append hi aaa</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; set hi aaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; append hi aaabbb</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; get hi</span><br><span class="line">&quot;aaaaaabbb&quot;</span><br><span class="line">127.0.0.1:6379&gt; set hi aaaaaabbb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; get hi</span><br><span class="line">&quot;aaaaaabbb&quot;</span><br><span class="line">127.0.0.1:6379&gt; set hi 111</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append hi 222</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; object encoding hi</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; get hi</span><br><span class="line">&quot;111222&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>随着对象的使用状态改变：</p><ul><li>创建一个新对象时，引用计数的值初始化为1；</li><li>被一个新程序使用时，引用计数值增1；</li><li>不再被一个程序使用时，引用计数值减1；</li><li>引用计数值为0时，对象所占的内存被释放。</li></ul><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>多个键共享一个值对象：</p><ul><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数赠一。</li></ul><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>lru属性，记录对象最后一次被命令程序访问的时间，</p><p>通过<code>OBJECT IDLETIME</code>命令打印给定键的空转时长，通过将当前时间减去键的值对象的lru时间计算得出，命令在访问键的对象时，不会修改值对象的lru属性。</p><p>打开maxmemory选项且服务器用于回收内存的算法为volatile-lru或allkeys-lru，占用内存数超过maxmemory选项所设置值，则空转时长较高的键优先被服务器释放，回收内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于数据结构创建对象系统，执行命令前根据对象的类型判断一个对象是否可以执行给定的命令。基于引用计数的内存回收机制，对象共享机制。带有访问时间信息，用于计算数据库键的空转时长，启用maxmemory功能下，空转时长较大的优先被服务器删除。&lt;/p&gt;
&lt;h3 id=&quot;对象类型和编
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="redisObject" scheme="bighua.top/tags/redisObject/"/>
    
  </entry>
  
  <entry>
    <title>redis-压缩列表/快速列表</title>
    <link href="bighua.top/2019/09/17/redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8:%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8/"/>
    <id>bighua.top/2019/09/17/redis-压缩列表:快速列表/</id>
    <published>2019-09-17T02:21:27.000Z</published>
    <updated>2019-09-17T03:21:22.540Z</updated>
    
    <content type="html"><![CDATA[<p>《redis设计与实现》实现的版本是3.0，截止今日最新的版本是5.x，本地安装的版本是4.0.10，此时列表应用的数据结构已发生变化。</p><p>参阅<a href="https://www.jianshu.com/p/ce24c9520731" target="_blank" rel="noopener">quicklist vs ziplist</a></p><p>参阅<a href="https://caticat.github.io/2018/05/09/redis-source-quicklist/" target="_blank" rel="noopener">Redis 源码分析-quicklist</a></p><p>参阅<a href="https://juejin.im/post/5ce0d1a36fb9a07ee168f876" target="_blank" rel="noopener">Redis从入门到放弃系列(三) List</a></p><p>参阅<a href="http://czrzchao.com/redisSourceQuicklist" target="_blank" rel="noopener">redis源码解读(六):基础数据结构之quicklist</a></p><p>参阅<a href="http://czrzchao.com/redisSourceAdlist" target="_blank" rel="noopener">redis源码解读(二):基础数据结构之ADLIST</a></p><h3 id="ziplist结构"><a href="#ziplist结构" class="headerlink" title="ziplist结构"></a>ziplist结构</h3><p>ziplist.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 保存 ziplist 节点信息的结构</span><br><span class="line"> */</span><br><span class="line">typedef struct zlentry &#123;</span><br><span class="line"></span><br><span class="line">    // prevrawlen ：前置节点的长度</span><br><span class="line">    // prevrawlensize ：编码 prevrawlen 所需的字节大小</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line"></span><br><span class="line">    // len ：当前节点值的长度</span><br><span class="line">    // lensize ：编码 len 所需的字节大小</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line"></span><br><span class="line">    // 当前节点 header 的大小</span><br><span class="line">    // 等于 prevrawlensize + lensize</span><br><span class="line">    unsigned int headersize;</span><br><span class="line"></span><br><span class="line">    // 当前节点值所使用的编码类型</span><br><span class="line">    unsigned char encoding;</span><br><span class="line"></span><br><span class="line">    // 指向当前节点的指针</span><br><span class="line">    unsigned char *p;</span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><p>空白 ziplist 示例图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes   4 bytes 2 bytes  1 byte</span><br><span class="line">            +---------+--------+-------+-----------+</span><br><span class="line">component   | zlbytes | zltail | zllen | zlend     |</span><br><span class="line">            |         |        |       |           |</span><br><span class="line">value       |  1011   |  1010  |   0   | 1111 1111 |</span><br><span class="line">            +---------+--------+-------+-----------+</span><br><span class="line">                                       ^</span><br><span class="line">                                       |</span><br><span class="line">                               ZIPLIST_ENTRY_HEAD</span><br><span class="line">                                       &amp;</span><br><span class="line">address                        ZIPLIST_ENTRY_TAIL</span><br><span class="line">                                       &amp;</span><br><span class="line">                               ZIPLIST_ENTRY_END</span><br><span class="line"></span><br><span class="line">非空 ziplist 示例图</span><br><span class="line"></span><br><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                        ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure><h3 id="quicklist结构"><a href="#quicklist结构" class="headerlink" title="quicklist结构"></a>quicklist结构</h3><p>quicklist.h+quicklist.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span><br><span class="line"> * We use bit fields keep the quicklistNode at 32 bytes.</span><br><span class="line"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span><br><span class="line"> * encoding: 2 bits, RAW=1, LZF=2.</span><br><span class="line"> * container: 2 bits, NONE=1, ZIPLIST=2.</span><br><span class="line"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span><br><span class="line"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span><br><span class="line"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span><br><span class="line">typedef struct quicklistNode &#123;</span><br><span class="line">    struct quicklistNode *prev;</span><br><span class="line">    struct quicklistNode *next;</span><br><span class="line">    unsigned char *zl;</span><br><span class="line">    unsigned int sz;             /* ziplist size in bytes */</span><br><span class="line">    unsigned int count : 16;     /* count of items in ziplist */</span><br><span class="line">    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */</span><br><span class="line">    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */</span><br><span class="line">    unsigned int recompress : 1; /* was this node previous compressed? */</span><br><span class="line">    unsigned int attempted_compress : 1; /* node can&apos;t compress; too small */</span><br><span class="line">    unsigned int extra : 10; /* more bits to steal for future usage */</span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line">/* quicklistLZF is a 4+N byte struct holding &apos;sz&apos; followed by &apos;compressed&apos;.</span><br><span class="line"> * &apos;sz&apos; is byte length of &apos;compressed&apos; field.</span><br><span class="line"> * &apos;compressed&apos; is LZF data with total (compressed) length &apos;sz&apos;</span><br><span class="line"> * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.</span><br><span class="line"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span><br><span class="line">typedef struct quicklistLZF &#123;</span><br><span class="line">    unsigned int sz; /* LZF size in bytes*/</span><br><span class="line">    char compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span><br><span class="line"> * &apos;count&apos; is the number of total entries.</span><br><span class="line"> * &apos;len&apos; is the number of quicklist nodes.</span><br><span class="line"> * &apos;compress&apos; is: -1 if compression disabled, otherwise it&apos;s the number</span><br><span class="line"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span><br><span class="line"> * &apos;fill&apos; is the user-requested (or default) fill factor. */</span><br><span class="line">typedef struct quicklist &#123;</span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    unsigned long count;        /* total count of all entries in all ziplists */</span><br><span class="line">    unsigned long len;          /* number of quicklistNodes */</span><br><span class="line">    int fill : 16;              /* fill factor for individual nodes */</span><br><span class="line">    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《redis设计与实现》实现的版本是3.0，截止今日最新的版本是5.x，本地安装的版本是4.0.10，此时列表应用的数据结构已发生变化。&lt;/p&gt;
&lt;p&gt;参阅&lt;a href=&quot;https://www.jianshu.com/p/ce24c9520731&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="redis设计与实现" scheme="bighua.top/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="ziplist" scheme="bighua.top/tags/ziplist/"/>
    
      <category term="quicklist" scheme="bighua.top/tags/quicklist/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="bighua.top/2019/09/16/%E4%BA%8B%E5%8A%A1/"/>
    <id>bighua.top/2019/09/16/事务/</id>
    <published>2019-09-16T06:26:40.000Z</published>
    <updated>2019-09-14T08:06:59.896Z</updated>
    
    <content type="html"><![CDATA[<p>事务把数据库从一种一致状态转换为另一种一致状态。</p><h3 id="认识事务"><a href="#认识事务" class="headerlink" title="认识事务"></a>认识事务</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是访问并更新数据库中各种数据项的一个程序执行单元。</p><p>A(Atomicity)，原子性。整个数据库事务是不可分割的工作单位。对只读操作发生错误，要么重试要么返回错误代码。但对于需要改变系统中状态的操作，若操作失败，需要保护系统中并发用户访问受影响的部分数据。</p><p>C(Consistency)，一致性。事务将数据库从一种状态转变为下一种一致的状态。事务开始前后，数据库的完整性约束没有被破坏。</p><p>I(Isolation)，隔离性。也称并发控制、锁、可串行化等。要求每个读写事务的对象对其他其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，通常用锁来实现。粒度锁（granular lock）策略，允许事务仅锁住一个实体对象的子集，以此提高事务之间的并发度。</p><p>D(Durability)，持久性。事务一旦提交，结果就是永久性的。持久性保证事务系统的高可靠性，非高可用性。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>事务理论角度：</p><ul><li>扁平事务（Flat transactions），使用最为频繁的事务。扁平事务中，所有操作都处于同一层次，由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。</li><li>带有保存点的扁平事务（Flat Transaction with Savepoints），除支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。保存点（Savepoint）通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。扁平事务隐式设置且整个事务中只有一个保存点，回滚只能回滚到事务开始时的状态。保存点SAVE WORK函数建立，通知系统当前的处理状态。出现问题时，保存点作为内部重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。保存点在事务内部递增，ROLLBACK不影响保存点的计数，递增编号能保持事务执行的整个历史过程。</li><li>链事务（Chained Transaction），保存点模式的变种。当系统崩溃时，扁平事务的保存点都将消失，恢复时，事务从开始处重新执行，不能从最近的一个点继续执行，保存点是易失的非持久的。链事务：在提交一个事务时，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作。扁平事务能回滚到任意正确的保存点，链事务回滚仅限于当前事务，只能恢复到最近一个的保存点。对于锁，链事务在执行COMMIT后释放当前事务所持有的锁，带保存点的扁平事务不影响其所持有的锁。</li><li>嵌套事务（Nested Transaction），层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（sub transaction），控制每一个局部的变换。</li><li>分布式事务（Distributed transaction），通常是一个在分布式环境下运行的扁平事务，需要根据数据所在的位置访问网络中的不同节点。</li></ul><p>Moss对嵌套事务的的定义：  </p><ol><li>由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。 </li><li>处在叶子节点的事务是扁平事务，每个子事务从根节点到叶节点的距离可以是不同的。</li><li>位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为（predecessor）为父事务（parent），事务的下一层为儿子事务（child）。</li><li>子事务既可以提交也可以回滚，并不会马上生效，需等待父事务提交。</li><li>书中任何一个事务的回滚会引起它的所有子事务一同回滚，子事务仅保留A、C、I特性，不具有D特性。</li></ol><p>Moss理论中实际工作由叶子节点来完成，只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。高层的事务仅负责逻辑控制，决定何时调用相关的子事务。</p><p>InnoDB支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的隔离性由锁实现。原子性、一致性、持久性通过数据库的redo log和undo log完成。redo log（重做日志）保证事务的原子性和持久性，undo log保证事务的一致性。</p><p>redo log恢复提交事务修改的页操作，undo log回滚记录到某个特定版本。两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行修改记录进行记录。</p><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>重做日志实现事务的持久性，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的。</p><p>InnoDB通过Force Log at Commit机制实现事务的持久性，当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成。此处日志分为redo log和undo log。前者宝成事务的持久性，后者帮助事务会回滚及MVCC的功能。redo log基本是顺序写的，undo log需要进行随机读写。</p><p>为确保每次日志写入重做日志文件，每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（同步内存中所有已修改的文件数据到存储设备）操作。重做日志文件打开没有使用O_DIRECT选项，重做日志缓冲先写入文件系统缓存。为确保重做日志写入磁盘，必须进行一次fsync操作。fsync的效率取决于磁盘的性能，磁盘的性能决定了事务提交的性能，即数据库的性能。</p><p>允许手工设置非持久性的情况发生，提高数据库的性能。此时事务提交时，日志不写入重做日志文件，等待下一个时间周期后再执行fsync操作。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，该参数的默认值为1，表示事务提交时必须调用一次fsync操作。可设置为0和2。0表示提交事务时不进行写入重做日志操作，操作仅在master thread中完成，master thread中每一秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入重做日志文件的缓存中，不进行fsync操作。</p><p>二进制日志文件bin log，用于进行POINT_IN_TIME（PIT）的恢复及主从复制（Replication）环境的建立。</p><p>重做日志在InnoDB存储引擎层产生，二进制日志在MySQL数据库的上层产生，二进制日志不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生二进制日志。MySQL上层的二进制日志是一种逻辑日志，记录的是对应的SQL语句，InnoDB存储引擎层的重做日志是物理格式日志，记录的是对于每个页的修改。二进制日志只在事务提交完成后进行一次写入，InnoDB存储引擎的重做日志在事务进行中不断地被写入，表现为日志并不是随事务提交的顺序进行写入的。</p><h5 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h5><p>InnoDB engine中重做日志以512字节进行存储的，意味着重做日志缓存、重做日志文件都是以块的方式进行保存的，称之为重做日志块（redo log block）。</p><p>若一个页产生的重做日志数量大于512字节，则需要分割为多个重做日志块进行存储。重做日志块的大小和扇区大小一样，重做日志的写入可保证原子性，不需要doublewrite技术。</p><p>重做日志块除日志本身外还由日志块头（log block header）及日志块尾（log block tailer）两部分组成。重做日志块头占用12字节，重做日志块尾占用8字节，每个重做日志块实际可存储的大小为492字节。</p><p>log block header由4个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用字节</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LOG_BLOCK_HDR_NO</td><td style="text-align:center">4</td><td style="text-align:center">标记log block在logbuffer中的位置，递增且循环使用，第一位用于判断是否是flush bit</td></tr><tr><td style="text-align:center">LOG_BLOCK_HDR_DATA_LEN</td><td style="text-align:center">2</td><td style="text-align:center">表示log block所占用的大小，当log block写满时，值为0x200，表示使用全部log block空间，即占用512字节</td></tr><tr><td style="text-align:center">LOG_BLOCK_FIRST_REC_GROUP</td><td style="text-align:center">2</td><td style="text-align:center">表示log block中第一个日志所在的偏移量，若等于LOG_BLOCK_HDR_DATA_LEN，表示当前log block不包含新的日志</td></tr><tr><td style="text-align:center">LOG_BLOCK_CHECKPOINT_NO</td><td style="text-align:center">4</td><td style="text-align:center">表示该log block最后被写入时检查点第4字节的值。</td></tr></tbody></table><p>log block tailer只由一个部分组成，值和LOG_BLOCK_CHECKPOINT_NO相同，并在函数log_block_init中被初始化。</p><h5 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h5><p>重做日志组，由多个重做日志文件。源码已支持log group的镜像功能，但在ha_innobase.cc文件中禁止该功能。InnoDB engine实际只有一个log group。</p><p>逻辑上的概念，并无实际物理文件表示log group信息。每个log group中日志文件大小相同，InnoDB v1.2前，重做日志文件总大小小于4GB，此版本开始大小限制提高为512GB。</p><p>重做日志文件中存储的是在log buffer中保存的log block，根据块的方式进行物理存储的管理，每个块大小与log block一样为512字节。log buffer根据一定规则将内存中的log block刷新到磁盘：</p><ul><li>事务提交时</li><li>log buffer中有一半的内存空间已经被使用时</li><li>log checkpoint时</li></ul><p>log block的写入为追加到redo log file的最后部分，当一个redo log被写满时，会接着写入下一个redo log file，使用方式为round-robin。redo log file除了保存log buffer刷新到磁盘的log block，还保存其他共占2KB大小的信息，每个redo log file的前2KB部分不保存log block信息。</p><p>log group中的第一个redo log file前2KB保存4个512字节大小的块，存放内容为：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小 </th></tr></thead><tbody><tr><td style="text-align:center">log file header</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint1</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint2</td><td style="text-align:center">512 </td></tr></tbody></table><p>仅在每个log group的第一个redo log file中进行存储，其余redo log file仅保留这些空间，但不保存上述信息。</p><p>写入redo log file时，除了log block的写入，还需要更新前2KB部分的信息，这些信息用于InnoDB engine恢复操作。log file header后面的部分为InnoBD存储引擎保存的checkpoint(检查点)值，设计为交替写入，避免因介质失败而导致无法找到可用的checkpoint的情况。</p><h5 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h5><p>InnoDB engine存储管理基于页，重做日志格式也是基于页的。其重做日志格式有着通用的头部格式。</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo log body</th></tr></thead><tbody><tr><td style="text-align:center">重做日志的类型</td><td style="text-align:center">表空间的ID</td><td style="text-align:center">页的偏移量</td><td style="text-align:center">存储内容  </td></tr></tbody></table><h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>Log Sequence Number的缩写，代表着日志序列号，InnoDB存储引擎中，占用8字节，单调递增。表示：</p><ul><li>重做日志写入的总量</li><li>checkpoint的位置</li><li>页的版本</li></ul><p>存在于每个页的头部，值FIL_PAGE_LSN，记录该页的LSN，表示该页最后刷新时LSN的大小。可用于根据重做日志的LSN比较页的LSN判断是否需要进行恢复操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5337425</span><br><span class="line">Log flushed up to   5337425</span><br><span class="line">Pages flushed up to 5337425</span><br><span class="line">Last checkpoint at  5337416</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">182 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Log sequence number表示当前的LSN，Log flushed up to表示刷新到重做日志文件的LSN，Pages flushed up to表示已经刷新到磁盘数据页上的LSN，Last checkpoint at表示刷新到磁盘的LSN。</p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>InnoDB eigine不管上次DB运行是否正常关闭，都会尝试进行恢复操作。</p><p>恢复过程中仅需恢复checkpoint开始的日志部分，即LSN记录开始的重做日志。</p><h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>利用undo信息对事务进行回滚到数据之前的样子。</p><p>undo存放在数据库内部的一个特殊段（segment）中，称为undo段（undo segment）。undo段位于共享表空间内。</p><p>undo是逻辑日志，只是将数据库逻辑地恢复到原来的样子，修改被逻辑地取消，由于可能存在其他用户对页上其他非锁定记录的修改，数据结构和页本身在回滚之后可能大不相同。</p><p>InnoDB engine回滚时，实际上做的是与先前相反的工作，对于每个INSERT，执行一个DELETE；对于每一个DELETE，会执行一个INSERT；对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。</p><p>undo的另一个作用是MVCC，当用户读取一行数据时，若该记录已经被其他事务占用，则当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><p>undo log会产生redo log，undo log需要持久性的保护。</p><h5 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h5><p>采用段的方式管理undo。InnoDB eigine有rollback segment，每个rollback segment记录了1024个undo log segment，每个undo log segment中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有的rollback segment header所在的页，页类型为FIL_PAGE_TYPE_SYS。</p><p>InnoDB v1.1前只有一个rollback segment，支持同时在线的事务限制为1024，1.1开始支持最大128个rollback segment，，支持同时在线的事务限制提高到128*1024.</p><p>InnoDB v1.2开始可通过参数对rollback segment进行设置：</p><ul><li><code>innodb_undo_directory</code>，设置rollback segment文件所在的路径，rollback segment可以存放在共享表空间之外的位置。</li><li><code>innodb_undo_logs</code>，设置rollback segment的个数，默认128，替换之前的参数<code>innodb_rollback_segments</code>。</li><li><code>innodb_undo_tablespaces</code>，设置构成rollback segment文件的数量，使rollback segment可以较平均分布在多个文件中。设置后可在路径<code>innodb_undo_directory</code>看到undo为前缀的文件，代表rollback segment文件。</li></ul><p>undo log segment分配页并写入undo log时同样需要写入重做日志，事务提交时，InnoDB会：</p><ul><li>将undo log放入列表，以供之后的purge操作。</li><li>判断undo log所在的页是否可以重用，若可以则分配给下一个事务使用。</li></ul><p>事务提交后不能马上删除undo log及undo log所在的页，可能有其他事务需要通过undo log取得行记录之前的版本，事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在的页由purge线程判断。</p><p>InnoDB engine中undo页可以进行重用，事务提交时，首先将undo log放入链表，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面。存放undo log的列表以记录进行组织，undo页可能存放着不同事务的undo log，purge操作需要涉及磁盘的离散读取操作，比较缓慢。</p><p>通过SHOW ENGINE INNODB STATUS查看链表中undo log的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46329</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>History list length代表undo log的数量，purge操作会减少该值。由于undo log所在的页可以被重用，操作后，改值也未必为0。</p><h5 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h5><p>参考<a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB undo log 漫游</a>。</p><p>分为：</p><ul><li>insert undo log，在insert操作过程中产生的undo log，insert操作只对事务本身可见，对其他事务不可见，事务提交后直接删除。不需要进行purge操作。</li><li>undapte undo log，对delete和update操作产生的undo log。可能需要提供MVCC机制，不能在事务提交后立即删除，提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul><p>undapte undo log较insert undo log记录的内容更多，占用的空间更大，undapte undo log又分为(type_cmpl值)：</p><ul><li>TRX_UNDO_UPD_EXIST_REC（=12），更新non-delete-mark的记录</li><li>TRX_UNDO_UPD_DEL_REC（=13），将delete的记录标记为not delete</li><li>TRX_UNDO_DEL_MARK_REC（=14）， 将记录标记为delete</li></ul><h5 id="查看undo信息"><a href="#查看undo信息" class="headerlink" title="查看undo信息"></a>查看undo信息</h5><p>InnoDB engine DBA只能通过原理和经验来判断。InnoSQL对information_schema拓展添加数据字典表<code>INNODB_TRX_ROLLBACK_SEGMENT</code>和<code>INNODB_TRX_UNDO</code>来查看undo信息，前者用于查看rollback segment，后者用于记录事务对应的undo log，方便了解事物产生的undo量。</p><p>delete操作并不直接删除记录，将记录标记为已删除（delete flag设置为1），记录的最终删除在purge中完成。update主键的操作分两步完成，先将原主键标记为已删除，需要产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log，之后插入一条新的记录，需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。</p><h4 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h4><p>purge最终完成delete和update操作，InnoDB支持MVCC，记录不能在事务提交时立即进行处理。因为其他事务可能正在引用这行，需要保存记录之前的版本。当该行记录不被任何其他事务引用，就可以进行真正的delete操作，清理之前行记录的版本。</p><p>InnoDB有一个histroy列表，根据事务提交的顺序，将undo log进行链接，先提交的事务总在尾端。</p><p>purge过程中，先在histroy list中找到第一个需要被清理的记录，清理之后会在被清除记录的undo log所在页继续寻找是否存在可以被清理的记录，有则清理，没有则返回histroy list中查找继续按此步骤清理。此法避免了大量的随机读取，提高purge效率。</p><p>动态参数<code>innodb_purge_batch_size</code>用于设置每次purge操作需要清理的undo page数量。InnoDB v1.2前默认20，此v开始默认300。动态参数<code>innodb_max_purge_lag</code>用于控制histroy list的长度，默认为0，表示不对其做限制，当大于0时，表示会延缓DML操作。延缓算法：<br><code>delay = ((length(histroy_list) - innodb_max_purge_lag) * 10) - 5</code></p><p>单位毫秒，对象是行，delay会在每次purge操作后重新计算。InnoDB v1.2后引入动态参数<code>innodb_max_purge_lag_delay</code>控制delay的最大毫秒数，当计算得到的delay值大于该值时，取<code>innodb_max_purge_lag_delay</code>，避免purge操作缓慢导致其他SQL线程无限制等待。</p><h4 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h4><p>非只读事务，每次事务提交时需要进行一次fsync操作，保证重做日志都已经写入磁盘。fsync性能有限，为提高效率，提供group commit功能，一次fsync可以刷新确保多个事务日志被写入文件。InnoDB事务提交时进行两个阶段操作：</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync将确保日志都从重做日志缓冲写入磁盘。</li></ol><p>步骤2相对步骤1慢，有事务进行步骤2时，其他事务可进行事务1，事务完成提交后，再次进行步骤2，将多个事务的重做日志通过一次fsync刷新到磁盘，减少磁盘的压力，提高性能。</p><p>InnoDB v1.2前，开启二进制日志InnoDB存储引擎的group commit功能会失效，导致性能下降。开启二进制日志为保证存储引擎层中事务和二进制日志的一致性，二者之间使用了两阶段事务：</p><ol><li>事务提交时InnoDB engine进行purge操作</li><li>MySQL数据库上层写入二进制日志。</li><li><p>InnoDB存储引擎将日志写入重做日志文件。</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync确保日志都从重做日志缓冲写入磁盘。</li></ol></li></ol><p>一旦步骤2完成，就确保了事务的提交，即使步骤3时发生宕机。但每个步骤都进行一次fsync操作才能保证上下两层数据的一致性。步骤2的fsync参数由参数<code>fsync_binlog</code>控制，步骤3的fsync由参数<code>innodb_flush_log_at_trx_commit</code>控制。MySQL内部使用<code>prepare_commit_mutex</code>锁保证上层二进制日志的写入顺序与InnoDB层事务提交顺序一致。启用锁后步骤3中的步骤1不可以在其他事务执行步骤3的步骤2时执行，导致group commit失效。</p><p>MySQL v5.6实现了Binary Log Group Commit（BLGC）解决此问题，在上层提交时先按顺序将其放入一个队列中，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。BLGC步骤：</p><ul><li>Flush阶段，将每个事务的二进制日志写入内存中。</li><li>Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，仅一次fsync操作完成二进制日志的写入，即BLGC。</li><li>Commit阶段，leader根据顺序调用存储引擎层事务的提交，修复由于锁<code>prepare_commit_mutex</code>导致group commit失效问题。</li></ul><p>当有一组事务提交时，其他新事务可以进行Flush阶段，使group commit不断生效。group commit的效果由队列中事务的数量决定，若每次队列中仅有一个事务，效果同之前可能会更差。提交的事务越多，group commit效果越明显。</p><p>参数<code>innodb_max_flush_queue_time</code>控制Flush阶段中等待的时间，即使之前的一组事务完成提交，当前一组事务也不马上进入Sync阶段，至少需要等待一段时间。使group commit的事务数量更多，可能导致事务响应时间变慢。参数默认值0，推荐设置也为0。</p><h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下，事务自动提交的，执行SQL语句后会马上执行COMMIT操作。</p><p>事务控制语句：</p><ul><li>START TRANSACTION | BEGIN：显示地开启一个事务。存储过程中，MySQL DB分析器会自动将BEGIN识别为BEGIN…END，存储过程中只能使用START TRANSACTION语句开启事务。</li><li>COMMIT：提交事务，使得已对数据库所做的所有修改称为永久性的。可直接发出COMMIT，也可写为等价语句COMMIT WORK。后者控制事务结束后的行为是CHAIN还是RELEASE的，是CHAIN方式，则事务变成链事务。通过参数<code>completion_type</code>进行控制，默认为0，表示没有任何操作，两者等价，设为1时，后者等价COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。</li><li>ROLLBACK：回滚结束事务，并撤销正在进行的所有未提交的修改。可直接发出ROLLBACK，也可写为等价语句ROLLBACK WORK。工作同上方语句。</li><li>SAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。</li><li>RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句会抛出一个异常。</li><li>ROLLBACK TO[SAVEPOINT] identifier：与SAVEPOINT命令一起使用，把事务回滚到标记点，而不回滚在此标记点之前任何工作。回滚到一个不存在的保存点会抛出异常。该语句并不是真正地结束一个事务，执行后任然需要显示地执行COMMIT或者ROLLBACK命令。</li><li>SET TRANSACTION：设置事务的隔离级别。InnoDB提供的隔离级别有：READ UNCOMMITTED、READCOMMITTD、REPEATABLE READ、SERIALIZABLE。</li></ul><p>事务是原子的，构成事务的每条语句都会提交或者所有语句都会回滚，一条语句要么完全成功要么完全回滚。一条语句失败并抛出异常时，并不会导致先前已执行的语句自动回滚，所有的执行都会得到保留， 由用户决定是否对事务进行提交或者回滚。</p><h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><p>执行语句后会有一个隐式的COMMIT操作的SQL语句：</p><ul><li>DDL语句：ALTER DATABASE…UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRUNCATE TABLE。</li><li>隐式修改MySQL机构操作：CREATE USER，DROP USER，GRANT，RENAME USER，REVOKE，SET PASSWORD。</li><li>管理语句：ANALYZE TABLE，CACHE INDEX，CHECK TABLE，LOAD INDEX INTO CACHE，OPTIMIZE TABLE，REPAIR TABLE。</li></ul><p>TRUNCATE TABLE语句是DDL，和对整张表执行DELETE操作结果一样，但不能被回滚。</p><h3 id="对事务操作的统计"><a href="#对事务操作的统计" class="headerlink" title="对事务操作的统计"></a>对事务操作的统计</h3><p>在考虑每秒请求数（Question Per Second，QPS）的同时，关注每秒事务处理（Transaction Per Second，TPS）的能力。</p><p>所有事务显示提交：<code>TPS = (com_commit + com_rollback) / time</code>，隐式提交和回滚不会计算到com_commit和com_rollback变量中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;com_commit&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_commit</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_rollback&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_rollback</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数handle_commit和handle_rollback用于事务统计。MySQL v5.1中可统计InnoDB engine显示和隐式的事务提交操作，在InnoDB Plugin中不准确。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL标准事务隔离级别：</p><ul><li>READ UNCOMMITTED：浏览访问。</li><li>READ COMMITTED：游标稳定。除唯一性的约束检查及外键约束的检查需要gap lock，engine 不会使用gap lock的锁算法。MySQl v5.1会导致主从数据不一致问题。</li><li>REPEATABLE READ：无幻读保护。</li><li>SERIALIZABLE：隔离。InnoDB为每个SELECT语句后自动加上LOCK IN SHARE MODE，即为读取加共享锁，对一致性的非锁定读不在于以支持。主要用于InnoDB engine的分布式事务。</li></ul><p>SQL和SQL2的默认事务隔离级别为SERIALIZABLE，InnoDB默认隔离级别为REPEATABLE READ，采用Next-Key Lock锁算法避免幻读。</p><p>级别越低事务请求锁越少或保持锁的时间越短。</p><p>设置当前回话或全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</span><br><span class="line">&#123;</span><br><span class="line">READ UNCOMMITTED</span><br><span class="line">| READ COMMITTED</span><br><span class="line">| REPEATABLE READ</span><br><span class="line">| SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过修改MySQL配置文件，在MySQL启动时设置事务默认隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">transaction-isolation = READ UNCOMMITTED</span><br></pre></td></tr></table></figure><p>查看当前事务隔离级别和全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务指允许多个独立的事务资源（transaction rescourcs）参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，对于事务原有的ACID要求有了提高。</p><h4 id="MySQL数据库分布式事务"><a href="#MySQL数据库分布式事务" class="headerlink" title="MySQL数据库分布式事务"></a>MySQL数据库分布式事务</h4><p>分布式事务</p><p>InnoDB engine提供对XA事务的支持，通过XA事务来支持分布式事务的实现。使用分布式事务时，InnoDB engine的事务隔离级别必须设置为SERIALIZABLE。</p><p>XA事务允许不同数据库之间的分布式事务，需要参与在全局事务中的每个节点都支持XA事务。XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p><ul><li>资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。</li><li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li><li>应用程序：定义事务边界，指定全局事务中的操作。</li></ul><p>MySQL DB分布式事务中，资源管理器是MySQL数据库，事务管理器为连接MySQL服务器的客户端。</p><p>分布式事务使用两段式提交（two-phase commit）的方式。第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好了。第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。若任何一个节点显示不能提交，则所有的节点都被告知需要回滚。与本地事务相比，分布式事务需要多一次PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或者ROLLBACK操作。</p><p>MySQL数据库XA事务的SQL语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XA &#123;START | BEGIN&#125; xid [JOIN | RESUME]</span><br><span class="line"></span><br><span class="line">XA END xid [SUSPEND [FOR MIGRATE]]</span><br><span class="line"></span><br><span class="line">XA PREPARE xid</span><br><span class="line"></span><br><span class="line">XA COMMIT xid [ONE PHASE]</span><br><span class="line"></span><br><span class="line">XA ROLLBACK xid</span><br><span class="line"></span><br><span class="line">XA RECOVER</span><br></pre></td></tr></table></figure><p>通过参数<code>innodb_support_xa</code>查看是否启用了XA事务的支持，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_support_xa&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_support_xa</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h4><p>外部事务：资源管理器是MySQL数据库本身。</p><p>内部XA事务：在存储引擎与插件之间，或者存储引擎与存储引擎之间</p><p>常见的内部XA事务存在于binlog与InnoDB存储引擎之间。事务提交时，InnoDB engine先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，若在InnoDB engine提交前宕机，MySQL DB重启后会先检查准备的UXID事务是否已经提交，若没有则在存储引擎层再进行一次提交操作。能够避免二进制日志写入后宕机，传给从数据库二进制日志并执行，导致主从数据库不一致问题。</p><h3 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h3><ul><li>在循环中提交：不论是现实的提交还是隐式的提交。</li><li>使用自动提交：应在程序端进行事务的开始和结束。对不同语言的API，自动提交不同。</li><li>使用自动回滚：InnoDB engine支持通过定义一个HANDLER来进行自动事务的回滚操作，如在一个存储过程中发生了错误会自动对其进行回滚操作。</li></ul><h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><p>执行时间较长的事务。对长事务，转化为小批量的事务进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事务把数据库从一种一致状态转换为另一种一致状态。&lt;/p&gt;
&lt;h3 id=&quot;认识事务&quot;&gt;&lt;a href=&quot;#认识事务&quot; class=&quot;headerlink&quot; title=&quot;认识事务&quot;&gt;&lt;/a&gt;认识事务&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="transaction" scheme="bighua.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="bighua.top/2019/09/11/%E9%94%81/"/>
    <id>bighua.top/2019/09/11/锁/</id>
    <published>2019-09-11T06:26:28.000Z</published>
    <updated>2019-09-12T11:37:26.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><p>InnoDB存储引擎在行级别上对表数据上锁，也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，锁保证一致性。</p><p>InnoDB锁的实现类似Oracle，提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，可以同时得到并发性和一致性。</p><h3 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h3><p>DB中，lock和latch都可以被称为“锁”。</p><p>latch一般称为闩锁（轻量级的锁），要求锁定的时间必须非常短，若持续的时间长，应用的性能会非常差。InnoDB中，latch分为mutex（互斥量）和rwlock（读写锁），目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或roolback后进行释放（不同事物隔离级别释放的时间可能不同）。</p><p>lock和latch的不同：</p><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">lock</th><th style="text-align:center">latch</th></tr></thead><tbody><tr><td style="text-align:center">对象</td><td style="text-align:center">事务</td><td style="text-align:center">线程</td></tr><tr><td style="text-align:center">保护</td><td style="text-align:center">数据库内容</td><td style="text-align:center">内存数据结构</td></tr><tr><td style="text-align:center">持续时间</td><td style="text-align:center">整个事务过程</td><td style="text-align:center">临界资源 </td></tr><tr><td style="text-align:center">模式</td><td style="text-align:center">行锁、表锁、意向锁</td><td style="text-align:center">读写锁、互斥量</td></tr><tr><td style="text-align:center">死锁</td><td style="text-align:center">通过waits-for graph、time out等机制进行死锁检测与处理</td><td style="text-align:center">无死锁检测与处理机制。仅通过应用程序加锁的顺序（lock leveling）保证无死锁的情况发生</td></tr><tr><td style="text-align:center">存在于</td><td style="text-align:center">Lock Manage的哈希表中</td><td style="text-align:center">每个数据结构的对象中</td></tr></tbody></table><p>通过命令<code>SHOW RNGINE INNODB MUTEX</code>查看InnoDB中的latch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb mutex;</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| Type   | Name                      | Status   |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:2730 | waits=2  |</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:1183 | waits=10 |</span><br><span class="line">| InnoDB | rwlock: log0log.cc:838    | waits=15 |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在Debug模式下Status列展示更多信息:</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">mutex被请求的次数</td></tr><tr><td style="text-align:center">spin_waits</td><td style="text-align:center">spin lock(自旋锁)的次数，InnoDB engine latch在不能获得锁时首先进行自旋，若自旋后还不能获得锁，则进入等待状态</td></tr><tr><td style="text-align:center">spin_rounds</td><td style="text-align:center">自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spain_waits表示平均每次所需的内部循环次数。</td></tr><tr><td style="text-align:center">os_waits</td><td style="text-align:center">表示操作系统等待的次数，当spin lock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒。</td></tr><tr><td style="text-align:center">os_yields</td><td style="text-align:center">进行os_thread_yield唤醒操作的次数</td></tr><tr><td style="text-align:center">os_wait_times</td><td style="text-align:center">操作系统等待的时间，单位ms</td></tr></tbody></table><p>可通过命令SHOW ENGINE INNODB STATUS及information_schema架构下的表INNODB_TRX，INNODB_LOCKS、INNODB_LOCK_WAITS观察锁的信息。</p><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或更新一行数据。</li></ul><p>X锁与任何锁都不兼容（变更行记录），S锁仅和S锁兼容（读取不更改行记录）。</p><p>意向将锁定的对象分为多个层次，意味着事务希望在更细粒度上进行加锁。支持多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在。 </p><p>InnoDB支持的意向锁为表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型。支持两种意向锁：</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</li></ul><p>意向锁不会阻塞除全表扫描以外的任何请求。意向锁和行级锁的兼容性：</p><table><thead><tr><th style="text-align:center">锁\兼容性</th><th style="text-align:center">IS</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center">IS</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N </td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><p>InnoDB v1.0前只能通过<code>SHOW ENGINE INNODB STATUS</code>、<code>SHOW FULL PROCESSLIST</code>命令查看当前锁请求的信息，之后可通过INFORMATION_SCHEMA架构下的表INNODB_LOCKS、INNODB_LOCK_TRX、INNODB_LOCK_WAITS更简单地监控当前事务并分析可能存在的锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46328</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_TRX;</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| Field                      | Type                | Null | Key | Default             | Extra |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| trx_id                     | varchar(18)         | NO   |     |                     |       |</span><br><span class="line">| trx_state                  | varchar(13)         | NO   |     |                     |       |</span><br><span class="line">| trx_started                | datetime            | NO   |     | 0000-00-00 00:00:00 |       |</span><br><span class="line">| trx_requested_lock_id      | varchar(81)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_wait_started           | datetime            | YES  |     | NULL                |       |</span><br><span class="line">| trx_weight                 | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_mysql_thread_id        | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_query                  | varchar(1024)       | YES  |     | NULL                |       |</span><br><span class="line">| trx_operation_state        | varchar(64)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_tables_in_use          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_tables_locked          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_structs           | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_memory_bytes      | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_locked            | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_modified          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_concurrency_tickets    | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_isolation_level        | varchar(16)         | NO   |     |                     |       |</span><br><span class="line">| trx_unique_checks          | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_foreign_key_checks     | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_last_foreign_key_error | varchar(256)        | YES  |     | NULL                |       |</span><br><span class="line">| trx_adaptive_hash_latched  | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_adaptive_hash_timeout  | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_is_read_only           | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_autocommit_non_locking | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCKS;</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| lock_id     | varchar(81)         | NO   |     |         |       |</span><br><span class="line">| lock_trx_id | varchar(18)         | NO   |     |         |       |</span><br><span class="line">| lock_mode   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_type   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_table  | varchar(1024)       | NO   |     |         |       |</span><br><span class="line">| lock_index  | varchar(1024)       | YES  |     | NULL    |       |</span><br><span class="line">| lock_space  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_page   | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_rec    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_data   | varchar(8192)       | YES  |     | NULL    |       |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCK_WAITS;</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field             | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| requesting_trx_id | varchar(18) | NO   |     |         |       |</span><br><span class="line">| requested_lock_id | varchar(81) | NO   |     |         |       |</span><br><span class="line">| blocking_trx_id   | varchar(18) | NO   |     |         |       |</span><br><span class="line">| blocking_lock_id  | varchar(81) | NO   |     |         |       |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参考<a href="https://dbarobin.com/2015/01/27/innodb-lock-wait-under-mysql-5.5/" target="_blank" rel="noopener">MySQL 5.5 InnoDB 锁等待</a></p><p>参考<a href="https://blog.winsky.wang/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E4%B8%8Einformation_schema%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A1%A8/" target="_blank" rel="noopener">锁等待超时与information_schema的三个表</a></p><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>指InnoDB engine通过行多版本控制的方式来读取当前执行时间数据库中行的数据。</p><p>若读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因为去等待行上锁的释放，会去读取行的一个快照数据。快照数据指该行的之前版本的数据，通过undo段来完成，undo用来在事务中回滚数据。</p><p>InnoDB默认读取方式，读取不会占用和等待表上的锁。在不同的事务隔离级别下读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读，对于快照数据的定义也各不相同。</p><p>事务隔离级别READ COMMITTED和REPEATABLE READ（默认隔离级别）下，使用非锁定的一致性读。前者对于快照数据，非一致性读总是读取被锁定的最新一份快照数据。后者对于快照数据，非一致性读总是读取事务开始时的行数据版本。前者违反了事务ACID中的I的特性，即隔离性。</p><h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB engine对SELECT语句支持两种一致性的锁定读（locking read）操作。</p><ul><li>SELECT … FOR UPDATE，对读取的行记录加一个X锁，其他的事务不能对已锁定行加上任何锁。</li><li>SELECT … LOCK IN SHARE MODE，对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，若加X，会被阻塞。</li></ul><p>已上两种操作必须在一个事务中，事务提交后，锁释放。</p><h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>InnoDB engine中，每个含有自增长的表都有一个自增长计数器，对含有自增长的计数器的表进行插入操作时，计数器会被初始化。</p><p>获取计算器的值：<code>SELECT MAX(auto_inc_col) FROM t FOR UPDATE</code>。</p><p>插入操作依据自增长的计数器值加1赋予自增长列，称为AUTO-INC Locking，采用一种特殊的表锁机制，为提高插入性能，锁在完成对自增长值插入的SQL语句后立即释放，并非在一个事务完成后才释放。</p><p>MySQL v5.1.22开始提供轻量级互斥量的自增长实现机制，提高自增长值插入的性能。提供参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，默认值为1.</p><p>自增长的插入分类：</p><table><thead><tr><th style="text-align:center">插入类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">insert-like</td><td style="text-align:center">指所有的插入语句，如INSERT、REPLACE、INSERT…SELECT，REPLACE…SELECT、LOAD DATA等</td></tr><tr><td style="text-align:center">simple inserts</td><td style="text-align:center">指能在插入前就确定插入行数的语句，包括INSERT、REPLACE等</td></tr><tr><td style="text-align:center">bulk inserts</td><td style="text-align:center">指在插入前不能确定得到插入行数的语句，如INSERT…SELECT、REPLACE…SELECT、LOAD DATA</td></tr><tr><td style="text-align:center">mixed-mode inserts</td><td style="text-align:center">指插入中有一部分的值是自增长的，有一部分是确定的。如INSERT INTO t1(c1,c2) VALUES (1,’a’),(NULL,’b’),(5,’c’),(NULL,’d’)；也可以指INSERT … ON DUPLICATE KEY UPDATE这类SQL语句</td></tr></tbody></table><p>参数<code>innodb_autoinc_lock_mode</code>的说明：</p><table><thead><tr><th style="text-align:center">innodb_autoinc_lock_mode</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">MySQL v5.1.22前的自增长实现方式，通过表锁的AUTO-INC Locking方式。不是新版本的首选项。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">默认值。对于simple inserts使用互斥量对于内存中的计数器进行累加操作，对于bulk inserts使用传统表锁的AUTO-INC Locking方式，不考虑回滚操作，对于自增列的增长是连续的。statement-based方式的replication还能很好地工作。若已经使用AUTO-INC Locking方式去产生自增长的值，而需要再进行simple inserts时，还是需要等待AUTO-INC Locking的释放。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">对于所有insert-like 自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。基于Statement-Base Replication会出现问题。该模式下任何时候都改使用row-base replication。保证最大的并发性能及replication主从数据的一致</td></tr></tbody></table><p>InnoDB engine中，自增长值的列必须是索引，同时必须时索引的第一个列，若不是第一个列，MySQL数据库会抛出异常。</p><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>外键用户完整性的约束检查，InnoDB对未显示加索引的外键列，会自动对其加以个索引，可避免表锁。</p><p>对外键值的插入或更新，首先会查询父表中的记录，对于父表的SELECT操作，不使用一致性非锁定读的方式，使用的是SELECT…LOCK IN SHARE MODE方式，主动对父表加一个S锁。若此时父表被加X锁，则子表上的操作会被阻塞。</p><h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><h4 id="锁的3种算法"><a href="#锁的3种算法" class="headerlink" title="锁的3种算法"></a>锁的3种算法</h4><p>InnoDB engine3种行锁算法：</p><ul><li>Record Lock：单个行记录上的锁。锁住索引记录，未设置索引则使用隐式的主键来进行锁定。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。阻止多个事务将记录插入到同一范围内。</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。为解决Phantom Problem（幻像问题），是谓词锁（predict lock）的一张改进。当查询的索引含有唯一属性时，查询所有的唯一索引列，InnoDB存储引擎会对Next-key Lock进行优化，将其降级为Record Lock，仅锁住索引本身，而不是范围。 </li></ul><p>若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，则查询其实是range类型查询，而不是point类型查询，依然使用Next-Key Lock进行锁定。</p><p>显式关闭Gap Lock：</p><ul><li>将事务隔离级别设置为READ COMMITTED</li><li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li></ul><p>此时除了外键约束和唯一性检查依然需要Gap Locl，其余情况仅使用Record Lock进行锁定。此时破坏了事务的隔离性，对于replication，会导致主从数据的不一致。性能上，READ COMMITTED不会优于默认事务隔离级别REPEATABLE READ。</p><h4 id="解决Phantom-Problem（幻像问题）"><a href="#解决Phantom-Problem（幻像问题）" class="headerlink" title="解决Phantom Problem（幻像问题）"></a>解决Phantom Problem（幻像问题）</h4><p>指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p><p>采用Next-Key Lock避免该问题，READ COMMITTED下仅采用Record Lock加锁，默认隔离级别REPEATABLE READ采用Next-Key Lock加锁。</p><h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏数据值事务对缓存池中行记录的修改，并且还没有被提交。</p><p>若读到脏数据，即一个事务可以读到另一个事务中未提交的数据，违反了数据库的隔离性。</p><p>脏读指在不同的事务下，当前事务可以读到另外事务未提交的数据，即可以读到脏数据。</p><p>脏读现象在生成环境中并不常发生，脏读发生的条件是需要事务隔离级别为READ UNCOMMITTED，目前大多至少设置成READ COMMITTED级别。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在一个事务内多次读取同一数据集合，事务还未结束时，另一个事务也访问该同一数据集合，并做了一些DML操作，导致第一个事务中的两次读取数据之间由第二个事务的修改，读取的数据不一致。</p><p>脏读读取的是未提交的数据，不可重复读读取的是已提交的数据，违反了事务的一致性要求。</p><p>MySQL将其定义为幻像问题（Phantom Problem），默认隔离级别下避免了该现象。</p><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作被另一个事务的更新操作覆盖，导致数据的不一致性。InnoDB对于行的DML操作需要对行或其他粗粒度级别的对象加锁，不会出现丢失更新问题。</p><p>基于B/S应用可能于业务层出现此现象。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，产生阻塞。阻塞为了确保事务可以并发且正常地运行。</p><p>参数<code>innodb_rollback_wait_timeout</code>控制等待的时间，参数<code>innodb_roolback_on_timeout</code>用来设定是否在等待超时时对进行中的事务进行回滚操作，默认OFF代表不回滚。参数<code>innodb_rollback_wait_timeout</code>是动态的，可以在MySQL DB运行时进行调整，参数<code>innodb_rollback_wait_timeout</code>是静态的，不可在启动后进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_rollback_wait_timeout&apos;\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_rollback_on_timeout&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_rollback_on_timeout</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>默认不会回滚超时引发的错误异常，在大部分情况下都不会对异常进行回滚。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互动等待的现象。</p><p>解决死锁最简单的方式时不要有等待，将任何等待都转化为回滚，并且事务重新开始。会导致并发性能的下降。</p><p>另一个解决方案是超时，当一个等待时间超过设置的某一阀值时，其中一个事务进行回滚，另一个事务获得资源继续进行。参数<code>innodb_lock_wait_timeout</code>用来设置超时的时间（默认50）。</p><p>目前普遍采用更为主动的wait-for graph（等待图）的方式来进行死锁的检测，要求数据库保存以下两种信息：</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述链表构造一张图，若图中存在回路，说明资源间互相发生等待，代表存在死锁。</p><p>wait-for graph中事务为图中的节点，图中T1指向T2边的定义为：</p><ul><li>事务T1等待事务T2所占用的资源</li><li>事务T1最终等待T2所占用的资源，事务之间等待相同的资源，而事务T1发生在事务T2的后面</li></ul><p>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常InnoDB存储引擎选择回滚undo量最小的事务。</p><p>wait-for graph的死锁检测通常采用深度优先的算法实现。InnoDB v1.2前采用递归实现，此版本开始采用非递归的方式实现。</p><h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁次数应少于等待，至少需要2次等待才会产生一次死锁。</p><p>事务发生死锁的概率影响因素：</p><ul><li>系统中事务的数量（n），数量越多发生死锁的概率越大。</li><li>每个事务操作的数量（r），每个事务操作的数量越多，发生死锁的概率越大。</li><li>操作数据的集合（R），越小发生死锁的概率越大。</li></ul><p>系统中任何一个事务发生死锁的概率～= (n^2*r^4)/4*R^2</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>指将当前锁粒度降低。可将一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</p><p>SQL Server认为锁是一种稀有资源，存在此现象。</p><p>InnoDB不存在锁升级问题，不是根据每个记录产生行锁， 而是根据每个事务访问的每个页对锁进行管理，采用位图的方式。不管一个事务锁住页中一个记录还是多个记录，开销是一致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是锁&quot;&gt;&lt;a href=&quot;#什么是锁&quot; class=&quot;headerlink&quot; title=&quot;什么是锁&quot;&gt;&lt;/a&gt;什么是锁&lt;/h3&gt;&lt;p&gt;锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="lock" scheme="bighua.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>索引与算法</title>
    <link href="bighua.top/2019/08/30/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>bighua.top/2019/08/30/索引与算法/</id>
    <published>2019-08-30T06:26:19.000Z</published>
    <updated>2019-09-11T13:51:00.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB支持的索引：</p><ul><li>B+ tree索引</li><li>全文索引</li><li>哈希索引</li></ul><p>InnoDB存储引擎支持的哈希索引是自适应的（见<a href="http://bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">自适应哈希索引</a>）。</p><p>B+ tree索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。</p><blockquote><p>B+ tree的B代表着平衡（balance），而非二叉（binary）。B+ tree从最早的平衡二叉树演变而来，但是不是一个二叉树。</p></blockquote><p>B+ tree index并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查到，最后得到要查找的数据。</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到。</p><h4 id="二分查找和平衡二叉树"><a href="#二分查找和平衡二叉树" class="headerlink" title="二分查找和平衡二叉树"></a>二分查找和平衡二叉树</h4><p>二叉查找树：左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p><p>若想最大性能地构造一棵二叉查找树，需要二叉查找树是平衡的——平衡二叉树（AVL树）。是二叉查找树，任何节点的两个子树的高度最大差为1。</p><p>维护一棵平衡二叉树需要一定的开销，多用于内存结构对象中，维护的开销相对较小。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质是B+树在数据库中的实现。B+树高扇出性，高度一般在2～4层，查找某一键值的行记录只需要2～4次IO。</p><p>B+树索引分为聚集索引（clustered index）和辅助索引（secondary index），内部都是B+树，高度平衡，叶子节点存放着所有的数据。聚集索引和辅助索引不同之处在于，叶子节点存放的是否是一整行的信息。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，表中的数据按照主键顺序存放。聚集索引按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表中存放的行记录数据，也将聚集索引的叶子节点称为数据页，决定了索引组织表中数据也是索引的一部分。每个数据页通过双向链表进行链接。</p><p>每张表只能拥有一个聚集索引，多数情况下，聚集索引能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询，查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>聚集索引非物理上连续，而是逻辑上连续。</p><ul><li>页通过双向链表链接，按照主键顺序排序</li><li>每个页中的记录通过双向链表进行维护，物理存储上可以同样不按照主键储存</li></ul><p>聚集索引对于主键排序查找和范围查找很快。</p><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>叶子节点不包含行记录的全部数据，除包含键值外，每个叶子节点中的索引行还包含一个书签。该书签告知InnoDB存储引擎哪里可以找到与索引相应的行数据。辅助索引的书签是相应的行数据的聚集索引键。</p><p>通过辅助索引查找数据，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>InnoDB存储引擎的Page Header中有以下几个部分用来保存插入的顺序信息：</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><p>决定向左还是向右进行分裂，决定将分裂点记录为哪一个。若插入随机，则取页的中间记录作为分裂点的记录，若往同一方向插入的记录数量为5，并且目前已经定位（cursor）到的记录（InnoDB存储引擎插入时，首先需要进行定位，定位到的记录为带插入记录的前一条记录）之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是带插入的记录。</p><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><h5 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h5><p>索引的创建和删除可通过两种方法，<code>ALTER TABLE</code>和<code>CREATE/DROP INDEX</code>。</p><p>ALTER TABLE创建索引语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option]...</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP PARIMARY KEY</span><br><span class="line">| DROP &#123;INDEX|KEY&#125; index_name</span><br></pre></td></tr></table></figure><p>CREATE/DROP INDEX语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line">[index_type]</span><br><span class="line">ON table_name (index_col_name,...)</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure><p>可设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据。</p><p>参见<a href="http://bighua.top/2018/07/30/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/">Mysql索引及优化</a></p><p>通过<code>SHOW INDEX FROM TABLE</code>查看索引信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from users_old\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_name_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_email_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: email</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: remember_token</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: remember_token</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 153</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>每列含义：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">  Table</td><td style="text-align:center">索引所在表名。</td></tr><tr><td style="text-align:center">  Non_unique</td><td style="text-align:center">非唯一的索引。</td></tr><tr><td style="text-align:center">  Key_name</td><td style="text-align:center">索引名。</td></tr><tr><td style="text-align:center">  Seq_in_index</td><td style="text-align:center">索引中该列的位置。</td></tr><tr><td style="text-align:center">  Column_name</td><td style="text-align:center">索引列的名称。</td></tr><tr><td style="text-align:center">  Collation</td><td style="text-align:center">列以什么方式存储在索引中，值为A或NULL。B+树索引总是A，即排序的。若使用Heap存储引擎，并建立了Hash索引，会显示NULL。Hash根据Hash桶存放索引数据，不对数据进行排序。</td></tr><tr><td style="text-align:center">  Cardinality</td><td style="text-align:center">表示索引中唯一值的数目的估计值。若非常小，可考虑是否删除此索引。</td></tr><tr><td style="text-align:center">  Sub_part</td><td style="text-align:center">是否是列的部分被索引，若索引整个列则值为NULL，否则为被索引字符长度。</td></tr><tr><td style="text-align:center">  Packed</td><td style="text-align:center">关键字如何被压缩，没被压缩值为NULL。</td></tr><tr><td style="text-align:center">  Null</td><td style="text-align:center">索引的列是否含有NULL值，列允许为NULL值则显示为Yes。</td></tr><tr><td style="text-align:center">  Index_type</td><td style="text-align:center">索引的类型，InnoDB只支持B+ Tree索引</td></tr><tr><td style="text-align:center">  Comment</td><td style="text-align:center">注释</td></tr></tbody></table><p>优化器会根据Cardinality值来判断是否使用这个索引，非实时更新，只是大概的值。可使用<code>ANALYZE TABLE</code>命令更新索引Cardinality信息，在非高峰期操作能使优化器更好的选择索引。</p><h5 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h5><p>MySQL v5.5之前，对于索引的添加或者删除类DDL操作过程：</p><ul><li>创建一张临时表，表结构为通过命令ALTER TABLE新定义的结构。</li><li>将原表数据导入到临时表。</li><li>删除原表。</li><li>把临时表重名为原来的表名。</li></ul><p>对大表进行索引的添加和删除操作耗时，大量访问时数据库服务不可用。</p><p>临时表的创建路径通过参数tmpdir进行设置，必须保证tmpdir有足够的空间存放临时表，否则会导致创建索引失败。</p><p>InnoDB v1.0.x开始支持Fast Index Creation（快速创建索引，FIC）的索引创建方式。 </p><p>辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁，在创建过程中不需要重建表。删除辅助索引，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL DB内部视图上对该表的索引定义。</p><p>加S锁操作导致过程中只能对表进行读操作，写操作不可用。FIC只限定于辅助索引的创建，主键的创建和删除同样需要重建一张表。</p><h5 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h5><p>Online Schema Change（在线架构改变，OSC）由Facebook采用PHP脚本实现的一种在线执行DDL的方式，在事务的创建过程中，可以有读写事务对表进行操作。</p><p>实现OSC步骤：</p><ul><li>init，初始化阶段，对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。</li><li>createCopyTable，创建和原始表结构一样的新表。</li><li>alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。</li><li>createDeltasTable，创建deltas表，为下一步创建的触发器所使用。之后对原表的所有的DML操作会被记录到createDeltasTable中。</li><li>createTirggers，对原表创建INSERT、UPDATE、DELETE操作的触发器，触发操作产生的记录被写入到deltas表。</li><li>startSnpshotXact，开始OSC操作的事务。</li><li>selectTableIntoOutfile，将原表中的数据写入到新表，通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中，分片大小可指定，默认500000。</li><li>dropNCIndexs，导入新表前，删除新表中所有的辅助索引。</li><li>loadCopyTable，将导出的分片文件导入到新表。</li><li>replayChanges，将OSC过程中原表DML操作的记录（被保存在deltas表中）应用到新表中。</li><li>recreateNCInedexes，创新创建辅助索引。</li><li>replayChanges，再次进行DML日志的回放操作，是上述创建辅助索引过程中新产生的日志。</li><li>swapTables，将原表和新表交换名字，操作过程需要锁定2张表，不允许新数据产生，改名操作很快，阻塞时间很短。</li></ul><p>要求进行修改表一定要有主键且表本身不能存在外键和触发器。进行OSC过程中，允许SET aql_bin_log=0，所在操作不会同步slave服务器，可能导致主从不一致。</p><h5 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h5><p>MySQL v5.6开始支持Online DDl（在线数据定义）操作，允许辅助索引创建的同时，进行其他诸如INSERT、UPDATE、DELETE这类DML操作。</p><p>可通过“在线”方式进行操作的DDL操作：</p><ul><li>辅助索引的创建和删除</li><li>改变自增长值</li><li>添加或删除外键约束</li><li>列的重命名</li></ul><p>通过新的ALTER TABLE语法，可选择索引的创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line">| ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option] ...</span><br><span class="line">ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</span><br><span class="line">LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure><p>ALGORITHM指定列创建或删除索引的算法，COPY表示按照MySQL v5.1之前的工作模式（创建临时表）。INPLACE表示索引创建或删除不需要创建临时表。DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，值默认为OFF，表示采用INPLACE方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;old_alter_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: old_alter_table</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>LOCK部分为索引创建或删除时对表加锁的情况，可为：</p><ol><li>NONE——执行索引创建或者删除操作时，对目标表不添加任何的锁，事务仍然可以进行读写操作，不会收到阻塞。可获得最大的并发度。</li><li>SHARE——类似FIC，执行索引创建或者删除操作时，对目标表加上一个S锁，不影响并发读事务，但是写事务会等待。若存储引擎不支持SHARE模式，会返回一个错误信息。</li><li>EXCLUSIVE——执行索引创建或删除操作时，对目标表加上一个X锁，读写事务都不能进行，会阻塞所有线程。</li><li>DEFAULT——通过判断事务的最大并发性来判断执行DDL的模式，选用顺序依次为NONE、SHARE、EXCLUSIVE。</li></ol><p>Online DDL原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。缓存的大小由参数<code>innodb_online_alter_log_max_size</code>控制，默认大小128MB。若更新表比较大，且创建过程中有大量写事务，空间不足会报错，需调大参数值，或者设置ALTER TABLE的模式为SHARE，在执行过程中不会有写事务发生。</p><h3 id="Cardinality-值"><a href="#Cardinality-值" class="headerlink" title="Cardinality 值"></a>Cardinality 值</h3><h4 id="Cardinality"><a href="#Cardinality" class="headerlink" title="Cardinality"></a>Cardinality</h4><p>并不是在所有的查询条件中出现的列都需要添加索引，一般在访问表中很少一部分时使用B+ Tree索引才有意义，对于性别字段、地区字段、类型字段可取范围小，称为低选择性。若字段取值范围广，几乎没有重复，属于高选择性，适合使用B+ Tree索引。</p><p>Cardinality列表示索引中不重复记录数量的预估值，而不是一个准确值，基本不可能得到一个确切值。实际应用中Cardinality/n_rows_in_table应尽可能接近1，若非常小则需要考虑是否还有必要创建这个索引。</p><h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>MySQL对Cardinality的统计放在存储引擎层进行的，通过采样的方法完成。</p><p>InnoDB中Cardinality统计信息的更新发生在INSERT和UPDATE操作中，策略为：</p><ul><li>表中1/16的数据已发生过变化。</li><li>stat_modified_counter&gt;2 000 000 000</li></ul><p>默认InnoDB存储引擎对8个叶子节点（Leaf Page）进行采样，采样过程：</p><ul><li>取得B+ Tree Index中叶子节点的数量记为A。</li><li>随机取得B+ Tree Index中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。</li><li>根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8）*A/8</li></ul><p>每次对Cardinality值的统计，都是随机取8个叶子节点得到的，每次得到的Cardinality值可能是不同的。</p><p>InnoDB v1.2之前可通过参数<code>innodb_stats_sample_pages</code>设置统计Cardinality时每次采样页的数量，默认为8。同时，参数<code>innodb_stats_method</code>用来判断如何对待索引中出现的NULL值记录，默认值为nulls_equal，表示将NULL值记录视为相等的记录，还可取nulls_unequal表示将NULL值视为不同的记录，取nulls_ignored表示忽略NULL值记录。</p><p>执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎重新计算索引的Cardinality值，表数据量过大且多个辅助索引时，执行可能会很慢。</p><p>InnoDB v1.2提供更多参数对Cardinality统计进行设置：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">innodb_stats_persistent</td><td style="text-align:center">是否将ANALYZE TABLE计算得到的Cardinality值存放到磁盘上，若是则可以减少重新计算每个索引的Cardinality值。也可通过命令CREATE TABLE和ALTER TABLE的选项STATS_PERSISTENT来对每张表进行控制。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_on_metadata</td><td style="text-align:center">通过SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时，是否需要重新计算索引的Cardinality值。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_persistent_sample_pages</td><td style="text-align:center">若innodb_stats_persistent设置为ON，该参数表示ANALYZE TABLE更新Cardinality值时每次采样页的数量。默认值为20。</td></tr><tr><td style="text-align:center">innodb_stats_transient_smaple_pages</td><td style="text-align:center">取代之前版本的参数innodb_stats_sample_pages，表示每次采样页的数量，默认值为8。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_on_metadata&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_on_metadata</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent_sample_pages</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_transient_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_transient_sample_pages</span><br><span class="line">        Value: 8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="B-Tree-Index的使用"><a href="#B-Tree-Index的使用" class="headerlink" title="B+ Tree Index的使用"></a>B+ Tree Index的使用</h3><h4 id="不同应用中B-Tree-Index的使用"><a href="#不同应用中B-Tree-Index的使用" class="headerlink" title="不同应用中B+ Tree Index的使用"></a>不同应用中B+ Tree Index的使用</h4><p>OLTP应用根据查询条件建立B+ Tree Index，取少部分数据走索引。</p><p>OLAP应用取大量数据视具体情况分析。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表上多个列进行索引。</p><p>本质上联合索引也是一棵B+ Tree，不同的是联合索引的键值的数量不是1，而是大于等于2。</p><p>对于联合索引（a,b），查询a或者a、b可走索引，查询b无法使用索引。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引（covering index，索引覆盖），从辅助索引中就可以得到查询的记录，不需要查询聚集索引中的记录。辅助索引不包含正行记录的所有信息，大小小于聚集索引，可减少大量的IO操作。</p><p>通常诸如（a，b）的联合索引，一般不会选择列b中所谓的查询条件，但若是统计操作，并且是覆盖索引，则优化器会进行选择。</p><h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>多发生于范围查找、JOIN链接操作等情况下。</p><p>要求访问的数据量很小，优化器会选择辅助索引，当访问的数据量占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。因为辅助索引中查询到指定数据后，还需要一次书签访问来查找整行数据的信息，辅助索引上的数据是顺序存放的，但再一次进行书签查找的数据是无序的，变为了磁盘上的离散读操作，顺序读远快于离散读，所以优化器直接选择聚集索引。</p><h4 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h4><p>MySQL DB支持索引提示（INDEX HINT），显示地告诉优化器使用哪个索引。</p><p>使用到INDEX HINTL的情况：</p><ul><li>MySQL DB的优化器错误滴选择了某个索引，导致SQL语句运行的很慢。非常少见。</li><li>某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。</li></ul><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tbl_name [[AS] alias] [index_hint_list]</span><br><span class="line">index_hint_list:</span><br><span class="line">index_hint [, index_hint] ...</span><br><span class="line">index_hint:</span><br><span class="line">USE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list])</span><br><span class="line">  | IGNORE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">  | FORCE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">index_list:</span><br><span class="line">index_name [, index_name] ...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://oceanbase.alipay.com/docs/oceanbase/OceanBase%20SQL%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BA%BA%E4%B8%BA%E6%8E%A7%E5%88%B6%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/hint" target="_blank" rel="noopener">11.1 优化器HINT</a></p><h4 id="Multi-Range-Read（MRR）优化"><a href="#Multi-Range-Read（MRR）优化" class="headerlink" title="Multi-Range Read（MRR）优化"></a>Multi-Range Read（MRR）优化</h4><p>MySQL v5.6开始支持Multi-Range Read（MRR）优化，减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于IO-bound类型的SQL查询语句可带来性能极大的提升，可适用于range，ref，eq_ref类型的查询。</p><p>MRR优化的好处：</p><ul><li>使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果按照主键进行排序，并按照主键排序的顺序进行书签查找。</li><li>减少缓冲池中页被替换的次数。</li><li>批量处理对键值的查询操作。</li></ul><p>对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR工作方式：</p><ul><li>将查询得到的辅助索引键值存放于一个缓存中，此时缓存中的数据是根据辅助索引键值排序的。</li><li>将缓存中的键值根据RowID进行排序。</li><li>根据RowID的排序顺序来访问实际的数据文件。</li></ul><p>当缓冲池不够大，离散读操作导致缓存中的页可能被重复替换出/读入缓冲池，按照主键顺序进行访问可将此行为降为最低。MRR还可将某些范围查询，拆分为键值对，以此来进行批量的数据查询。可以在拆分的过程中，直接过滤一些不符合查询条件的数据。</p><p>是否启用Multi-Range Read优化可通过参数<code>optimizer_switch</code>中的标记（flag）来控制。mrr为on时，表示启用Multi-Range Read优化。<code>mrr_cost_based</code>标记表示是否通过cost based的方式来选择是否启用mrr。</p><p>参数<code>read_rnd_buffer_size</code>用来控制键值的缓冲区大小，当大于该值时，则执行器对已经缓存的数据根据RowID进行排序，并通过RowID来取得行数据。默认为256K。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;optimizer_switch&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: optimizer_switch</span><br><span class="line">        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;read_rnd_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: read_rnd_buffer_size</span><br><span class="line">        Value: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown(ICP)优化"></a>Index Condition Pushdown(ICP)优化</h4><p>MySQL v5.6开始支持Index Condition Pushdown(ICP)优化。不支持前进行索引查询时，先根据索引来查找记录，然后再根据WHERE条件来过滤记录。支持后，会在取出索引的同时，判断是否可以进行WHERE条件的过滤，将WHERE的部分过滤操作放在存储引擎层。某些查询下可大大减少上层SQL层对记录的索取，提高数据库的整体性能。</p><p>ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>时间复杂度为O（1），不只存在于索引中，每个数据库应用中都存在该数据结构。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>也称散列表，由直接寻址表改进而来。</p><p>哈希函数h必须可以很好地进行散列，最好的情况下是能避免碰撞的发生，即使不能避免也应该使碰撞在最小程度下产生。一般都将关键字转换为自然数。然后通过除法散列、乘法散列或全域散列来实现。数据库一般采用除法散列的方法。</p><h4 id="InnoDB存储引擎中的哈希算法"><a href="#InnoDB存储引擎中的哈希算法" class="headerlink" title="InnoDB存储引擎中的哈希算法"></a>InnoDB存储引擎中的哈希算法</h4><p>InnoDB存储引擎使用哈希算法来对字典进行查找，冲突机制采用链表方式，哈希函数采用除法散列方式。</p><p>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，指向相同哈希函数值的页。</p><p>对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。</p><p>将要查找的页转换为自然数。InnoDB存储引擎的表空间有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，及偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，关键字K=space_id&lt;&lt;20+space_id+offset，然后通过除法散列到各个槽中去。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>采用哈希表的方式实现，仅是数据库自身创建并使用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询。其他类型查找如范围查找是不能使用哈希索引的。</p><p>通过参数<code>innodb_adaptive_hash_index</code>控制是否开启。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。可根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。</p><p>InnoDB v1.2.x开始支持全文索引，支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文索引通常使用倒排索（inverted index）引来实现，倒排索引同B+ 树索引一样，也是一种索引结构。在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现，其拥有两种表现形式：</p><ul><li>inverted file index, 表现为{单词，单词所在文档的ID}</li><li>full inverted index，表现为{单词，（单词所在文档的ID，在具体文档中的位置）}</li></ul><h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>InnoDB采用full inverted index的方式，将（DocumentId，Position）视为一个“list”。在全文检索的表中，有两个列，一个是word字段，另一个是ilist字段，并且在word字段上设有索引。在ilist字段中存放了Position信息，可进行Proximity Search。</p><p>倒序排序需要将word存放到一张表中，该表称为Auxiliary Table（辅助表）。在InnoDB存储引擎中，为提高全文检索的并行性能，共有6张Auxiliary Table，每张表根据word的Latin编码进行分区。</p><p>Auxiliary Table是持久的表存放于磁盘上。FTS Index Cache（全文检索索引缓存），用于提高全文检索的性能。</p><p>FTS Index Cache是一个红黑树结构，根据（word，ilist）进行排序。意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table可能还没有更新。InnoDB存储引擎会批量对Auxiliary Table进行更新，不是每次插入后更新一次Auxiliary Table。对全文检索进行查询时，Auxiliary Table会先将FTS Index Cache中对应的word字段合并到Auxiliary Table中，然后再进查询。</p><p>允许用户查看指定倒排索引的Auxiliary Table中分词的信息，可以通过设置参数<code>innodb_ft_aux_table</code>来观察倒排索引的Auxiliary Table。</p><p>InnoDB总在事务提交时将分词写入到FTS Index Cache，然后通过批量更新写入到磁盘。数据库关闭时，FTS Index Cache中的数据会同步到磁盘上的Auxiliary Table中。若数据库宕机时，一些FTS Index Cache中的数据可能未被同步到磁盘上，下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中。</p><p>参数<code>innodb_ft_cache_size</code>控制FTS Index Cache的大小，默认值为32MB。当该缓存满时，会将其中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大该参数可提高全文检索的性能，宕机时，未同步到磁盘中的索引信息可能需要更长的时间恢复。</p><p>为支持全文索引，必须有一个列与word进行映射，在InnoDB中该列被命名为FTS_DOC_ID，类型必须是BIGINT UNSIGNED NOT NULL，会自动在该列上加入一个名为FTS_DOC_ID_INDEX的Unique Index。</p><p>对于删除操作，在事务提交时，不删除磁盘Auxiliary Table中的记录，而只是删除FTS Cache Index中的记录。对于Auxiliary Table中被删除的记录，InnoDB存储引擎会记录其FTS Document ID，并将其保存在DELETED auxiliary table中，设置<code>innodb_ft_aux_table</code>后，同样可以访问information_schema架构下的表INNODB_FT_DELETED来观察删除的FTS Document<br>ID。</p><p>OPTIMIZE TABLE命令允许用户手工地将已经删除的记录从索引中彻底删除，该命令还进行一些其他操作如Cardinality的重新统计。若只对倒排索引进行操作，可通过参数<code>innodb_optimize_fulltext_only</code>进行设置。若被删除文档数量非常多，会占用非常多的时间，影响程序的并发性，降低用户响应时间，可通过参数<code>innnodb_ft_num_word_optimize</code>来限制每次实际删除的分词数量，默认值2000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from test.fts_a where FTS_DOC_ID&lt;7;</span><br><span class="line">Query OK, 6 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE fts_a (</span><br><span class="line">    -&gt; FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,</span><br><span class="line">    -&gt; body TEXT,</span><br><span class="line">    -&gt; PRIMARY KEY(FTS_DOC_ID)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE FULLTEXT INDEX idx_fts ON fts_a(body);</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          1 | I am a boy                                |</span><br><span class="line">|          2 | I am a bad boy                            |</span><br><span class="line">|          3 | I am a good boy                           |</span><br><span class="line">|          4 | I am a good boy,who love liwenqi          |</span><br><span class="line">|          5 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|          6 | where is my heart                         |</span><br><span class="line">|          7 | what a beautiful girl                     |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts_a&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_INDEX_TABLE;</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD      | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| bad       |            2 |           2 |         1 |      2 |        7 |</span><br><span class="line">| beautiful |            7 |           7 |         1 |      7 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      1 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      2 |       11 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      3 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      4 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      5 |       12 |</span><br><span class="line">| girl      |            7 |           7 |         1 |      7 |       17 |</span><br><span class="line">| good      |            3 |           5 |         3 |      3 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      4 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      5 |        7 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      5 |       36 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      6 |       12 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      4 |       25 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      5 |       25 |</span><br><span class="line">| love      |            4 |           5 |         2 |      4 |       20 |</span><br><span class="line">| love      |            4 |           5 |         2 |      5 |       20 |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">17 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>FIRST_DOC_ID、LAST_DOC_ID、DOC_COUNT分别代表该word第一次出现的文档ID，最后一次出现的文档ID，以及该word在多少个文档中存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;liwenqi,what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          8 | I am a boy                                |</span><br><span class="line">|          9 | I am a bad boy                            |</span><br><span class="line">|         10 | I am a good boy                           |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         13 | where is my heart                         |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_optimize_fulltext_only=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; optimize table test.fts_a;</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| Table      | Op       | Msg_type | Msg_text |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| test.fts_a | optimize | status   | OK       |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEGIN_DELETED;</span><br><span class="line">ERROR 1109 (42S02): Unknown table &apos;innodb_ft_begin_deleted&apos; in information_schema</span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEING_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>命令OPTIMIZE TABLE可将记录进行彻底的删除，并且彻底删除的文档ID会记录到表information_schema.INNODB_FT_BEING_DELETED中。已被删除的文档ID不允许被再次使用。</p><p>stopword列表（stopword list）表示该列表中的word不需要对其进行索引分词操作。InnoDB存储引擎有一张默认的stopword列表，在information_schema架构下，表名为INNODB_FT_DEFAULT_STOPWORD，默认共36个stopword。可通过参数<code>innodb_ft_server_stopword_table</code>来自定义stopword列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DEFAULT_STOPWORD;</span><br><span class="line">+-------+</span><br><span class="line">| value |</span><br><span class="line">+-------+</span><br><span class="line">| a     |</span><br><span class="line">| about |</span><br><span class="line">| an    |</span><br><span class="line">| are   |</span><br><span class="line">| as    |</span><br><span class="line">| at    |</span><br><span class="line">| be    |</span><br><span class="line">| by    |</span><br><span class="line">| com   |</span><br><span class="line">| de    |</span><br><span class="line">| en    |</span><br><span class="line">| for   |</span><br><span class="line">| from  |</span><br><span class="line">| how   |</span><br><span class="line">| i     |</span><br><span class="line">| in    |</span><br><span class="line">| is    |</span><br><span class="line">| it    |</span><br><span class="line">| la    |</span><br><span class="line">| of    |</span><br><span class="line">| on    |</span><br><span class="line">| or    |</span><br><span class="line">| that  |</span><br><span class="line">| the   |</span><br><span class="line">| this  |</span><br><span class="line">| to    |</span><br><span class="line">| was   |</span><br><span class="line">| what  |</span><br><span class="line">| when  |</span><br><span class="line">| where |</span><br><span class="line">| who   |</span><br><span class="line">| will  |</span><br><span class="line">| with  |</span><br><span class="line">| und   |</span><br><span class="line">| the   |</span><br><span class="line">| www   |</span><br><span class="line">+-------+</span><br><span class="line">36 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE user_stopword (</span><br><span class="line">    -&gt; value VARCHAR(30)</span><br><span class="line">    -&gt; ) ENGINE = INNODB;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_server_stopword_table = &quot;test/user_stopword&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_ft_server_stopword_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_ft_server_stopword_table</span><br><span class="line">        Value: test/user_stopword</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>InnoDB全文索引的限制：</p><ul><li>每张表只能有一个全文索引。</li><li>由多列组合而成的全文检索的索引必须使用相同的字符集与排序规则。</li><li>不支持没有单词界定符的语言，如中文、日语、韩语等。</li></ul><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL全文检索查询语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">IN NATURAL LANGUAGE MODE</span><br><span class="line">| IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line">| IN BOOLEAN MODE</span><br><span class="line">| WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MATCH 指定了需要被查询的列，AGAINST指定了使用何种方法去进行查询。</p><h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>通过MATCH函数进行查询，默认采用Natural Language模式，表示查询带有指定word的文档。</p><p>不使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a </span><br><span class="line">    -&gt; where match(body)</span><br><span class="line">    -&gt; against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type     | possible_keys | key     | key_len | ref   | rows | filtered | Extra                         |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | fulltext | idx_fts       | idx_fts | 0       | const |    1 |   100.00 | Using where; Ft_hints: sorted |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>NATURAL LANGUAGE MODE默认的全文检索查询模式，可省略查询修饰符。</p><p>type列显示fulltext表示使用全文检索的倒排索引，key显示了索引的名字，相对like查询，全文索引只进行了一次扫描。</p><p>查询返回的结果是根据相关性（Relevance）进行降序排序的，相关性最高的结果放在第一位。由一个非负的浮点数表示，0表示没有任何相关性。相关性计算依据的条件：</p><ul><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>有多少个文档包含该word。</li></ul><p>统计查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|        3 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+-------+</span><br><span class="line">| count |</span><br><span class="line">+-------+</span><br><span class="line">|     3 |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | index | NULL          | PRIMARY | 8       | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>第二句SQL执行速度更快，第一句SQL语句需要进行相关性的排序统计。</p><p>通过SQL查看相关性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select fts_doc_id,body, match(body) against(&apos;liwenqi&apos; in natural language mode) as relevance from fts_a;</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">| fts_doc_id | body                                      | relevance          |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">|          8 | I am a boy                                |                  0 |</span><br><span class="line">|          9 | I am a bad boy                            |                  0 |</span><br><span class="line">|         10 | I am a good boy                           |                  0 |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          | 0.0906190574169159 |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart | 0.0906190574169159 |</span><br><span class="line">|         13 | where is my heart                         |                  0 |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             | 0.0906190574169159 |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>需考虑因素：</p><ul><li>查询word在stopword列中，忽略该字符串的查询。</li><li>查询的word字符长度是否在区间[innodb_ft_min_token_size, innodb_ft_max_token_size]内。</li></ul><p>若词在stopword中，不对该词进行查询。</p><p>参数<code>innodb_ft_min_token_size</code>和<code>innodb_ft_max_token_size</code>控制InnoDB存储引擎查询字符的长度，当长度小于<code>innodb_ft_min_token_size</code>或者大于<code>innodb_ft_max_token_size</code>时，会忽略该词的搜索，InnoDB存储引擎中，前者值默认为3，后者值默认为84。</p><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>使用该修饰符时，查询字符串的前后缀字符会有特殊的含义，支持以下几种操作符：</p><ul><li>+表示该word必须存在。</li><li>-表示该word必须被排除。</li><li>（no operator）表示该word是可选的，但是如果出现，相关性会更高。</li><li>@distance表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。该全文检索的查询也称为Proximity Search。</li><li><blockquote><p>表示出现该单词时增加相关性。</p></blockquote></li><li><blockquote><p>表示出现该单词时降低相关性。</p></blockquote></li><li>～表示允许出现该单词，但是出现时的相关性为负。</li><li>*表示以该单词开头的单词。</li><li>“表示短语。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;liwenqi girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;+liwenqi -girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Query-Expansion"><a href="#Query-Expansion" class="headerlink" title="Query Expansion"></a>Query Expansion</h5><p>MySQL支持全文索引的拓展查询，通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。通过Query Expansion模式开启全文检索的implied knowledge。</p><p>通过在查询短语中添加WITH QUERY EXPANSION或者IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION可以开启blind query knowledge（又称为automatic relevance feedback）。该查询分为两个阶段：</p><ul><li>第一阶段：根据搜索的单词进行全文索引查询。</li><li>第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li></ul><p>Query Expansion的全文检索可能会带来许多非相关性的查询。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;InnoDB存储引擎索引概述&quot;&gt;&lt;a href=&quot;#InnoDB存储引擎索引概述&quot; class=&quot;headerlink&quot; title=&quot;InnoDB存储引擎索引概述&quot;&gt;&lt;/a&gt;InnoDB存储引擎索引概述&lt;/h3&gt;&lt;p&gt;InnoDB支持的索引：&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="index" scheme="bighua.top/tags/index/"/>
    
      <category term="alg" scheme="bighua.top/tags/alg/"/>
    
  </entry>
  
  <entry>
    <title>表</title>
    <link href="bighua.top/2019/08/19/%E8%A1%A8/"/>
    <id>bighua.top/2019/08/19/表/</id>
    <published>2019-08-19T06:26:08.000Z</published>
    <updated>2019-08-30T12:24:03.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：</p><ul><li>首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。</li><li>不符合上述条件则自动创建一个6字节大小的指针。</li></ul><p>若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。</p><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。</p><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>启用参数<code>innodb_file_per_table</code>，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。</p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。</p><p>InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数<code>KEY_BLOCK_SIZE</code>设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.</p><p>InnoDB v1.2.x新增参数<code>innodb_page_size</code>，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。</p><p>在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。</p><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为<code>innodb_page_size</code>，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p><p>常见的页类型：</p><ul><li>数据页（B-Tree Node）</li><li>undo页（undo LogPage）</li><li>系统页（System Page）</li><li>事务数据页（Transaction system Page）</li><li>插入缓冲位图页（Insert Buffer Bitmap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOG Page）</li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。</p><h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>书中介绍不完善，参考博客<a href="https://www.cnblogs.com/wilburxu/p/9435818.html" target="_blank" rel="noopener">MySQL InnoDB 行记录格式</a>。</p><h4 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h4><p>在MySQL 5.0中引入，设计目标是高效地存储数据。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">变长字段长度列表</th><th style="text-align:center">NULL标志位</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节</td><td style="text-align:center">有NULL值列用1表示，占1字节</td><td style="text-align:center">固定占用5字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息每位含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的排序记录</td></tr><tr><td style="text-align:center">record_type</td><td style="text-align:center">3</td><td style="text-align:center">记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimum，011表示Supermum、1xx表示保留</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相应位置</td></tr></tbody></table><p>数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。</p><p>InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。</p><h4 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h4><p>MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">字段长度偏移列表</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示</td><td style="text-align:center">占用六字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知   </td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的索引号</td></tr><tr><td style="text-align:center">n_flieds</td><td style="text-align:center">10</td><td style="text-align:center">记录中列的数量</td></tr><tr><td style="text-align:center">1 byte_offs_flag</td><td style="text-align:center">1</td><td style="text-align:center">偏移列表为1字节还是2字节</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相对位置</td></tr></tbody></table><p>对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。</p><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOG、LOB这类大对象列类型的存储会把数据存放在数据页面之外，但是BLOG可以不将数据放在溢出页面，即便VARCHAR列数据依然有可能被存放为行溢出数据。</p><p>存放VARCHAR类型的最大长度（所有VARCHAR列的长度总和）为65532字节，超出且将SQL_MODE设为严格模式，建表时会报错，没设置严格模式或许可以建表但是会抛出一个warning，会将VARCHAR类型转换为TEXT类型。</p><p>InnoDB存储引擎的页为16KB，一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，发生行溢出时，数据存放在页类型为Uncompress BLOG页中。</p><p>InnoDB存储引擎表是索引组织的（B+Tree结构），每个页至少应该有两条行记录（否则失去B+Tree意义变成链表）。若页中只能存放下一条记录，则InnoDB存储引擎会自动将行数据放到溢出页中。若能至少放入两行数据则VARCHAR类型的行数据不会存放到BLOG页中，阀值的长度为8098。</p><p>TEXT或BLOG的数据类型，存放在数据页还是BLOG页和VARCHAR原则一致。大多数情况下BLOG的行数据会发生行溢出，实际数据保存在BLOG页中，数据页只保存前768字节。</p><h4 id="Compressed和Dynamic行记录数据"><a href="#Compressed和Dynamic行记录数据" class="headerlink" title="Compressed和Dynamic行记录数据"></a>Compressed和Dynamic行记录数据</h4><p>InnoDB v1.0.x开始引入新的文件格式，以前支持的Compact和Redundant格式被称为Antelope文件格式，新的文件格式称为Barracuda文件格式，其拥有两种新的行记录格式：Compressed和Dynamic。</p><p>新的两种行记录格式对于存放在BLOG中的数据采用了完全的行溢出的方式，数据页中只存放20个字节的指针，实际数据都存放在Off Page中。</p><p>Compressed行记录格式的另一个功能是，存放在其中的行数据会已zlib的算法进行压缩，对BLOG、TEXT、VARCHAR类大长度类型的数据能够进行有效的存储。</p><h4 id="CHAR的行存储结构"><a href="#CHAR的行存储结构" class="headerlink" title="CHAR的行存储结构"></a>CHAR的行存储结构</h4><p>通常理解VARCHAR存储变长长度的字符类型，CHAR存储固定长度的字符类型。</p><p>MySQL v4.1开始，CHAR（N）中N指的是字符的长度，而非字节长度，在不同的字符集下，CHAR类型列内部存储的可能不是定长数据。</p><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度。在多字符集的存储情况下，CHAR和VARCHAR的实际存储基本没有区别。</p><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InoDB数据页组成：</p><ul><li>File Header（文件头）</li><li>Page Header（页头）</li><li>Infimum和Supermun Records</li><li>User Records（用户记录，即行记录）</li><li>Free Space（空闲空间）</li><li>Page Directory（页目录）</li><li>File Trailer（文件结尾信息）</li></ul><p>Flie Header、Page Header、File Trailer大小固定，分别为38、56、8字节，标记该页的一些信息，如Checksum，数据页所在B+ Tree索引的层等。User Records、Free Space、Page Directory为实际的行记录存储空间，大小是动态的。</p><table><thead><tr><th style="text-align:center">File Header</th><th style="text-align:center">Page Header</th><th style="text-align:center">Infimum + Supermum Records</th><th style="text-align:center">User Recodrds</th><th style="text-align:center">Free Space</th><th style="text-align:center">Page Directory</th><th style="text-align:center">File Trailer</th></tr></thead><tbody><tr><td style="text-align:center">38字节</td><td style="text-align:center">56字节</td><td style="text-align:center">行记录</td><td style="text-align:center">行记录</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">8字节</td></tr></tbody></table><h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>组成 ：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（字节）</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_SPACE_OR_CHKSUM</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.0.14之前值为0，之后代表页的checksum值</td></tr><tr><td style="text-align:center">FIL_PAGE_OFFSET</td><td style="text-align:center">4</td><td style="text-align:center">表空间中页的偏移量，表示当前页在表空间所有页中的位置</td></tr><tr><td style="text-align:center">FIL_PAGE_PREV</td><td style="text-align:center">4</td><td style="text-align:center">当前页的上一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_NEXT</td><td style="text-align:center">4</td><td style="text-align:center">当前页的下一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_LSN</td><td style="text-align:center">8</td><td style="text-align:center">最后被修改的日志序列位置LSN（Log Sequence Number）</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE</td><td style="text-align:center">2</td><td style="text-align:center">页的类型，见下表枚举</td></tr><tr><td style="text-align:center">FIL_PAGE_FILE_FLUSH_LSN</td><td style="text-align:center">8</td><td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间值为0</td></tr><tr><td style="text-align:center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.1开始代表页属于哪个表空间。</td></tr></tbody></table><p>InnoDB存储引擎中页的类型</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">十六进制</th><th style="text-align:center">解释 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_INDEX</td><td style="text-align:center">0x45BF</td><td style="text-align:center">B+树叶节点</td></tr><tr><td style="text-align:center">FIL_PAGE_UNDO_LOG</td><td style="text-align:center">0x0002</td><td style="text-align:center">Undo Log页</td></tr><tr><td style="text-align:center">FIL_PAGE_INODE</td><td style="text-align:center">0x0003</td><td style="text-align:center">索引节点</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_FREE_LIST</td><td style="text-align:center">0x0004</td><td style="text-align:center">Insert Buffer空闲列表</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_ALLOCATED</td><td style="text-align:center">0x0000</td><td style="text-align:center">该页为最新分配</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_BITMAP</td><td style="text-align:center">0x0005</td><td style="text-align:center">Insert Buffer位图</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_SYS</td><td style="text-align:center">0x0006</td><td style="text-align:center">系统页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_TRX_SYS</td><td style="text-align:center">0x0007</td><td style="text-align:center">事务系统数据</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_FSP_HDR</td><td style="text-align:center">0x0008</td><td style="text-align:center">File Space Header</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_XDES</td><td style="text-align:center">0x0009</td><td style="text-align:center">拓展描述页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_BLOG</td><td style="text-align:center">0x000A</td><td style="text-align:center">BLOG页</td></tr></tbody></table><h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>记录数据页的状态信息，由14个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">PAGE_N_DIR_SLOTS</td><td style="text-align:center">2</td><td style="text-align:center">在Page Directory（页目录）中的Slot（槽）数</td></tr><tr><td style="text-align:center">PAGE_HEAP_TOP</td><td style="text-align:center">2</td><td style="text-align:center">堆中第一个记录的指针、记录在页中是根据堆的形式存放的</td></tr><tr><td style="text-align:center">PAGE_N_HEAP</td><td style="text-align:center">2</td><td style="text-align:center">堆中的记录数，第15位表示行记录数</td></tr><tr><td style="text-align:center">PAGE_FREE</td><td style="text-align:center">2</td><td style="text-align:center">指向可重用空间的首指针</td></tr><tr><td style="text-align:center">PAGE_GARBAGE</td><td style="text-align:center">2</td><td style="text-align:center">已删除记录的字节数，行记录结构中delete flag为1的记录大小的总数</td></tr><tr><td style="text-align:center">PAGE_LAST_INSERT</td><td style="text-align:center">2</td><td style="text-align:center">最后插入记录的位置</td></tr><tr><td style="text-align:center">PAGE_DIRECTORY</td><td style="text-align:center">2</td><td style="text-align:center">最后插入的方向，可取：PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0x03)，PAGE_SAME_PAGE(0x04)，PAGE_NO_DIRECTION(0x05)</td></tr><tr><td style="text-align:center">PAGE_N_DIRECTION</td><td style="text-align:center">2</td><td style="text-align:center">一个方向连续插入数据的数量</td></tr><tr><td style="text-align:center">PAGE_N_RECS</td><td style="text-align:center">2</td><td style="text-align:center">该页中记录的数量</td></tr><tr><td style="text-align:center">PAGE_MAX_TEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">当前页的最大事务ID，仅在Secondary Index(辅助索引)中定义</td></tr><tr><td style="text-align:center">PAGE_LEVEL</td><td style="text-align:center">2</td><td style="text-align:center">当前页在索引树中的位置，0x00代表页节点，页节点总在第0层</td></tr><tr><td style="text-align:center">PAGE_INDEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">索引ID，表示当前页属于哪个索引</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_LEAF</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree树的Root页中定义，B+ Tree数据页非页节点所在段的seqment header</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_TOP</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree的Root页中定义，B+ Tree数据页所在段的segment header</td></tr></tbody></table><h4 id="Infimum和Supermum-Record"><a href="#Infimum和Supermum-Record" class="headerlink" title="Infimum和Supermum Record"></a>Infimum和Supermum Record</h4><p>Infimum记录比该页中任何主键值都要小得值，Supermum指比任何可能大的值还要大的值，在页创建时被建立，在任何情况下都不会被删除。在Compact和Redundant行格式下，两者占用的字节数各不相同。</p><h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record：实际存储行记录的内容。</p><p>Free Space：空闲空间，链表数据结构，在一条记录被删除后，该空间被加入到空闲链表中。</p><h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>页目录中存放记录的相对位置，有些时候这些记录指针被称为Slots（槽）或目录槽（Directory Slots）。</p><p>InnoDB的槽是一个稀疏目录（sparse directory），一个槽中可能包含多个记录。伪记录Infimum的n_owned值总是1，记录Supermum的n_owned的取值范围为[1, 8]，其他用户记录n_owned的取值范围为[4, 8]，当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。</p><p>Slots中记录按照索引键值顺序存放，可以利用二叉查找，查找结果只是一个粗略的结果，必须通过recorder header中的next_record继续查找相关记录。</p><p>B+ Tree索引找到记录所在的页，数据库把页载入内存，然后通过Page Directory再进行二叉查找。</p><h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>检测页是否已经完整地写入磁盘（可能发生在写入过程中磁盘损坏）。</p><p>只有以一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，后4字节和File Header中的FIL_PAGE_LSN相同。通过InnoDB的checksum函数将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致，保证页的完整行。</p><p>默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，即该页是否发生Corrupt，该检测会有一定的开销，可通过innodb_checksums来开启或关闭对这个页完整性的检查。</p><p>MySQL v5.6.6新增参数<code>innodb_checksum_algorithm</code>，控制检测checksum函数的算法，默认crc32，可设置：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_checksum%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_checksum_algorithm</span><br><span class="line">        Value: crc32</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_checksums</span><br><span class="line">        Value: ON</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>innodb为兼容之前版本的checksum检测方式，crc于v 5.6.6引入，有更高的性能。若表中所有页的checksum值都以strict算法保存，脚底版本MySQL数据库不能读取这些页。none表示不对页启用checksum检测。strict_*表示严格按照checksum算法进行页的检测，较低版本MySQL升级到MySQL5.6.6+版本，启用strict_crc32将不能读取表中的页。启用strict_crc32方式是最快的方式，其不再对innodb和crc32算法进行两次检测。数据库从低版本升级而来需进行mysql_upgrade操作。</p><h3 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h3><p>从InnoDB v1.0.x引入，通过Named File Formats机制解决不同版本下页结构兼容性问题。</p><p>通过参数<code>innodb_file_format</code>指定文件格式，通过参数<code>innodb_file_format_check</code>检测当前存储引擎文件格式的支持度，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_file_format&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_format</span><br><span class="line">        Value: Barracuda</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，文件系统一般需要在程序端进行控制。</p><p>数据完整性的三种形式：</p><ul><li>实体完整性保证表中有一个主键。通过Primary Key或Unique Key约束来保证实体的完整性。可通过编写一个触发器来保证数据的完整性。</li><li>域完整性保证数据每列的值满足特定的条件。域完整性保证途径：<ul><li>选择合适的数据类型确保一个数据值满足特定条件。</li><li>外键（Foreign key）约束。</li><li>编写触发器。</li><li>用DEFAULT约束强制域完整性</li></ul></li><li>参照完整性保证两张表之间的关系。InnoDB存储引擎支持外健，允许用户自定义外键以强制参照完整性，通过编写触发器以强制执行。</li></ul><p>InnoDB存储引擎本身提供约束：</p><ul><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL </li></ul><h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>采用两种方式：</p><ul><li>表建立时进行约束定义</li><li>利用ALTER TABLE命令来进行创建约束</li></ul><p>对Unique Key约束，还可通过命令CREATE UNIQUE INDEX来建立。主键约束默认名Primary，Unique Key约束默认约束名和列名一样，可指定Unique Key约束名。Foreign Key约束默认名称特殊。</p><p>可通过information_schema架构下的表TABLE_CONSTRAINTS查看当前MySQL库下所有的约束信息，通过表REFERENTIAL_CONSTRAINTS查看Foreign Key的约束命名和外健的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from information_schema.TABLE_CONSTRAINTS;</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field              | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from information_schema.REFERENTIAL_CONSTRAINTS;</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field                     | Type         | Null | Key | Default | Extra |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG        | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME           | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_NAME    | varchar(64)  | YES  |     | NULL    |       |</span><br><span class="line">| MATCH_OPTION              | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UPDATE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| DELETE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME                | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| REFERENCED_TABLE_NAME     | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>约束是逻辑概念，用来保证数据的完整性，索引是一个数据结构，在数据库中代表着物理存储的方式。</p><h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>默认设置下，MySQL允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL会将其更改为0再进行插入。</p><p>可通过设置参数<code>sql_mode</code>为STRICT_TRANS_TABLES，对输入值的合法性进行约束，用来严格审核输入的参数。sql_mode可设值参考MySQL官方手册。</p><h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><p>MySQL数据库不支持传统的CHECK约束，通过ENUM和SET类型解决。</p><p>对于传统CHECK约束支持的连续值的范围约束或更复杂的约束，可通过触发器来实现对于值域的约束。</p><h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。MySQL v5.1开始触发器相对稳定。</p><p>通过命令CREATE TRIGGER创建触发器，具备Super权限的MySQL数据库用户才可执行这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE | AFTER INSERT | UPDATE | DELETE</span><br><span class="line">ON tb1_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure><p>最多可为一个表建立6个触发器，分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。BEFORE和AFTER代表触发器发生的时间，表示在每行操作之前发生还是之后发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table usercash ( userid INT NOT NULL, cash INT UNSIGNED NOT NULL);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table usercash_err_log ( userid INT NOT NULL, old_cash INT UNSIGNED NOT NULL, new_cash INT UNSIGNED NOT NULL, user VARCHAR(30), time DATETIME);</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER $$ </span><br><span class="line">mysql&gt; create trigger tgr_usercash_update before update on usercash</span><br><span class="line">    -&gt; for each row</span><br><span class="line">    -&gt; begin </span><br><span class="line">    -&gt; if new.cash-old.cash &gt; 0 then</span><br><span class="line">    -&gt; insert into usercash_err_log</span><br><span class="line">    -&gt; select old.userid,old.cash,new.cash,USER(),NOW();</span><br><span class="line">    -&gt; set new.cash = old.cash;</span><br><span class="line">    -&gt; end if;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update usercash set cash=cash-(-20) where userid=1;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  userid: 1</span><br><span class="line">old_cash: 1000</span><br><span class="line">new_cash: 1020</span><br><span class="line">    user: root@localhost</span><br><span class="line">    time: 2019-08-23 15:18:08</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>保证参照的完整性，MyISAM引擎本身不支持外键，对于外键的定义只起注释的作用。InnoDB完整支持外键约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT [symbol]] FOREIGN KEY</span><br><span class="line">[index_name] (index_col_name, ...)</span><br><span class="line">REFERENCES tb1_name (index_col_name, ...)</span><br><span class="line">[ON DELETE reference_option]</span><br><span class="line">[ON UPDATE reference_option]</span><br><span class="line">reference_option:</span><br><span class="line">RESTRICT | CASCADE | SET NULL | NO ACTION</span><br></pre></td></tr></table></figure><p>可执行CREATE TABLE或者ALTER TABLE命令添加外健。</p><p>被引用的表为父表、引用的表称为子表，外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作，可定义字表操作有：</p><ul><li>CASCADE：父表发生DELETE或UPDATE操作时对相应字表中的数据也进行DELETE或UPDATE操作。</li><li>SET NULL：父表发生DELETE或UPDATE操作时，相应的字表中的数据被更新为NULL值，字表相应字段必须允许为NULL值。</li><li>NO ACTION：父表发生DELETE或UPDATE操作时，抛出错误，不允许此类操作发生。</li><li>RESTRICT：未定义ON DELETE或ON UPDATE时的默认外健设置。</li></ul><p>MySQL数据库的外键约束为及时检查，在SQL语句运行时进行检查。MySQL数据库中NO ACTION和RESTRICT的功能是相同的。</p><p>InnoDB在外键建立时会自动为该列加一个索引，可避免外键列上无索引而导致的死锁问题产生。</p><p>可通过参数<code>foreign_key_checks</code>设置是否开启外键检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;foreign_key_checks&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: foreign_key_checks</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，由一个SQL查询来定义，可当作表使用，没有实际的物理存储。</p><h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><p>被用作一个抽象装置，不需关心基表（base table）的结构，只需按视图定义来取数据或更新数据。一定程度上起到安全层作用。</p><p>MySQL v5.0开始支持视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[OR REPLACE]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">[SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>可对某些视图进行更新操作，本质是通过视图的定义来更新基本表。称可进行更新操作的视图为可更新视图（updatable view）。WITH CHECK OPTION针对于可更新视图更新的值是否需要检查。</p><p>通过SHOW TABLES命令显示结果包含基表和视图，只查询基表可通过information_schema架构下的TABLE表查询，并搜索类型为BASE TABLE的表。</p><p>查看视图的元数据（meta data）可访问information_schema架构下的VIEWS表，给出了视图的定义者（definer）、定义内容、是否是可更新视图、字符集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">+------------------+</span><br><span class="line">8 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create view v_users</span><br><span class="line">    -&gt; as</span><br><span class="line">    -&gt; select * from users where id&lt;10;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">| v_users          |</span><br><span class="line">+------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.VIEWS where table_schema=database()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       TABLE_CATALOG: def</span><br><span class="line">        TABLE_SCHEMA: login</span><br><span class="line">          TABLE_NAME: v_users</span><br><span class="line">     VIEW_DEFINITION: select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`sex` AS `sex` from `login`.`users` where (`login`.`users`.`id` &lt; 10)</span><br><span class="line">        CHECK_OPTION: NONE</span><br><span class="line">        IS_UPDATABLE: YES</span><br><span class="line">             DEFINER: root@localhost</span><br><span class="line">       SECURITY_TYPE: DEFINER</span><br><span class="line">CHARACTER_SET_CLIENT: utf8</span><br><span class="line">COLLATION_CONNECTION: utf8_general_ci</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果，在执行复杂查询时，可避免进行这些耗时的操作，从而快速得到结果，对于一些复杂的统计类查询能直接查处结果。</p><p>MySQL数据库不支持物化视图，可通过一些机制来实现物化视图的功能。例如可通过触发器维护一个结果状态副表，每当发生INSERT、UPDATE和DELETE操作时触发器更新结果状态表。</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h4><p>MySQL v5.1时添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对应用，逻辑上只有一个或一个索引，但在物理上表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p><p>MySQL支持水平分区（同一表中不同行的记录分配到不同的物理文件中），不支持垂直分区（同一表中不同列的记录分配到不同的物理文件中）。MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。全局分区指数据存放在各个分区中，但是所有数据的索引放在一个对象中。</p><p>可通过<code>SHOW VARIABLES LIKE &#39;%partition%&#39;\G</code> 和<code>SHOW PLUGINS\G</code>查看是否启用了分区功能。</p><p>MySQL数据库支持分区类型：</p><ul><li>RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区，v5.5开始支持RANGE COLUMNS的分区。</li><li>LIST分区：面向离散的值。v5.5开始支持LIST COLUMNS的分区。</li><li>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的哈希函数进行分区。</li></ul><p>若表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引允许NULL值，分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。若建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><h5 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h5><p>启用分区之后，表由建立分区时的各个分区ibd文件组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t</span><br><span class="line">    -&gt; (id INT) engine=innodb</span><br><span class="line">    -&gt; partition by range (id) (partition p0 values less than (10),partition p1 values less than (20));</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login | grep t</span><br><span class="line">total 2288</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 16:06 t.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    40B  8 23 14:49 tgr_usercash_update.TRN</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (9);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (15);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 30</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t add partition (partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.PARTITIONS where table_schema=database() and table_name=&apos;t&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p0</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 1</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 10</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:12</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p1</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 2</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 20</span><br><span class="line">                   TABLE_ROWS: 2</span><br><span class="line">               AVG_ROW_LENGTH: 8192</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:31</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询information_schema架构下的PARTITION表来查看每个分区的具体信息，TABLE_ROWS为每个分区中记录的数量，PARTITION_METHOD为分区的类型。插入一个不在分区中定义的值时，会抛出一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE sales ( money INT UNSIGNED NOT NULL, date DATETIME ) ENGINE=INNODB PARTITION by RANGE (YEAR(date)) ( PARTITION p2018 VALUES LESS THAN (2019), PARTITION p2019 VALUES LESS THAN (2020) );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-02-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2019-03-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2020-03-02&apos;);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 2020</span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2018-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 33.33</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2019-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018,p2019</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 25.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过EXPLAIN PARTITIONS可查看查询条件搜索的分区，SQL优化器会做分区修剪。可根据分区直接删除指定范围内的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from sales;·</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table sales drop partition p2018;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于RANGE分区的查询，优化器只能对YESR()、TO_DAYS()、TO_SECONDS()、UNIX_TIMESTAMP()这类函数进行优化选择。</p><h5 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h5><p>LIST分区相似于RANGE分区，分区列的值是离散的，而非连续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,1,2,4,6,8));</span><br><span class="line">ERROR 1495 (HY000): Multiple definition of same constant in list partitioning</span><br><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,2,4,6,8));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,6);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,7);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,10);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 10</span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 2</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 2</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>VALUES IN中的值又重复时创建表会报错，插入值不在其中会报错。</p><p>INSERT插入多个数据的过程中遇到分区未定义时，MyISAM和InnoDB存储引擎表现不同，MyISAM会将之前的行数据都插入，之后的数据不插入。InnoDB将其视为一个事务，没有任何数据插入。</p><h5 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h5><p>目的将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致都是一样的。需要基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_hash (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by hash (year(b))</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; insert into t_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>插入分区：mod(expr, num)</p><p>对于连续的值进行HASH分区，可以较好的将数据进行平均分区。</p><p>LINEAR HASH分区，使用更加复杂的算法确定新行插入到已经分区的表中的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_linear_hash ( a int, b datetime )engine=innodb partition by linear hash (year(b)) partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_linear_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_linear_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>计算分区：</p><ul><li>取大于分区数量4的下一个2的幂值V，V=POWER(2,CEILING(LOG(2,num)))=4</li><li>所在分区N=YEAR(‘010-04-01’)&amp;(V-1)=2</li></ul><p>LINEAR HASH分区的优势在于增加、删除、合并和拆分分区变得更加快捷，有利于处理含有大量数据的表。缺点在于各分区数据的分布可能不大均衡。</p><h5 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h5><p>与HASH分区相似，HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。对于NDB Cluster引擎，MySQL DB使用MD5函数来分区；其他存储引擎使用内部分哈希函数，这些函数基于PASSWORD()一样的运算法则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_key (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by key (b)</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>在key分区中使用关键字LINEAR和在HASH分区中使用具有相同的效果，分区编号通过2的幂算法得到而不是通过模数算法。</p><h5 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h5><p>RANGE、LIST、HASH、和KEY分区条件：数据必须是整型，或通过函数将其转化为整型。</p><p>MySQL v5.5开始支持COLUMNS分区，是RANGE分区和LIST分区的进化，可以直接使用非整型数据进行分区，分区根据类型直接比较而得，不需要转化为整型。RANGE COLUMNS分区可对多个列的值进行分区。</p><p>COLUMNS分区支持的数据类型：</p><ul><li>所有整型类型，如INT、SMALLINT、TINYINT、BIGINT。FLOAT和DECIMAL不支持。</li><li>日期类型，DATE和DATETIME。其余日期类型则不支持。</li><li>字符串类型，如CHAR、VARCHAR、BINARY和VARBINARY。BLOB和TEXT类型不支持。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_columns_range ( </span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b datetime</span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (b) (</span><br><span class="line">-&gt;partition p0 values less than (&apos;2019-01-01&apos;), </span><br><span class="line">-&gt;partition p1 values less than (&apos;2020-01-01&apos;) );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table rcx (</span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b int, </span><br><span class="line">-&gt;c char(3), </span><br><span class="line">-&gt;d int </span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (a,b,c) ( </span><br><span class="line">-&gt;partition p0 values less than (5,10,&apos;ggg&apos;),</span><br><span class="line">-&gt;partition p1 values less than (10,20,&apos;mmm&apos;), </span><br><span class="line">-&gt;partition p2 values less than (15,30,&apos;sss&apos;),</span><br><span class="line">-&gt;partition p3 values less than (maxvalue,maxvalue,maxvalue));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_columns_range&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;rcx&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h5 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h5><p>在分区的基础上再进行分区，也称符合分区。MySQL DB允许再RANGE和LIST的分区上再进行HASH或KEY的子分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table ts ( a int, b date)engine=innodb</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b))</span><br><span class="line">    -&gt; subpartitions 2 (</span><br><span class="line">    -&gt; partition p0 values less than (2019),</span><br><span class="line">    -&gt; partition p1 values less than (2020),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:27 ts.frm</span><br><span class="line"></span><br><span class="line">mysql&gt; create table ts_subpartition (a int,b date)engine=innodb                                                                                                                                                                                                                     </span><br><span class="line">    -&gt; partition by range (year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b)) (</span><br><span class="line">    -&gt; partition p0 values less than (2019) (subpartition s0, subpartition s1)</span><br><span class="line">    -&gt; ,partition p1 values less than (2020) (subpartition s2, subpartition s3)</span><br><span class="line">    -&gt; ,partition p2 values less than maxvalue (subpartition s4, subpartition s5));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts_subpartition</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s2.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s3.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s4.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s5.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:37 ts_subpartition.frm</span><br></pre></td></tr></table></figure><p>子分区建立：</p><ul><li>每个子分区的数量必须相同</li><li>要在一个分区表的任何分区上使用subpartition来明确定义任何子分区，就必须定义所有的子分区</li><li>每个subpartition子句必须包括子分区的一个名字</li><li>子分区的名字必须是唯一的</li></ul><p>子分区可用于特别大的表，在多个磁盘分别分配数据和索引。</p><h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MySQL允许对NULL值做分区，总是视NULL值小于任何一个非NULL的值，与MySQL DB中处理NULL值的ORDER BY操作是一样的。对于不同的分区类型，MySQL DB对NULL值的处理也各不相同。</p><p>对RANGE分区，若向分区列插入NULL值，则将该值放入最左边的分区。</p><p>在LIST分区下使用NULL值需要显式地指定哪个分区中放入NULL值，否则报错。</p><p>HASH和KEY分区处理NULL值时，任何分区函数都会将含有NULL值的记录返回为0。</p><h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>数据库应用分为：OLTP（在线事务处理），如Blog、电子商务、网络游戏等；OLAP（在线分析处理），如数据仓库、数据集市。</p><p>对OLAP应用，分区一般能很好地提高查询的性能。OLAP应用大多数查询需要频繁地扫描一张很大的表。</p><p>对OLTP应用，分区需要注意，用用通常不可能会获取一张大表中10%的数据，大部分都可通过索引返回几条记录即可。对一张大表，一般的B+ Tree需要2～3次的磁盘IO。设计时需要确认数据的访问模式，分析查询时使用分区是否能够比未使用分区减少IO访问次数。</p><h4 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h4><p>MySQL v5.6开始支持ALTER TABLE … EXCHANGE PARTITION语法。允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。若非分区表中的数据为空，则相当于将分区中的数据迁移到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。</p><p>使用语句条件：</p><ul><li>要交换的表需和分区表有着相同的表结构，但是表不能含有分区</li><li>在非分区表中数据必须在交换的分区定义内</li><li>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</li><li>用户除了需要ALTER、INSERT和CREATE权限外，还需要DROP的权限</li></ul><p>需要注意的细节：</p><ul><li>使用该语句不会触发交换表和被交换表上的触发器</li><li>AUTO_INCREMENT列将被重置</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引组织表&quot;&gt;&lt;a href=&quot;#索引组织表&quot; class=&quot;headerlink&quot; title=&quot;索引组织表&quot;&gt;&lt;/a&gt;索引组织表&lt;/h3&gt;&lt;p&gt;表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="table" scheme="bighua.top/tags/table/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="bighua.top/2019/08/16/%E6%96%87%E4%BB%B6/"/>
    <id>bighua.top/2019/08/16/文件/</id>
    <published>2019-08-16T06:20:30.000Z</published>
    <updated>2019-08-19T09:38:01.311Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB存储引擎表的各种类型文件。</p><ul><li>参数文件：告知MYSQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，介绍各种参数的类型。</li><li>日志文件：记录MySQL实例对某种条件做出响应时写入的文件，如错误的日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</li><li>socket文件：当用UNIX域套接字方式进行连接时需要的文件。</li><li>pid文件：MySQL实例的进程ID文件。</li><li>MySQL表结构文件：用来存放MySQL表结构定义文件。</li><li>存储引擎文件：每个存储引擎有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。</li></ul><h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><p>默认MySQL实例会按照一定的顺序在指定的位置进行读取，可通过<code>mysql --help | grep my.cnf</code>来寻找。</p><p>MySQL的mysql架构中记录了访问该实例的权限，当找不到这个架构时，MySQL实例不会启动成功。</p><h4 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h4><p>可以把数据参数看成一个键/值（Key/Value）对。</p><p>MySQL v5.1开始可以通过<code>information_schema</code>架构下的<code>GLOBAL_VARIABLES</code>试图来进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from global_variables where variable_name like &apos;innodb_buffer%&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_AT_STARTUP</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_FILENAME</span><br><span class="line">VARIABLE_VALUE: ib_buffer_pool</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_POPULATE</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_AT_SHUTDOWN</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_ABORT</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_INSTANCES</span><br><span class="line">VARIABLE_VALUE: 8</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_SIZE</span><br><span class="line">VARIABLE_VALUE: 4294967296</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_at_shutdown</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_filename</span><br><span class="line">        Value: ib_buffer_pool</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 8</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_abort</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_at_startup</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_populate</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 4294967296</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>各版本都支持<code>SHOW VARIABLES</code>命令。</p><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>可分为：</p><ul><li>动态参数（dynamic）参数，可在MySQL实例运行中进行更改</li><li>静态（static）参数，在整个实例生命周期内都不得进行更改</li></ul><p>可通过SET命令对动态参数值进行更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET | [global | session] system_var_name = expr | [@@global. | @@session. | @@]system_var_name= expr</span><br></pre></td></tr></table></figure><p>global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。有些参数如autocommit只能在会话中进行修改；有些参数如binlog_cache_size修改完后，在整个实例生命周期中都会生效；有些参数如read_buffer_size既可以在会话中修改又可以在整个实例的生命周期内生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set read_buffer_size=524288;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @@global.read_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>动态变量的可修改范围参考MySQL官方手册Dynamic System Variables。</p><p>修改静态变量报错，提示静态变量是只读的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set GLOBAL datadir=&apos;/db/mysql&apos;;</span><br><span class="line">ERROR 1238 (HY000): Variable &apos;datadir&apos; is a read only variable</span><br></pre></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>记录MySQL数据库的各种类型活动：</p><ul><li>错误日志（error log）</li><li>二进制日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>对MySQL的启动、运行、关闭过程进行了记录，可通过<code>SHOW VARIABLES LIKE ‘log_error’</code>来定位文件。可从中得到数据库优化的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_error&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_error</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.err</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system hostname</span><br><span class="line">wuhua</span><br></pre></td></tr></table></figure><p>默认情况下错误文件的文件名为服务器的主机名（自己mac下默认安装v5.7.22时使用了默认配置创建了_mysql用户，但是也有wuhua.err日志）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# ps aux | grep mysql | grep -v grep</span><br><span class="line">wuhua            27197   0.0  0.0  4301596   1628 s000  S+   二05下午   0:00.18 mysql -u root -p</span><br><span class="line">_mysql              95   0.0  0.1  4667136   8176   ??  Ss    8 819    0:50.48 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring --early-plugin-load=keyring_file=keyring_file.so</span><br><span class="line">sh-3.2# pwd</span><br><span class="line">/usr/local/mysql/data</span><br><span class="line">sh-3.2# ls -la</span><br><span class="line">total 390208</span><br><span class="line">drwxr-x---   17 _mysql  _mysql       544  8 13 17:50 .</span><br><span class="line">drwxr-xr-x   13 root    wheel        416 10 22  2018 ..</span><br><span class="line">-rw-r-----    1 _mysql  _mysql        56  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       559  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  79691776  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql       224  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql       512  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql      2464  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1493892  8 16 14:11 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql         3  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql      2880  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql      3456  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql       160 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    137797  8 13 17:50 wuhua.err</span><br><span class="line">sh-3.2# tail -n 10 mysqld.local.err </span><br><span class="line">2019-08-15T03:46:55.758211Z 4 [Note] Aborted connection 4 to db: &apos;unconnected&apos; user: &apos;root&apos; host: &apos;localhost&apos; (Got timeout reading communication packets)</span><br><span class="line">2019-08-15T05:57:18.115284Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 2089426ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T10:19:57.114776Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 591037ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T12:48:35.002866Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 257282ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T00:45:10.005256Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 42960754ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T02:30:30.003258Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 6316989ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T04:41:49.003687Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 1295395ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:09:32.002146Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 68711ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:11:12.002422Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 24552ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T07:44:47.528144Z 8 [Note] Access denied for user &apos;wuhua&apos;@&apos;localhost&apos; (using password: NO)</span><br></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。</p><p>可通过参数<code>long_query_time</code>来设置超时阀值，默认10，代表10秒，将运行超过该值的SQL语句记录到慢查询日志文件中。</p><p>默认不启动慢查询日志，需要手工将这个参数设置为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 10.000000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 2.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当设置了参数<code>log_queries_not_using_indexes</code>为开启时，会将没有使用索引的SQL语句记录到慢查询日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_queries_not_using_indexes&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_queries_not_using_indexes</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可通过参数<code>log_throttle_queries_not_using_indexes</code>设置每分钟允许记录到slow log的且未使用索引的SQL语句的次数。默认为0表示无限制。</p><p>可通过mysqldumpslow命令分析慢查询日志文件。使用参考<a href="http://www.dbhelp.net/2017/01/17/mysqldumpslow-%E8%AF%BB%E6%87%82mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.html" target="_blank" rel="noopener">mysqldumpslow – 读懂MySQL慢查询日志</a></p><p>v 5.1开始可以将慢查询的日志记录放入到一张表中，在mysql架构下的slow_log表，表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show create table mysql.slow_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: slow_log</span><br><span class="line">Create Table: CREATE TABLE `slow_log` (</span><br><span class="line">  `start_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  `user_host` mediumtext NOT NULL,</span><br><span class="line">  `query_time` time NOT NULL,</span><br><span class="line">  `lock_time` time NOT NULL,</span><br><span class="line">  `rows_sent` int(11) NOT NULL,</span><br><span class="line">  `rows_examined` int(11) NOT NULL,</span><br><span class="line">  `db` varchar(512) NOT NULL,</span><br><span class="line">  `last_insert_id` int(11) NOT NULL,</span><br><span class="line">  `insert_id` int(11) NOT NULL,</span><br><span class="line">  `server_id` int(10) unsigned NOT NULL,</span><br><span class="line">  `sql_text` mediumtext NOT NULL,</span><br><span class="line">  `thread_id` bigint(21) unsigned NOT NULL</span><br><span class="line">) ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT=&apos;Slow log&apos;</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>显示该表的引擎为CSV，对大数据量下的查询效率不高，可将其转换为MyISAM引擎并在start_time列上添加索引，但是已经启动了慢查询修改会报错，而且更改后会对数据库造成额外的开销。</p><p>参数log_output指定了慢查询输出的格式，默认为FILE，指定为TABLE即可将其输出到mysql架构下的slow_log表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_output&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_output</span><br><span class="line">        Value: FILE</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数<code>log_output</code>是动态全局的。</p><p>InnoSQl版本加强了对于SQL语句的捕获方式，在原版MySQL数据库的基础上在slow log中增加了对于物理读取（physical reads：从磁盘进行IO读取的次数）和逻辑读取（logic reads：所有的读取，无论磁盘还是缓冲池）的统计。可通过参数<code>long_query_io</code>将超过指定逻辑IO次数的SQL语句记录到slow log中，默认为100。为兼容原MySQL数据库的运行方式，还添加了参数<code>slow_query_type</code>用来表示启用slow log的方式，可选：</p><ul><li>0 表示不将SQL语句记录到slow log</li><li>1 表示根据运行时间将SQL语句记录到slow log</li><li>2 表示根据逻辑IO次数将SQL语句记录到slow log</li><li>3 表示根据运行时间及逻辑IO次数将SQL语句记录到slow log </li></ul><h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p>记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行，默认文件名为：主机名.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%general%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: general_log</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: general_log_file</span><br><span class="line">        Value: /usr/local/mysql/data/wuhua.log</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>本地没有开启查询日志。同slow log，v5.1开始可将查询日志放入mysql架构下的general_log表中。</p><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>binary log记录了对MySQL数据库执行更改的所有操作，不包括SELECT和SHOW这类操作。</p><p>作用：</p><ul><li>恢复：某些数据的恢复需要需要二进制日志。例如再一个数据库全备文件恢复后，可通过二进制日志进行ponit-in-time的恢复。</li><li>复制：原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般为slave或standby）与一台MySQL数据库（一般为master或primary）进行实时同步。</li><li>审计：可通过审计判断是否有对数据库进行注入的攻击。</li></ul><p>通过配置参数log-bin [=name]启动二进制日志，不指定name则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号，所在路径为数据库所在目录。</p><p>默认没启动，需要手动指定参数启动。影响二进制日志记录的信息和行为：</p><ul><li>max_binlog_size：指定单个二进制日志文件的最大值，超过该值产生新的二进制日志文件，后缀名加1，并记录到index文件。</li><li>binlog_cache_size：使用事务表存储引擎时，未提交的二进制日志会被记录到一个缓冲中去，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，缓冲的大小由binlog_cache_size决定，默认为32k。基于session，当一个线程开启事务时会分配一个大小为binlog_cache_seze的缓存，若一个事务的记录大于设定的binlog_cache_size，会将缓冲中的日志写入一个临时文件。可通过<code>SHOW GLOBAL STATUS</code>查看<code>binlog_cache_use</code>和<code>binlog_cache_disk_use</code>的状态判断当前的设置是否合适，前者记录使用缓冲写二进制日志的次数，后者记录使用临时文件写二进制日志的次数。</li><li>sync_binlog：表示每写缓冲多少次就同步到磁盘。值1表示采用同步写磁盘的方式来写二进制日志，但是若在事务发出commit之前发生宕机，此时二进制日志写入文件，但是提交还没有发生，在启动恢复时由于二进制日志已经记录了该事务信息，不能被回滚，可通过将参数innodb_support_xa设为1解决，能同时保证二进制日志和InnoDB存储引擎数据文件的同步；默认0。若使用InnoDB存储引擎进行复制，并且想得到最大的高可用行，建议将该值设置为ON。</li><li>binlog-do-db和binlog-ignore-db：表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</li><li>log-slave-update：若当前DB是复制中的slave角色，不会将从master取得并执行二进制日志写入自己的二进制日志文件中去，若需要写入则需设置log-slave-update。若搭建master=&gt;slave=&gt;slave架构的复制则必须设置该参数。</li><li>bin_format：二进制日志的格式。MySQL v5.1前无此参数，格式基于SQL语句级别，存在问题：若在主服务器上运行rand、uuid等函数或者使用触发器会导致主从服务器上表中数据的不一致；因为二进制日志文件格式的关系默认事务隔离级别为REPEATABLE READ，若使用READ COMMITTED的事务隔离级别会出现丢失更新的现象，出现主从数据库上的数据不一致。</li></ul><p>v5.1开始引入参数bin_format可设STATEMENT、ROW和MIXED。</p><ol><li>STATEMENT格式和之前的版本一样，二进制文件记录的是日志的逻辑SQL语句。</li><li>ROW格式下，二进制日志记录表的行更改情况，对Statement格式下的复制问题予以解决，若设置bin_format为ROW，可将InnoDB的事务隔离级别设为READ COMMITTED，以获得更好的并发行。</li><li>MIXED格式下，默认采用STATEMENT格式进行二进制日志文件的记录，但在一些情况下会使用ROW格式，可能有：<ul><li>表的存储引擎为NDB，对表的DML操作都会以ROW格式记录。</li><li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数。</li><li>使用了INSERT DELAY语句。</li><li>使用了用户定义函数（UDF）</li><li>使用了临时表（temeporary table）</li></ul></li></ol><p>binlog_format参数对于存储引擎的限制：</p><table><thead><tr><th style="text-align:center">存储引擎</th><th style="text-align:center">Row格式</th><th style="text-align:center">Statement格式</th></tr></thead><tbody><tr><td style="text-align:center">InnoDB</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MyISAM</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">HEAP</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MERGE</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">NDB</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">Archive</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">CSV</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Federate</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Blockhole</td><td style="text-align:center">N</td><td style="text-align:center">Y </td></tr></tbody></table><p>通常将参数binlog_format设置为ROW，可为数据库的恢复和复制带来更好的可靠性。有些语句下的ROW格式可能需要更大的容量，会带来二进制文件大小的增加。由于复制是采用传输二进制日志方式实现，复制的网络开销也有所增加。</p><p>二进制日志文件需要通过MySQL提供的工具mysqlbinlog工具查看。</p><p><a href="https://juejin.im/post/5a72c2daf265da3e5234d879" target="_blank" rel="noopener">腾讯工程师带你深入解析 MySQL binlog</a></p><h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3><p>UNIX系统下可采用UINX域套接字方式连接本地MySQL，需要一个套接字文件。</p><p>可由参数socket控制，一般在/tmp目录下，名为mysql.sock。</p><h3 id="pid-文件"><a href="#pid-文件" class="headerlink" title="pid 文件"></a>pid 文件</h3><p>MySQL实例启动时，会将进程ID写入一个文件——该文件即为pid文件，可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &apos;pid_file&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: pid_file</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.pid</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h3><p>MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储是根据表进行，每个表都有与之对应的文件。无论表采用何种引擎，都有一个以frm为后缀名的文件，记录了该表的表结构定义。frm文件还用来存放视图的定义，文件为文本文件。</p><p>查看时发现文件内容像加密过，一查果然，参考<a href="http://mysql.taobao.org/monthly/2018/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 表空间加密</a></p><h3 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h3><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>InnoDB采用存储的数据按表空间（tablespace）进行存放的设计，默认配置下会有一个初始大小为10M名为ibdata1的文件，其为默认的表空间文件，可通过参数innodb_data_file_path对其进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=datafile_spec1[;datafile_spec2]...</span><br></pre></td></tr></table></figure><p>可通过多个文件组成一个表空间文件，同时制定文件的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = /db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure><p>意味着将/db/ibdata1和/dr2/db/ibdata2两个文件用来组成表空间，大小都为2000MB，若用完可自动增长。若位于不同的磁盘上，磁盘的负载可能被平均，提高数据库的整体性能。</p><p>设置该参数后，所有基于InnoDB的表的数据都会记录到该共享表空间中，若设置了参数<code>innodb_file_pre_table</code>，则用户可以将每个基于InnoDB存储引擎的产生一个独立表空间，命令规则为：表名.idb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_file_per_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login</span><br><span class="line">total 1424</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.6K  8 16  2018 jobs.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  8 16  2018 jobs.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.5K  7 26  2018 user_profiles.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   128K  7 27  2018 user_profiles.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   100B  7 18 16:11 users.MYD</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   2.0K  7 24 09:58 users.MYI</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 18 15:55 users.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    13K  7 18 15:48 users_old.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   176K  7 18 15:48 users_old.ibd</span><br></pre></td></tr></table></figure><p>单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>默认情况下InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。记录了InnoDB存储引擎的事务日志。</p><p>当实例或介质失败（media failure）时，InnoDB存储引擎会根据重做日志恢复到掉电前的时刻，以此来保证数据的完整性。</p><p>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。可设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。</p><p>影响重做日志文件的属性：</p><ul><li>innodb_log_file_size：指定每个重做日志文件的大小，InnnoDB v1.2.x前总大小小于等于4GB，v1.2.x将限制扩大为512GB。</li><li>innodb_log_files_in_group：指定日志文件组中重做日志文件的数量，默认为2。</li><li>innodb_mirrored_log_groups：指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像。若磁盘本身已做了高可用方案，如磁盘列阵，则可以不开启重做日志镜像的功能。</li><li>innodb_log_group_home_dir：指定了日志文件组所在的路径，默认为./，表示在MySQL数据库的数据目录下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data</span><br><span class="line">Password:</span><br><span class="line">total 390208</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    56B  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   559B  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    76M  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    12M  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql   224B  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql   512B  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql   2.4K  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1.4M  8 19 13:43 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql     3B  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql   2.8K  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql   3.4K  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql   160B 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   135K  8 13 17:50 wuhua.err</span><br></pre></td></tr></table></figure><p>重做日志文件设置过大会导致恢复需要很长的时间，太小会导致一个事务需要多次切换重做日志文件。此外太小会导致频繁地发生async checkpoint，导致性能的抖动。</p><p>二进制日志记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志，InnoDB存储引擎的重做日志只记录有关该存储引擎本身的事务日志。二进制日志记录的是关于一个事务的具体操作内容，该日志是逻辑日志，InnoDB存储引擎的重做日志记录的是关于每个页的更改的物理情况。二进制日志文件仅在事务提交前进行提交，只写磁盘一次，不论该事务多大，在事务进行的过程中，不断有重做日志被写入到重做日志文件中。</p><p>到InnoDB v1.2.x版本为止，共定义了51种重做日志类型，基本格式相同：</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo_log_body</th></tr></thead><tbody><tr><td style="text-align:center">占用1字节，表示重做日志的类型</td><td style="text-align:center">表示表空间的ID，采用压缩的方式，占用空间可能小于4字节</td><td style="text-align:center">表示页的偏移量，采用压缩的方式</td><td style="text-align:center">表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析</td></tr></tbody></table><p>从重做日志缓冲往磁盘写入时按照512个字节（一个扇区）的大小进行写入，因为扇区是写入的最小单位，可以保证写入必定是成功的。重做日志的写入过程中不需要有doublewrite。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>控制在提交时，处理重做日志的方式：</p><ul><li>0 ：表示当事务提交时，不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</li><li>1 ：执行commit时将重做日志缓冲同步写到缓存中，伴有fsync的调用。</li><li>2 ：表示将重做日志异步写到磁盘，即写到文件系统的缓存中，不能完全保证执行commit时肯定会写入重做日志文件，只是有这个动作发生。</li></ul><p>为保证ACID中的持久性，必须将innodb_flush_log_at_trx_commit设为1，即每档事务提交时就必须确保事务已经写入重做日志文件，当数据库意外宕机时可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。设为0或2时，都有可能发生恢复时部分事务的丢失，但是设置为2若MySQL数据库宕机而操作系统及服务器没有宕机时，由于此时为写入磁盘的事务日志保存在文件系统缓冲中，恢复时同样能保证数据不丢失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB存储引擎表的各种类型文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数文件：告知MYSQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，介绍各种参数的类型。&lt;/li&gt;
&lt;li&gt;日志文件：记录MySQL实例对某种条件做出响
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="file" scheme="bighua.top/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-命令</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2019/04/06/Docker学习-命令/</id>
    <published>2019-04-06T08:07:44.000Z</published>
    <updated>2019-04-29T06:59:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><p>EXAMPLES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">//绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h4 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h4><p>docker start :启动一个或多个已经被停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker stop :停止一个运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker restart :重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">//停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">//重启容器myrunoob</span><br><span class="line"></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>docker kill :杀掉一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-s :向容器发送一个信号</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//杀掉运行中的容器mynginx</span><br><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>docker rm ：删除一个或多少容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">//移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line">//删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h4 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h4><p>docker pause :暂停容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker unpause :恢复容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//暂停数据库容器db01提供服务。</span><br><span class="line">docker pause db01</span><br><span class="line"></span><br><span class="line">//恢复数据库容器db01提供服务。</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>docker create ：创建一个新的容器但不启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>同<code>docker run</code><br>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>docker exec ：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">//在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>docker ps : 列出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//列出所有在运行的容器信息</span><br><span class="line">wuhua:blog wuhua$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>####inspect<br>docker inspect : 获取容器/镜像的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li><li>-s :显示总的文件大小。</li><li>–type :为指定类型返回JSON。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取镜像mysql:5.6的元信息</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">//获取正在运行的容器mymysql的 IP</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>docker attach :连接到正在运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><p>docker events : 从服务器获取实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示docker 2016年7月1日后的所有事件</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">//显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</span><br></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p><p>OPTIONS:</p><ul><li>-f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>-t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">//查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :将输入内容写到文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure><p>###容器rootfs命令</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>docker commit :从容器创建一个新的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>docker cp :用于容器与主机之间的数据拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-L :保持源目标中的链接</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">//将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>docker diff : 检查容器里文件结构的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看容器mymysql的文件结构更改。</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><h4 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h4><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker logout [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-u :登陆的用户名</li><li>-p :登陆的密码</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">//登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :拉取所有 tagged 镜像</li><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从Docker Hub下载java最新版镜像。</span><br><span class="line">docker pull java</span><br><span class="line">//从Docker Hub下载REPOSITORY为java的所有镜像。</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>docker search : 从Docker Hub查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–automated :只列出 automated build类型的镜像；</li><li>–no-trunc :显示完整的镜像描述；</li><li>-s :列出收藏数不小于指定值的镜像。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:blog wuhua$ docker search -s 10 java</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                         Node.js is a JavaScript-based platform for s…   7238                [OK]                </span><br><span class="line">tomcat                                       Apache Tomcat is an open source implementati…   2333                [OK]                </span><br><span class="line">java                                         Java is a concurrent, class-based, and objec…   1967                [OK]                </span><br><span class="line">openjdk                                      OpenJDK is an open-source implementation of …   1599                [OK]                </span><br><span class="line">ghost                                        Ghost is a free and open source blogging pla…   951                 [OK]                </span><br><span class="line">anapsix/alpine-java                          Oracle Java 8 (and 7) with GLIBC 2.28 over A…   402                                     [OK]</span><br><span class="line">jetty                                        Jetty provides a Web server and javax.servle…   294                 [OK]                </span><br><span class="line">couchdb                                      CouchDB is a database that uses JSON for doc…   269                 [OK]                </span><br><span class="line">ibmjava                                      Official IBM® SDK, Java™ Technology Edition …   67                  [OK]                </span><br><span class="line">groovy                                       Apache Groovy is a multi-faceted language fo…   66                  [OK]                </span><br><span class="line">tomee                                        Apache TomEE is an all-Apache Java EE certif…   64                  [OK]                </span><br><span class="line">lwieske/java-8                               Oracle Java 8 Container - Full + Slim - Base…   43                                      [OK]</span><br><span class="line">cloudbees/jnlp-slave-with-java-build-tools   Extends cloudbees/java-build-tools docker im…   25                                      [OK]</span><br><span class="line">zabbix/zabbix-java-gateway                   Zabbix Java Gateway                             16                                      [OK]</span><br><span class="line">frekele/java                                 docker run --rm --name java frekele/java        13                                      [OK]</span><br><span class="line">davidcaste/alpine-java-unlimited-jce         Oracle Java 8 (and 7) with GLIBC 2.21 over A…   11                                      [OK]</span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>docker images : 列出本地镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID.</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">//列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure><h4 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h4><p>docker rmi : 删除本地一个或多少镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制删除本地镜像runoob/ubuntu:v4。</span><br><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>docker tag : 标记本地镜像，将其归入某一仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>docker build 命令用于使用 Dockerfile 创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–build-arg=[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label=[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置/dev/shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line">//使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">//通过 -f Dockerfile 文件的位置</span><br><span class="line"> docker build -f /path/to/a/Dockerfile .</span><br><span class="line">//在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回</span><br><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>docker history : 查看指定镜像的创建历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-H :以可读的格式打印镜像大小和日期，默认为true；</li><li>–no-trunc :显示完整的提交记录；</li><li>-q :仅列出提交记录ID。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>docker save : 将指定镜像保存成 tar 归档文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :输出到的文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>docker import : 从归档文件中创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-c :应用docker 指令创建镜像；</li><li>-m :提交时的说明文字；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info [OPTIONS]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-11T12:27:47.5699614Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>docker version :显示 Docker 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器生命周期管理&quot;&gt;&lt;a href=&quot;#容器生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;容器生命周期管理&quot;&gt;&lt;/a&gt;容器生命周期管理&lt;/h3&gt;&lt;h4 id=&quot;run&quot;&gt;&lt;a href=&quot;#run&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
      <category term="命令" scheme="bighua.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
