<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2019-08-16T06:38:04.691Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InnoDB存储引擎源代码的编译和调试</title>
    <link href="bighua.top/2019/08/16/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>bighua.top/2019/08/16/InnoDB存储引擎源代码的编译和调试/</id>
    <published>2019-08-16T06:30:31.000Z</published>
    <updated>2019-08-16T06:38:04.691Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>性能调优</title>
    <link href="bighua.top/2019/08/16/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>bighua.top/2019/08/16/性能调优/</id>
    <published>2019-08-16T06:27:16.000Z</published>
    <updated>2019-08-16T06:36:31.868Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="majorization" scheme="bighua.top/tags/majorization/"/>
    
  </entry>
  
  <entry>
    <title>备份与恢复</title>
    <link href="bighua.top/2019/08/16/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>bighua.top/2019/08/16/备份与恢复/</id>
    <published>2019-08-16T06:26:59.000Z</published>
    <updated>2019-08-16T06:35:19.706Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="backup" scheme="bighua.top/tags/backup/"/>
    
      <category term="recovery" scheme="bighua.top/tags/recovery/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="bighua.top/2019/08/16/%E4%BA%8B%E5%8A%A1/"/>
    <id>bighua.top/2019/08/16/事务/</id>
    <published>2019-08-16T06:26:40.000Z</published>
    <updated>2019-08-16T06:34:34.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="transaction" scheme="bighua.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="bighua.top/2019/08/16/%E9%94%81/"/>
    <id>bighua.top/2019/08/16/锁/</id>
    <published>2019-08-16T06:26:28.000Z</published>
    <updated>2019-08-16T06:33:07.778Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="lock" scheme="bighua.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>索引与算法</title>
    <link href="bighua.top/2019/08/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>bighua.top/2019/08/16/索引与算法/</id>
    <published>2019-08-16T06:26:19.000Z</published>
    <updated>2019-08-16T06:38:42.428Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="index" scheme="bighua.top/tags/index/"/>
    
      <category term="alg" scheme="bighua.top/tags/alg/"/>
    
  </entry>
  
  <entry>
    <title>表</title>
    <link href="bighua.top/2019/08/16/%E8%A1%A8/"/>
    <id>bighua.top/2019/08/16/表/</id>
    <published>2019-08-16T06:26:08.000Z</published>
    <updated>2019-08-16T06:31:46.197Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="table" scheme="bighua.top/tags/table/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="bighua.top/2019/08/16/%E6%96%87%E4%BB%B6/"/>
    <id>bighua.top/2019/08/16/文件/</id>
    <published>2019-08-16T06:20:30.000Z</published>
    <updated>2019-08-16T06:25:51.731Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="file" scheme="bighua.top/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-命令</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2019/04/06/Docker学习-命令/</id>
    <published>2019-04-06T08:07:44.000Z</published>
    <updated>2019-04-29T06:59:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><p>EXAMPLES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">//绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h4 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h4><p>docker start :启动一个或多个已经被停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker stop :停止一个运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker restart :重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">//停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">//重启容器myrunoob</span><br><span class="line"></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>docker kill :杀掉一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-s :向容器发送一个信号</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//杀掉运行中的容器mynginx</span><br><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>docker rm ：删除一个或多少容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">//移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line">//删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h4 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h4><p>docker pause :暂停容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker unpause :恢复容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//暂停数据库容器db01提供服务。</span><br><span class="line">docker pause db01</span><br><span class="line"></span><br><span class="line">//恢复数据库容器db01提供服务。</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>docker create ：创建一个新的容器但不启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>同<code>docker run</code><br>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>docker exec ：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">//在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>docker ps : 列出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//列出所有在运行的容器信息</span><br><span class="line">wuhua:blog wuhua$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>####inspect<br>docker inspect : 获取容器/镜像的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li><li>-s :显示总的文件大小。</li><li>–type :为指定类型返回JSON。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取镜像mysql:5.6的元信息</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">//获取正在运行的容器mymysql的 IP</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>docker attach :连接到正在运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><p>docker events : 从服务器获取实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示docker 2016年7月1日后的所有事件</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">//显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</span><br></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p><p>OPTIONS:</p><ul><li>-f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>-t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">//查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :将输入内容写到文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure><p>###容器rootfs命令</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>docker commit :从容器创建一个新的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>docker cp :用于容器与主机之间的数据拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-L :保持源目标中的链接</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">//将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>docker diff : 检查容器里文件结构的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看容器mymysql的文件结构更改。</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><h4 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h4><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker logout [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-u :登陆的用户名</li><li>-p :登陆的密码</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">//登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :拉取所有 tagged 镜像</li><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从Docker Hub下载java最新版镜像。</span><br><span class="line">docker pull java</span><br><span class="line">//从Docker Hub下载REPOSITORY为java的所有镜像。</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>docker search : 从Docker Hub查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–automated :只列出 automated build类型的镜像；</li><li>–no-trunc :显示完整的镜像描述；</li><li>-s :列出收藏数不小于指定值的镜像。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:blog wuhua$ docker search -s 10 java</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                         Node.js is a JavaScript-based platform for s…   7238                [OK]                </span><br><span class="line">tomcat                                       Apache Tomcat is an open source implementati…   2333                [OK]                </span><br><span class="line">java                                         Java is a concurrent, class-based, and objec…   1967                [OK]                </span><br><span class="line">openjdk                                      OpenJDK is an open-source implementation of …   1599                [OK]                </span><br><span class="line">ghost                                        Ghost is a free and open source blogging pla…   951                 [OK]                </span><br><span class="line">anapsix/alpine-java                          Oracle Java 8 (and 7) with GLIBC 2.28 over A…   402                                     [OK]</span><br><span class="line">jetty                                        Jetty provides a Web server and javax.servle…   294                 [OK]                </span><br><span class="line">couchdb                                      CouchDB is a database that uses JSON for doc…   269                 [OK]                </span><br><span class="line">ibmjava                                      Official IBM® SDK, Java™ Technology Edition …   67                  [OK]                </span><br><span class="line">groovy                                       Apache Groovy is a multi-faceted language fo…   66                  [OK]                </span><br><span class="line">tomee                                        Apache TomEE is an all-Apache Java EE certif…   64                  [OK]                </span><br><span class="line">lwieske/java-8                               Oracle Java 8 Container - Full + Slim - Base…   43                                      [OK]</span><br><span class="line">cloudbees/jnlp-slave-with-java-build-tools   Extends cloudbees/java-build-tools docker im…   25                                      [OK]</span><br><span class="line">zabbix/zabbix-java-gateway                   Zabbix Java Gateway                             16                                      [OK]</span><br><span class="line">frekele/java                                 docker run --rm --name java frekele/java        13                                      [OK]</span><br><span class="line">davidcaste/alpine-java-unlimited-jce         Oracle Java 8 (and 7) with GLIBC 2.21 over A…   11                                      [OK]</span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>docker images : 列出本地镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID.</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">//列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure><h4 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h4><p>docker rmi : 删除本地一个或多少镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制删除本地镜像runoob/ubuntu:v4。</span><br><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>docker tag : 标记本地镜像，将其归入某一仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>docker build 命令用于使用 Dockerfile 创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–build-arg=[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label=[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置/dev/shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line">//使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">//通过 -f Dockerfile 文件的位置</span><br><span class="line"> docker build -f /path/to/a/Dockerfile .</span><br><span class="line">//在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回</span><br><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>docker history : 查看指定镜像的创建历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-H :以可读的格式打印镜像大小和日期，默认为true；</li><li>–no-trunc :显示完整的提交记录；</li><li>-q :仅列出提交记录ID。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>docker save : 将指定镜像保存成 tar 归档文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :输出到的文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>docker import : 从归档文件中创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-c :应用docker 指令创建镜像；</li><li>-m :提交时的说明文字；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info [OPTIONS]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-11T12:27:47.5699614Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>docker version :显示 Docker 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器生命周期管理&quot;&gt;&lt;a href=&quot;#容器生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;容器生命周期管理&quot;&gt;&lt;/a&gt;容器生命周期管理&lt;/h3&gt;&lt;h4 id=&quot;run&quot;&gt;&lt;a href=&quot;#run&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
      <category term="命令" scheme="bighua.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-安装配置</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>bighua.top/2019/04/06/Docker学习-安装配置/</id>
    <published>2019-04-06T07:50:07.000Z</published>
    <updated>2019-04-11T12:33:14.177Z</updated>
    
    <content type="html"><![CDATA[<p>mac环境桌面版</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ brew search docker</span><br><span class="line">==&gt; Formulae</span><br><span class="line">docker                                   docker-machine-completion</span><br><span class="line">docker-clean                             docker-machine-driver-hyperkit</span><br><span class="line">docker-cloud                             docker-machine-driver-vultr</span><br><span class="line">docker-completion                        docker-machine-driver-xhyve</span><br><span class="line">docker-compose                           docker-machine-nfs</span><br><span class="line">docker-compose-completion                docker-machine-parallels</span><br><span class="line">docker-credential-helper                 docker-squash</span><br><span class="line">docker-credential-helper-ecr             docker-swarm</span><br><span class="line">docker-gen                               docker2aci</span><br><span class="line">docker-ls                                dockerize</span><br><span class="line">docker-machine</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">docker                                   homebrew/cask-versions/docker-edge</span><br><span class="line">docker-toolbox</span><br><span class="line">wuhua:src wuhua$ brew cask install docker</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/31259/Docker.dmg</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask &apos;docker&apos;.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App &apos;Docker.app&apos; to &apos;/Applications/Docker.app&apos;.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure><p>点<code>访达</code>边的<code>启动台</code> 可看到下载好的桌面版docker，点击启动按步骤操作输入密码授权</p><p>配置后启动查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Error response from daemon: Bad response from Docker engine</span><br><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 51</span><br><span class="line"> System Time: 2019-04-06T07:47:49.465200315Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><p>第一次<code>docker info</code>查询失败是因为未启动完毕。</p><p>关于docker命令参考<a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></p><p>关于设置docker国内镜像参考<a href="https://www.cnblogs.com/anliven/p/6218741.html" target="_blank" rel="noopener">Docker国内镜像</a></p><p>关于其他系统Doker安装参考<a href="http://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">MacOS Docker 安装</a></p><p>关于<code>brew</code>和<code>brew cask</code>参考<a href="https://blog.csdn.net/yanxiaobo1991/article/details/78455908" target="_blank" rel="noopener">mac brew和brew cask的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac环境桌面版&lt;/p&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="bighua.top/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>bighua.top/2019/02/02/2018年终总结/</id>
    <published>2019-02-01T17:19:30.000Z</published>
    <updated>2019-02-04T17:17:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。</p><h3 id="上半年-大学毕业"><a href="#上半年-大学毕业" class="headerlink" title="上半年-大学毕业"></a>上半年-大学毕业</h3><p>从17年11月份确定毕设课题开始，毕设导师就开始积极联系我们进行相关课题的研究工作。可能是由于导师也是第一年回校园工作，对之前的毕设流程不了解，对我们的要求可以说是有点太过严谨。在10月末确定工作签好三方后，本想去公司实习一段时间，了解公司和相关技术，但是导师以毕设为由，建议将毕设弄差不多后再去实习。</p><p>17年末，过的很轻松，结束掉了大学最后的几门课程考试。这段时间， 每天基本睡到自然醒，中午一点多去梦泽园吃顿饭，回宿舍打游戏，晚上玩手机熬夜到很晚，第二天循环如此。这一段时间，应该是大学过的最爽的一段时间，不用再顾虑学习，确定好了工作，混吃等死。每天重复的事情——打游戏、睡觉、一切其他感兴趣的事情。有点遗憾是经济不支持，没能实现出去旅游四处走走的心愿。有点不爽的是，考试结束本来可以回家的，导师要求留校十天，进行毕设课题相关的工作。其实这十天完全没做多少毕设相关的工作，大多数时间依旧堕落的生活。放假前的例会，发给我们相关软硬件，让我们回家摸索。然而，春节期间谁会想到这玩意呢，怎么样带回去，再怎么样的带回来，再在例会前几天突击了解一下。</p><p>春节期间，由于工作的<code>理想工资</code>，自己快有点飘了，在各个房产软件上查看洛阳、信阳等各处楼盘的信息，心里决定一定要靠自己买到理想的、位置合适的一套房子。现在想想，当时的想法还有点太遥远，想要去实现，还远得很。</p><p>18年开学，晚来了一周多，如果不是导师要求例会，完全不想再返回学校。到学校后，发现很多同学已经开始或打算去实习了，这时有个换毕设课题的机会，跟与学校合作的企业去开发<code>养猪</code>项目，当作毕设课题，当时爽妈还建议我一起报，可以想着搞定毕设去公司实习，拒绝了，结合后来苦逼的毕设过程、没能够去公司实习、看他们<code>养猪</code>玩的不亦乐乎，简直想抽自己两巴掌，后悔得要死。后来18年大四最后一学期的前几个月——3月中旬至五月中旬——就如前面所说。每天在导师给找的办公室里做毕设相关——看资料、翻译、看源代码、记录，枯燥无聊。四月初感觉毕设做的差不多了想去实习，联系hr后反馈没有实习名额了，然后<code>养猪</code>的同学四处游山玩水，简直心里不爽到极点。不爽的最后也是有些收获的，阅读项目底层C语言源码，收获有一些，在18年的一篇日志中有些记录，这里就不重记了。到5月中旬，毕设论文准备的差不多了，就趁二姐回家，回家过了半个月，陪可爱的外甥女玩，很是惬意开心。6月初返校，修修改改准备最后的论文终稿、答辩PPT，10号答辩顺利通过，其实感觉我是通过的最顺利的一个，整个过程不到5分钟，没有安全相关的老师，没问什么问题，对做的工作进行了一些了解性提问，最后甚至还有个老师想要推优我的毕设论文。还好最终没推优，省去了一些麻烦事。作为一条咸鱼，已经不对大学再抱有任何幻想，只想着顺利毕业结束这不怎么样的四年。</p><p>这半年沉寂了N久的和尚之心也随着与李老师的几次会面交流在18年春天有了一些蠢蠢欲动，也是在枯燥的毕设过程中多了一些点缀。但是毕竟多年修炼有素，内心抑制住了，对于没有把握的事情不再轻易尝试。在四月时，自己曾一人骑着小蓝车再一次逛了一遍校园。从图书馆出发，骑到24节气看观赏的游客，骑到油菜田拍一片金黄、骑过基本建成养猪厂、骑过坟场前面旁边开的鲜花正盛的小户人家、骑过柳树随着春风摇曳着枝条的南湖边、骑过情侣经常约会的小树林、起过吐槽了四年的环湖跑路线、起过茶叶地、骑过种满各种花卉和作物的研究圆、起过二运篮球场旁边开满紫色小花的小树林、骑到清真食堂再感受一遍不怎么喜欢的饭菜最终还是照旧选择了炒饭，最后在慢慢走回去，体验这最后的悠闲时光。六月中旬班级毕业晚饭到毕设典礼以及最后的毕业离校时间，其实还是挺想留下来感受下这最后的相聚时光的，虽然回家过端午节并送二姐回家是提前离校原因之一，但是更过的原因是不想再见那些隔阂了很久的同学，想早点逃离这不爽快的生活。</p><p>总的来说，18年的上半年，生活的主要节奏是毕设，心中住进的人在毕设枯燥的生活中增添了一些别样色彩，可爱的外甥女，毕设离别。在技术上，学习了go的一点皮毛，复习一些c相关的东西，遗忘了PHP。</p><h3 id="下半年-参入工作"><a href="#下半年-参入工作" class="headerlink" title="下半年-参入工作"></a>下半年-参入工作</h3><p>拿到小强寄回的毕业证后，迟迟不想离家，想在家多待几天，定的火车票也很晚，直到日期到达不得不收拾行李开始北漂生活。六月二十八下午到北京，出站后马上办理了一卡通，先坐地铁去上班的地方看了一眼，拍了一张北大的竺可桢大楼，由于之前没租好房，然后立刻拖着行李开始去附近找中介看房子，然后这附近的房子符合心里价位预期的不是小就是破旧，最终没能定下，看完房子吃完晚饭差不多六点了，才开始考虑宾馆的事情。这个时候才开始去美团上看附近的青旅，基本上家家都爆满了。最后花了100多大洋找到一家<code>招待所</code>，直到七绕八绕问了路人才找到这家在地下二层的<code>招待所</code>。是的，地下室，很多间，里面住着不少人，看着有晾晒衣服的，其中不少工作服，例如交通协助员服、清洁工服等，虽然这里并没有阳关。里面用的公用的洗漱间和卫生间，有点高中公共卫生间的感觉，但是要比那糟糕多了，这里没有阳光，通气靠中央空调，异常潮湿，老旧残破。这个地下室在中关村靠近苏州街那边，具体的位置记不太清了。那天晚上才确认到，原来还真有在这种环境中常驻生活的人的，体会到生活的不易。虽然环境差了些，但我还是睡着了，因为太困了，拖着大行李箱跑了好久。</p><p>29号早晨离开地下室、拖着行李箱开始坐四号线往南走到自如上房价相对便宜点的站点下，但一下地铁，计算下路上消耗的时间就打消了租房的念头，然后又坐四号线往北走，到安河桥北下，计算公司地铁站点到安河桥北消耗的时间。下地铁后，之前在自如上关注的房源负责的中介联系上了我，说是十六号线永丰南有房源要马上释放了，想帮我抢，这个时候拖着行李跑了老半天的我简直感动到不行，然后立刻提供了账号，可惜她并没有帮我抢到，她甚至怀疑他们内部有挂，也是很有趣。然后从安河桥北站向外面忘了几眼，合计下地铁时间，就开始重新进站，向hr推荐的十六号线上的几点地点去，根据通勤时间以及自如上的房价，最终选择了在马连洼站下，然后开始搜索附近的中介，最后拖着行李先找了链家，他们的房源与自如上的是统一的，中介也是根据需求在自如上查找，最后给推荐了一个在圆明园别墅的将要退租的房源，但是到30号才能看房。出了链家，又找了一家不远的我爱我家，才知道他们的房源与平台展示的是不同步的，给推荐了三处房源，最终选择了30号可马上入住的肖家河，思考再三签了合同，交了12500元，花了人生中最大的一笔钱。这一晚，在同是应届生的同事租好的房子里打地铺凑合了一晚，他刚好租在隔壁小区，感谢这位热心广东同事。30号早去办完交接手续，就开始布置房子，正式入住了。七月一号，和这位广东同事一起去逛了故宫，但是实在太大了，我们只走了一条线就结束了，然后骑自行经过天安门，去同事推荐的美食街吃了碗面，坐地铁回家。</p><p>七月二号，正式入职，去总部本办理入职手续，花了一上午时间，吃完午饭去办公地点，由hr领着带到每个人的小组，交给组长。我们组长帆哥再带领我们去见经理、和前端负责人打招呼，然后给我们安排工位。接着hr带领我们熟悉办公环境，介绍我们所在的组，以及生活上的日常。</p><p>七月和八月这两个月算事这半年最轻松的，跟着新人培养计划熟悉相关技术和工具，做一个内部项目，每晚都能八点左右甚至吃完晚饭后直接回去，这两个月回去后还经常再开几把lol。到了九月份开始熟悉正在开发的正式项目X，就慢慢开始忙起来了。这两个月我们组有些人事变动，七月中旬刚聚餐完，下旬组长就开始离职前的最后休假了，到了九月中旬及十月中旬，陆续又有三名同事离开。技术上完全是学习状态，虽然之前撸项目PHP用的挺多，但是也快有大半年未接触过了，这大半年都投入到毕设和了解Go上去了，其他相关的技术如mysql、nginx、redis等也是学习使用状态。</p><p>刚开始接触正式项目X，有些吃力，没有从一开始就关注这个项目，业务完全不了解，读相关产品文档、wiki、代码都有些吃力。这时正值这个正式项目第一次上线，离职同事负责的模块留下了很多待解决bug，这时他的模块交给了另一个同事，待解决bug也基本都有这位交接的同事慢慢解决完了。他带着我开始熟悉这部分的业务，从一些新增的简单接口开始，慢慢熟悉了解整个模块。这时候也大部分都是在学习状态，跟着了解业务，跟着学会排查bug，解决bug。十月下旬述职转正，可能是不适应经理的冷脸，心里总是很紧张，比笔毕设答辩时还紧张，表现很差，最后顺序转正，算是正式员工可以有绩效了。</p><p>九月到十一月还不是很忙，基本上是熟悉业务写些小接口的状态，还可以有些时间进行其他的学习。十一月过的很糟心，三叔的离世。十一月末回来后，正式开始了这半年最繁忙的两个月。</p><p>十一月时接了一个评审中的项目A，十二月开始进入开发，但是十二月上旬，同事由于有其他工作需求解决，交给了我另一个项目B。还好的是老项目逻辑可以参考，坏的是时间很紧，根据排期只有一周多的时间就要体测，没有参入评审，对很多细节不了解，也给后来埋了不少坑。这一两周每天都回去很晚，整理老项目逻辑，开发，调试，该bug。十二月初，十一月评审的项目A也正式进入排期阶段，在做项目B的同时整理项目A相关产品文档，确定需求接口，再向被人要接口要排期。同时，十二月初，之前负责的项目X需要改版，之前写的接口基本不能复用，好在接口不多，在十二月中旬花了三四天完成。完成项目X的接口后，项目A也开始进入开发阶段，同时还要排查修改项目X和项目B的相关bug，直到项目A接口交付deadline的前一天——圣诞后两天，项目A需要的10个接口还有一半未完成，而在圣诞节这天项目X改版上线，通宵到四五点才回去。睡到中午醒，立刻开始项目A未完成的接口开发，一直到交付日期五点基本开发完。这两天简直有点吃不消，一直影响到一月，脸上又开始出现很多痘痘，脸色也很不好。一开始以为项目A只有刚开始需求的十多个新接口，其他的可以复用老接口，后来发现我错了，一月份的整个工作都消耗在了老接口的调试重写上，被提N多BUG，每天在改bug、熟悉老代码逻辑、调试接口中度过。目前还有一个遗留bug未解决，需要年后继续联调。在一月中旬，接了哟哥小工具的开发工作，开始以为是一个简单的小功能，最开始的产品需求也比较简单，可是后来出现一些问题后就突然麻烦起来，虽然目前给了一个折中解决方案，年后估计还有好一整。</p><p>这半年，也和几个老同学们聚过几次，去过北京几个地儿。技术上的状态，目前仍然是学习阶段，这半年大多时间都在用php撸业务去了，上半年了解的go也基本忘差不多了。上半年住进心里的李老师，我也终于鼓起勇气直面内心了一回，希望在新的一年里能有更多时间去争取。</p><p>一会就到站了，希望自己在新的一年里一切顺利，家人身体健康～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。&lt;/p&gt;
&lt;h3 id=&quot;上半年-大学毕业&quot;&gt;&lt;a href=&quot;#上半年-大学毕业&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="bighua.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql的character_set变量</title>
    <link href="bighua.top/2019/01/25/%E5%85%B3%E4%BA%8Emysql%E7%9A%84character-set%E5%8F%98%E9%87%8F/"/>
    <id>bighua.top/2019/01/25/关于mysql的character-set变量/</id>
    <published>2019-01-25T08:08:27.000Z</published>
    <updated>2019-03-31T15:20:02.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show full columns from table_name;</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">| Field              | Type                | Collation       | Null | Key | Default | Extra          | Privileges           | Comment     |</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">...</span><br><span class="line">| user_name          | varchar(100)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ????        |</span><br><span class="line">| chapter_name       | varchar(255)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ?????       |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看数据库字符集设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;char%&apos;;</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| Variable_name            | Value                               |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| character_set_client     | latin1                              |</span><br><span class="line">| character_set_connection | latin1                              |</span><br><span class="line">| character_set_database   | utf8                                |</span><br><span class="line">| character_set_filesystem | binary                              |</span><br><span class="line">| character_set_results    | latin1                              |</span><br><span class="line">| character_set_server     | utf8                                |</span><br><span class="line">| character_set_system     | utf8                                |</span><br><span class="line">| character_sets_dir       | /usr/share/percona-server/charsets/ |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>大致感觉到原因是由于数据表相关字段字符集设置为utf8，以utf8编码存储，但是查询结果以latin1编码输出，导致汉字出现乱码。</p><p>搜索得解决办法，在查询语句中对出现乱码字段字符集编码进行转换，具体转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(unhex(hex(convert(user_name using utf8))) using latin1) as user_name,convert(unhex(hex(convert(chapter_name using utf8))) using latin1) as chapter_name</span><br></pre></td></tr></table></figure><p>最终得到正确无乱码的查询结果。</p><h3 id="各character-set变量的含义"><a href="#各character-set变量的含义" class="headerlink" title="各character_set变量的含义"></a>各character_set变量的含义</h3><p>参考博客<a href="http://www.laruence.com/2008/01/05/12.html" target="_blank" rel="noopener">深入Mysql字符集设置</a>,<br><a href="https://hk.saowen.com/a/9c46af2db75e4f83be2d3eecd0d8de1246c3a69aed5facfbebe19ad46ca2600c" target="_blank" rel="noopener">Mysql中各種與字符編碼集（character_set）有關的變量含義</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="character_set" scheme="bighua.top/tags/character-set/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/15/InnoDB存储引擎/</id>
    <published>2019-01-15T07:33:37.000Z</published>
    <updated>2019-08-16T06:33:03.699Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。</p><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池，负责工作：</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构。</li><li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li><li>重做日志（redo log）缓冲。 </li></ul><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据。将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB是多线程模型，后台有多个不同的后台线程，负责处理不同的任务。</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>使用AIO（Async IO）来处理写IO请求，提高数据库的性能。IO Thread负责这些IO请求的回调（call back）处理。InnoDB V1.0前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。Linux下IO Thread的数量不能进行调整，Win下可以通过参数<code>innodb_file_io_threads</code>来增大IO Thread。InnoDB V1.0开始，read thread和write thread分别增大到了4个，不再使用<code>innodb_file_io_threads</code>参数，分别使用<code>inodb_read_io_threads</code>和<code>innodb_write_io_threads</code>参数进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_%io_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_read_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_write_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-23 00:22:55 0x7000078ef000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 30 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3 srv_active, 0 srv_shutdown, 261512 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 261494</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 9</span><br><span class="line">OS WAIT ARRAY INFO: signal count 9</span><br><span class="line">RW-shared spins 0, rounds 9, OS waits 2</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 9.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 23555</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479475189552, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for i/o request (log thread)</span><br><span class="line">I/O thread 2 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 3 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 4 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 5 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 6 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 7 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 8 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 9 state: waiting for i/o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&apos;s:, sync i/o&apos;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">432 OS file reads, 59 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 4861558</span><br><span class="line">Log flushed up to   4861558</span><br><span class="line">Pages flushed up to 4861558</span><br><span class="line">Last checkpoint at  4861549</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 137933</span><br><span class="line">Buffer pool size   8191</span><br><span class="line">Free buffers       7760</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 42</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=94, Main thread ID=123145423732736, state: sleeping</span><br><span class="line">Number of rows inserted 90, updated 0, deleted 0, read 98</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.08 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p><code>show engine innodb status</code>观察IO Thread。读线程的ID总是小于写线程。</p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>事务被提交后，其所使用的undolog可能不再需要，需要Purge Thread回收已经使用并分配的undo页，V1.1之前，purge操作仅在InnoDB存储引擎的Master Thread中完成，V1.1开始，可以单独到独立的线程中进行，减轻Master Thread的工作，提高CPU使用率、提升存储引擎的性能。</p><p>在数据库配置文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=1</span><br></pre></td></tr></table></figure><p>来启用独立的Purge Thread。</p><blockquote><p>查看配置文件位置  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ /usr/local/mysql/bin/mysql --verbose --help |grep -A 1 &apos;Default options&apos;</span><br><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf </span><br><span class="line">wuhua:~ wuhua$ mysql --help|grep &apos;my.cnf&apos;</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>设置后重启mysql（<code>sudo /usr/local/mysql/support-files/mysql.server restart</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>V1.1即使将<code>innodb_purge_threads</code>设为大于一，启动时也会将其设为1。V1.2开始，为进一步加快undo页的回收，支持多个Purge Thread。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 4</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>于V1.2.x版本引入，为减轻原Master Thread的工作及对于用户查询线程的阻塞、进一步提高InnoDB存储引擎的性能，将之前版本中脏页的刷新操作放到单独的线程中来完成。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>InnoDB存储引擎基于磁盘存储，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。因CPU速度与磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。</p><p>数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，过程称为将页‘FIX’在缓冲池中。下一次再读取相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取页，否则读取磁盘上的页。</p><p>进行页的修改操作时，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，通过一种称为Checkpoint的机制刷新回磁盘。为提高数据库的整体性能。</p><p>缓冲池的大小直接影响着数据库的整体性能。32位系统下该值为3G，可打开操作系统的PAE选项来获得32位操作系统下最大64GB内存的支持。为使数据库使用更多的内存，建议数据库服务器采用64位操作系统。</p><p>缓存池的配置通过参数<code>innodb_buffer_pool_size</code>来设置，默认值是128M，最小5M(当小于该值时会设置成5M)，最大为LLONG_MAX。</p><p>修改前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 134217728</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 268435456</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>缓冲池中缓冲的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。索引页和数据页占缓冲池很大一部分。</p><p>从V1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。可以减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数<code>innodb_buffer_pool_instances</code>来进行设置，默认值为1，设置大于1时需保证缓冲池大小（<code>innodb_buffer_pool_size</code>）最小为1G。</p><p>设置前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>设置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=1028M</span><br><span class="line">innodb_buffer_pool_instances=2</span><br></pre></td></tr></table></figure><p>多种方式查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema</span><br><span class="line">mysql&gt; select pool_id,pool_size,free_buffers,database_pages from innodb_buffer_pool_stats\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       pool_id: 0</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40724</span><br><span class="line">database_pages: 231</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">       pool_id: 1</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40755</span><br><span class="line">database_pages: 200</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 2</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40724</span><br><span class="line">Database pages     231</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 196, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 231, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40755</span><br><span class="line">Database pages     200</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 200, created 0, written 0</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 200, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h5><p>通常数据库中的缓冲池通过LRU（Latest Recent Used）算法来进行管理。InnoDB缓冲池中页的大小默认为16KB，使用LRU算法管理。但对LRU算法做了一些优化，在LRU列表中增加了midpoint位置，新读取到的页放入到LRU列表的midpoint位置。默认配置下，该位置在LRU列表长度的5/8处。可由参数<code>innodb_old_blocks_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p>表示新读取的页插入到LRU列表尾端37%（3/8）的位置，把midpoint之后的列表称为old表，之前的列表称为new列表。引入另一个参数<code>innodb_old_blocks_time</code>进一步管理LRU列表，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 1000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">mysql&gt; set global innodb_old_blocks_time=999;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 999</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>若预估活跃的热点数据不止63%，可以在执行SQL前，通过设置<code>innodb_old_blocks_pct</code>的值减少热点页可能被刷出来的概率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_old_blocks_pct=20;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>LRU列表管理已经读取的页，当数据库刚启动时，LRU列表是空的，此时页存放在Free列表中。从缓冲池中分页时，先从Free列表中查找可用的空闲页，有则从Free列表中删除，放入到LRU列表中，否则根据LRU算法淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p><p>通过<code>show engine innodb status</code>观察LRU列表及Free列表的使用情况和运行状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-24 21:13:11 0x700007d13000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 53 seconds</span><br><span class="line">-----------------</span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Free buffers与Database pages的数量之和可能不等于Buffer pool size，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页。Buffer pool hit rate表示缓冲池命中率，小于95%需要观察是否由于全表扫描引起的LRU列表被污染问题。</p><blockquote><p>该命令显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。<code>Per second averages calculated from the last 53 seconds</code></p></blockquote><p>可通过<code>INNODB_BUFFER_PAGE_LRU</code>来观察每个LRU列表中每个页的具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where space=189;</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| table_name | space | page_number | page_type         |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| NULL       |   189 |           0 | FILE_SPACE_HEADER |</span><br><span class="line">| NULL       |   189 |           1 | IBUF_BITMAP       |</span><br><span class="line">| NULL       |   189 |           2 | INODE             |</span><br><span class="line">| NULL       |   189 |           3 | INDEX             |</span><br><span class="line">| NULL       |   189 |           4 | INDEX             |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br></pre></td></tr></table></figure><p>V1.0.x开始支持压缩页的功能，可将原本16KB的页压缩为1KB、2KB、4KB和8KB，非16KB的页，通过unzip_LRU列表进行管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure><p>LRU中的页包含了unzip_LRU列表中的页。</p><p>unzip_LRU列表中对不同压缩页大小的风进行分别管理，通过伙伴算法进行内存的分配。例如从缓冲池中申请页为4KB的大小，过程为：</p><ul><li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</li><li>若有，直接使用；</li><li>否则检查8KB的unzip_LRU列表；</li><li>若有空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</li><li>否则从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ul><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察unzip_LRU列表中的项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,compressed_size from innodb_buffer_page_lru where compressed_size&lt;&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flu</span><br></pre></td></tr></table></figure><p><code>Modified db pages</code>显示了脏页的数量。</p><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察脏页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where oldest_modification&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p><code>TABLE_NAME</code>为NULL表示该页属于系统表空间。</p></blockquote><h5 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h5><p>InnoDB存储引擎的内存区域除缓冲池外还有重做日志缓存（redo log buffer），InnoDB先将重做日志信息先放入到这个缓冲区，然后按一定的频率将其刷新到重做日志文件，一般每秒都会将重做日志缓冲刷新到日志文件，用户只需保证每秒产生的事务量在这个缓冲大小之内，不需要将其设置的很大。该值可由配置参数innodb_log_buffer_size控制，默认为8M（mac v5.7.22 默认16M）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_log_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_log_buffer_size</span><br><span class="line">        Value: 16777216</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在以下三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p><ul><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件；</li><li>每个事物提交时会将重做日志缓冲刷新到重做日志文件；</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5><p>InnoDB对内存的管理是通过堆内存（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓存（frame buffer）还有对应的缓冲控制对象（buffer control block：记录一些诸如LRU、锁、等待等信息），对象的内存需要从额外内存池中申请。在申请了很大的InnoDB缓冲池时，也应考虑相应地增加额外内存池的大小。</p><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>页的操作首先都是在缓冲池中完成的，若一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本比磁盘的新，数据库将新版本的页从缓冲池刷新到磁盘。</p><p>为避免数据丢失问题，当前事物数据库系统普遍都采用了Write Ahead Log策略，即当事物提交时，先写重做日志，再修改页。当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。事务ACID中D（Durability持久性）的要求。</p><p>Checkpoint（检查点）技术的目的：</p><ul><li>缩短数据库的恢复时间；</li><li>缓冲池不够用时，将脏数据刷新到磁盘；</li><li>重做日志不可用时，刷新脏页。</li></ul><p> 数据库发生宕机时，数据库不需要重做所有的日志，Checkpoint之前的页都已经刷新回磁盘，数据库只需对Checkpoint后的重做日志进行恢复。</p><p> 当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</p><p> 重做日志不可用的情况是因为在当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，这部分可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p> InnoDB存储引擎通过LSN（Log Sequence Number）来标记版本，LSN是8字节数字，单位是字节。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5009487</span><br><span class="line">Log flushed up to   5009487</span><br><span class="line">Pages flushed up to 5009487</span><br><span class="line">Last checkpoint at  5009478</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1。</p><p>数据库运行时在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即指刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p><p>在InnoDB存储引擎中可能发生Fuzzy Checkpoint的情况：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async/Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><p>Master Thread中发生的Checkpoint，每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。过程异步，用户查询线程不会阻塞。</p><p>FLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，在v1.1.x之前检查LRU列表中是否有足够可用空间操作发生在<br>用户查询线程中，会阻塞用户查询操作。若无100个可用空闲页，会将LRU列表尾端的页移除，若其中有脏页，则进行Checkpoint。</p><p>InnoDB v1.2.x（MySQL 5.6）开始检查被放在Page Cleaner Thread中进行，可通过参数<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认1024。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_lru_scan_depth&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_lru_scan_depth</span><br><span class="line">        Value: 1024</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>Async/Sync Flush Checkpoint指的是重做日志不可用的情况下，需要强制将一些页刷新回磁盘，此时脏页是从脏页列表中选取。将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则：</p><blockquote><p>checkpoint_age = redo_lsn - checkpoint_lsn</p><p>async_water_mark = 75% * total_redo_log_file_size</p><p>sync_water_mark = 90% * total_redo_log_file_size</p></blockquote><ul><li>checkpoint_age &lt; async_water_mark，不需要刷新任何脏页到磁盘</li><li>async_water_mark &lt; checkpoint_age &lt; sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark</li><li>checkpoint_age &gt; sync_water_mark很少发生除非设置的重做日志文件太小，在进行类似LOAD DATA的BULK INSETRT操作，触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark。</li></ul><p>Async/Sync Flush Checkpoint保证重做日志循环使用的可用性，v1.2.x之前，Async Flush Checkpoint阻塞发现问题的用户查询线程，Sync Flush Checkpoint阻塞所有用户的查询线程，并且等待脏页刷新的完成。v1.2.x开始，放入到单独的Page Cleaner Thread中。</p><p>MySQL官版不能查看刷新页是从Flush列表中还是从LRU列表中进行Checkpoint的，不知道因为重做日志而产生的Async/Sync Flush的次数。InnoSQL版本可通过命令<code>show engine innodb status</code>来观察。</p><p>Dirty Page too much Checkpoint是因为脏页数量太多，导致InnoDB存储引擎强制进行Checkpoint。目的为了保证缓冲池中有足够可用的页。可由参数<code>innodb_max_dirty_page_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_max_dirty_pages_pct&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_max_dirty_pages_pct</span><br><span class="line">        Value: 75.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>75表示缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分脏页到磁盘，InnoDB v1.0.x之前是90，之后是75。</p><h3 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h3><h4 id="InnoDB-1-0-x之前的Master-Thread"><a href="#InnoDB-1-0-x之前的Master-Thread" class="headerlink" title="InnoDB 1.0.x之前的Master Thread"></a>InnoDB 1.0.x之前的Master Thread</h4><p>具有最高的线程优先级别。内部由多个loop组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。根据数据库运行状态进行切换。</p><p>主循环有两大部分操作——每秒钟的操作和每10秒钟的操作。</p><p>每秒钟的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是），因此再大的事务提交时间也是很短的；</li><li>合并插入缓冲（可能），判断上一秒内发生的IO次数是否小于5次，若小于5次，认为当前的IO压力很小，可以住行合并插入缓冲的操作；</li><li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能），判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认90，代表90%），若超过，认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</li></ul><p>每10秒的操作：</p><ul><li>刷新100个脏页到磁盘（可能的情况下），若过去10秒内磁盘的IO操作小于200次，则认为有足够的磁盘IO能力，将100个脏个刷新到磁盘；</li><li>合并至多5个插入缓冲（总是）；</li><li>将日志缓冲刷新到磁盘（总是）；</li><li>删除无用的undo页（总是），full purge操作，每次最多尝试回收20个undo页，对表进行updae、delete操作时，原行被标记为删除，因一致性读（consistent read）需要保留这些行版本的信息，在full purge过程中，判断当前事务系统中已被删除的行是否可以删除（可能有查询操作需要读取之前版本的undo信息），若可以则立即删除；</li><li>刷新100个或10个脏页到磁盘（总是），判断缓冲池中脏页的比例（buf_get_modified_ratio_pct），若有超过70%的脏页，则刷新100个脏页到磁盘，若小于70%则只刷新10个脏页到磁盘。</li></ul><p>若当前没有用户活动（数据库空闲）或者数据库关闭（shutdown），切换到background loop，执行的操作：</p><ul><li>删除无用的undo页（总是）；</li><li>合并20个插入缓冲（总是）；</li><li>跳回到主循环（总是）；</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</li></ul><p>若flush loop中也无事可做，则切换到suspend_loop，将Master Thread挂起，等待事情的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起状态。</p><h4 id="InnoDB-1-2-x版本之前的Master-Thread"><a href="#InnoDB-1-2-x版本之前的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本之前的Master Thread"></a>InnoDB 1.2.x版本之前的Master Thread</h4><p>v1.0.x对于IO有限制，向磁盘刷新时做了一定的硬编码（刷新数固定值），限制了对磁盘IO的性能，尤其是写入性能。v1.0.x开始提供参数innnodb_io_capacity，用来表示磁盘IO的吞吐量，默认值200，对于刷新到磁盘的页的数量，按照innnodb_io_capacity的百分比来进行控制：</p><ul><li>合并插入缓冲时，合并插入缓冲的数量为innnodb_io_capacity值的5%；</li><li>从缓冲区刷新脏页到时，刷新脏页的数量为innnodb_io_capacity。</li></ul><p>参数innodb_max_dirty_pages_pct默认值为90，当内存很大，或者数据库服务的压力很大，刷新脏页的速度会降低，数据库恢复时需要更多的时间。设置过低时会增加磁盘IO压力。v1.0.x开始，默认值设置为75，和Google测试的最优值80接近。</p><p>引入参数innodb_adaptive_flushing（自适应刷新）。愿刷新规则：大于innodb_max_dirty_pages_pct时，刷新100个脏页， 否则不刷新脏页。引入后通过名为buf_flush_get_desired_flush_rate函数（通过判断产生重做日志redo log的速度来决定最合适的刷新脏页数量）判断需要刷新脏页最合适的数量。当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。</p><p>引入参数innodb_purge_batch_size，控制每次full purge回收的Undo页的数量，之前最多回收20个Undo页，该参数默认值20(用的mysql 5.7.22，默认值300)，可动态地对其进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 300</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; set global innodb_purge_batch_size=320;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 320</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可由命令<code>SHOW ENGINE INNODB STATUS</code>查看当前Master Thread的状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">...</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 2 srv_active, 0 srv_shutdown, 139324 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 139319</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="InnoDB-1-2-x版本的Master-Thread"><a href="#InnoDB-1-2-x版本的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本的Master Thread"></a>InnoDB 1.2.x版本的Master Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if InnoDD is idle</span><br><span class="line">  srv_master_do_idle_tasks(); //每10s的操作</span><br><span class="line">else </span><br><span class="line">  srv_master_do_active_tasks(); //每秒的操作</span><br></pre></td></tr></table></figure><p>刷新脏页的操作，从Master Thread线程分离到单独的Page Cleaner Thread。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>和数据页一样，是物理页的一个组成部分。</p><p>插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取，这类插入操作速度是非常快的。但并不是所有的主键插入都是顺序的，若主键是UUID类，则插入和辅助索引一样，同样是随机的。即使主键是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。</p><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作（在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><p>Insert Buffer的使用需要同时满足两个条件：</p><ul><li>索引是辅助索引（secondary index）；</li><li>索引不是唯一（unique）的。</li></ul><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看插入缓冲的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行：size代表已合并记录页的数量；free list len代表空闲列表的长度；seg size显示当前Insert Buffer的大小为14*16k；merges代表合并的次数。</p><p>写密集情况下，插入缓冲会占用过多的缓冲池内存，默认最大可占用1/2。可通过修改<code>IBUF_POOL_SIZE_PER_MAX_SIZE</code>对插入缓冲的大小进行控制。将其修改为3则最大只能使用1/3的缓冲池内存。</p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p><p>同Insert Buffer，Change Buffer适用的对象依然是非唯一的辅助索引。</p><p>对一条记录进行UPDATE操作可能分为两个过程：</p><ul><li>将记录标记为已删除；</li><li>真正将记录删除。</li></ul><p>Delete Buffer对应操作的第一个过程，Purge Buffer对应操作的第二个过程。通过参数<code>innodb_change_buffering</code>开启各种Buffer的选项，可选：inserts、deletes、purges、changes、all、none。changes表示启用inserts和deletes、all表示启用所有，none表示都不启用。</p><p>通过<code>innodb_change_buffer_max_size</code>来控制Change Buffer最大使用内存的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_change_buffer_max_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_change_buffer_max_size</span><br><span class="line">        Value: 25</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>默认值为25，表示最多使用1/4（25%）的缓冲池内存空间，最大有效值50。</p><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>insert表示Insert Buffer；delete mark表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时无需再将记录合并到辅助索引中。</p><h5 id="Insert-Buffer的内部实现"><a href="#Insert-Buffer的内部实现" class="headerlink" title="Insert Buffer的内部实现"></a>Insert Buffer的内部实现</h5><p>Insert Buffer的数据结构是一棵B+树，MySQL v4.1前每张表有一棵Insert Buffer B+树，现版本全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。存放在共享表空间中，默认ibdata1中。在试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败，因为表的辅助索引中的数据可能还在Insert Buffer中，即共享表空间中。</p><p>Insert Buffer非叶节点存放查询的search key（键值）。</p><p>search key一共占用9个字节，space表示待插入记录所在表的表空间id，InnoDB存储引擎中每个表有一个唯一的space id，可通过space id查询得知是哪张表。space占用4字节。marker占用1字节，用于兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。</p><p>当辅助索引要插入到页（space，offset）时，若页不在缓冲池中，则首先根据上述规则构造一个search key，然后查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。<br>插入到Insert Buffer B+树叶子节点的记录，需要根据规则进行构造。</p><blockquote><p>space | marker | offset | metadata |{ secondary index record}|</p></blockquote><p>metadata占用4字节，存储内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">字节 </th></tr></thead><tbody><tr><td style="text-align:center">IBUF_REC_OFFSET_COUNT</td><td style="text-align:center">2 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_TYPE</td><td style="text-align:center">1 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_FLAGS</td><td style="text-align:center">1  </td></tr></tbody></table><p>IBUF_REC_OFFSET_COUNT保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。第五列开始是实际插入记录的各个字段。</p><p>启用Insert Buffer索引后，辅助索引页中的记录可能被插入到Insert Buffer B+树中，为保证每次Merge Insert Buffer页必须成功，需要特殊页用来标记每个辅助索引页（sapce，page_no）的可用空间。该页类型为Insert Buffer Bitamp。</p><p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）。每个Insert Buffer Bitmap页在16384个页的第二个页中。</p><p>每个辅助索引页在Insert Buffer Bitmap页中占用4位，由三部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">IBUF_BITMAP_FREE</td><td style="text-align:center">2</td><td style="text-align:center">表示该辅助索引页中的可用空间数量，可取值0，1，2，3。0表示无可用剩余空间；1表示剩余空间大于1/32页（512字节）</td></tr><tr><td style="text-align:center">IBUF_BITMAP_BUFFERED</td><td style="text-align:center">1</td><td style="text-align:center">1表示该辅助索引页有记录被缓存在Insert Buffer B+树中</td></tr><tr><td style="text-align:center">IBUF_BITMAP_IBUF</td><td style="text-align:center">1</td><td style="text-align:center">1表示该页为Insert Buffer B+树的索引页</td></tr></tbody></table><h5 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h5><p>Merge Insert Buffer的操作发生在：</p><ul><li>辅助索引页被读取到缓冲池时，例如执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中，若有则将Insert Buffer B+树中该页的记录插入到该辅助索引页中；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时，若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则强制进行一个合并操作（强制读取辅助索引页），将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中；</li><li>Master Thread，每秒和每10秒进行一次的Merger Insert Buffer操作。</li></ul><p>Mater Thread根据<code>srv_innodb_io_capactity</code>的百分比来决定真正要合并多少个辅助索引页。</p><p>Insert Buffer B+ Tree中，辅助索引页根据（space，offset）都已排序好，根据（space，offset）的排序顺序进行页的选择。</p><h4 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h4><p>doublewrite保障InnoDB存储引擎数据页的可靠性。</p><p>若发生写失效，可以通过重做日志进行恢复，但重做日志记录的是对页的物理操作，若页本身已损坏，则再对其重做是无意义的。在应用重做日志之前，需要一个页的副本，当写失效发生时，先通过页的副本还原页，在进行重做，即doublewrite。</p><p>doublewrite由两部分组成：内存中的doublewrite buffer，大小为2MB；物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小为2MB。</p><p>在对缓冲池的脏页进行刷行时，并不直接写磁盘，会先通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。因为doublewrite页连续，过程是顺序写的，开销不大。完成doublewrite页的写入后，再将doublewrite buufer中的页写入各个表空间文件中，此时写入则是离散的，</p><p>通过<code>SHOW GLOBAL STATUS LIKE &#39;innodb_dblwr%&#39;</code>观察doublewrite的运行情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;innodb_dblwr%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 269936</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 26401</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>表示一共写了269936个页，实际写入次数26401，<code>Innodb_dblwr_pages_written:Innodb_dblwr_writes</code>比例10:1。若系统高峰时远小于64:1，说明系统写入压力不是很高。</p><p>若操作系统在写入磁盘过程发生崩溃，在恢复时InnoDB先从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p><p>通过命令<code>SHOW BLOBAL STATUS like &#39;Innodb_buffer_pool_pages_flushed&#39;</code>查看当前从缓冲池中刷新到磁盘页的数量。该变量和<code>Innodb_dblwr_pages_written</code>一致。MySQL 5.5.24版本之前，<code>Innodb_buffer_pool_pages_flushed</code>总是<code>Innodb_dblwr_pages_written</code>的2倍，之后才被修复，统计数据库在生产环境中写入的量，最安全的方法是根据<code>Innodb_dblwr_pages_written</code>来进行统计。</p><p>参数<code>skip_innnodb_doublewrite</code>可以禁用doublewrite功能，可能发生写失效问题，若有多个从服务器（slave server），需要提供较快的性能（在slave server上做RAID0），启用该参数是一个办法。对于需要提供数据高可用性的主服务器（master server），任何时候都应确保开启doublewrite功能。</p><p>有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统，可不用开启doublewrite。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希一般查找的时间复杂度为O(1)，B+ Tree的查找次数取决于B+ tree的高度，一般为3～4层。</p><p>InnoDB会监控对表上各索引页的查询，若观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI通过缓冲池的B+ tree构建而来，建立的速度很快，不需要对整张表构建哈希索引。InnoDB会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><p>AHI要求这个页的连续访问模式必须是一样的。如对（a，b）这样的联合索引页，访问模式可以是：</p><ul><li>WHERE a=xxx</li><li>WHERE a=xxx and b=xxx</li></ul><p>访问模式指查询条件一样，若交替上述两种查询，则不会对该页构造AHI。AHI还要求：</p><ul><li>以该模式访问了100次</li><li>页通过该模式访问了N次，其中N=页中记录*1/16</li></ul><p>启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。其为数据库自由化，可通过命令<code>SHOW ENGINE INNODB STATUS</code>查看当前AHI的使用状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 347 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1702, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">1.04 hash searches/s, 4.33 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询，如SELECT * FROM table WHERE index_col=’xxx’。其他如范围查找不能使用哈希索引。通过hash searches:non-hash searches可以了解使用哈希索引后的效率。</p><p>可通过<code>SHOW ENGINE INNODB STATUS</code>的结果及参数<code>innodb_adaptive_hash_index</code>来考虑是禁用或启动，默认AHI开启。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>用户发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，AIO。AIO可以进行IO Merge操作。</p><p>Linux通过<code>iostat</code>动态监视系统的磁盘操作活动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[work~]$ iostat -x</span><br><span class="line">Linux 2.6.32-754.9.1.el6.x86_64 08/16/2019 _x86_64_(8 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">          18.99    0.00   16.12    1.36    0.00   63.53</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.08     7.78    0.29    4.19    16.15    93.35    24.46     0.01    2.39    4.96    2.22   0.94   0.42</span><br><span class="line">vdb               4.07   405.85   10.49    7.69  2980.62  3309.01   345.87     0.72   39.40   26.06   57.61   2.08   3.78</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>InnoDB v1.1.x前，AIO通过InnoDB存储引擎中的代码来模拟实现，v1.1.x开始提供了内核级别AIO的支持，Native AIO，依赖libaio库。Native AIO需要操作系统提供支持，Win OS和Linux OS都提供Native AIO支持，Mac OSX未提供，只能使用原模拟的方式。</p><p>参数<code>innodb_use_native_aio</code>用来控制是否启用Native AIO，Linux OS下默认为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Mac OS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>InnoDB中read ahead方式的读取都是AIO完成，脏页的刷新也是通过AIO完成。</p><h4 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h4><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，若是脏页，则一起进行刷新。通过将多个IO写入操作合并为一个IO操作，在传统机械磁盘下有着显著优势。</p><p>需要考虑：</p><ul><li>将不怎么脏的页进行了写入，该页之后又会很快变成脏页；</li><li>固态硬盘有着较高的IOPS，是否需要该特性。</li></ul><p>所以从v 1.2.x版本开始提供了参数<code>innodb_flush_neighbors</code>，用来控制是否启用该特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_flush_neighbors&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_flush_neighbors</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="启动、关闭与恢复"><a href="#启动、关闭与恢复" class="headerlink" title="启动、关闭与恢复"></a>启动、关闭与恢复</h3><p>MySQL实例在启动过程中对InnoDB存储引擎的处理过程。</p><p>关闭时，参数<code>innodb_fast_shutdown</code>影响着表的存储引擎为InnoDB的行为。该参数可取0，1，2。默认1。</p><ul><li>0：在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。需要一些时间，在进行InnoDB升级时，必须将此参数设置为0，然后关闭数据库。</li><li>1:表示不需要完成full purge和merge insert buffer操作，但是缓冲池中的一些数据脏页还是会刷新回磁盘。</li><li>2:表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志写入日志文件。不会有事务的丢失，在下次MySQL数据库启动时，会进行恢复操作。</li></ul><p>若没有正常的关闭数据库，例如使用kill命令关闭数据库、MySQL运行中重启服务器，或者关闭数据库时将参数<code>innodb_fast_shutdown</code>设为2，下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数<code>innodb_force_recovery</code>影响整个InnoDB存储引擎恢复的状况，默认为0，代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机，并把错误写入错误日志。还可以设置6个非零值，大的数字表示包含了前面所有小数字表示的影响：</p><ul><li>1（SRV_FORCE_IGNORE_CORRUPT）：忽略检查到的corrupt页。</li><li>2（SRV_FORCE_NO_BACKGROUND）：阻止Master Thread线程的运行，如Master Thread线程需要进行full merge操作，会导致crash。</li><li>3（SRV_FORCE_NO_TRX_UNDO）：不进行事务的回滚操作。</li><li>4（SRV_FORCE_NO_IBUF_MERGE）：不进行插入缓冲的合并操作。</li><li>5（SRV_FORCE_NO_UNDO_LOG_SCAN）：不查看撤销日志（Undo Log），将未提交的事务视为已提交。</li><li>6（SRV_FORCE_NO_LOG_SCAN）：不进行前滚的操作。</li></ul><p>在设置了<code>innodb_force_recovery</code>大于0后，可进行select、create和drop操作，但insert、update和delete操作是不允许的。（修改表涉及到脏页的刷新、undo log等）</p><p>START TRANSACTION语句开启了事务，防止了自动提交的发生，UPDATE操作会产生大量的UNDO日志。人为通过kill命令杀掉MySQL数据库，下次MySQL数据库启动会对之前的UPDATE事务进行回滚操作，这些信息会记录在错误日志文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。&lt;/p&gt;
&lt;h3 id=&quot;InnoDB体系架构&quot;&gt;&lt;a href=&quot;#InnoDB体系架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系架构&quot;&gt;&lt;/a&gt;Inno
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构和存储引擎</title>
    <link href="bighua.top/2019/01/10/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/10/MySQL体系结构和存储引擎/</id>
    <published>2019-01-10T09:07:34.000Z</published>
    <updated>2019-01-15T07:27:51.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h3><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>实例：MySQL数据库由后台线程以及一个共享内存区组成。</li></ul><p>MySQL设计为单进程多线程架构，数据库实例在系统上表现为一个进程。</p><p>启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例，没有配置文件时，按照编译时的默认参数设置启动实例。使用<code>mysql --help | grep my.cnf</code>查看启动时从哪些位置查找配置文件。当几个配置文件都有同一个参数，MySQL数据库以读取到的最后一个配置文件中的参数为准。</p><p>配置文件参数<code>datadir</code>指定了数据库所在的路径。linux操作系统下默认为<code>/usr/local/mysql/data</code>，该路径只是一个链接，指向<code>/opt/mysql_data</code>目录，必须保证该目录的用户和权限使mysql用户和组可以访问。</p><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>MySQL组成部分：  </p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（cache）组件</li><li>插件式存储引擎</li><li><p>物理文件</p><p>区别于其他数据库的重要特点是插件式的表存储引擎。MySQL插件式存储引擎架构提供一系列标准的管理和服务支持，这些标准与存储引擎本身无关，存储引擎是底层物理结构的实现。存储引擎是基于表的，而不是数据库。</p></li></ul><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。用户可以根据MySQL预定义的存储引擎接口编写自己的存储引擎。</p><p>通过<code>SHOW ENGINES</code>语句或者通过查找<code>information_schema</code>架构下的ENGINES表，查看当前使用的MySQL数据库所支持的存储引擎。</p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，设计目标面向在线事务处理的应用。行锁设计、支持外键，支持类似Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB存储引擎将数据放在一个逻辑的表空间中，表空间由InnoDB存储引擎自身进行管理。每个InnoDB存储引擎的表单独存放到一个ibd文件中。InnoDB存储引擎支持用裸设备（row disk）来建立其表空间。</p><p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发，实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。使用被称为next-key locking策略避免幻读现象的产生。还提供了插入缓存（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p><p>InnoDB存储引擎采用聚集（clustered）的方式存储表中的数据，每张表的存储都是按主键的顺序进行存放。当没有显示的指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务，支持全文索引，表锁设计，主要面向一些OLAP数据库应用。MyISAM存储引擎的缓冲池只缓存索引文件，而不缓存数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用<code>myisampack</code>工具进一步压缩数据文件，因myisampack工具使用哈夫曼编码静态算法来压缩数据，所以压缩后的表是只读的，也可以使用myisampack工具解压数据文件。</p><p>V5.0前MyISAM默认支持的表大小为4GB，制定MAX_ROWS和AVG_ROW_LENGTH属性拓展为大于4GB的表。V5.0及以后，默认支持256TB的表单数据。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。</p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -h 127.0.0.1 -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>通过TCP/IP连接到MySQL实例时，MySQL会先检查一张权限视图，判断发起请求的客户端IP是否允许连接到MySQL实例。视图在mysql结构下，表名为<code>user</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show columns from user;</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</span><br><span class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Insert_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Update_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Delete_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Drop_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Reload_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Shutdown_priv          | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Process_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| File_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Grant_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| References_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Index_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_db_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Super_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tmp_table_priv  | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Lock_tables_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Execute_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_slave_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_client_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_view_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_view_priv         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_routine_priv    | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_routine_priv     | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_user_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Event_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Trigger_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| ssl_type               | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO   |     |                       |       |</span><br><span class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</span><br><span class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</span><br><span class="line">| password_expired       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</span><br><span class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</span><br><span class="line">| account_locked         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">45 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host,user,password_expired FROM user;</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| host      | user          | password_expired |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| localhost | root          | N                |</span><br><span class="line">| localhost | mysql.session | N                |</span><br><span class="line">| localhost | mysql.sys     | N                |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h4><p>Win 2000、Win XP、Win 2003和Win Vista以及在此之上的平台，若两个需要进程通信的进程在同一台服务器上，可以使用命名管道。MySQL数据库须在配置文件中启用–enable-named-pipe。V4.1后提供共享内存的连接方式，须在配置文件中添加–shared-memory，在连接时客户端还必须使用–protocol=memory选项。</p><h4 id="UNIX套接字"><a href="#UNIX套接字" class="headerlink" title="UNIX套接字"></a>UNIX套接字</h4><p>Linux和UNIX环境下，可以使用UNIX域套接字，因其非网络协议，只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径<code>--socket=/tmp/mysql.sock</code>。</p><p>查询UNIX域套接字文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;socket&apos;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| socket        | /tmp/mysql.sock |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用UNIX域套接字方式进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -uroot -S /tmp/mysql.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义数据库和实例&quot;&gt;&lt;a href=&quot;#定义数据库和实例&quot; class=&quot;headerlink&quot; title=&quot;定义数据库和实例&quot;&gt;&lt;/a&gt;定义数据库和实例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库：物理操作系统文件或其他形式文件类型的集合。&lt;/li&gt;
&lt;li&gt;实例：My
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战笔记</title>
    <link href="bighua.top/2018/11/19/Netty%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>bighua.top/2018/11/19/Netty实战笔记/</id>
    <published>2018-11-19T06:30:29.000Z</published>
    <updated>2018-11-19T06:35:14.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写Echo服务器"><a href="#编写Echo服务器" class="headerlink" title="编写Echo服务器"></a>编写Echo服务器</h2><h3 id="ChannelHandler和业务逻辑"><a href="#ChannelHandler和业务逻辑" class="headerlink" title="ChannelHandler和业务逻辑"></a>ChannelHandler和业务逻辑</h3><p>响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写Echo服务器&quot;&gt;&lt;a href=&quot;#编写Echo服务器&quot; class=&quot;headerlink&quot; title=&quot;编写Echo服务器&quot;&gt;&lt;/a&gt;编写Echo服务器&lt;/h2&gt;&lt;h3 id=&quot;ChannelHandler和业务逻辑&quot;&gt;&lt;a href=&quot;#Channe
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>世事无常</title>
    <link href="bighua.top/2018/11/04/%E4%B8%96%E4%BA%8B%E6%97%A0%E5%B8%B8/"/>
    <id>bighua.top/2018/11/04/世事无常/</id>
    <published>2018-11-04T12:54:26.000Z</published>
    <updated>2019-03-31T15:20:05.855Z</updated>
    
    <content type="html"><![CDATA[<p>记2018-11-04，悼念三叔！</p><p>总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无常的世界，然后一点一点平息自己的思绪，使自己接受现实，最后慢慢的消化在内心，做到不外露一点情绪！</p><p>我不敢想象老家没有你了会是怎样，高三的堂弟、初入社会心思单纯的堂妹、年迈的爷爷、指望不上的大爹家，远离老家很多事帮不上忙的我们，以后三婶在老家要承担怎样的重担渡过这些日子，想想就揪心。</p><p>如果可以在身边选择一个最适合父亲的角色，我觉得是你。只有你最关注子辈的内心，在意孩子的想法，注重子辈多方面的培养教育。对比常年在外打工只给予我生活费关怀的老爸，可以说是你，在我心目中对父亲的角色有了该有的模样。对堂弟寄予厚望的你，怎么忍心被这次意外带走，还有好多次成绩没向你汇报、还没为他操心高考后的学校和专业、还没同意他找女朋友呢…</p><p>还想着以后能再回老家过元宵节，再跟着你去认祖坟送亮；过春节中午在我家吃，然后去你家吃年夜饭；跟着你去拜年走亲戚，去看斗地主炸金花；跟着你去山里伐几颗松树用作冬天取暖的柴火，然后交给我一颗小的背回家；跟着你学习人生经验，如何处理好人和事…可是这以后都没有了，都停留在回忆里了。</p><p>中午收到老爸发过来的消息，震惊意外，不敢相信。大姐打过来的视频，猜到肯定是为了此事，不愿意接听，宁愿今天是做了一个梦，而我还没醒。直到晚上二姐多次挂过来视频，才交谈起此事，聊起话题一想起这个事实，鼻子不由自主的酸楚。</p><p>记得13年秋，我高三时，突然接到通知家里有事，在回家的车上，虽然没有任何人告知我发生了什么，但我知道肯定是我某个亲人不在了，心中异常忐忑，眼泪止不住的流。直到车停在家门口，看到一个个花圈，搭起的灵台，奶奶的遗像，此时声音也控制不住了，眼泪也肆无忌惮起来。如今是你，还有很多的事情等着你去解决去承担，怎么舍得离去，我不敢相信，也不能接受…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记2018-11-04，悼念三叔！&lt;/p&gt;
&lt;p&gt;总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="天堂安好" scheme="bighua.top/tags/%E5%A4%A9%E5%A0%82%E5%AE%89%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>Netty的核心组件</title>
    <link href="bighua.top/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>bighua.top/2018/11/02/Netty的核心组件/</id>
    <published>2018-11-02T06:42:46.000Z</published>
    <updated>2018-11-19T06:31:51.902Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《netty实战》，初识netty的一些笔记。</p><p>异步、事件驱动。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Java NIO的一个基本构造。</p><blockquote><p>代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。</p></blockquote><p>可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>一个指向已经被提供给另一个方法的方法的引用。使得后者可以调用前者。</p><p>Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interface ChannelHandler的实现处理。</p><p>当一个新的连接已经被建立，ChannelHandler的channelActive()回调方法将会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>提供了另一种在操作完成时通知应用程序的方式。可以看作是一个异步操作的结果的占位符；将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK预置的interface java.util.concurrent.Future提供的实现只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供额外的方法，使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个Netty的出站I/O操作都将返回一个ChannelFuture，它们都不会阻塞。</p><p>ChannelFuture作为一个I/O操作的一部分返回。connect()方法将会直接返回，而不会阻塞，调用将会在后台完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"></span><br><span class="line">ChannelFuture future = Channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));</span><br></pre></td></tr></table></figure><p>利用ChannelFutureListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));异步连接到远程节点</span><br><span class="line">future.addListener(new ChannelFutureListener() &#123;//注册一个ChannelFutureListener，在操作完成时获得通知</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;//检查操作的状态</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="事件和ChannelHandler"><a href="#事件和ChannelHandler" class="headerlink" title="事件和ChannelHandler"></a>事件和ChannelHandler</h4><p>Netty使用不同的事件来通知状态的改变或者是操作的状态。能够基于已经发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据流转换；</li><li>流控制；</li><li>应用程序逻辑。</li></ul><p>Netty的事件是按照它们与入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：</p><ul><li>连接已被激活或者连接失活；</li><li>数据读取；</li><li>用户事件；</li><li>错误事件。</li></ul><p>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：</p><ul><li>打开或者关闭到远程节点的连接；</li><li>将数据写到或者冲刷到套接字。</li></ul><p>每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法（将事件驱动范式直接转换为应用程序构件块）。</p><p> Netty的ChannelHandler为处理器提供了基本的抽象。每个ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="Future、回调和ChannelHandler"><a href="#Future、回调和ChannelHandler" class="headerlink" title="Future、回调和ChannelHandler"></a>Future、回调和ChannelHandler</h4><p>Netty异步编程模型建立在Future和回调之上，将事件派发到ChannelHandler的方法发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，需要提供回调或者利用操作所返回的Future。</p><h4 id="选择器、事件和EventLoop"><a href="#选择器、事件和EventLoop" class="headerlink" title="选择器、事件和EventLoop"></a>选择器、事件和EventLoop</h4><p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来将需要手动编写的派发代码。在内部，会为每个Channel分配一个EventLoop，用以处理所有事件，包括：</p><ul><li>注册感兴趣的事件；</li><li>将事件派发给ChannelHandler；</li><li>安排进一步的动作。</li></ul><p>EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。此设计消除了可能有的在ChannelHandler实现中需要进行同步的任何顾虑，只需专注于提供正确的逻辑，用来在感兴趣的数据要处理的时候执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读《netty实战》，初识netty的一些笔记。&lt;/p&gt;
&lt;p&gt;异步、事件驱动。&lt;/p&gt;
&lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Channel
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>web服务</title>
    <link href="bighua.top/2018/10/12/web%E6%9C%8D%E5%8A%A1/"/>
    <id>bighua.top/2018/10/12/web服务/</id>
    <published>2018-10-12T06:41:00.000Z</published>
    <updated>2019-03-31T15:20:08.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h3><blockquote><p>一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互操作机器间交互提供支持。每个web服务都拥有一套自己的接口，由一种名为Web服务描述语言的机器可处理格式描述。其他系统需要根据Web服务的描述，适用SOAP消息与Web服务交互。SOAP消息常被序列化为XML并通过HTTP传输。</p></blockquote><p>存在着多种不同类型的Web服务，其中包括基于SOAP的、基于REST的以及基于XML-RPC的，基于REST的和基于SOAP的Web服务最为流行。企业级系统大多数都是基于SOAP的Web服务实现，公开可访问的Web服务更青睐基于REST的Web服务。</p><p>基于SOAP的Web服务由功能驱动，基于REST的Web服务由数据驱动。基于SOAP的Web服务往往是RPC风格；基于REST的Web服务关注的是资源，HTTP方法是对这些资源执行操作的动词。</p><h3 id="基于SOAP的Web服务"><a href="#基于SOAP的Web服务" class="headerlink" title="基于SOAP的Web服务"></a>基于SOAP的Web服务</h3><p>SOAP（Simple Object Access Protocol：简单对象访问协议）是一种协议，用于交换定义在XML里面的结构化数据。能够跨越不同的网络协议并在不同的编程模式中使用，其处理的并不是对象，已经不再代表Simple Object Access Protocol。</p><p>SOAP高度结构化，需要严格地进行定义，用于传输数据的XML可能会变的非常复杂。WSDL是客户端与服务器之间的契约，定义了服务提供的功能以及提供这些功能的方式，服务的每个操作以及输入/输出都需要由WSDL明确地定义。</p><p>SOAP将报文内容放入到信封里面，信封相当于一个运输容器，并且它还能够独立于实际的数据传输方式存在。</p><p>经过简化的SOAP请求报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /GetComment HTTP/1.1</span><br><span class="line">Host: www.chitchatcom</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.chitchat.com/forum&quot;&gt;</span><br><span class="line">&lt;m:GetCommentRequest&gt;</span><br><span class="line">&lt;m:CommentId&gt;123&lt;/m:CommentID&gt;</span><br><span class="line">&lt;/m:GetCommentRequest&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>简化后的SOAP响应报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3/org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">&lt;m:GetCommentResponse&gt;</span><br><span class="line">&lt;m:Text&gt;Hello World!&lt;/m:Text&gt;</span><br><span class="line">&lt;/m:GetCommentResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:envelope&gt;</span><br></pre></td></tr></table></figure><p>SOAP 1.2允许通过HTTP的Get方法发送SOAP报文，但大多数基于SOAP的Web服务都是通过HTTP的POST方法发送SOAP报文的。</p><p>一个基于SOAP的Web服务越复杂，对应的WSDL报文就越冗长。实际中SOAP请求报文通常会由WSDL生成的SOAP客户端负责生成，SOAP响应报文通常也是由WSDL生成的SOAP服务器负责生成。</p><h3 id="基于REST的Web服务"><a href="#基于REST的Web服务" class="headerlink" title="基于REST的Web服务"></a>基于REST的Web服务</h3><p>REST（Representational State transfer，具象状态传输）是一种设计理念，用于设计通过标准的几个动作来操纵资源，并以此来进行互相交流的程序（将操纵资源的动作称为“动词”，即verb）。</p><p>REST并不把函数暴露为可调用的服务，而是以资源（resource）的名义把模型暴露出来，允许通过少数几个称为动词的动作来操纵这些资源。</p><p>使用HTTP协议实现REST服务，URL将用于表示资源，HTTP方法则会用作操纵资源的动词。如表所示：</p><table><thead><tr><th style="text-align:left">HTTP方法</th><th style="text-align:left">作用</th><th style="text-align:left">使用实例</th></tr></thead><tbody><tr><td style="text-align:left">POST</td><td style="text-align:left">在一项资源尚未存在的情况下创建该资源</td><td style="text-align:left">POST /users</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">获取一项资源</td><td style="text-align:left">GET /users/1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">重新给定URL上的资源</td><td style="text-align:left">PUT /users/1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除一项资源</td><td style="text-align:left">DELETE /users/1</td></tr></tbody></table><p>POST和PUT的区别在于，PUT需要准确地知道哪一项资源将会被替换，使用POST只会创建出一项新资源以及一个新的URL。POST用于创建一项全新的资源，PUT用于替换一项已经存在的资源。</p><p>REST不经只能通过这几个HTTP方法实现，如可以使用PATCH方法对一项资源进行部分更新。使用REST API的时候通常都是返回JSON，或者返回一些比SOAP报文要简单得多的XML，很少返回SOAP报文。</p><p>基于REST的Web服务也拥有相应的WADL（Web Applicaton Description Language，Web应用描述语言），可以对基于REST的Web服务进行描述，能够生成访问这些服务的客户端。</p><p>REST设计理念适用于只执行简单的CURD操作的应用，适用于更为复杂的服务可以通过如下两个方法对过程或者动作进行建模。</p><h4 id="将动作转化为资源"><a href="#将动作转化为资源" class="headerlink" title="将动作转化为资源"></a>将动作转化为资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /user/123/activation HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;data&quot;:&quot;2018-10-13T17:12:12Z&quot; &#125;</span><br></pre></td></tr></table></figure><p>将创建一个被激活的资源（activation resource），表示用户的激活状态，可以为激活的资源添加额外的属性。</p><h4 id="将动作转换为资源的属性"><a href="#将动作转换为资源的属性" class="headerlink" title="将动作转换为资源的属性"></a>将动作转换为资源的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH /user/123 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;active&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>把用户的active属性设置为true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web服务&quot;&gt;&lt;a href=&quot;#web服务&quot; class=&quot;headerlink&quot; title=&quot;web服务&quot;&gt;&lt;/a&gt;web服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="web服务" scheme="bighua.top/tags/web%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOAP" scheme="bighua.top/tags/SOAP/"/>
    
      <category term="REST" scheme="bighua.top/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>jenkins初探</title>
    <link href="bighua.top/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/"/>
    <id>bighua.top/2018/10/08/jenkins初探/</id>
    <published>2018-10-08T11:33:45.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档<a href="https://www.kancloud.cn/louis1986/jenkins/481896" target="_blank" rel="noopener">Jenkins学习文档</a>，<a href="https://blog.csdn.net/sms15732621690/article/details/71336224" target="_blank" rel="noopener">CentOS7Jenkins安装</a></p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget http://soft.51yuki.cn/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo vim /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_131/</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib.tools.jar</span><br><span class="line">PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  sudo sh /etc/profile.d/jdk.sh</span><br><span class="line">[wuhua@VM_0_10_centos local]$ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>浏览器中输入<code>ip:8080</code></p><p>获取登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>参考<a href="https://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文档&lt;a href=&quot;https://www.kancloud.cn/louis1986/jenkins/481896&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins学习文档&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="持续集成" scheme="bighua.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="jenkins" scheme="bighua.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>redis-整数集合</title>
    <link href="bighua.top/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>bighua.top/2018/09/13/redis-整数集合/</id>
    <published>2018-09-13T13:42:03.000Z</published>
    <updated>2018-10-30T11:56:56.983Z</updated>
    
    <content type="html"><![CDATA[<p>是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>是redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>由intset.h/intset结构表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">unint32_t encoding;//编码方式</span><br><span class="line">unint32_t length;//集合包含的元素数量</span><br><span class="line">int8_t contents[];//保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，数组中各项按值从小到大排列，且数组中不包含重复项。</p><p>length属性记录整数集合包含的元素数量，即contents数组的长度。</p><p>contents数组的真正类型取决于encoding属性的值。</p><p>根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>将新元素添加到整数集合里面且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后将新元素添加到整数集合里面。</p><p>升级过程：</p><ul><li>根据新元素的类型，拓展整数集合底层数组的空间大小，并未新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置上，在放置的过程中维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组中。</li></ul><p>引发升级的新元素的长度总是比整数集合现在所有元素的长度都大，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。前者将新元素放置在底层数组的最开头（索引0），后者将新元素放置在底层数组的最末尾（索引length-1）。</p><blockquote><p>升级策略能提升整数集合的灵活性，尽可能地节约内存。</p></blockquote><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><p>整数集合操作API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">intsetNew</td><td style="text-align:left">创建一个新的压缩列表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetAdd</td><td style="text-align:left">将给定元素添加到整数集合里</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetRemove</td><td style="text-align:left">从整数集合中移除给定元素</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetFind</td><td style="text-align:left">检查给定值是否存在于集合</td><td style="text-align:left">O(logN)，二分查找法</td></tr><tr><td style="text-align:left">intsetRandom</td><td style="text-align:left">从整数集合中随机返回一个元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetGet</td><td style="text-align:left">取出底层数组在给定索引上的元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetLen</td><td style="text-align:left">返回整数集合包含的元素的个数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetBlobLen</td><td style="text-align:left">返回整数集合占用的内存字节数</td><td style="text-align:left">O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="intset" scheme="bighua.top/tags/intset/"/>
    
  </entry>
  
</feed>
