<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2018-04-11T10:27:38.737Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang学习（语法基础笔记）</title>
    <link href="bighua.top/2018/04/10/Golang%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%89/"/>
    <id>bighua.top/2018/04/10/Golang学习（语法基础笔记）/</id>
    <published>2018-04-10T07:24:09.000Z</published>
    <updated>2018-04-11T10:27:38.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本词法"><a href="#基本词法" class="headerlink" title="基本词法"></a>基本词法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h4 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h4><blockquote><p>1.基本数据类型名称。<br>2.接口类型error。<br>3.常量true、false和iota。<br>4.所有内建函数的名称，即append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、peintln、real和recover。</p></blockquote><h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>由一个下划线_表示。一般用在不需要引入一个新邦定的声明中。例如在代码中存在一个变量x，但是却不存在对它的使用。这样的代码会使编译器报错。在变量x的声明代码后添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = x</span><br></pre></td></tr></table></figure></p><p>可以绕过编译器检查，使它不产生任何编译错误。因为x在此处被使用到，但是对x未进行任何操作。在导入声明中，当我们只想执行一下某个代码包中的初始化函数，而不需要使用这个代码包中的任何程序实体的时候，可以编写导入语句为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;runtime/cgo&quot;</span><br></pre></td></tr></table></figure></p><p>引入了这个代码包所需的所有操作，没有绑定到一个具体的名称上，在当前的源码文件中，我们无法对这个代码包中的任何程序实体进行调用。<br>以上，”_”会导致赋值或导入操作的相关准备工作的进行。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-程序声明-："><a href="#1-程序声明-：" class="headerlink" title="1. 程序声明 ："></a>1. 程序声明 ：</h4><pre><code>&gt; import、package</code></pre><h4 id="2-程序实体声明和定义："><a href="#2-程序实体声明和定义：" class="headerlink" title="2. 程序实体声明和定义："></a>2. 程序实体声明和定义：</h4><pre><code>&gt;chan、const、func、interface、map、struct、type、var</code></pre><h4 id="3-程序流程控制："><a href="#3-程序流程控制：" class="headerlink" title="3. 程序流程控制："></a>3. 程序流程控制：</h4><pre><code>&gt;go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><p>用于表示基础数据类型值的各种字面量。基本数据类型。</p><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><p> 用于构造各种自定义的符合数据类型的类型字面量。自定义数据类型如结构体。</p><h4 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h4><p> 用于表示符合数据类型的值的符合字面量。会被用来构造类型Struct结构体、Array(数组)、Slice(切片)、Map(字典)的值。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="基本类型（预定义类型）："><a href="#基本类型（预定义类型）：" class="headerlink" title="基本类型（预定义类型）："></a>基本类型（预定义类型）：</h4><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、complex64、complex128</p></blockquote><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型:"></a>复合类型:</h4><blockquote><p>Array(数组)、Struct(结构体)、Function(函数)、Interface(接口)、Slice(切片)、Map(字典)、Channel(通道)、Pointer(指针)</p></blockquote><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型:"></a>静态类型:</h4><blockquote><p>在变量声明中示出的类型。动态类型，在运行时与改变量绑定在一起的实际类型，实际类型可以是实现了这个接口的任何类型。接口类型的变量既拥有静态类型，也有动态类型。接口类型的变量的动态类型可以在执行期间变化，但是变量的静态类型永远只能是它声明时被指定的那个类型。</p></blockquote><h4 id="潜在类型"><a href="#潜在类型" class="headerlink" title="潜在类型:"></a>潜在类型:</h4><blockquote><p>每一个类型都会有一个潜在类型，若是预定义类型或者由类型字面量构造的符合类型，潜在类型就是它自身。</p></blockquote><p>可以用type声明自定义类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">type iString MyString</span><br><span class="line">type MyStrings [3]string</span><br></pre></td></tr></table></figure></p><p>可以把MyString看作string类型的一个别名类型，MyStrings、iString和MyString的潜在类型都是string。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="与C语言基本一致。新增："><a href="#与C语言基本一致。新增：" class="headerlink" title="与C语言基本一致。新增："></a>与C语言基本一致。新增：</h4><blockquote><p>&amp;^     按位清除操作，即根据第二个操作数的二进制值对第一个操作数的二进制值进行相应的清零操作。二元操作符，属于算术操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 7       &amp;^ 13       = 2</span><br><span class="line">00000111 &amp;^ 00001101 = 00000010</span><br><span class="line">      00000111</span><br><span class="line">&amp;^    00001101</span><br><span class="line">=     00000010</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>&lt;- 接收操作，一元操作符，属于接收操作符。只作用于通道类型的值。对于通道ch，表达式&lt;-的含义是从此通道中接收一个值。前提是通道的方向必须允许接收操作，并且该操作的结果的类型必须与通道元素的类型之间存在可赋予的关系。这个表达式会被阻塞直到通道中有一个值可用。<br>需要注意：</p><ul><li>从一个通道类型的空值（即nil）接收值的表达式将会永远阻塞.</li><li>从一个已经被关闭的通道类型值接收值会永远成功并且立即返回一个其元素类型的零值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">v,ok  = &lt;-ch</span><br><span class="line">v,ok := &lt;-ch</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>“=”用于将一个值赋给一个已被声明的变量或常量，”:=”用于在声明一个变量的同时对这个变量进行赋值，”:=”只能在函数体内使用。v1，v2，v用于接收值，ok为布尔类型的值，代表了接收操作的成功与否，可用来判断一个通道是否被关闭了，为false时表明通道已经关闭。</p></blockquote><p>操作符优先级：</p><blockquote><p>5      * / % &lt;&lt; &gt;&gt; &amp; &amp;^<br>4     + - | ^<br>3      == !=  &lt;  &lt;=  &gt;  &gt;=<br>2     &amp;&amp;<br>1     ||</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="1-基本表达式"><a href="#1-基本表达式" class="headerlink" title="1. 基本表达式"></a>1. 基本表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[2]</span><br><span class="line">int(v1) + v2</span><br><span class="line">len(v3)</span><br><span class="line">x.f</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3]</span><br><span class="line">interface&#123;&#125;(num).(int)</span><br><span class="line">os.Open(&quot;/etc/profile&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-选择符号和选择表达式"><a href="#2-选择符号和选择表达式" class="headerlink" title="2. 选择符号和选择表达式"></a>2. 选择符号和选择表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.f      ##深度0</span><br><span class="line">x.f.f2   ##深度1</span><br></pre></td></tr></table></figure><blockquote><p>规则</p><ul><li>对于一个类型T或者对应的指针类型*T的值x，表达式x.f表示类型T的最浅深度（即深度0）的字段或者方法。前提是：T不能是接口类型；类型T必须要有名称为f的字段或者方法。</li><li>对于一个接口类型I的变量x，表达式x.f表示赋给x的那个值(实现了接口类型I的那个类型的值)的方法f。如果接口类型I的方法法集合中不包含名称为f的方法，那么选择表达式x.f非法。<br>其它情况</li><li>如果x是一个与某个构体类型对应的指针类型的变量，并且它的值为nil，那么针对表达式x.f的赋值和求值都会引起一个运行时的恐慌。不论f是字段还是方法。</li><li>如果x是一个接口类型的变量且它的值为nil，那么针对表达式x.f的调用和求值都会引起一个运行时恐慌，前提是f是该接口类型的一个方法。</li></ul></blockquote><p>自动解引用：如果x是一个结构体类型对应的指针类型的值，那么x.f就是表达式(<em>x).f的一个速记法，不论f代表的是一个字段还是一个方法，如果f代表了一个字段且也是一个与结构体类型对应的指针类型，那么x.f.f2就是表达式(</em>(*x.f).f2的一个速记法，不论f2是一个字段还是方法。</p><h4 id="3-索引符号和索引表达式"><a href="#3-索引符号和索引表达式" class="headerlink" title="3. 索引符号和索引表达式"></a>3. 索引符号和索引表达式</h4><p>一个索引表达式有一个基本表达式和一个索引符号组成，形如a[x]，会求索引值为x的a中的那个元素的值。</p><blockquote><p>规则</p><ul><li>a不是字典类型的值，x必须是一个int类型或者无类型的证书字面量，x大于0且小于a的长度。否则引起一个与越界有关的运行时的恐慌。</li><li>a是一个数组类型A的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个切片S类型的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个字符串类型T的变量，x必须在a的长度的有效范围内，a[x]表示字符串a中索引值为x对应的那个字节类型值。不能对a[x]进行赋值操作，字符串类型值是不能改变的。</li><li>a是一个字典类型M的变量，x的类型必须是可以赋值给M的键的类型，即键x的类型可以通过类型推断符号判定为M的键的类型。a[x]表示a中的、与键x对应的那个值，且a[x]的类型与字典M的元素的类型相同。若a为nil或者其中不包含以x为键的键值对，那么a[x]的求值结果就会是字典M的元素的类型的零值。通过赋值语句<br>v,ok := a[x]<br>判断是因为上方原因导致的零值还是与键x对应的值本身就是这个零值。ok为true表示赋值成功，原本就是零值，为false则表明由上方情况引起。当a为nil时对a[x]赋值会引起一个运行时恐慌。</li></ul></blockquote><h4 id="4-切片符号和切片表达式"><a href="#4-切片符号和切片表达式" class="headerlink" title="4. 切片符号和切片表达式"></a>4. 切片符号和切片表达式</h4><p>切片符号可以是操作字符串、数组、数组的指针以及切片类型的值。<br>对于这样一个类型的值a，切片表达式为a[x:y:z]。<br>x代表元素下界索引，y代表元素上界索引，z代表切片的容量上界索引。<br>有如下约束：</p><blockquote><p>0 &lt;= 元素下界索引 &lt;= 元素上界索引 &lt;= 容量上界索引 &lt;= 操作对象的容量  </p></blockquote><p>若不满足，则在表达式求值时造成一个越界错误并引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3] = []int&#123;2,3&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[3:] = []int&#123;1,2,3,4,5&#125;[3:5] = []int&#123;4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[:3] = []int&#123;1,2,3,4,5&#125;[0:3] = []int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></p><p>若a代表的是一个切片类型的值，那么表达式a[:]就等同于复制a所代表的值并将其作为此表达式的求值结果。否则表达式a[:]就意味着有一个包含了指向a的第一个元素的指针的切片类型值被创建。</p><h4 id="5-类型断言"><a href="#5-类型断言" class="headerlink" title="5. 类型断言"></a>5. 类型断言</h4><p>对于一个求值结果为接口类型值表达式x和一个类型T，对应的类型断言为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure></p><p>用于判断“x不为nil且存储在其中的值是T类型的”这一假设是否成立。如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致，即为关于“类型T是否为x的动态类型”的判断。  类型T必须是x的一个实现类型，x必须是一个接口类型的值。<br>int(123).(int)引发编译错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid type assertion: 123.(int)(non-interface type int on left )</span><br></pre></td></tr></table></figure></p><p>即表达式int(123)的求值结果是int类型，而int类型并不是一个接口类型。将表达式改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;(123).(int)</span><br></pre></td></tr></table></figure></p><p>则会顺利通过编译，表达式interface{}(123)将字面量123转换为interface{}类型的值。interface{}是一个特殊的接口类型，代表空接口，所有类型都是他的实现类型。<br>如果T不是一个接口类型且类型T不是x的类型的一个实现，那么类型断言x.(T)就是失败的，会引发一个运行时恐慌。</p><blockquote><p>只有在程序运行期间，x的动态类型才能够被获知，而在编译期间能够确定的只有T所代表的类型。  </p></blockquote><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v,ok := x.(T)</span><br><span class="line">``` </span><br><span class="line">断言成功v为已经被转换为T类型的表达式x的求值结果，否着为类型T的零值。ok可以判断断言是否成功，此时类型断言失败也不会引发运行时恐慌。</span><br><span class="line">#### 6. 调用</span><br><span class="line">如果由函数类型F的值f，表达式f(a1,a2,a3)表达了对函数f的调用，同时以a1、a2和a3作为参数传递给函数f。  </span><br><span class="line">方法是函数的一种，比函数多了一个接收者。接收者可以是该方法所属的结构体类型的值，或者与该结构体类型对应的那个指针类型的值。</span><br><span class="line">&gt;在求值一个表达式、赋值语句或者返回语句中包含的操作数的时候，所有的函数调用、方法调用和通信调用都会按照从左到右的顺序被求值。</span><br><span class="line">```code</span><br><span class="line">a := 10</span><br><span class="line">f := func()int&#123; a = a*2;return 5&#125;</span><br><span class="line">x := []int&#123;a,f()&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中，x的值可能是[]int{10,5},也可能是[]int{20,5}。（有待考证</p><h4 id="7-可变长参数"><a href="#7-可变长参数" class="headerlink" title="7. 可变长参数"></a>7. 可变长参数</h4><p>如果函数f可以接受的参数的数量是不固定的，那么函数f就是一个能够接受可变长参数的函数，简称为可变参函数。<br>在可变函数的参数列表的最后总会出现一个可变长参数，这个可变长参数的类型声明形如…T。用于接受数量不定但类型均为T或其实现类型的参数值。等同于一个元素类型为T的切片类型的参数。对于函数f的每一次调用，被传递给可变长参数的值实际上都是包含了实际参数、元素类型为T的切片类型值。对可变参函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func appendIfAbsent(s []string,t ...string)[]string</span><br></pre></td></tr></table></figure></p><p>可以这样编写针对他的调用表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,&quot;C&quot;,&quot;N&quot;,&quot;E&quot;)</span><br></pre></td></tr></table></figure></p><p>其中，与可变长参数t绑定的切片类型值为[]string{“C”,”B”,”E”}。<br>可以直接把一个类型T的切片类型值赋给…T类型的可变长参数，需要在欲赋予可变长参数的那个切片类型值的后面追加…。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,[]string&#123;&quot;C&quot;,&quot;B&quot;,&quot;E&quot;&#125;...)</span><br></pre></td></tr></table></figure></p><p>若有元素类型为string的切片类型的变量s，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,s...)</span><br></pre></td></tr></table></figure></p><p>此时可变长参数t的值就是变量s的值，即不会专门创建于个切片类型值来存储其中的实际参数。</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、<br> complex64、complex128  </p></blockquote><p> 分为三类：</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><pre><code>&gt;bool：true、false</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><h5 id="特殊rune："><a href="#特殊rune：" class="headerlink" title="特殊rune："></a>特殊rune：</h5><blockquote><p>类型rune的值由rune类型字面量代表，专用于存储经过Unicode编码的字符。<br>    一个rune常量即是一个Unicode编码值，使用十六进制表示法来表示与Unicode对应的数字值，并使用“U+”作为前缀。<br>    一个rune字面量由外层的单引号和内层的一个或多个字符组成，在包裹字符的单引号中不能出现单引号“’”和换行符“\n”。    </p></blockquote><h5 id="可以用5种方式来表示一个rune字面量："><a href="#可以用5种方式来表示一个rune字面量：" class="headerlink" title="可以用5种方式来表示一个rune字面量："></a>可以用5种方式来表示一个rune字面量：</h5><ol><li>该rune字面量所对应的字符。如：’a’、’-‘，字符必须是Unicode编码规范所支持。</li><li>使用“\x”为前导并后跟两位十六进制数。可以表示宽度为一个字皆的值，即一个ASCII编码值。<ol start="3"><li>使用“\”为前导并后跟三位八进制数。宽度限制为一个字皆，只能用于表示对应数值在0和255之间的值。</li></ol></li><li>使用“\u”为前导并后跟四位十六进制数。只能用于表示两个字节宽度的值，为Unicode编码规范中的UCS-2表示法。</li><li><p>使用“\U”为前导并后跟八位十六进制数。为Unicode编码规范中的UCS-4表示法。为Unicode编码规范和相关国际标准中的规范编码格式。  </p><p>rune字面量可以支持转义符，有固定的几个，在规定之外的以“\”为前导的字符序列都是不合法的，转义符“\””也不能出现在rune字面量中。</p></li></ol><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串的长度即是底层字节序列中字节的个数，一个字符串常量的长度在编译期间就能够确定。<br>字符串代表了一个连续的字符序列，每一个字符都会被隐含地以Unicode编码规范的UTF-8编码个是编码为若干字节。<br>字符串字面量的两种表示格式：原生字符串字面量和解释型字符串字面量。    </p><blockquote><p>原生字符串字面量在两个反引号“`”之间的字符序列。在反引号之间，除了反引号之外的其他字符都是合法的，两个反引号之间的所有内容都看作是这个原生字符串字面量的值，其内容由在编译期间就可以确定的字符（非解释型字符）组成。原生字符串字面量中，不存在任何转义字符，所有内容都是所见即所得，也包括换行符。原生字符串字面量中的回车符会被编译器移除。    </p></blockquote><blockquote><p>解释型字符串字面量是被两个双引号“””包含的字符序列。解释型字符串中的转义字符都会被成功转义。在解释型字符串字面量中，转义符“\’”是不合法的，而转义字符“\””却是合法的，与rune字面量相反。在字符串字面量中可以包含rune字面量。  </p></blockquote><p>字符串字面量与rune字面量的本质区别是在于他们所代表的Unicode字符的数量上。</p><blockquote><p>字符串值是不可变的，不可能改变一个字符串的内容，对字符串的操作只会返回一个新字符串，而不是改变原字符串并返回</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个数组就是一个由若干个相同类型的元素组成的序列。    </p><h4 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1. 类型表示法"></a>1. 类型表示法</h4><p> 声明要指明长度和元素类型<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[n]T  ##[非负整数字面量]元素类型</span><br><span class="line">[2*3*4]byte</span><br><span class="line">[5]struct&#123;name,address string&#125; ##自定义匿名结构体类型</span><br></pre></td></tr></table></figure></p><h4 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2. 值表示法"></a>2. 值表示法</h4><p>值由符合字面量表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125; </span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;.&quot;, 5:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;2:&quot;I&quot;, 1:&quot;am&quot;, 5:&quot;a&quot;, 4:&quot;loser&quot;, 0:&quot;.&quot;, 3:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;5:&quot;I&quot;, 0:&quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;&quot;, 5:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;1:&quot;I&quot;, &quot;am&quot;, 4:&quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;1:&quot;I&quot;, 2:&quot;am&quot;, 3:&quot;&quot;, 4:&quot;a&quot;, 5:&quot;loser&quot;&#125;</span><br><span class="line"></span><br><span class="line">[...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[4]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">``` </span><br><span class="line">* 默认第一个元素值对应索引值0，之后的每个元素值的索引值都是在前一个元素值的索引值的基础上再加1，可以显示的指定索引值。</span><br><span class="line">* 在数组中未指定的元素将会被填充为元素类型的零值，可以通过显示地指定索引值来改变被填充元素值的位置。</span><br><span class="line">* 用特殊标记“...”替换为数组长度，意为并不显示地指定数组值的长度，而让Go语言编辑器为我们计算该值所包含的元素值的数量并以此确定这个长度的值。可以避免由于指定的长度和元素值的实际数量不相符而导致的多于零值元素或编译错误。</span><br><span class="line">&gt;0 &lt;= 索引值 &lt; 数组长度  </span><br><span class="line">指定的索引值不能与其他元素值的索引值重复，不论其他元素值的索引值是隐含对应的还是显示对应的。  </span><br><span class="line">####  3. 属性和基本操作  </span><br><span class="line">使用函数len计算数组值长度</span><br><span class="line">```code</span><br><span class="line">len([...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot; &#125;)</span><br></pre></td></tr></table></figure></p><p>通过索引值访问元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;[0] =&gt; &quot;bighua&quot;</span><br></pre></td></tr></table></figure></p><p>通过索引值改变对应元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array1 := [...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array1[0] = &quot;cocowh.github&quot;</span><br><span class="line">array1[2] = &quot;io&quot;</span><br></pre></td></tr></table></figure></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>Slice可以看作是Array的一种包装形式，是针对其底层包装数组中某个连续片段的描述苻，包装的数组称为该切片的底层数组。</p><h4 id="类型表示法"><a href="#类型表示法" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>由一对中间没有任何内容的方括号和代表其元素类型的标识符组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]T</span><br></pre></td></tr></table></figure></p><p>长度并不是切片类型的一部分，不会出现在表示切片类型的类型字面量中，切片的长度是可变的，相同类型的切片值可能会有不同的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]rune</span><br><span class="line">[]struct&#123;name,department string&#125;</span><br></pre></td></tr></table></figure></p><p>切片类型声明中的元素类型可以是任意一个有效的Go语言数据类型。</p><h4 id="值表示法"><a href="#值表示法" class="headerlink" title="值表示法"></a>值表示法</h4><p>切片的零值为nil，在初始化之前，一个切片类型的变量值为nil。</p><blockquote><p>切片值的长度为其所含的元素值的实际数量，使用函数len获取切片值的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len([]string&#123;4:&quot;bighua&quot;, 2: &quot;.&quot;,  &quot;com&quot;&#125;)  ##= 5</span><br></pre></td></tr></table></figure></p></blockquote><p>在切片类型的零值（即nil）上应用内建函数len将会得到0。</p><blockquote><p>一个切片一旦被初始化，就会与一个包含了其中元素值的数组相关联，即一个切片值总会持有一个对某个数组值的引用。</p></blockquote><p>多个切片值可能会共用同一个底层数组。把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的值，这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对其底层数组上的对应元素的修改，作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片之上。切片值类似于指向底层数组的指针。  </p><blockquote><p>切片值的容量是其能够访问到的当前底层数组中的元素值的最大数量，即从其中的指针指向的那个元素值到底层数组的最后一个元素值的计数值，用内建函数cap获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap([]string&#123;4:&quot;bighua&quot;, 2:&quot;.&quot;, &quot;com&quot;&#125;)   ##=5</span><br></pre></td></tr></table></figure></p></blockquote><p>此例中切片值的容量就等于它的长度，对切片类型的零值应用内建函数cap也会得到0。</p><blockquote><p>一个切片值的底层数据结构中包含一个指向底层数组的指针类型值、一个代表切片长度的int类型值和一个代表切片容量的int类型值。  </p></blockquote><blockquote><p>使用复合字面量初始化一个切片值的时候，首先创建的是这个切片值所引用的底层数组，该底层数组与这个切片值有相同的元素类型、元素值及其排列顺序和长度，因此切片值的长度和容量一定相同。  </p></blockquote><blockquote><p>切片表达式的作用不是复制数组值中某个连续片段所包含的元素值，而是创建一个新的切片值，新的切片值中包含了指向这个连续片段中的第一个元素值的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;a&quot;, &quot;loser&quot;&#125;     ##底层数组长度5，即切片容量5</span><br><span class="line">slice := array[:4]      ##切片长度4，能够访问前4个元素值</span><br><span class="line">slice = slice[:cap(slice)]  ##扩大窗口，改变长度为容量，能够访问所有元素值</span><br></pre></td></tr></table></figure></p></blockquote><p>通过切片的方式把slicede的窗口扩展到最大，此时slice的值的长度等于其容量，窗口只能向索引值递增的方向拓展。当一个切片的索引值不在切片的长度范围内时，会引起一个运行时恐慌。<br>使用内建函数append对切片值进行拓展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array[:4]</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">slice ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">长度扩展到最大容量7，此时array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">slice1 := append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">不会改变slice的值，声明并初始化一个新变量slice1</span><br><span class="line">slice1 ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>第一个参数为将要被拓展的切片，第二个可变长参数类型应与第一个参数元素类型相同，与作为拓展内容的一个或多个元素值绑定。此函数又返回结果，结果的类型与其第一个参数的类型完全一致。<br>append函数不是在原始切片值上进行拓展，而是创建一个新的切片值，在无需扩容时，此切片值与原切片值共用一个底层数组，指针类型值和容量值与原切片值保持一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">此时长度超出容量，会创建一个新的长度大于需要存储的元素值总和的底层数组，新切片指针、长度、容量改变。</span><br><span class="line">*/相似</span><br></pre></td></tr></table></figure></p><p>上例中slice长度超出容量，此时会有一个新的数组值被创建并初始化，新的数组值将作为在append函数新创建的切片值的底层数组，包含原切片之中的全部元素值以及作为拓展内容的所有元素值。此底层数组的长度总是大于需要存储的元素值的总和，新切片值中的指针将指向其底层数组的第一个元素值，长度和容量与其底层数组的长度相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice = append(slice, slice1...)</span><br><span class="line">---</span><br><span class="line">slice1 = nil</span><br><span class="line">slice1 = append(slice2, slice...)</span><br><span class="line">---</span><br><span class="line">var slice2 []string</span><br><span class="line">slice2 = append(slice2, slice...)</span><br></pre></td></tr></table></figure></p><p>运用“…”符号，集合追加方式。</p><blockquote><p>如果容量上限索引被指定，作为切片表达式的求值结果的新切片值的容量则为容量上界索引与元素下界索引之间的差值。指定容量上界索引的目的是为了缩小新切片值的容量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arrray = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">slice := array[2:6]</span><br><span class="line">/*可直接修改array对应索引值在[2,6)的元素值，通过扩大slice窗口，可修改array对应索引值[6,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice :=array[2:6:8]</span><br><span class="line">/*即使扩大长度也仅能访问修改array中对应索引值[2,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice = append(slice, []int&#123;10 ,11, 12, 13, 14, 15&#125;...)</span><br><span class="line">/*拓展超出容量创建新的底层数组，指针指向新底层数组，彻底无法访问修改array的元素值*/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用容量上限索引能有效的精细控制切片值对其底层数组的访问权限。<br>指定容量上限索引时，元素上界索引时不能够省略的，可以省略元素下界索引。</p></blockquote><p>使用内建函数copy批量赋值切片值中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []string&#123;&quot;I&quot;, &quot;love&quot;, &quot;my&quot;, &quot;family&quot;&#125;</span><br><span class="line">slice2 := []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">n1 := copy(slice1,slice2)</span><br><span class="line">/*</span><br><span class="line">n1 = 3</span><br><span class="line">slice =&gt; []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;, &quot;family&quot;&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>把原切片值（参数二）中的元素值复制到目标切片值（参数一）中，返回被复制的元素值的数量。参数一和参数二的元素类型必须一致，实际复制的元素值的数量等于长度较短的切片值的长度。<br>切片类型相当于于其他编程语言中的动态数组类型，扩展机制也与动态数组类型相似。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典（Map）是哈希表（Hash Table）的一个实现。哈希表是一个实现了关联数组的数据结构，关联数组是用于代表键值对的集合的一种抽象数据类型，在一个键值对集合中，一个键最多能够出现一次。与这个抽象数据结构相关联的操作有：  </p><ul><li>向集合中添加键值对。</li><li>从集合中删除键值对。</li><li>修改集合中已存在的键值对的值。</li><li>查找一个特定键所对应的值。</li></ul><p>哈希表通过哈希函数建立键值对的内部关联，键值对之间是没有顺序关系的。</p><h4 id="类型表示法-1"><a href="#类型表示法-1" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>如果一个字典类型中的键的类型为K，且元素的类型为T，字典类型的类型字面量为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map[K]T</span><br><span class="line">---</span><br><span class="line">map[int]string</span><br><span class="line">map[string]struct&#123;name,department string&#125;</span><br><span class="line">map[string]interface&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>字典类型的键类型和元素类型都需要在其声明中指定，元素类型可以是任意一个有效的Go语言数据类型，键类型不能是函数类型、字典类型或切片类型，键类型必须是可比较的。若键类型是接口类型，在程序运行期间，该类型的字典值中的每一个键值的动态类型都必须是可比较的，否则引起运行时异常。</p><h4 id="值表示法-1"><a href="#值表示法-1" class="headerlink" title="值表示法"></a>值表示法</h4><p>由复合字面量表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]bool&#123;&quot;bighua&quot;:true, &quot;cool&quot;:true, &quot;smart&quot;:true, &quot;ugly&quot;:false&#125;</span><br><span class="line">---</span><br><span class="line">map[string]bool&#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>同指针类型和切片类型，字典类型是一个引用类型。字典会持有一个针对某个底层数据结构值的引用，将一个字典值传递给一个会改变它的函数，这个改变对于函数的调用方是可见的。  </p><blockquote><p>在Go语言中只有“传值”没有“传引用”，函数内部对参数值的改变是否会在该函数之外体现出来，只取决于这个被改变的值的类型是值类型还是引用类型。  </p></blockquote><p>字典的零值是nil，类似一个长度为零的字典，可对其进行读取操作，对其进行写操作引发运行时恐慌。为初始化的字典类型的变量的值为nil。<br>用内建函数len获取字典值的长度，代表当前所包含的键值对的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">editorSign := map[string]bool&#123;&quot;cool&quot;:true, &quot;smart&quot;:true, &quot;stupid&quot;:false&#125;</span><br><span class="line">editorSign[&quot;ugly&quot;] = false</span><br><span class="line">/*新增*/</span><br><span class="line">---</span><br><span class="line">sign1 := editorSign[&quot;smart&quot;]</span><br><span class="line">sign1,ok := editorSign[&quot;smart&quot;]</span><br><span class="line">/*查找获取，消除不存在歧义*/</span><br><span class="line">---</span><br><span class="line">delete(editorSign,&quot;stupid&quot;)</span><br><span class="line">/*删除键为&quot;stupid&quot;的键值对，无返回结果，即使不存在要删的键值对也不引起恐慌*/</span><br></pre></td></tr></table></figure></p><blockquote><p>字典类型不是并发安全的，官方认为在大多数使用字典值的地方并不需要多线程场景下的安全访问控制，为了少数的并发使用场景而强制要求所有的字典都满足互斥操作将会降低大多数程序的速度。  </p></blockquote><blockquote><p>对一个非并发安全的字典值进行不受控制的并发访问可能会导致程序行为错乱，可以使用标准库代码包sync中的结构体类型RWMutex扩展字典类来保证并发安全性。RWMutex是一个读写互斥量，常用于多线程环境下的并发读写控制。</p></blockquote><h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数类型是一等类型，可以把函数当作一个值来传递和使用，即可以作为其他函数的参数，也可以作为其他函数的结果，可以利用函数的和则以特性生成闭包。</p><h4 id="类型表示法-2"><a href="#类型表示法-2" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>函数类型指代了所有可以接受若干参数并能够返回若干结果的函数。<br>声明一个函数以关键字func作为开始，其后紧跟函数签名，包括参数声明列表和结果声明列表。参数声明一般参数名在前，参数类型在后，中间空格分隔，参数名称唯一。若相邻两个参数的类型一致，可以只写第二个参数的参数类型。可以在函数声明的参数列表中略去所有参数的名称。可添加可变长参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(name string, age int)</span><br><span class="line">---</span><br><span class="line">(name string, age, seniority int)</span><br><span class="line">---</span><br><span class="line">(string,int,int)</span><br><span class="line">---</span><br><span class="line">(name string,age int,seniority int,informations ...string)</span><br></pre></td></tr></table></figure></p><p>结果声明列表的编写规则与参数声明基本一致，区别于：  </p><ul><li>只存在可变长参数的声明不存在可变长结果的声明。</li><li>如果结果声明列表中只有一个结果声明且这个结果声明中并不包含结果的名称，则可以忽略圆括号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int, seniority int, informations ...string)bool</span><br><span class="line">-&gt;</span><br><span class="line">func (name string, age int, seniority int, informations ...string)(done bool)</span><br><span class="line">/*命名结果*/</span><br></pre></td></tr></table></figure></li></ul><p>Go语言的函数雷ixng可以由多个结果，为函数声明多个结果可以让每个结果的职责更单一。可以利用此特性将错误值作为结果返回给调用它的代码，而不是把错误抛出来，然后在调用它的地方编写代码处理这个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int , seniority int)(effected uint, err error)</span><br></pre></td></tr></table></figure></p><h4 id="值表示法-2"><a href="#值表示法-2" class="headerlink" title="值表示法"></a>值表示法</h4><p>函数类型的零值是nil，未被初始化的函数类型的变量的值为nil，在一个未被初始化的函数类型的变量上调用表达式会引发一个运行时的恐慌。<br>函数类型的值分为命名函数值和匿名函数值。<br>命名函数由关键字func、函数名、函数的签名和函数体组成。若签名中包含了结果声明列表，则在函数体中的任何可到达的流程分支的最后一条语句都必须是终止语句。终止语句有多种，return或goto开始的语句，针对内建函数panic的调用表达式的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Module(x, y int) int&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在关键字return之后的结果必须在数量上与该函数的结果声明列表中的内容完全一致，对应位置的结果的类型上存在可赋予的关系。</p><blockquote><p>函数的声明可以省略掉函数体，表示会由外部程序（如汇编语言程序）实现，而不会由Go语言程序实现。</p></blockquote><p>匿名函数由函数字面量表示，函数没有名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作-1"><a href="#属性和基本操作-1" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本词法&quot;&gt;&lt;a href=&quot;#基本词法&quot; class=&quot;headerlink&quot; title=&quot;基本词法&quot;&gt;&lt;/a&gt;基本词法&lt;/h2&gt;&lt;h3 id=&quot;标识符&quot;&gt;&lt;a href=&quot;#标识符&quot; class=&quot;headerlink&quot; title=&quot;标识符&quot;&gt;&lt;/a&gt;标识
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>启航</title>
    <link href="bighua.top/2018/04/05/%E5%90%AF%E8%88%AA/"/>
    <id>bighua.top/2018/04/05/启航/</id>
    <published>2018-04-05T13:48:46.000Z</published>
    <updated>2018-04-09T10:19:26.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搭建缘由"><a href="#搭建缘由" class="headerlink" title="搭建缘由"></a>搭建缘由</h3><p> 在前段时间又重新搭建了一系列的开发环境，安装了数遍双系统和虚拟机，折腾ubuntu和centos，搭建php+nginx+go+mariadb+node等等，期间遇到了很多的新问题，也有一些老问题，学到了很多东西，越来越感觉到笔记的重要性。想要自己搭建一套博客，怕是ui丑到自己都下不去笔。另外耽误时间、服务器配置以及相关稳定性长久性等也是个问题。从今开始，将所学所得所感记录在此。</p><h3 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h3><p>本博客由hexo驱动，尝试过很多主题，例如yilia、material等，最终选择了next主题。之前也尝试过rubuy的jekyll，但是更偏向于比较熟悉的基于node的hexo。使用yilia主题时，强迫症改liyia的侧滑抖动动画，改侧滑背景颜色，最终还是感觉界面不理想，在移动端每个页面上都挂着个人prefile，有种特沙比的感觉，非常浪费空间影响阅读体验，而且作者留了个badjs report收集异常信息和用户信息，感觉很是不爽，并且对应的提交端口貌似没有在维护了，调试时一个红色的eroor简直逼死强迫症。</p><p>使用material主题时也有类似yilia冗余的一点，有个logo perfile简直累赘，而且对应的官方网站相应文档总是加载不出来，貌似被墙了，很遗憾，没搭建完美就放弃了。</p><p>后来用到next主题，对于用户来说要比前两个友好很多，简洁大方，留给了用户更多的配置项，在移动端浏览更简洁舒服，封装了更多的第三方插件。评论插件建议畅言，加载快多了。但是目前有个问题，编写tags、about等page页面时，在page页面配置comments为false，编译后对应的页面虽然不出现畅言插件，即没加入相应的html页面块，但是却加入了相应的js用，然后在控制台会一直报js未寻找到畅言对应html节点的错误。使用来必力虽然也加入了相应的js调用，但是不会出现此类错误，应该编译过程未处理好。等以后有机会再探究修改一番，作为强迫症，把所有的页面评论功能都打开了。。。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望自己能够</p><blockquote><p>勤操代码多读书，善用时间少偷懒。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;搭建缘由&quot;&gt;&lt;a href=&quot;#搭建缘由&quot; class=&quot;headerlink&quot; title=&quot;搭建缘由&quot;&gt;&lt;/a&gt;搭建缘由&lt;/h3&gt;&lt;p&gt; 在前段时间又重新搭建了一系列的开发环境，安装了数遍双系统和虚拟机，折腾ubuntu和centos，搭建php+nginx+
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客" scheme="bighua.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="bighua.top/tags/hexo/"/>
    
      <category term="next" scheme="bighua.top/tags/next/"/>
    
  </entry>
  
</feed>
