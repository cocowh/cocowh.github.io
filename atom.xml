<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2019-04-29T06:59:07.430Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习-命令</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2019/04/06/Docker学习-命令/</id>
    <published>2019-04-06T08:07:44.000Z</published>
    <updated>2019-04-29T06:59:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><p>EXAMPLES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">//绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h4 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h4><p>docker start :启动一个或多个已经被停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker stop :停止一个运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker restart :重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">//停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">//重启容器myrunoob</span><br><span class="line"></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>docker kill :杀掉一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-s :向容器发送一个信号</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//杀掉运行中的容器mynginx</span><br><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>docker rm ：删除一个或多少容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">//移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line">//删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h4 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h4><p>docker pause :暂停容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker unpause :恢复容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//暂停数据库容器db01提供服务。</span><br><span class="line">docker pause db01</span><br><span class="line"></span><br><span class="line">//恢复数据库容器db01提供服务。</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>docker create ：创建一个新的容器但不启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>同<code>docker run</code><br>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>docker exec ：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">//在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>docker ps : 列出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//列出所有在运行的容器信息</span><br><span class="line">wuhua:blog wuhua$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>####inspect<br>docker inspect : 获取容器/镜像的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li><li>-s :显示总的文件大小。</li><li>–type :为指定类型返回JSON。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取镜像mysql:5.6的元信息</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">//获取正在运行的容器mymysql的 IP</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>docker attach :连接到正在运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><p>docker events : 从服务器获取实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示docker 2016年7月1日后的所有事件</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">//显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</span><br></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p><p>OPTIONS:</p><ul><li>-f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>-t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">//查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :将输入内容写到文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure><p>###容器rootfs命令</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>docker commit :从容器创建一个新的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>docker cp :用于容器与主机之间的数据拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-L :保持源目标中的链接</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">//将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>docker diff : 检查容器里文件结构的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看容器mymysql的文件结构更改。</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><h4 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h4><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker logout [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-u :登陆的用户名</li><li>-p :登陆的密码</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">//登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :拉取所有 tagged 镜像</li><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从Docker Hub下载java最新版镜像。</span><br><span class="line">docker pull java</span><br><span class="line">//从Docker Hub下载REPOSITORY为java的所有镜像。</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>docker search : 从Docker Hub查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–automated :只列出 automated build类型的镜像；</li><li>–no-trunc :显示完整的镜像描述；</li><li>-s :列出收藏数不小于指定值的镜像。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:blog wuhua$ docker search -s 10 java</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                         Node.js is a JavaScript-based platform for s…   7238                [OK]                </span><br><span class="line">tomcat                                       Apache Tomcat is an open source implementati…   2333                [OK]                </span><br><span class="line">java                                         Java is a concurrent, class-based, and objec…   1967                [OK]                </span><br><span class="line">openjdk                                      OpenJDK is an open-source implementation of …   1599                [OK]                </span><br><span class="line">ghost                                        Ghost is a free and open source blogging pla…   951                 [OK]                </span><br><span class="line">anapsix/alpine-java                          Oracle Java 8 (and 7) with GLIBC 2.28 over A…   402                                     [OK]</span><br><span class="line">jetty                                        Jetty provides a Web server and javax.servle…   294                 [OK]                </span><br><span class="line">couchdb                                      CouchDB is a database that uses JSON for doc…   269                 [OK]                </span><br><span class="line">ibmjava                                      Official IBM® SDK, Java™ Technology Edition …   67                  [OK]                </span><br><span class="line">groovy                                       Apache Groovy is a multi-faceted language fo…   66                  [OK]                </span><br><span class="line">tomee                                        Apache TomEE is an all-Apache Java EE certif…   64                  [OK]                </span><br><span class="line">lwieske/java-8                               Oracle Java 8 Container - Full + Slim - Base…   43                                      [OK]</span><br><span class="line">cloudbees/jnlp-slave-with-java-build-tools   Extends cloudbees/java-build-tools docker im…   25                                      [OK]</span><br><span class="line">zabbix/zabbix-java-gateway                   Zabbix Java Gateway                             16                                      [OK]</span><br><span class="line">frekele/java                                 docker run --rm --name java frekele/java        13                                      [OK]</span><br><span class="line">davidcaste/alpine-java-unlimited-jce         Oracle Java 8 (and 7) with GLIBC 2.21 over A…   11                                      [OK]</span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>docker images : 列出本地镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID.</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">//列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure><h4 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h4><p>docker rmi : 删除本地一个或多少镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制删除本地镜像runoob/ubuntu:v4。</span><br><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>docker tag : 标记本地镜像，将其归入某一仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>docker build 命令用于使用 Dockerfile 创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–build-arg=[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label=[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置/dev/shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line">//使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">//通过 -f Dockerfile 文件的位置</span><br><span class="line"> docker build -f /path/to/a/Dockerfile .</span><br><span class="line">//在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回</span><br><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>docker history : 查看指定镜像的创建历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-H :以可读的格式打印镜像大小和日期，默认为true；</li><li>–no-trunc :显示完整的提交记录；</li><li>-q :仅列出提交记录ID。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>docker save : 将指定镜像保存成 tar 归档文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :输出到的文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>docker import : 从归档文件中创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-c :应用docker 指令创建镜像；</li><li>-m :提交时的说明文字；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info [OPTIONS]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-11T12:27:47.5699614Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>docker version :显示 Docker 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器生命周期管理&quot;&gt;&lt;a href=&quot;#容器生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;容器生命周期管理&quot;&gt;&lt;/a&gt;容器生命周期管理&lt;/h3&gt;&lt;h4 id=&quot;run&quot;&gt;&lt;a href=&quot;#run&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
      <category term="命令" scheme="bighua.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-安装配置</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>bighua.top/2019/04/06/Docker学习-安装配置/</id>
    <published>2019-04-06T07:50:07.000Z</published>
    <updated>2019-04-11T12:33:14.177Z</updated>
    
    <content type="html"><![CDATA[<p>mac环境桌面版</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ brew search docker</span><br><span class="line">==&gt; Formulae</span><br><span class="line">docker                                   docker-machine-completion</span><br><span class="line">docker-clean                             docker-machine-driver-hyperkit</span><br><span class="line">docker-cloud                             docker-machine-driver-vultr</span><br><span class="line">docker-completion                        docker-machine-driver-xhyve</span><br><span class="line">docker-compose                           docker-machine-nfs</span><br><span class="line">docker-compose-completion                docker-machine-parallels</span><br><span class="line">docker-credential-helper                 docker-squash</span><br><span class="line">docker-credential-helper-ecr             docker-swarm</span><br><span class="line">docker-gen                               docker2aci</span><br><span class="line">docker-ls                                dockerize</span><br><span class="line">docker-machine</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">docker                                   homebrew/cask-versions/docker-edge</span><br><span class="line">docker-toolbox</span><br><span class="line">wuhua:src wuhua$ brew cask install docker</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/31259/Docker.dmg</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask &apos;docker&apos;.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App &apos;Docker.app&apos; to &apos;/Applications/Docker.app&apos;.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure><p>点<code>访达</code>边的<code>启动台</code> 可看到下载好的桌面版docker，点击启动按步骤操作输入密码授权</p><p>配置后启动查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Error response from daemon: Bad response from Docker engine</span><br><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 51</span><br><span class="line"> System Time: 2019-04-06T07:47:49.465200315Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><p>第一次<code>docker info</code>查询失败是因为未启动完毕。</p><p>关于docker命令参考<a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></p><p>关于设置docker国内镜像参考<a href="https://www.cnblogs.com/anliven/p/6218741.html" target="_blank" rel="noopener">Docker国内镜像</a></p><p>关于其他系统Doker安装参考<a href="http://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">MacOS Docker 安装</a></p><p>关于<code>brew</code>和<code>brew cask</code>参考<a href="https://blog.csdn.net/yanxiaobo1991/article/details/78455908" target="_blank" rel="noopener">mac brew和brew cask的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac环境桌面版&lt;/p&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="bighua.top/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>bighua.top/2019/02/02/2018年终总结/</id>
    <published>2019-02-01T17:19:30.000Z</published>
    <updated>2019-02-04T17:17:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。</p><h3 id="上半年-大学毕业"><a href="#上半年-大学毕业" class="headerlink" title="上半年-大学毕业"></a>上半年-大学毕业</h3><p>从17年11月份确定毕设课题开始，毕设导师就开始积极联系我们进行相关课题的研究工作。可能是由于导师也是第一年回校园工作，对之前的毕设流程不了解，对我们的要求可以说是有点太过严谨。在10月末确定工作签好三方后，本想去公司实习一段时间，了解公司和相关技术，但是导师以毕设为由，建议将毕设弄差不多后再去实习。</p><p>17年末，过的很轻松，结束掉了大学最后的几门课程考试。这段时间， 每天基本睡到自然醒，中午一点多去梦泽园吃顿饭，回宿舍打游戏，晚上玩手机熬夜到很晚，第二天循环如此。这一段时间，应该是大学过的最爽的一段时间，不用再顾虑学习，确定好了工作，混吃等死。每天重复的事情——打游戏、睡觉、一切其他感兴趣的事情。有点遗憾是经济不支持，没能实现出去旅游四处走走的心愿。有点不爽的是，考试结束本来可以回家的，导师要求留校十天，进行毕设课题相关的工作。其实这十天完全没做多少毕设相关的工作，大多数时间依旧堕落的生活。放假前的例会，发给我们相关软硬件，让我们回家摸索。然而，春节期间谁会想到这玩意呢，怎么样带回去，再怎么样的带回来，再在例会前几天突击了解一下。</p><p>春节期间，由于工作的<code>理想工资</code>，自己快有点飘了，在各个房产软件上查看洛阳、信阳等各处楼盘的信息，心里决定一定要靠自己买到理想的、位置合适的一套房子。现在想想，当时的想法还有点太遥远，想要去实现，还远得很。</p><p>18年开学，晚来了一周多，如果不是导师要求例会，完全不想再返回学校。到学校后，发现很多同学已经开始或打算去实习了，这时有个换毕设课题的机会，跟与学校合作的企业去开发<code>养猪</code>项目，当作毕设课题，当时爽妈还建议我一起报，可以想着搞定毕设去公司实习，拒绝了，结合后来苦逼的毕设过程、没能够去公司实习、看他们<code>养猪</code>玩的不亦乐乎，简直想抽自己两巴掌，后悔得要死。后来18年大四最后一学期的前几个月——3月中旬至五月中旬——就如前面所说。每天在导师给找的办公室里做毕设相关——看资料、翻译、看源代码、记录，枯燥无聊。四月初感觉毕设做的差不多了想去实习，联系hr后反馈没有实习名额了，然后<code>养猪</code>的同学四处游山玩水，简直心里不爽到极点。不爽的最后也是有些收获的，阅读项目底层C语言源码，收获有一些，在18年的一篇日志中有些记录，这里就不重记了。到5月中旬，毕设论文准备的差不多了，就趁二姐回家，回家过了半个月，陪可爱的外甥女玩，很是惬意开心。6月初返校，修修改改准备最后的论文终稿、答辩PPT，10号答辩顺利通过，其实感觉我是通过的最顺利的一个，整个过程不到5分钟，没有安全相关的老师，没问什么问题，对做的工作进行了一些了解性提问，最后甚至还有个老师想要推优我的毕设论文。还好最终没推优，省去了一些麻烦事。作为一条咸鱼，已经不对大学再抱有任何幻想，只想着顺利毕业结束这不怎么样的四年。</p><p>这半年沉寂了N久的和尚之心也随着与李老师的几次会面交流在18年春天有了一些蠢蠢欲动，也是在枯燥的毕设过程中多了一些点缀。但是毕竟多年修炼有素，内心抑制住了，对于没有把握的事情不再轻易尝试。在四月时，自己曾一人骑着小蓝车再一次逛了一遍校园。从图书馆出发，骑到24节气看观赏的游客，骑到油菜田拍一片金黄、骑过基本建成养猪厂、骑过坟场前面旁边开的鲜花正盛的小户人家、骑过柳树随着春风摇曳着枝条的南湖边、骑过情侣经常约会的小树林、起过吐槽了四年的环湖跑路线、起过茶叶地、骑过种满各种花卉和作物的研究圆、起过二运篮球场旁边开满紫色小花的小树林、骑到清真食堂再感受一遍不怎么喜欢的饭菜最终还是照旧选择了炒饭，最后在慢慢走回去，体验这最后的悠闲时光。六月中旬班级毕业晚饭到毕设典礼以及最后的毕业离校时间，其实还是挺想留下来感受下这最后的相聚时光的，虽然回家过端午节并送二姐回家是提前离校原因之一，但是更过的原因是不想再见那些隔阂了很久的同学，想早点逃离这不爽快的生活。</p><p>总的来说，18年的上半年，生活的主要节奏是毕设，心中住进的人在毕设枯燥的生活中增添了一些别样色彩，可爱的外甥女，毕设离别。在技术上，学习了go的一点皮毛，复习一些c相关的东西，遗忘了PHP。</p><h3 id="下半年-参入工作"><a href="#下半年-参入工作" class="headerlink" title="下半年-参入工作"></a>下半年-参入工作</h3><p>拿到小强寄回的毕业证后，迟迟不想离家，想在家多待几天，定的火车票也很晚，直到日期到达不得不收拾行李开始北漂生活。六月二十八下午到北京，出站后马上办理了一卡通，先坐地铁去上班的地方看了一眼，拍了一张北大的竺可桢大楼，由于之前没租好房，然后立刻拖着行李开始去附近找中介看房子，然后这附近的房子符合心里价位预期的不是小就是破旧，最终没能定下，看完房子吃完晚饭差不多六点了，才开始考虑宾馆的事情。这个时候才开始去美团上看附近的青旅，基本上家家都爆满了。最后花了100多大洋找到一家<code>招待所</code>，直到七绕八绕问了路人才找到这家在地下二层的<code>招待所</code>。是的，地下室，很多间，里面住着不少人，看着有晾晒衣服的，其中不少工作服，例如交通协助员服、清洁工服等，虽然这里并没有阳关。里面用的公用的洗漱间和卫生间，有点高中公共卫生间的感觉，但是要比那糟糕多了，这里没有阳光，通气靠中央空调，异常潮湿，老旧残破。这个地下室在中关村靠近苏州街那边，具体的位置记不太清了。那天晚上才确认到，原来还真有在这种环境中常驻生活的人的，体会到生活的不易。虽然环境差了些，但我还是睡着了，因为太困了，拖着大行李箱跑了好久。</p><p>29号早晨离开地下室、拖着行李箱开始坐四号线往南走到自如上房价相对便宜点的站点下，但一下地铁，计算下路上消耗的时间就打消了租房的念头，然后又坐四号线往北走，到安河桥北下，计算公司地铁站点到安河桥北消耗的时间。下地铁后，之前在自如上关注的房源负责的中介联系上了我，说是十六号线永丰南有房源要马上释放了，想帮我抢，这个时候拖着行李跑了老半天的我简直感动到不行，然后立刻提供了账号，可惜她并没有帮我抢到，她甚至怀疑他们内部有挂，也是很有趣。然后从安河桥北站向外面忘了几眼，合计下地铁时间，就开始重新进站，向hr推荐的十六号线上的几点地点去，根据通勤时间以及自如上的房价，最终选择了在马连洼站下，然后开始搜索附近的中介，最后拖着行李先找了链家，他们的房源与自如上的是统一的，中介也是根据需求在自如上查找，最后给推荐了一个在圆明园别墅的将要退租的房源，但是到30号才能看房。出了链家，又找了一家不远的我爱我家，才知道他们的房源与平台展示的是不同步的，给推荐了三处房源，最终选择了30号可马上入住的肖家河，思考再三签了合同，交了12500元，花了人生中最大的一笔钱。这一晚，在同是应届生的同事租好的房子里打地铺凑合了一晚，他刚好租在隔壁小区，感谢这位热心广东同事。30号早去办完交接手续，就开始布置房子，正式入住了。七月一号，和这位广东同事一起去逛了故宫，但是实在太大了，我们只走了一条线就结束了，然后骑自行经过天安门，去同事推荐的美食街吃了碗面，坐地铁回家。</p><p>七月二号，正式入职，去总部本办理入职手续，花了一上午时间，吃完午饭去办公地点，由hr领着带到每个人的小组，交给组长。我们组长帆哥再带领我们去见经理、和前端负责人打招呼，然后给我们安排工位。接着hr带领我们熟悉办公环境，介绍我们所在的组，以及生活上的日常。</p><p>七月和八月这两个月算事这半年最轻松的，跟着新人培养计划熟悉相关技术和工具，做一个内部项目，每晚都能八点左右甚至吃完晚饭后直接回去，这两个月回去后还经常再开几把lol。到了九月份开始熟悉正在开发的正式项目X，就慢慢开始忙起来了。这两个月我们组有些人事变动，七月中旬刚聚餐完，下旬组长就开始离职前的最后休假了，到了九月中旬及十月中旬，陆续又有三名同事离开。技术上完全是学习状态，虽然之前撸项目PHP用的挺多，但是也快有大半年未接触过了，这大半年都投入到毕设和了解Go上去了，其他相关的技术如mysql、nginx、redis等也是学习使用状态。</p><p>刚开始接触正式项目X，有些吃力，没有从一开始就关注这个项目，业务完全不了解，读相关产品文档、wiki、代码都有些吃力。这时正值这个正式项目第一次上线，离职同事负责的模块留下了很多待解决bug，这时他的模块交给了另一个同事，待解决bug也基本都有这位交接的同事慢慢解决完了。他带着我开始熟悉这部分的业务，从一些新增的简单接口开始，慢慢熟悉了解整个模块。这时候也大部分都是在学习状态，跟着了解业务，跟着学会排查bug，解决bug。十月下旬述职转正，可能是不适应经理的冷脸，心里总是很紧张，比笔毕设答辩时还紧张，表现很差，最后顺序转正，算是正式员工可以有绩效了。</p><p>九月到十一月还不是很忙，基本上是熟悉业务写些小接口的状态，还可以有些时间进行其他的学习。十一月过的很糟心，三叔的离世。十一月末回来后，正式开始了这半年最繁忙的两个月。</p><p>十一月时接了一个评审中的项目A，十二月开始进入开发，但是十二月上旬，同事由于有其他工作需求解决，交给了我另一个项目B。还好的是老项目逻辑可以参考，坏的是时间很紧，根据排期只有一周多的时间就要体测，没有参入评审，对很多细节不了解，也给后来埋了不少坑。这一两周每天都回去很晚，整理老项目逻辑，开发，调试，该bug。十二月初，十一月评审的项目A也正式进入排期阶段，在做项目B的同时整理项目A相关产品文档，确定需求接口，再向被人要接口要排期。同时，十二月初，之前负责的项目X需要改版，之前写的接口基本不能复用，好在接口不多，在十二月中旬花了三四天完成。完成项目X的接口后，项目A也开始进入开发阶段，同时还要排查修改项目X和项目B的相关bug，直到项目A接口交付deadline的前一天——圣诞后两天，项目A需要的10个接口还有一半未完成，而在圣诞节这天项目X改版上线，通宵到四五点才回去。睡到中午醒，立刻开始项目A未完成的接口开发，一直到交付日期五点基本开发完。这两天简直有点吃不消，一直影响到一月，脸上又开始出现很多痘痘，脸色也很不好。一开始以为项目A只有刚开始需求的十多个新接口，其他的可以复用老接口，后来发现我错了，一月份的整个工作都消耗在了老接口的调试重写上，被提N多BUG，每天在改bug、熟悉老代码逻辑、调试接口中度过。目前还有一个遗留bug未解决，需要年后继续联调。在一月中旬，接了哟哥小工具的开发工作，开始以为是一个简单的小功能，最开始的产品需求也比较简单，可是后来出现一些问题后就突然麻烦起来，虽然目前给了一个折中解决方案，年后估计还有好一整。</p><p>这半年，也和几个老同学们聚过几次，去过北京几个地儿。技术上的状态，目前仍然是学习阶段，这半年大多时间都在用php撸业务去了，上半年了解的go也基本忘差不多了。上半年住进心里的李老师，我也终于鼓起勇气直面内心了一回，希望在新的一年里能有更多时间去争取。</p><p>一会就到站了，希望自己在新的一年里一切顺利，家人身体健康～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。&lt;/p&gt;
&lt;h3 id=&quot;上半年-大学毕业&quot;&gt;&lt;a href=&quot;#上半年-大学毕业&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="bighua.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql的character_set变量</title>
    <link href="bighua.top/2019/01/25/%E5%85%B3%E4%BA%8Emysql%E7%9A%84character-set%E5%8F%98%E9%87%8F/"/>
    <id>bighua.top/2019/01/25/关于mysql的character-set变量/</id>
    <published>2019-01-25T08:08:27.000Z</published>
    <updated>2019-03-31T15:20:02.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show full columns from table_name;</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">| Field              | Type                | Collation       | Null | Key | Default | Extra          | Privileges           | Comment     |</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">...</span><br><span class="line">| user_name          | varchar(100)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ????        |</span><br><span class="line">| chapter_name       | varchar(255)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ?????       |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看数据库字符集设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;char%&apos;;</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| Variable_name            | Value                               |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| character_set_client     | latin1                              |</span><br><span class="line">| character_set_connection | latin1                              |</span><br><span class="line">| character_set_database   | utf8                                |</span><br><span class="line">| character_set_filesystem | binary                              |</span><br><span class="line">| character_set_results    | latin1                              |</span><br><span class="line">| character_set_server     | utf8                                |</span><br><span class="line">| character_set_system     | utf8                                |</span><br><span class="line">| character_sets_dir       | /usr/share/percona-server/charsets/ |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>大致感觉到原因是由于数据表相关字段字符集设置为utf8，以utf8编码存储，但是查询结果以latin1编码输出，导致汉字出现乱码。</p><p>搜索得解决办法，在查询语句中对出现乱码字段字符集编码进行转换，具体转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(unhex(hex(convert(user_name using utf8))) using latin1) as user_name,convert(unhex(hex(convert(chapter_name using utf8))) using latin1) as chapter_name</span><br></pre></td></tr></table></figure><p>最终得到正确无乱码的查询结果。</p><h3 id="各character-set变量的含义"><a href="#各character-set变量的含义" class="headerlink" title="各character_set变量的含义"></a>各character_set变量的含义</h3><p>参考博客<a href="http://www.laruence.com/2008/01/05/12.html" target="_blank" rel="noopener">深入Mysql字符集设置</a>,<br><a href="https://hk.saowen.com/a/9c46af2db75e4f83be2d3eecd0d8de1246c3a69aed5facfbebe19ad46ca2600c" target="_blank" rel="noopener">Mysql中各種與字符編碼集（character_set）有關的變量含義</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="character_set" scheme="bighua.top/tags/character-set/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/15/InnoDB存储引擎/</id>
    <published>2019-01-15T07:33:37.000Z</published>
    <updated>2019-08-15T12:13:04.116Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。</p><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池，负责工作：</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构。</li><li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li><li>重做日志（redo log）缓冲。 </li></ul><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据。将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB是多线程模型，后台有多个不同的后台线程，负责处理不同的任务。</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>使用AIO（Async IO）来处理写IO请求，提高数据库的性能。IO Thread负责这些IO请求的回调（call back）处理。InnoDB V1.0前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。Linux下IO Thread的数量不能进行调整，Win下可以通过参数<code>innodb_file_io_threads</code>来增大IO Thread。InnoDB V1.0开始，read thread和write thread分别增大到了4个，不再使用<code>innodb_file_io_threads</code>参数，分别使用<code>inodb_read_io_threads</code>和<code>innodb_write_io_threads</code>参数进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_%io_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_read_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_write_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-23 00:22:55 0x7000078ef000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 30 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3 srv_active, 0 srv_shutdown, 261512 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 261494</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 9</span><br><span class="line">OS WAIT ARRAY INFO: signal count 9</span><br><span class="line">RW-shared spins 0, rounds 9, OS waits 2</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 9.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 23555</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479475189552, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for i/o request (log thread)</span><br><span class="line">I/O thread 2 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 3 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 4 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 5 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 6 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 7 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 8 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 9 state: waiting for i/o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&apos;s:, sync i/o&apos;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">432 OS file reads, 59 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 4861558</span><br><span class="line">Log flushed up to   4861558</span><br><span class="line">Pages flushed up to 4861558</span><br><span class="line">Last checkpoint at  4861549</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 137933</span><br><span class="line">Buffer pool size   8191</span><br><span class="line">Free buffers       7760</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 42</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=94, Main thread ID=123145423732736, state: sleeping</span><br><span class="line">Number of rows inserted 90, updated 0, deleted 0, read 98</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.08 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p><code>show engine innodb status</code>观察IO Thread。读线程的ID总是小于写线程。</p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>事务被提交后，其所使用的undolog可能不再需要，需要Purge Thread回收已经使用并分配的undo页，V1.1之前，purge操作仅在InnoDB存储引擎的Master Thread中完成，V1.1开始，可以单独到独立的线程中进行，减轻Master Thread的工作，提高CPU使用率、提升存储引擎的性能。</p><p>在数据库配置文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=1</span><br></pre></td></tr></table></figure><p>来启用独立的Purge Thread。</p><blockquote><p>查看配置文件位置  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ /usr/local/mysql/bin/mysql --verbose --help |grep -A 1 &apos;Default options&apos;</span><br><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf </span><br><span class="line">wuhua:~ wuhua$ mysql --help|grep &apos;my.cnf&apos;</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>设置后重启mysql（<code>sudo /usr/local/mysql/support-files/mysql.server restart</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>V1.1即使将<code>innodb_purge_threads</code>设为大于一，启动时也会将其设为1。V1.2开始，为进一步加快undo页的回收，支持多个Purge Thread。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 4</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>于V1.2.x版本引入，为减轻原Master Thread的工作及对于用户查询线程的阻塞、进一步提高InnoDB存储引擎的性能，将之前版本中脏页的刷新操作放到单独的线程中来完成。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>InnoDB存储引擎基于磁盘存储，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。因CPU速度与磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。</p><p>数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，过程称为将页‘FIX’在缓冲池中。下一次再读取相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取页，否则读取磁盘上的页。</p><p>进行页的修改操作时，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，通过一种称为Checkpoint的机制刷新回磁盘。为提高数据库的整体性能。</p><p>缓冲池的大小直接影响着数据库的整体性能。32位系统下该值为3G，可打开操作系统的PAE选项来获得32位操作系统下最大64GB内存的支持。为使数据库使用更多的内存，建议数据库服务器采用64位操作系统。</p><p>缓存池的配置通过参数<code>innodb_buffer_pool_size</code>来设置，默认值是128M，最小5M(当小于该值时会设置成5M)，最大为LLONG_MAX。</p><p>修改前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 134217728</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 268435456</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>缓冲池中缓冲的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。索引页和数据页占缓冲池很大一部分。</p><p>从V1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。可以减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数<code>innodb_buffer_pool_instances</code>来进行设置，默认值为1，设置大于1时需保证缓冲池大小（<code>innodb_buffer_pool_size</code>）最小为1G。</p><p>设置前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>设置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=1028M</span><br><span class="line">innodb_buffer_pool_instances=2</span><br></pre></td></tr></table></figure><p>多种方式查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema</span><br><span class="line">mysql&gt; select pool_id,pool_size,free_buffers,database_pages from innodb_buffer_pool_stats\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       pool_id: 0</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40724</span><br><span class="line">database_pages: 231</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">       pool_id: 1</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40755</span><br><span class="line">database_pages: 200</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 2</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40724</span><br><span class="line">Database pages     231</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 196, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 231, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40755</span><br><span class="line">Database pages     200</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 200, created 0, written 0</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 200, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h5><p>通常数据库中的缓冲池通过LRU（Latest Recent Used）算法来进行管理。InnoDB缓冲池中页的大小默认为16KB，使用LRU算法管理。但对LRU算法做了一些优化，在LRU列表中增加了midpoint位置，新读取到的页放入到LRU列表的midpoint位置。默认配置下，该位置在LRU列表长度的5/8处。可由参数<code>innodb_old_blocks_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p>表示新读取的页插入到LRU列表尾端37%（3/8）的位置，把midpoint之后的列表称为old表，之前的列表称为new列表。引入另一个参数<code>innodb_old_blocks_time</code>进一步管理LRU列表，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 1000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">mysql&gt; set global innodb_old_blocks_time=999;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 999</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>若预估活跃的热点数据不止63%，可以在执行SQL前，通过设置<code>innodb_old_blocks_pct</code>的值减少热点页可能被刷出来的概率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_old_blocks_pct=20;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>LRU列表管理已经读取的页，当数据库刚启动时，LRU列表是空的，此时页存放在Free列表中。从缓冲池中分页时，先从Free列表中查找可用的空闲页，有则从Free列表中删除，放入到LRU列表中，否则根据LRU算法淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p><p>通过<code>show engine innodb status</code>观察LRU列表及Free列表的使用情况和运行状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-24 21:13:11 0x700007d13000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 53 seconds</span><br><span class="line">-----------------</span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Free buffers与Database pages的数量之和可能不等于Buffer pool size，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页。Buffer pool hit rate表示缓冲池命中率，小于95%需要观察是否由于全表扫描引起的LRU列表被污染问题。</p><blockquote><p>该命令显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。<code>Per second averages calculated from the last 53 seconds</code></p></blockquote><p>可通过<code>INNODB_BUFFER_PAGE_LRU</code>来观察每个LRU列表中每个页的具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where space=189;</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| table_name | space | page_number | page_type         |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| NULL       |   189 |           0 | FILE_SPACE_HEADER |</span><br><span class="line">| NULL       |   189 |           1 | IBUF_BITMAP       |</span><br><span class="line">| NULL       |   189 |           2 | INODE             |</span><br><span class="line">| NULL       |   189 |           3 | INDEX             |</span><br><span class="line">| NULL       |   189 |           4 | INDEX             |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br></pre></td></tr></table></figure><p>V1.0.x开始支持压缩页的功能，可将原本16KB的页压缩为1KB、2KB、4KB和8KB，非16KB的页，通过unzip_LRU列表进行管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure><p>LRU中的页包含了unzip_LRU列表中的页。</p><p>unzip_LRU列表中对不同压缩页大小的风进行分别管理，通过伙伴算法进行内存的分配。例如从缓冲池中申请页为4KB的大小，过程为：</p><ul><li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</li><li>若有，直接使用；</li><li>否则检查8KB的unzip_LRU列表；</li><li>若有空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</li><li>否则从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ul><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察unzip_LRU列表中的项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,compressed_size from innodb_buffer_page_lru where compressed_size&lt;&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flu</span><br></pre></td></tr></table></figure><p><code>Modified db pages</code>显示了脏页的数量。</p><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察脏页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where oldest_modification&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p><code>TABLE_NAME</code>为NULL表示该页属于系统表空间。</p></blockquote><h5 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h5><p>InnoDB存储引擎的内存区域除缓冲池外还有重做日志缓存（redo log buffer），InnoDB先将重做日志信息先放入到这个缓冲区，然后按一定的频率将其刷新到重做日志文件，一般每秒都会将重做日志缓冲刷新到日志文件，用户只需保证每秒产生的事务量在这个缓冲大小之内，不需要将其设置的很大。该值可由配置参数innodb_log_buffer_size控制，默认为8M（mac v5.7.22 默认16M）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_log_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_log_buffer_size</span><br><span class="line">        Value: 16777216</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在以下三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p><ul><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件；</li><li>每个事物提交时会将重做日志缓冲刷新到重做日志文件；</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5><p>InnoDB对内存的管理是通过堆内存（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓存（frame buffer）还有对应的缓冲控制对象（buffer control block：记录一些诸如LRU、锁、等待等信息），对象的内存需要从额外内存池中申请。在申请了很大的InnoDB缓冲池时，也应考虑相应地增加额外内存池的大小。</p><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>页的操作首先都是在缓冲池中完成的，若一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本比磁盘的新，数据库将新版本的页从缓冲池刷新到磁盘。</p><p>为避免数据丢失问题，当前事物数据库系统普遍都采用了Write Ahead Log策略，即当事物提交时，先写重做日志，再修改页。当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。事务ACID中D（Durability持久性）的要求。</p><p>Checkpoint（检查点）技术的目的：</p><ul><li>缩短数据库的恢复时间；</li><li>缓冲池不够用时，将脏数据刷新到磁盘；</li><li>重做日志不可用时，刷新脏页。</li></ul><p> 数据库发生宕机时，数据库不需要重做所有的日志，Checkpoint之前的页都已经刷新回磁盘，数据库只需对Checkpoint后的重做日志进行恢复。</p><p> 当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</p><p> 重做日志不可用的情况是因为在当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，这部分可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p> InnoDB存储引擎通过LSN（Log Sequence Number）来标记版本，LSN是8字节数字，单位是字节。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5009487</span><br><span class="line">Log flushed up to   5009487</span><br><span class="line">Pages flushed up to 5009487</span><br><span class="line">Last checkpoint at  5009478</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1。</p><p>数据库运行时在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即指刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p><p>在InnoDB存储引擎中可能发生Fuzzy Checkpoint的情况：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async/Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><p>Master Thread中发生的Checkpoint，每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。过程异步，用户查询线程不会阻塞。</p><p>FLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，在v1.1.x之前检查LRU列表中是否有足够可用空间操作发生在<br>用户查询线程中，会阻塞用户查询操作。若无100个可用空闲页，会将LRU列表尾端的页移除，若其中有脏页，则进行Checkpoint。</p><p>InnoDB v1.2.x（MySQL 5.6）开始检查被放在Page Cleaner Thread中进行，可通过参数<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认1024。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_lru_scan_depth&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_lru_scan_depth</span><br><span class="line">        Value: 1024</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>Async/Sync Flush Checkpoint指的是重做日志不可用的情况下，需要强制将一些页刷新回磁盘，此时脏页是从脏页列表中选取。将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则：</p><blockquote><p>checkpoint_age = redo_lsn - checkpoint_lsn</p><p>async_water_mark = 75% * total_redo_log_file_size</p><p>sync_water_mark = 90% * total_redo_log_file_size</p></blockquote><ul><li>checkpoint_age &lt; async_water_mark，不需要刷新任何脏页到磁盘</li><li>async_water_mark &lt; checkpoint_age &lt; sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark</li><li>checkpoint_age &gt; sync_water_mark很少发生除非设置的重做日志文件太小，在进行类似LOAD DATA的BULK INSETRT操作，触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark。</li></ul><p>Async/Sync Flush Checkpoint保证重做日志循环使用的可用性，v1.2.x之前，Async Flush Checkpoint阻塞发现问题的用户查询线程，Sync Flush Checkpoint阻塞所有用户的查询线程，并且等待脏页刷新的完成。v1.2.x开始，放入到单独的Page Cleaner Thread中。</p><p>MySQL官版不能查看刷新页是从Flush列表中还是从LRU列表中进行Checkpoint的，不知道因为重做日志而产生的Async/Sync Flush的次数。InnoSQL版本可通过命令<code>show engine innodb status</code>来观察。</p><p>Dirty Page too much Checkpoint是因为脏页数量太多，导致InnoDB存储引擎强制进行Checkpoint。目的为了保证缓冲池中有足够可用的页。可由参数<code>innodb_max_dirty_page_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_max_dirty_pages_pct&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_max_dirty_pages_pct</span><br><span class="line">        Value: 75.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>75表示缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分脏页到磁盘，InnoDB v1.0.x之前是90，之后是75。</p><h3 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h3><h4 id="InnoDB-1-0-x之前的Master-Thread"><a href="#InnoDB-1-0-x之前的Master-Thread" class="headerlink" title="InnoDB 1.0.x之前的Master Thread"></a>InnoDB 1.0.x之前的Master Thread</h4><p>具有最高的线程优先级别。内部由多个loop组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。根据数据库运行状态进行切换。</p><p>主循环有两大部分操作——每秒钟的操作和每10秒钟的操作。</p><p>每秒钟的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是），因此再大的事务提交时间也是很短的；</li><li>合并插入缓冲（可能），判断上一秒内发生的IO次数是否小于5次，若小于5次，认为当前的IO压力很小，可以住行合并插入缓冲的操作；</li><li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能），判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认90，代表90%），若超过，认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</li></ul><p>每10秒的操作：</p><ul><li>刷新100个脏页到磁盘（可能的情况下），若过去10秒内磁盘的IO操作小于200次，则认为有足够的磁盘IO能力，将100个脏个刷新到磁盘；</li><li>合并至多5个插入缓冲（总是）；</li><li>将日志缓冲刷新到磁盘（总是）；</li><li>删除无用的undo页（总是），full purge操作，每次最多尝试回收20个undo页，对表进行updae、delete操作时，原行被标记为删除，因一致性读（consistent read）需要保留这些行版本的信息，在full purge过程中，判断当前事务系统中已被删除的行是否可以删除（可能有查询操作需要读取之前版本的undo信息），若可以则立即删除；</li><li>刷新100个或10个脏页到磁盘（总是），判断缓冲池中脏页的比例（buf_get_modified_ratio_pct），若有超过70%的脏页，则刷新100个脏页到磁盘，若小于70%则只刷新10个脏页到磁盘。</li></ul><p>若当前没有用户活动（数据库空闲）或者数据库关闭（shutdown），切换到background loop，执行的操作：</p><ul><li>删除无用的undo页（总是）；</li><li>合并20个插入缓冲（总是）；</li><li>跳回到主循环（总是）；</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</li></ul><p>若flush loop中也无事可做，则切换到suspend_loop，将Master Thread挂起，等待事情的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起状态。</p><h4 id="InnoDB-1-2-x版本之前的Master-Thread"><a href="#InnoDB-1-2-x版本之前的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本之前的Master Thread"></a>InnoDB 1.2.x版本之前的Master Thread</h4><p>v1.0.x对于IO有限制，向磁盘刷新时做了一定的硬编码（刷新数固定值），限制了对磁盘IO的性能，尤其是写入性能。v1.0.x开始提供参数innnodb_io_capacity，用来表示磁盘IO的吞吐量，默认值200，对于刷新到磁盘的页的数量，按照innnodb_io_capacity的百分比来进行控制：</p><ul><li>合并插入缓冲时，合并插入缓冲的数量为innnodb_io_capacity值的5%；</li><li>从缓冲区刷新脏页到时，刷新脏页的数量为innnodb_io_capacity。</li></ul><p>参数innodb_max_dirty_pages_pct默认值为90，当内存很大，或者数据库服务的压力很大，刷新脏页的速度会降低，数据库恢复时需要更多的时间。设置过低时会增加磁盘IO压力。v1.0.x开始，默认值设置为75，和Google测试的最优值80接近。</p><p>引入参数innodb_adaptive_flushing（自适应刷新）。愿刷新规则：大于innodb_max_dirty_pages_pct时，刷新100个脏页， 否则不刷新脏页。引入后通过名为buf_flush_get_desired_flush_rate函数（通过判断产生重做日志redo log的速度来决定最合适的刷新脏页数量）判断需要刷新脏页最合适的数量。当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。</p><p>引入参数innodb_purge_batch_size，控制每次full purge回收的Undo页的数量，之前最多回收20个Undo页，该参数默认值20(用的mysql 5.7.22，默认值300)，可动态地对其进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 300</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; set global innodb_purge_batch_size=320;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 320</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可由命令<code>SHOW ENGINE INNODB STATUS</code>查看当前Master Thread的状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">...</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 2 srv_active, 0 srv_shutdown, 139324 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 139319</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="InnoDB-1-2-x版本的Master-Thread"><a href="#InnoDB-1-2-x版本的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本的Master Thread"></a>InnoDB 1.2.x版本的Master Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if InnoDD is idle</span><br><span class="line">  srv_master_do_idle_tasks(); //每10s的操作</span><br><span class="line">else </span><br><span class="line">  srv_master_do_active_tasks(); //每秒的操作</span><br></pre></td></tr></table></figure><p>刷新脏页的操作，从Master Thread线程分离到单独的Page Cleaner Thread。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>和数据页一样，是物理页的一个组成部分。</p><p>插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取，这类插入操作速度是非常快的。但并不是所有的主键插入都是顺序的，若主键是UUID类，则插入和辅助索引一样，同样是随机的。即使主键是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。</p><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作（在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><p>Insert Buffer的使用需要同时满足两个条件：</p><ul><li>索引是辅助索引（secondary index）；</li><li>索引不是唯一（unique）的。</li></ul><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看插入缓冲的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行：size代表已合并记录页的数量；free list len代表空闲列表的长度；seg size显示当前Insert Buffer的大小为14*16k；merges代表合并的次数。</p><p>写密集情况下，插入缓冲会占用过多的缓冲池内存，默认最大可占用1/2。可通过修改<code>IBUF_POOL_SIZE_PER_MAX_SIZE</code>对插入缓冲的大小进行控制。将其修改为3则最大只能使用1/3的缓冲池内存。</p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p><p>同Insert Buffer，Change Buffer适用的对象依然是非唯一的辅助索引。</p><p>对一条记录进行UPDATE操作可能分为两个过程：</p><ul><li>将记录标记为已删除；</li><li>真正将记录删除。</li></ul><p>Delete Buffer对应操作的第一个过程，Purge Buffer对应操作的第二个过程。通过参数<code>innodb_change_buffering</code>开启各种Buffer的选项，可选：inserts、deletes、purges、changes、all、none。changes表示启用inserts和deletes、all表示启用所有，none表示都不启用。</p><p>通过<code>innodb_change_buffer_max_size</code>来控制Change Buffer最大使用内存的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_change_buffer_max_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_change_buffer_max_size</span><br><span class="line">        Value: 25</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>默认值为25，表示最多使用1/4（25%）的缓冲池内存空间，最大有效值50。</p><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>insert表示Insert Buffer；delete mark表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时无需再将记录合并到辅助索引中。</p><h5 id="Insert-Buffer的内部实现"><a href="#Insert-Buffer的内部实现" class="headerlink" title="Insert Buffer的内部实现"></a>Insert Buffer的内部实现</h5><p>Insert Buffer的数据结构是一棵B+树，MySQL v4.1前每张表有一棵Insert Buffer B+树，现版本全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。存放在共享表空间中，默认ibdata1中。在试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败，因为表的辅助索引中的数据可能还在Insert Buffer中，即共享表空间中。</p><p>Insert Buffer非叶节点存放查询的search key（键值）。</p><p>search key一共占用9个字节，space表示待插入记录所在表的表空间id，InnoDB存储引擎中每个表有一个唯一的space id，可通过space id查询得知是哪张表。space占用4字节。marker占用1字节，用于兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。</p><p>当辅助索引要插入到页（space，offset）时，若页不在缓冲池中，则首先根据上述规则构造一个search key，然后查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。<br>插入到Insert Buffer B+树叶子节点的记录，需要根据规则进行构造。</p><blockquote><p>space | marker | offset | metadata |{ secondary index record}|</p></blockquote><p>metadata占用4字节，存储内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">字节 </th></tr></thead><tbody><tr><td style="text-align:center">IBUF_REC_OFFSET_COUNT</td><td style="text-align:center">2 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_TYPE</td><td style="text-align:center">1 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_FLAGS</td><td style="text-align:center">1  </td></tr></tbody></table><p>IBUF_REC_OFFSET_COUNT保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。第五列开始是实际插入记录的各个字段。</p><p>启用Insert Buffer索引后，辅助索引页中的记录可能被插入到Insert Buffer B+树中，为保证每次Merge Insert Buffer页必须成功，需要特殊页用来标记每个辅助索引页（sapce，page_no）的可用空间。该页类型为Insert Buffer Bitamp。</p><p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）。每个Insert Buffer Bitmap页在16384个页的第二个页中。</p><p>每个辅助索引页在Insert Buffer Bitmap页中占用4位，由三部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">IBUF_BITMAP_FREE</td><td style="text-align:center">2</td><td style="text-align:center">表示该辅助索引页中的可用空间数量，可取值0，1，2，3。0表示无可用剩余空间；1表示剩余空间大于1/32页（512字节）</td></tr><tr><td style="text-align:center">IBUF_BITMAP_BUFFERED</td><td style="text-align:center">1</td><td style="text-align:center">1表示该辅助索引页有记录被缓存在Insert Buffer B+树中</td></tr><tr><td style="text-align:center">IBUF_BITMAP_IBUF</td><td style="text-align:center">1</td><td style="text-align:center">1表示该页为Insert Buffer B+树的索引页</td></tr></tbody></table><h5 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h5><p>Merge Insert Buffer的操作发生在：</p><ul><li>辅助索引页被读取到缓冲池时，例如执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中，若有则将Insert Buffer B+树中该页的记录插入到该辅助索引页中；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时，若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则强制进行一个合并操作（强制读取辅助索引页），将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中；</li><li>Master Thread，每秒和每10秒进行一次的Merger Insert Buffer操作。</li></ul><p>Mater Thread根据<code>srv_innodb_io_capactity</code>的百分比来决定真正要合并多少个辅助索引页。</p><p>Insert Buffer B+ Tree中，辅助索引页根据（space，offset）都已排序好，根据（space，offset）的排序顺序进行页的选择。</p><h4 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h4><p>doublewrite保障InnoDB存储引擎数据页的可靠性。</p><p>若发生写失效，可以通过重做日志进行恢复，但重做日志记录的是对页的物理操作，若页本身已损坏，则再对其重做是无意义的。在应用重做日志之前，需要一个页的副本，当写失效发生时，先通过页的副本还原页，在进行重做，即doublewrite。</p><p>doublewrite由两部分组成：内存中的doublewrite buffer，大小为2MB；物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小为2MB。</p><p>在对缓冲池的脏页进行刷行时，并不直接写磁盘，会先通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。因为doublewrite页连续，过程是顺序写的，开销不大。完成doublewrite页的写入后，再将doublewrite buufer中的页写入各个表空间文件中，此时写入则是离散的，</p><p>通过<code>SHOW GLOBAL STATUS LIKE &#39;innodb_dblwr%&#39;</code>观察doublewrite的运行情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;innodb_dblwr%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 269936</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 26401</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>表示一共写了269936个页，实际写入次数26401，<code>Innodb_dblwr_pages_written:Innodb_dblwr_writes</code>比例10:1。若系统高峰时远小于64:1，说明系统写入压力不是很高。</p><p>若操作系统在写入磁盘过程发生崩溃，在恢复时InnoDB先从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p><p>通过命令<code>SHOW BLOBAL STATUS like &#39;Innodb_buffer_pool_pages_flushed&#39;</code>查看当前从缓冲池中刷新到磁盘页的数量。该变量和<code>Innodb_dblwr_pages_written</code>一致。MySQL 5.5.24版本之前，<code>Innodb_buffer_pool_pages_flushed</code>总是<code>Innodb_dblwr_pages_written</code>的2倍，之后才被修复，统计数据库在生产环境中写入的量，最安全的方法是根据<code>Innodb_dblwr_pages_written</code>来进行统计。</p><p>参数<code>skip_innnodb_doublewrite</code>可以禁用doublewrite功能，可能发生写失效问题，若有多个从服务器（slave server），需要提供较快的性能（在slave server上做RAID0），启用该参数是一个办法。对于需要提供数据高可用性的主服务器（master server），任何时候都应确保开启doublewrite功能。</p><p>有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统，可不用开启doublewrite。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。&lt;/p&gt;
&lt;h3 id=&quot;InnoDB体系架构&quot;&gt;&lt;a href=&quot;#InnoDB体系架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系架构&quot;&gt;&lt;/a&gt;Inno
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构和存储引擎</title>
    <link href="bighua.top/2019/01/10/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/10/MySQL体系结构和存储引擎/</id>
    <published>2019-01-10T09:07:34.000Z</published>
    <updated>2019-01-15T07:27:51.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h3><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>实例：MySQL数据库由后台线程以及一个共享内存区组成。</li></ul><p>MySQL设计为单进程多线程架构，数据库实例在系统上表现为一个进程。</p><p>启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例，没有配置文件时，按照编译时的默认参数设置启动实例。使用<code>mysql --help | grep my.cnf</code>查看启动时从哪些位置查找配置文件。当几个配置文件都有同一个参数，MySQL数据库以读取到的最后一个配置文件中的参数为准。</p><p>配置文件参数<code>datadir</code>指定了数据库所在的路径。linux操作系统下默认为<code>/usr/local/mysql/data</code>，该路径只是一个链接，指向<code>/opt/mysql_data</code>目录，必须保证该目录的用户和权限使mysql用户和组可以访问。</p><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>MySQL组成部分：  </p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（cache）组件</li><li>插件式存储引擎</li><li><p>物理文件</p><p>区别于其他数据库的重要特点是插件式的表存储引擎。MySQL插件式存储引擎架构提供一系列标准的管理和服务支持，这些标准与存储引擎本身无关，存储引擎是底层物理结构的实现。存储引擎是基于表的，而不是数据库。</p></li></ul><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。用户可以根据MySQL预定义的存储引擎接口编写自己的存储引擎。</p><p>通过<code>SHOW ENGINES</code>语句或者通过查找<code>information_schema</code>架构下的ENGINES表，查看当前使用的MySQL数据库所支持的存储引擎。</p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，设计目标面向在线事务处理的应用。行锁设计、支持外键，支持类似Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB存储引擎将数据放在一个逻辑的表空间中，表空间由InnoDB存储引擎自身进行管理。每个InnoDB存储引擎的表单独存放到一个ibd文件中。InnoDB存储引擎支持用裸设备（row disk）来建立其表空间。</p><p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发，实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。使用被称为next-key locking策略避免幻读现象的产生。还提供了插入缓存（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p><p>InnoDB存储引擎采用聚集（clustered）的方式存储表中的数据，每张表的存储都是按主键的顺序进行存放。当没有显示的指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务，支持全文索引，表锁设计，主要面向一些OLAP数据库应用。MyISAM存储引擎的缓冲池只缓存索引文件，而不缓存数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用<code>myisampack</code>工具进一步压缩数据文件，因myisampack工具使用哈夫曼编码静态算法来压缩数据，所以压缩后的表是只读的，也可以使用myisampack工具解压数据文件。</p><p>V5.0前MyISAM默认支持的表大小为4GB，制定MAX_ROWS和AVG_ROW_LENGTH属性拓展为大于4GB的表。V5.0及以后，默认支持256TB的表单数据。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。</p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -h 127.0.0.1 -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>通过TCP/IP连接到MySQL实例时，MySQL会先检查一张权限视图，判断发起请求的客户端IP是否允许连接到MySQL实例。视图在mysql结构下，表名为<code>user</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show columns from user;</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</span><br><span class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Insert_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Update_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Delete_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Drop_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Reload_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Shutdown_priv          | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Process_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| File_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Grant_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| References_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Index_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_db_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Super_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tmp_table_priv  | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Lock_tables_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Execute_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_slave_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_client_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_view_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_view_priv         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_routine_priv    | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_routine_priv     | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_user_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Event_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Trigger_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| ssl_type               | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO   |     |                       |       |</span><br><span class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</span><br><span class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</span><br><span class="line">| password_expired       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</span><br><span class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</span><br><span class="line">| account_locked         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">45 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host,user,password_expired FROM user;</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| host      | user          | password_expired |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| localhost | root          | N                |</span><br><span class="line">| localhost | mysql.session | N                |</span><br><span class="line">| localhost | mysql.sys     | N                |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h4><p>Win 2000、Win XP、Win 2003和Win Vista以及在此之上的平台，若两个需要进程通信的进程在同一台服务器上，可以使用命名管道。MySQL数据库须在配置文件中启用–enable-named-pipe。V4.1后提供共享内存的连接方式，须在配置文件中添加–shared-memory，在连接时客户端还必须使用–protocol=memory选项。</p><h4 id="UNIX套接字"><a href="#UNIX套接字" class="headerlink" title="UNIX套接字"></a>UNIX套接字</h4><p>Linux和UNIX环境下，可以使用UNIX域套接字，因其非网络协议，只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径<code>--socket=/tmp/mysql.sock</code>。</p><p>查询UNIX域套接字文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;socket&apos;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| socket        | /tmp/mysql.sock |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用UNIX域套接字方式进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -uroot -S /tmp/mysql.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义数据库和实例&quot;&gt;&lt;a href=&quot;#定义数据库和实例&quot; class=&quot;headerlink&quot; title=&quot;定义数据库和实例&quot;&gt;&lt;/a&gt;定义数据库和实例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库：物理操作系统文件或其他形式文件类型的集合。&lt;/li&gt;
&lt;li&gt;实例：My
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战笔记</title>
    <link href="bighua.top/2018/11/19/Netty%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>bighua.top/2018/11/19/Netty实战笔记/</id>
    <published>2018-11-19T06:30:29.000Z</published>
    <updated>2018-11-19T06:35:14.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写Echo服务器"><a href="#编写Echo服务器" class="headerlink" title="编写Echo服务器"></a>编写Echo服务器</h2><h3 id="ChannelHandler和业务逻辑"><a href="#ChannelHandler和业务逻辑" class="headerlink" title="ChannelHandler和业务逻辑"></a>ChannelHandler和业务逻辑</h3><p>响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写Echo服务器&quot;&gt;&lt;a href=&quot;#编写Echo服务器&quot; class=&quot;headerlink&quot; title=&quot;编写Echo服务器&quot;&gt;&lt;/a&gt;编写Echo服务器&lt;/h2&gt;&lt;h3 id=&quot;ChannelHandler和业务逻辑&quot;&gt;&lt;a href=&quot;#Channe
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>世事无常</title>
    <link href="bighua.top/2018/11/04/%E4%B8%96%E4%BA%8B%E6%97%A0%E5%B8%B8/"/>
    <id>bighua.top/2018/11/04/世事无常/</id>
    <published>2018-11-04T12:54:26.000Z</published>
    <updated>2019-03-31T15:20:05.855Z</updated>
    
    <content type="html"><![CDATA[<p>记2018-11-04，悼念三叔！</p><p>总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无常的世界，然后一点一点平息自己的思绪，使自己接受现实，最后慢慢的消化在内心，做到不外露一点情绪！</p><p>我不敢想象老家没有你了会是怎样，高三的堂弟、初入社会心思单纯的堂妹、年迈的爷爷、指望不上的大爹家，远离老家很多事帮不上忙的我们，以后三婶在老家要承担怎样的重担渡过这些日子，想想就揪心。</p><p>如果可以在身边选择一个最适合父亲的角色，我觉得是你。只有你最关注子辈的内心，在意孩子的想法，注重子辈多方面的培养教育。对比常年在外打工只给予我生活费关怀的老爸，可以说是你，在我心目中对父亲的角色有了该有的模样。对堂弟寄予厚望的你，怎么忍心被这次意外带走，还有好多次成绩没向你汇报、还没为他操心高考后的学校和专业、还没同意他找女朋友呢…</p><p>还想着以后能再回老家过元宵节，再跟着你去认祖坟送亮；过春节中午在我家吃，然后去你家吃年夜饭；跟着你去拜年走亲戚，去看斗地主炸金花；跟着你去山里伐几颗松树用作冬天取暖的柴火，然后交给我一颗小的背回家；跟着你学习人生经验，如何处理好人和事…可是这以后都没有了，都停留在回忆里了。</p><p>中午收到老爸发过来的消息，震惊意外，不敢相信。大姐打过来的视频，猜到肯定是为了此事，不愿意接听，宁愿今天是做了一个梦，而我还没醒。直到晚上二姐多次挂过来视频，才交谈起此事，聊起话题一想起这个事实，鼻子不由自主的酸楚。</p><p>记得13年秋，我高三时，突然接到通知家里有事，在回家的车上，虽然没有任何人告知我发生了什么，但我知道肯定是我某个亲人不在了，心中异常忐忑，眼泪止不住的流。直到车停在家门口，看到一个个花圈，搭起的灵台，奶奶的遗像，此时声音也控制不住了，眼泪也肆无忌惮起来。如今是你，还有很多的事情等着你去解决去承担，怎么舍得离去，我不敢相信，也不能接受…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记2018-11-04，悼念三叔！&lt;/p&gt;
&lt;p&gt;总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="天堂安好" scheme="bighua.top/tags/%E5%A4%A9%E5%A0%82%E5%AE%89%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>Netty的核心组件</title>
    <link href="bighua.top/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>bighua.top/2018/11/02/Netty的核心组件/</id>
    <published>2018-11-02T06:42:46.000Z</published>
    <updated>2018-11-19T06:31:51.902Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《netty实战》，初识netty的一些笔记。</p><p>异步、事件驱动。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Java NIO的一个基本构造。</p><blockquote><p>代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。</p></blockquote><p>可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>一个指向已经被提供给另一个方法的方法的引用。使得后者可以调用前者。</p><p>Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interface ChannelHandler的实现处理。</p><p>当一个新的连接已经被建立，ChannelHandler的channelActive()回调方法将会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>提供了另一种在操作完成时通知应用程序的方式。可以看作是一个异步操作的结果的占位符；将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK预置的interface java.util.concurrent.Future提供的实现只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供额外的方法，使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个Netty的出站I/O操作都将返回一个ChannelFuture，它们都不会阻塞。</p><p>ChannelFuture作为一个I/O操作的一部分返回。connect()方法将会直接返回，而不会阻塞，调用将会在后台完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"></span><br><span class="line">ChannelFuture future = Channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));</span><br></pre></td></tr></table></figure><p>利用ChannelFutureListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));异步连接到远程节点</span><br><span class="line">future.addListener(new ChannelFutureListener() &#123;//注册一个ChannelFutureListener，在操作完成时获得通知</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;//检查操作的状态</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="事件和ChannelHandler"><a href="#事件和ChannelHandler" class="headerlink" title="事件和ChannelHandler"></a>事件和ChannelHandler</h4><p>Netty使用不同的事件来通知状态的改变或者是操作的状态。能够基于已经发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据流转换；</li><li>流控制；</li><li>应用程序逻辑。</li></ul><p>Netty的事件是按照它们与入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：</p><ul><li>连接已被激活或者连接失活；</li><li>数据读取；</li><li>用户事件；</li><li>错误事件。</li></ul><p>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：</p><ul><li>打开或者关闭到远程节点的连接；</li><li>将数据写到或者冲刷到套接字。</li></ul><p>每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法（将事件驱动范式直接转换为应用程序构件块）。</p><p> Netty的ChannelHandler为处理器提供了基本的抽象。每个ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="Future、回调和ChannelHandler"><a href="#Future、回调和ChannelHandler" class="headerlink" title="Future、回调和ChannelHandler"></a>Future、回调和ChannelHandler</h4><p>Netty异步编程模型建立在Future和回调之上，将事件派发到ChannelHandler的方法发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，需要提供回调或者利用操作所返回的Future。</p><h4 id="选择器、事件和EventLoop"><a href="#选择器、事件和EventLoop" class="headerlink" title="选择器、事件和EventLoop"></a>选择器、事件和EventLoop</h4><p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来将需要手动编写的派发代码。在内部，会为每个Channel分配一个EventLoop，用以处理所有事件，包括：</p><ul><li>注册感兴趣的事件；</li><li>将事件派发给ChannelHandler；</li><li>安排进一步的动作。</li></ul><p>EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。此设计消除了可能有的在ChannelHandler实现中需要进行同步的任何顾虑，只需专注于提供正确的逻辑，用来在感兴趣的数据要处理的时候执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读《netty实战》，初识netty的一些笔记。&lt;/p&gt;
&lt;p&gt;异步、事件驱动。&lt;/p&gt;
&lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Channel
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>web服务</title>
    <link href="bighua.top/2018/10/12/web%E6%9C%8D%E5%8A%A1/"/>
    <id>bighua.top/2018/10/12/web服务/</id>
    <published>2018-10-12T06:41:00.000Z</published>
    <updated>2019-03-31T15:20:08.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h3><blockquote><p>一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互操作机器间交互提供支持。每个web服务都拥有一套自己的接口，由一种名为Web服务描述语言的机器可处理格式描述。其他系统需要根据Web服务的描述，适用SOAP消息与Web服务交互。SOAP消息常被序列化为XML并通过HTTP传输。</p></blockquote><p>存在着多种不同类型的Web服务，其中包括基于SOAP的、基于REST的以及基于XML-RPC的，基于REST的和基于SOAP的Web服务最为流行。企业级系统大多数都是基于SOAP的Web服务实现，公开可访问的Web服务更青睐基于REST的Web服务。</p><p>基于SOAP的Web服务由功能驱动，基于REST的Web服务由数据驱动。基于SOAP的Web服务往往是RPC风格；基于REST的Web服务关注的是资源，HTTP方法是对这些资源执行操作的动词。</p><h3 id="基于SOAP的Web服务"><a href="#基于SOAP的Web服务" class="headerlink" title="基于SOAP的Web服务"></a>基于SOAP的Web服务</h3><p>SOAP（Simple Object Access Protocol：简单对象访问协议）是一种协议，用于交换定义在XML里面的结构化数据。能够跨越不同的网络协议并在不同的编程模式中使用，其处理的并不是对象，已经不再代表Simple Object Access Protocol。</p><p>SOAP高度结构化，需要严格地进行定义，用于传输数据的XML可能会变的非常复杂。WSDL是客户端与服务器之间的契约，定义了服务提供的功能以及提供这些功能的方式，服务的每个操作以及输入/输出都需要由WSDL明确地定义。</p><p>SOAP将报文内容放入到信封里面，信封相当于一个运输容器，并且它还能够独立于实际的数据传输方式存在。</p><p>经过简化的SOAP请求报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /GetComment HTTP/1.1</span><br><span class="line">Host: www.chitchatcom</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.chitchat.com/forum&quot;&gt;</span><br><span class="line">&lt;m:GetCommentRequest&gt;</span><br><span class="line">&lt;m:CommentId&gt;123&lt;/m:CommentID&gt;</span><br><span class="line">&lt;/m:GetCommentRequest&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>简化后的SOAP响应报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3/org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">&lt;m:GetCommentResponse&gt;</span><br><span class="line">&lt;m:Text&gt;Hello World!&lt;/m:Text&gt;</span><br><span class="line">&lt;/m:GetCommentResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:envelope&gt;</span><br></pre></td></tr></table></figure><p>SOAP 1.2允许通过HTTP的Get方法发送SOAP报文，但大多数基于SOAP的Web服务都是通过HTTP的POST方法发送SOAP报文的。</p><p>一个基于SOAP的Web服务越复杂，对应的WSDL报文就越冗长。实际中SOAP请求报文通常会由WSDL生成的SOAP客户端负责生成，SOAP响应报文通常也是由WSDL生成的SOAP服务器负责生成。</p><h3 id="基于REST的Web服务"><a href="#基于REST的Web服务" class="headerlink" title="基于REST的Web服务"></a>基于REST的Web服务</h3><p>REST（Representational State transfer，具象状态传输）是一种设计理念，用于设计通过标准的几个动作来操纵资源，并以此来进行互相交流的程序（将操纵资源的动作称为“动词”，即verb）。</p><p>REST并不把函数暴露为可调用的服务，而是以资源（resource）的名义把模型暴露出来，允许通过少数几个称为动词的动作来操纵这些资源。</p><p>使用HTTP协议实现REST服务，URL将用于表示资源，HTTP方法则会用作操纵资源的动词。如表所示：</p><table><thead><tr><th style="text-align:left">HTTP方法</th><th style="text-align:left">作用</th><th style="text-align:left">使用实例</th></tr></thead><tbody><tr><td style="text-align:left">POST</td><td style="text-align:left">在一项资源尚未存在的情况下创建该资源</td><td style="text-align:left">POST /users</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">获取一项资源</td><td style="text-align:left">GET /users/1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">重新给定URL上的资源</td><td style="text-align:left">PUT /users/1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除一项资源</td><td style="text-align:left">DELETE /users/1</td></tr></tbody></table><p>POST和PUT的区别在于，PUT需要准确地知道哪一项资源将会被替换，使用POST只会创建出一项新资源以及一个新的URL。POST用于创建一项全新的资源，PUT用于替换一项已经存在的资源。</p><p>REST不经只能通过这几个HTTP方法实现，如可以使用PATCH方法对一项资源进行部分更新。使用REST API的时候通常都是返回JSON，或者返回一些比SOAP报文要简单得多的XML，很少返回SOAP报文。</p><p>基于REST的Web服务也拥有相应的WADL（Web Applicaton Description Language，Web应用描述语言），可以对基于REST的Web服务进行描述，能够生成访问这些服务的客户端。</p><p>REST设计理念适用于只执行简单的CURD操作的应用，适用于更为复杂的服务可以通过如下两个方法对过程或者动作进行建模。</p><h4 id="将动作转化为资源"><a href="#将动作转化为资源" class="headerlink" title="将动作转化为资源"></a>将动作转化为资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /user/123/activation HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;data&quot;:&quot;2018-10-13T17:12:12Z&quot; &#125;</span><br></pre></td></tr></table></figure><p>将创建一个被激活的资源（activation resource），表示用户的激活状态，可以为激活的资源添加额外的属性。</p><h4 id="将动作转换为资源的属性"><a href="#将动作转换为资源的属性" class="headerlink" title="将动作转换为资源的属性"></a>将动作转换为资源的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH /user/123 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;active&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>把用户的active属性设置为true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web服务&quot;&gt;&lt;a href=&quot;#web服务&quot; class=&quot;headerlink&quot; title=&quot;web服务&quot;&gt;&lt;/a&gt;web服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="web服务" scheme="bighua.top/tags/web%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOAP" scheme="bighua.top/tags/SOAP/"/>
    
      <category term="REST" scheme="bighua.top/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>jenkins初探</title>
    <link href="bighua.top/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/"/>
    <id>bighua.top/2018/10/08/jenkins初探/</id>
    <published>2018-10-08T11:33:45.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档<a href="https://www.kancloud.cn/louis1986/jenkins/481896" target="_blank" rel="noopener">Jenkins学习文档</a>，<a href="https://blog.csdn.net/sms15732621690/article/details/71336224" target="_blank" rel="noopener">CentOS7Jenkins安装</a></p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget http://soft.51yuki.cn/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo vim /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_131/</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib.tools.jar</span><br><span class="line">PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  sudo sh /etc/profile.d/jdk.sh</span><br><span class="line">[wuhua@VM_0_10_centos local]$ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>浏览器中输入<code>ip:8080</code></p><p>获取登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>参考<a href="https://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文档&lt;a href=&quot;https://www.kancloud.cn/louis1986/jenkins/481896&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins学习文档&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="持续集成" scheme="bighua.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="jenkins" scheme="bighua.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>redis-整数集合</title>
    <link href="bighua.top/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>bighua.top/2018/09/13/redis-整数集合/</id>
    <published>2018-09-13T13:42:03.000Z</published>
    <updated>2018-10-30T11:56:56.983Z</updated>
    
    <content type="html"><![CDATA[<p>是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>是redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>由intset.h/intset结构表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">unint32_t encoding;//编码方式</span><br><span class="line">unint32_t length;//集合包含的元素数量</span><br><span class="line">int8_t contents[];//保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，数组中各项按值从小到大排列，且数组中不包含重复项。</p><p>length属性记录整数集合包含的元素数量，即contents数组的长度。</p><p>contents数组的真正类型取决于encoding属性的值。</p><p>根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>将新元素添加到整数集合里面且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后将新元素添加到整数集合里面。</p><p>升级过程：</p><ul><li>根据新元素的类型，拓展整数集合底层数组的空间大小，并未新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置上，在放置的过程中维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组中。</li></ul><p>引发升级的新元素的长度总是比整数集合现在所有元素的长度都大，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。前者将新元素放置在底层数组的最开头（索引0），后者将新元素放置在底层数组的最末尾（索引length-1）。</p><blockquote><p>升级策略能提升整数集合的灵活性，尽可能地节约内存。</p></blockquote><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><p>整数集合操作API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">intsetNew</td><td style="text-align:left">创建一个新的压缩列表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetAdd</td><td style="text-align:left">将给定元素添加到整数集合里</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetRemove</td><td style="text-align:left">从整数集合中移除给定元素</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetFind</td><td style="text-align:left">检查给定值是否存在于集合</td><td style="text-align:left">O(logN)，二分查找法</td></tr><tr><td style="text-align:left">intsetRandom</td><td style="text-align:left">从整数集合中随机返回一个元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetGet</td><td style="text-align:left">取出底层数组在给定索引上的元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetLen</td><td style="text-align:left">返回整数集合包含的元素的个数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetBlobLen</td><td style="text-align:left">返回整数集合占用的内存字节数</td><td style="text-align:left">O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="intset" scheme="bighua.top/tags/intset/"/>
    
  </entry>
  
  <entry>
    <title>redis-跳跃表</title>
    <link href="bighua.top/2018/09/12/redis-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>bighua.top/2018/09/12/redis-跳跃表/</id>
    <published>2018-09-12T13:37:34.000Z</published>
    <updated>2018-10-30T11:56:56.973Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。支持平均O(logN)，最坏O(N)复杂度的节点查找。可以通过顺序性操作来批量处理节点。</p><p>redis使用跳跃表作为有序集合键的底层实现之一，若有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>redis只在实现有序集合键和在集群节点用作内部数据结构用到跳跃表。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，前者用于表示跳跃表节点，后者用于保存跳跃表节点的相关信息，例如节点的数量、指向表头节点和表尾节点的指针等。</p><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>由redis.h/zskiplistNode结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">struct zskiplistLevel &#123;</span><br><span class="line">struct zskiplistNode *forward;//前进指针</span><br><span class="line">unsigned int span;//跨度</span><br><span class="line">&#125; level[];//层</span><br><span class="line">struct zskiplistNode *backward;//后退指针</span><br><span class="line">double score;//分值</span><br><span class="line">robj *obj;//成员对象</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ul><li>level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，可通过这些层加快访问其他节点的速度，一般层数量越多访问其他节点的速度越快。每创建一个新跳跃表节点的时候，程序根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小，即层的高度。</li><li>每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。</li><li>跨度用于记录两个节点之间的距离，跨度越大，节点间距离越远，指向NULL的所有前进指针的跨度都为0。实际上用来计算排位（rank），在查找某个节点的过程中，将沿途访问过的所有层的跨度累计，得到的结果就是目标节点在跳跃表中的排位。</li><li>后退指针用于从表尾向表头方向访问节点，每个节点中有一个后退节点，每次只能后退至前一个节点。</li><li>分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序，成员对象是一个指针，指向一个字符串对象，字符串对象则保存着一个SDS值。同一跳跃表中，各个节点保存的成员对象必须是唯一的，多个节点保存的分值可以相同：分值相同的节点按照成员对象在字典序中的大小进行排序，成员对象较小的节点排在前面。</li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>由redis.h/zskiplist结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">struct zskiplistNode *header, *tail;//表头节点和表尾节点</span><br><span class="line">unsigned long length;//表中节点的数量</span><br><span class="line">int level;//表中层数最大节点的层数</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h3 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h3><p>跳跃表的所有操作API:</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">zslCreate</td><td style="text-align:left">创建一个新的跳跃表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">zslFree</td><td style="text-align:left">释放给定跳跃表以及表中包含的所有节点</td><td style="text-align:left">O(N)，N为跳跃表的长度</td></tr><tr><td style="text-align:left">zslInsert</td><td style="text-align:left">将包含给定成员和分值的新节点添加到跳跃表中</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDelete</td><td style="text-align:left">删除跳跃表中包含给定成员和分值的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetRank</td><td style="text-align:left">返回包含给定成员和分值的节点在跳跃表中的排位</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetElementByRank</td><td style="text-align:left">返回跳跃表在给定排位上的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslIsInRange</td><td style="text-align:left">判断跳跃表中是否有节点的分值在给定分值范围内</td><td style="text-align:left">O(1）</td></tr><tr><td style="text-align:left">zslFirstInrange</td><td style="text-align:left">返回跳跃表中第一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslLastInrange</td><td style="text-align:left">返回跳跃表中最后一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDeleteRangeByScore</td><td style="text-align:left">删除跳跃表中所有在给定分值范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr><tr><td style="text-align:left">zslDeleteRangeByRank</td><td style="text-align:left">删除跳跃表中所有在给定排位范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。支持平均O(logN)，最坏O(N)复杂度的节点查找。可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt;redis使用跳跃表作为有序集合键的底层实现之一，若有序集合包含的元素数量
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="skiplist" scheme="bighua.top/tags/skiplist/"/>
    
  </entry>
  
  <entry>
    <title>redis-字典</title>
    <link href="bighua.top/2018/09/10/redis-%E5%AD%97%E5%85%B8/"/>
    <id>bighua.top/2018/09/10/redis-字典/</id>
    <published>2018-09-10T13:30:23.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>又称符号表、关联数组或映射，一种用于保存键值对的抽象数据结构。</p><p>一个键可以和一个值进行关联，字典中的每个键都是独一无二的，通过键查找与之关联的值、更新值或删除整个键值对。</p><p>redis构建了自己的字典实现，redis数据库使用字典作为底层实现，对数据库的增、删、改、查操作也是构建在对字典的操作之上。字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>redis字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>由dict.h/dictht结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;//哈希表数组</span><br><span class="line">unsigned long size;//哈希表大小</span><br><span class="line">unsigned long sizemask;//哈希表大小掩码，用于计算索引值，等于size-1</span><br><span class="line">unsigned long used;//该哈希表已有节点的数量</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。</p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">void *key;//键</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v; //值</span><br><span class="line">struct dictEntry *next;//指向下个哈希表节点，形成链表</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>next属性是一个指向哈希表节点的指针，可以将多个哈希表值相同的键值对链接在一起，以此来解决键冲突的问题。</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>由dict.h/dict结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">dictType *type;//类型特定函数</span><br><span class="line">void *privdata;//私有数据</span><br><span class="line">dictht ht[2];//哈希表</span><br><span class="line">int rehashidx;//rehash索引，当rehash不再进行时，值为-1  </span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">unsigned int (*hashFunction)(const void *key);//计算哈希值的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);//复制键的函数</span><br><span class="line">void *(*valDup)(void *privdata, const void *key);//复制值的函数</span><br><span class="line">int (*keyCompare)(void *privdata, const void *key1, const void *key2);对比键的函数</span><br><span class="line">void (*keyDestructor)(void *privdata, void *key);//销毁键的函数</span><br><span class="line">void (*valDestructor)(void *privdata, void *obj);//销毁值的函数</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p><p>rehashidx属性记录rehash目前的进度，若没有在进行rehash，则值为-1。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>redis计算哈希值和索引值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">//使用哈希表的sizemask属性和哈希值，计算出索引值</span><br><span class="line">//ht[x]根据情况选择ht[0]和ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算哈希值。</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量键被分配到了哈希数组的同一个索引上面时，称这些键发生了冲突。</p><p>redis的哈希表使用链表链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以使用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单项链表连接起来，解决键冲突问题。速度考虑，程序总是将新节点添加到链表的表头位置，排在其他已有节点的前面。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>为让哈希表的负载因子维持在一个合理的范围之内，哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的拓展或者收缩，通过执行rehash（重新散列）操作来完成。步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，哈希表的空间的大小取决于要执行的操作，以及ht[0]当前包含的键值对数量。</li><li>若执行的是扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2^n;<br>若执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。<br>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash重新计算键的哈希值和索引，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]表变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash作准备。</li></ol><p><code>哈希表的拓展和收缩</code>：</p><blockquote><p>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。<br>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。<br>哈希表的负载因子计算公式：<br> 负载因子 = 哈希表已保存节点数量 / ht[0].size<br> load_factor = ht[0].used / ht[0].size</p></blockquote><p>根据BGSAVE命令和BGREWRITEAOF命令是否正在执行，服务器执行拓展操作所需的负载因子并不相同。在执行BGSAVE命令或者BGREWRITEAOF命令的过程中，redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，在子进程存在期间，服务器会提高执行拓展操作所需的负载因子，尽可能地避免在子进程存在期间进行哈希表拓展操作，避免不必要的内存写入操作，节约内存。</p><p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，为避免数据量过大rehash对服务器性能造成影响，rehash动作是分多次、渐进式地完成的，当数据量过大时将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，避免了集中式rehash而带来的庞大计算量。</p><p>哈希表渐进式rehash的步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已经完成。</li></ol><p>在渐进式rehash执行期间，字典的删除、查找、更新等操作会在两个哈希表上进行，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何操作。</p><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><p>字典的主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">dictCreate</td><td style="text-align:left">创建一个新的字典</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictAdd</td><td style="text-align:left">将给定的键值对添加到字典里面</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictReplace</td><td style="text-align:left">将给定的键值对添加到字典里面，如果键已经存在于字典，用新值取代原有的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictFetchValue</td><td style="text-align:left">返回给定键的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictGetRandomKey</td><td style="text-align:left">从字典中随机返回一个键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictDelete</td><td style="text-align:left">从字典中删除给定键所对应键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictRelease</td><td style="text-align:left">释放给定字典，以及字典中包含的所有键值对</td><td style="text-align:left">O(N)，N为字典包含的键值对数量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又称符号表、关联数组或映射，一种用于保存键值对的抽象数据结构。&lt;/p&gt;
&lt;p&gt;一个键可以和一个值进行关联，字典中的每个键都是独一无二的，通过键查找与之关联的值、更新值或删除整个键值对。&lt;/p&gt;
&lt;p&gt;redis构建了自己的字典实现，redis数据库使用字典作为底层实现，对数
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="dict" scheme="bighua.top/tags/dict/"/>
    
      <category term="字典" scheme="bighua.top/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>redis-链表</title>
    <link href="bighua.top/2018/09/09/redis-%E9%93%BE%E8%A1%A8/"/>
    <id>bighua.top/2018/09/09/redis-链表/</id>
    <published>2018-09-09T13:24:28.000Z</published>
    <updated>2018-10-30T11:56:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>redis构建了自己的链表实现。</p><p>列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。</p><p>除链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，redis服务器本身还使用链表来保存多个客户端的状态信息，使用链表来构建客户端输出缓冲区。</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>链表节点由adlist.h/listNode结构来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">struct listNode *prev;//前置节点</span><br><span class="line">struct listNode *next;//后置节点</span><br><span class="line">void *value;//节点的值</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p><p>使用多个listNode结构可组成链表，使用adlist.h/list来持有链表，操作起来更方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">listNode *head;//表头节点</span><br><span class="line">listNode *tail;//表尾节点</span><br><span class="line">unsigned long len;//链表所包含的节点的数量</span><br><span class="line">void *(*dup)(void *ptr);//节点值复制函数</span><br><span class="line">void *(*free)(void *ptr);//节点值释放函数</span><br><span class="line">int (*match)(void *ptr, void *key);//节点值对比函数</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>提供了表头指针head，表尾指针tail，链表长度计数器len，dup、free和match用于实现多态链表所需的类型特定函。</p><p>redis链表实现的特性：</p><ul><li>双端。</li><li>无环。</li><li>带表头指针和表尾指针。</li><li>带链表长度计数器。</li><li>多态：链表节点使用void*指针来保存节点值，可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，链表可用于保存各种不同类型的值。</li></ul><h3 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h3><p>链表和链表节点的API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数</td><td style="text-align:left">O(1)，可通过链表的dup属性直接获得</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数</td><td style="text-align:left">O(1)，可通过链表的free属性直接获得</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）</td><td style="text-align:left">O(1)，链表的len属性</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点</td><td style="text-align:left">O(1)，链表的head属性</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表为节点</td><td style="text-align:left">O(1)，链表的tail属性</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点</td><td style="text-align:left">O(1)，节点的prev属性</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点</td><td style="text-align:left">O(1)，节点的next属性</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值</td><td style="text-align:left">O(1)，节点的value属性</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，成为新的表头节点</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis构建了自己的链表实现。&lt;/p&gt;
&lt;p&gt;列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。&lt;/p&gt;
&lt;p&gt;除链表键之外，发布与订阅、慢查询、监视器等功能也用到了链
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="链表" scheme="bighua.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis-简单动态字符串</title>
    <link href="bighua.top/2018/09/08/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>bighua.top/2018/09/08/redis-简单动态字符串/</id>
    <published>2018-09-08T13:16:08.000Z</published>
    <updated>2018-10-30T11:56:56.986Z</updated>
    
    <content type="html"><![CDATA[<p>redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush fruits &quot;banana&quot; &quot;apple&quot; &quot;cheery&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>redis在数据库中创建一个新的键值对，其中：</p><ul><li>键是一个字符串对象，对象底层的实现是一个保存了字符串“fruits”的SDS。</li><li>值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，分别保存着字符串“banana”、“apple”、“cheery”。  </li></ul><p>SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>sds.h/sdshdr:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">int len; //buf数组中已使用字节的数量、SDS所保存字符串的长度</span><br><span class="line">int free; //buf数组中未使用字节的数量</span><br><span class="line">char buf[]; //字节数组，用于保存字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，为其分配额外的一字节空间和添加空字符到字符串末尾等操作都由SDS函数自动完成。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><p>C语言使用长度为N+1的字符数组表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。但不能满足redis对字符串安全性、效率以及功能方面的要求。</p><h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>C字符串需遍历整个字符串对字符进行计数，复杂度为O(N)，redis直接返回SDS的len属性值，复杂度O(1)。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>C字符串不记录自身长度容易造成缓冲区溢出（buffer overflow），改写其后缓冲区的内容。</p><p>SDS的空间分配策略杜绝发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，若不满足，API会自动将SDS的空间拓展至执行修改所需的大小，然后才执行修改操作。</p><h4 id="减少修改字符串时带来的内存冲分配次数"><a href="#减少修改字符串时带来的内存冲分配次数" class="headerlink" title="减少修改字符串时带来的内存冲分配次数"></a>减少修改字符串时带来的内存冲分配次数</h4><p>每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>若程序执行的是增长字符串的操作，例如拼接操作（append），执行操作之前，程序需要先通过内存重分配来拓展底层数组的空间大小——忽略此步会产生缓冲区溢出。</li><li>若程序执行的是缩短字符串的操作，例如截断操作（tirm），在执行操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——忽略会产生内存泄漏。</li></ul><p>内存重分配涉及复杂的算法，可能需要执行系统调用，通常是比较耗时的操作：</p><ul><li>一般程序中，若修改字符串长度的情况不太常出现，每次修改都执行一次内存重分配是可接受的。</li><li>redis经常用于速度要求严苛、数据被频繁修改的场合，执行内存重分配会占去修改字符串所用时间的一大部分，频繁操作影响性能。</li></ul><p>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量加一，可以包含未使用字节。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必需要的空间，还会为SDS分配额外的未使用空间，可以使redis减少连续执行字符串增长操作所需的内存重分配次数。</p><p>分配未使用空间数量：</p><ul><li>若修改之后SDS的长度小于1M，程序分配和len属性同样大小的未使用空间，SDS的len属性值将和free属性的值相同，总长度=len+free+1byte（额外的一字节用于保存空字符）。</li><li>若修改之后SDS的长度大于等于1M，程序会分配1M的未使用空间，即free=1，总长度=len+1M+1byte。</li></ul><p>拓展SDS空间之前，SDS API会先检查未使用空间是否足够，若足够，API就会直接使用未分配空间，无需执行内存重分配。</p><h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><p>SDS提供了相关的API，可以在有需要的时候，真正地释放SDS的未使用空间，不必担心惰性空间释放策略会造成内存浪费。</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C字符串中的字符必须符合某种编码（ASCII），且除字符串末尾外，字符串里面不能包含空字符。限制C字符串只能保存文本数据，而不能保存图像、音频、视频、压缩文件这样的二进制数据。</p><p>为确保redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样子，被读取时就是什么样子。</p><p>redis不是使用buf字节数组保存字符，而是保存一系列二进制数据。SDS使用len属性的值而不是空字符来判断字符串是否结束。</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>SDS的API是二进制安全的，但一样遵循C字符串以空字符结尾的惯例：这些API会将SDS保存的数据的末尾设置为空字符，并且会在为buf数组分配空间时多分配一个字节来容纳这个空字符，为了让保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数，避免了不必要的代码重复。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>C字符串和SDS之间的区别：</p><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(n)</td><td style="text-align:left">获取字符串长度的复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API是安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td style="text-align:left">只能保存文本数据</td><td style="text-align:left">可以保存文本或者二进制数据</td></tr><tr><td style="text-align:left">可以使用所有&lt;string.h&gt;库中的函数</td><td style="text-align:left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>SDS主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">sdsnew</td><td style="text-align:left">创建一个包含给定C字符串的SDS</td><td style="text-align:left">O(N)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdsempty</td><td style="text-align:left">创建一个不包含任何内容的空SDS</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">sdsfree</td><td style="text-align:left">释放给定的SDS</td><td style="text-align:left">O(N)，N为被释放SDS的长度</td></tr><tr><td style="text-align:left">sdslen</td><td style="text-align:left">返回SDS的已使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的len属性</td></tr><tr><td style="text-align:left">sdsavail</td><td style="text-align:left">返回SDS的未使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的free属性</td></tr><tr><td style="text-align:left">sdsdup</td><td style="text-align:left">创建一个给定SDS的副本（copy）</td><td style="text-align:left">O(N)，N为给定SDS的长度</td></tr><tr><td style="text-align:left">sdsclear</td><td style="text-align:left">清空SDS保存的字符串内容</td><td style="text-align:left">O(1)，惰性空间释放策略</td></tr><tr><td style="text-align:left">sdscat</td><td style="text-align:left">将给定字符串拼接到SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接的字符串的长度</td></tr><tr><td style="text-align:left">sdscatsds</td><td style="text-align:left">将给定SDS字符串拼接到另一个SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接SDS字符串的长度</td></tr><tr><td style="text-align:left">sdscpy</td><td style="text-align:left">将给定C字符串复制到SDS里面，覆盖SDS原有的字符串</td><td style="text-align:left">O(N)，N为被复制C字符串的长度</td></tr><tr><td style="text-align:left">sdsgrowzero</td><td style="text-align:left">用空字符串将SDS拓展至给定长度</td><td style="text-align:left">O(N)，N为拓展新增的字节数</td></tr><tr><td style="text-align:left">sdsrange</td><td style="text-align:left">保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除</td><td style="text-align:left">O(N)，N为被保留数据的字节数</td></tr><tr><td style="text-align:left">sdstrim</td><td style="text-align:left">接受一个SDS和C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符</td><td style="text-align:left">O(N^2)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdscmp</td><td style="text-align:left">对比两个SDS字符串是否相同</td><td style="text-align:left">O(N)，N为两个SDS中较短的那个SDS的长度</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="sds" scheme="bighua.top/tags/sds/"/>
    
  </entry>
  
  <entry>
    <title>Go模板引擎</title>
    <link href="bighua.top/2018/08/24/Go%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2018/08/24/Go模板引擎/</id>
    <published>2018-08-24T13:01:29.000Z</published>
    <updated>2018-10-30T11:56:56.980Z</updated>
    
    <content type="html"><![CDATA[<p>Go标准库text/template、html/template。</p><hr><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>可以把模板引擎划分为两种理想的类型：</p><ul><li>无逻辑模板引擎（logic-less template engine）——将模板中指定的占位符替换成相应的动态数据。只进行字符串替换，不执行任何逻辑处理。目的是完全分离程序的表现和逻辑，并将所有计算方面的工作都交给处理器完成。</li><li>嵌入逻辑的模板引擎（embedded logic template engine）——将编程语言代码嵌入模板当中，并在模板引擎渲染时，由模板引擎执行这些代码并进行相应的字符串替换工作。</li></ul><p>无逻辑模板引擎的渲染速度往往会更快一些。</p><h3 id="Go的模板引擎"><a href="#Go的模板引擎" class="headerlink" title="Go的模板引擎"></a>Go的模板引擎</h3><p>Go语言的模板引擎介于无逻辑模板引擎和嵌入逻辑模板引擎之间，由处理器负责触发。</p><p>Go的通用模板引擎库text/template可以处理任意格式的文本，模板引擎库html/template专门处理HTML格式。模板中的动作默认使用两个大括号<code>{</code>和<code>}</code>包围，也可以通过模板引擎提供的方法自行指定其他定界符（delimiter）。</p><p>使用Go的Web模板引擎需要的步骤：</p><ul><li>对文本格式的模板源进行语法分析，创建一个经过语法分析的模板结构，模板源既可以是一个字符串，也可以是模板文件中包含的内容。</li><li>执行经过语法分析的模板，将ResponseWriter和模板所需的动态数据传递给模板引擎，被调用的模板引擎会把经过语法分析的模板和传入的数据结合起来，生成最终的HTML传递给ResponseWriter。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, &quot;Hello World!)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></li></ul><h4 id="对模板进行语法分析"><a href="#对模板进行语法分析" class="headerlink" title="对模板进行语法分析"></a>对模板进行语法分析</h4><p>ParseFiles是一个独立的函数，可以对模板文件进行语法分析，并创建出一个经过语法分析的模板结构以供Execute方法执行。</p><blockquote><p>调用ParseFiles函数的时候，Go会创建出一个新的模板，并将用户给定的模板文件的名字用作这个新模板的名字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := template.New(&quot;tmpl.html&quot;)</span><br><span class="line">t, _ := t.ParseFiles(&quot;tmpl.html&quot;)</span><br></pre></td></tr></table></figure><p>ParseFiles函数和Template结构的ParseFiles方法都可以接受一个或多个文件名作为参数，但只返回一个模板。返回用户传入的第一个文件的已分析模板，模板也会根据用户传入的第一个文件的名字进行命名，其他传入文件的已分析模板会被放置到一个映射里面，可以在之后执行模板时使用。</p><blockquote><p>即，向ParseFiles传入单个文件时，ParseFiles返回的是一个模板，向ParseFiles传入多个文件时，ParseFiles返回的是一个模板集合。</p></blockquote><p>使用ParseGlob函数对模板文件进行语法分析，会对匹配给定模式的所有文件进行语法分析。</p><p>实际上，所有对模板进行语法分析的手段最终都需要调用Parse方法来执行实际的语法分析操作。</p><p>专门用于处理分析模板时出现的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := template.Must(template.ParseFiles(&quot;tmpl.html&quot;))</span><br></pre></td></tr></table></figure><p>Must函数可以包裹起一个函数，被包裹的函数会返回一个指向模板的指针和一个错误，若错误不是nil，Must函数将产生一个panic。</p><h4 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h4><p>常用方法调用模板的Execute方法，并向它传递ResponseWriter以及模板所需的数据。若对模板集合调用Execute方法，只会执行模板集合中的第一个模板。使用ExecuteTemplate方法执行其他模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;)</span><br><span class="line"></span><br><span class="line">t.Execute(w, &quot;hello world!&quot;)</span><br><span class="line"></span><br><span class="line">t.ExecuteTemplate(w, &quot;t2.html&quot;, &quot;Hello World!&quot;)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作即嵌入在模板里面的命令，使用两个大括号{和}进行包围。</p><p>主要有动作：</p><ul><li>条件动作；</li><li>迭代动作；</li><li>设置动作；</li><li>包含动作。</li></ul><p>还有<code>定义动作</code>，（ . ）也是一个动作，代表的是传递给模板的数据，其他动作和函数基本上都会对这个动作进行处理，达到格式化和内容展示的目的。</p><h4 id="条件动作"><a href="#条件动作" class="headerlink" title="条件动作"></a>条件动作</h4><p>根据参数的值决定对多条语句中的哪一条语句进行求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line"></span><br><span class="line">some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="迭代动作"><a href="#迭代动作" class="headerlink" title="迭代动作"></a>迭代动作</h4><p>迭代动作可以对数组、切片、映射或者通道进行迭代，在迭代循环的内部点(.)会被设置为当前被迭代的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range . &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content to show</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="设置动作"><a href="#设置动作" class="headerlink" title="设置动作"></a>设置动作</h4><p>允许用户在指定的范围之内为点<code>(.)</code>设置值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;the dot is already set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;Dot is set to arg</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">Fallback if arg is empty</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="包含动作"><a href="#包含动作" class="headerlink" title="包含动作"></a>包含动作</h4><p>允需用户在一个模板里面包含另一个模板，从而构建出嵌套的模板。包含动作的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template &quot;name&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p>name参数为被包含模板的名字。</p><h3 id="参数、变量和管道"><a href="#参数、变量和管道" class="headerlink" title="参数、变量和管道"></a>参数、变量和管道</h3><p>参数即模板中的值，可以是布尔值、整数、字符串等字面量，也可以是结构、结构中的一个字段或者数组中的一个键。还可以是一个变量、一个方法（该方法必须只返回一个值、或只返回一个值和一个错误）或者一个函数。参数也可以是一个点(.)，用于表示处理器向模板引擎传递的数据。</p><p>除参数外，可在工作中设置以美元符号开头的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或者使用管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; 12.3456 | printf &quot;%.2f&quot; &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go的模板引擎函数都是受限制的：函数可以接受任意多个参数作为输入，但是只能返回一个值，或者返回一个值和一个错误。</p><p>创建自定义模板函数：</p><ul><li>创建一个名为FuncMap的映射，将映射的键设置为函数的名字，映射的值设置为实际定义的函数；</li><li>将FuncMap与模板进行绑定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func formatDate(t time.Time) string &#123;</span><br><span class="line">layout := &quot;2006-01-02&quot;</span><br><span class="line">return t.Format(layout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">funcMap := template.FuncMap&#123; &quot;fdate&quot;: formatDate &#125;</span><br><span class="line">t := template.New(&quot;tmpl.html&quot;).Funcs(funcMap)</span><br><span class="line">t, _ = t.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>模板中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;The Date/Time is &#123;&#123; . | fdate &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>又或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;the Date/Time is &#123;&#123; fdate . &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>使用管道将一个函数的输出传递给另一个函数作为输入，使代码更简单易读。</p><h3 id="上下文感知"><a href="#上下文感知" class="headerlink" title="上下文感知"></a>上下文感知</h3><p>Go的模板引擎可以根据内容所处的上下文改变其显示的内容。根据内容在模板中所处的位置，模板在显示这些内容的时候将对其进行相应的修改。可对被显示的内容实施正确的转义（escape）：模板现实的是HTML格式的内容，模板对其实施HTML转义；显示的是JavaScript格式的内容，对其实施JavaScript转义。还可以识别出内容中的URl或者CSS样式。</p><p>主要用于实现自动的防御编程，防止某些明显并且低级的编程错误。</p><h3 id="防御XSS攻击"><a href="#防御XSS攻击" class="headerlink" title="防御XSS攻击"></a>防御XSS攻击</h3><p>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致。</p><p>通过模板引擎在显示用户输入时将其转换为转义之后的HTML，避免可能会出现的问题。</p><h3 id="不对HTML进行转义"><a href="#不对HTML进行转义" class="headerlink" title="不对HTML进行转义"></a>不对HTML进行转义</h3><p>使用“不转义代码机制”允许用户输入HTML代码或者JavaScript代码，并在显示内容时执行这些代码。</p><p>将不想被转义的内容传给template.HTML函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;comment)))</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>程序通过类型转换（typecast）将表单中的评价值转换成template.HTML类型。</p><blockquote><p>可通过发送一个最初由微软公司为IE浏览器创建的特殊HTTP响应首部X-XSS-Protection让浏览器关闭内置的XSS防御功能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func process (w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">w.Header().Set(&quot;X-XSS-Protection&quot;, &quot;0&quot;)</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html&quot;)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;content)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套模版"><a href="#嵌套模版" class="headerlink" title="嵌套模版"></a>嵌套模版</h3><p>布局指Web设计中可以重复应用在多个页面上的固定模式。</p><p>通过包含动作，在一个模版里面包含另一个模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; template &quot;name&quot; . &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>动作参数name为被包含的模板名字，是一个字符串常量。每个页面都拥有它们各自的布局模版文件，程序最终无法拥有任何可共用的公共布局。</p><p>可通过定义动作（define action），在模板文件里面显示地定义模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>在一个模板文件里定义多个不同模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">Hello World!</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>使用显示定义模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w, http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>可在不同的模板文件里面定义同名的模板（red_hello.html，blue_hello.html）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content&quot; &#125;&#125;</span><br><span class="line">&lt;h1 style= &quot;color: red;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt; hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用在不同模板文件中定义的同名模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *template.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red_hello.html&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layput.html&quot;, &quot;blue_hello.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.Execute(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>通过块动作定义默认模板<br>块动作（block action）允许用户定义一个模板并且立即使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>改进上方逻辑，默认展示蓝色else只对layout.html进行语法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *tempale.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="通过块动作添加默认的content模版"><a href="#通过块动作添加默认的content模版" class="headerlink" title="通过块动作添加默认的content模版"></a>通过块动作添加默认的content模版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">···</span><br><span class="line">&#123;&#123; block &quot;content&quot; . &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>块动作定义的content模板，当layout模板被执行时，若模板引擎没找到可用的content模板，就会使用块动作中定义的content模板。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go标准库text/template、html/template。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;模板引擎&quot;&gt;&lt;a href=&quot;#模板引擎&quot; class=&quot;headerlink&quot; title=&quot;模板引擎&quot;&gt;&lt;/a&gt;模板引擎&lt;/h3&gt;&lt;p&gt;可以把模板引擎划分为两种理想的类
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Go模板库" scheme="bighua.top/tags/Go%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    
      <category term="模板引擎" scheme="bighua.top/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Go与Cookie</title>
    <link href="bighua.top/2018/08/23/Go%E4%B8%8ECookie/"/>
    <id>bighua.top/2018/08/23/Go与Cookie/</id>
    <published>2018-08-23T12:57:26.000Z</published>
    <updated>2018-10-30T11:56:56.979Z</updated>
    
    <content type="html"><![CDATA[<p>大多数cookie都可以被划分为会话cookie和持久cookie两种类型。</p><hr><h3 id="Go与cookie"><a href="#Go与cookie" class="headerlink" title="Go与cookie"></a>Go与cookie</h3><p>cookie在Go语言中用Cookie结构表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Cookie struct &#123;</span><br><span class="line">Namestring</span><br><span class="line">Valuestring</span><br><span class="line">Pathstring</span><br><span class="line">Domainstring</span><br><span class="line">Expirestime.Time</span><br><span class="line">RawExpiresstring</span><br><span class="line">MaxAgeint</span><br><span class="line">Securebool</span><br><span class="line">HttpOnlybool</span><br><span class="line">Rawstring</span><br><span class="line">Unparsed[]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有设置Expires字段的cookie通常称为会话cookie或者临时cookie，这种cookie在浏览器关闭的时候就会自动被移除。设置了Expires字段的cookie通常称为持久cookie，这种cookie会一直存在，直到指定的过期时间来临或者被手动删除为止。</p><p>Expires字段和MaxAge字段都可以设置cookie的过期时间，Expires字段用于明确地指定cookie应该在什么时候过期，MaxAge字段指明cookie在被浏览器创建出来之后能够存活多少秒。</p><p>为使cookie在所有浏览器上都能够正常运行，只使用Expires，或者同时使用Expires和MaxAge。</p><h3 id="将cookie发送至浏览器"><a href="#将cookie发送至浏览器" class="headerlink" title="将cookie发送至浏览器"></a>将cookie发送至浏览器</h3><p>Cookie结构的String方法可以返回一个经过序列化处理的cookie，其中Set-Cookie响应首部的值即为这些序列化之后的cookie组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">w.Header().Set(&quot;Set-Cookie&quot;, c1.String())</span><br><span class="line">w.Header().Add(&quot;Set-Cookie&quot;, c2.String())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>除Set方法和Add方法外，还可使用net/http库中的SetCookie方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c1)</span><br><span class="line">http.SetCookie(w, &amp;c2)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用SetCookie方法设置cookie，传递给方法的是指向Cookie的指针而不是Cookie结构本身。</p><h3 id="从浏览器获取cookie"><a href="#从浏览器获取cookie" class="headerlink" title="从浏览器获取cookie"></a>从浏览器获取cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">h := r.Header[&apos;Cookie&apos;]</span><br><span class="line">fmt.Fprintln(w, h)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>语句<code>r.Header[&quot;Cookie&quot;]</code>返回一个切片，切片包含一个字符串，字符串包含了客户端发送的任意多个cookie。取得单独的键值对格式的cookie，需要对r.Header[“Cookie”]返回的字符串进行语法分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1, err := r.Cookie(&quot;first_cookie&quot;);</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;Cannot get the first cookie&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cs := r.Cookies()</span><br><span class="line">fmt.Fprintln(w, c1)</span><br><span class="line">fmt.Fprintln(w, cs)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用Request结构的Cookie方法获取指定名字的cookie，若指定的cookie不存在，则方法返回一个错误。使用Cookies方法获取多个cookie，返回一个包含了所有cookie的切片。</p><p>上方未设置cookie的过期时间，为会话cookie，完全退出浏览器并重启这些cookie会消失。</p><h3 id="使用cookie实现闪现消息"><a href="#使用cookie实现闪现消息" class="headerlink" title="使用cookie实现闪现消息"></a>使用cookie实现闪现消息</h3><p>实现闪现消息的常用方法是将这些消息存储在页面刷新时就会被移除的会话cookie里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setMessage(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">msg := []byte(&quot;Hello World!)</span><br><span class="line">c := http.Cookie&#123;</span><br><span class="line">Name:&quot;flash&quot;,</span><br><span class="line">Value:base64.URLEncoding.EncodeToString(msg),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>设置cookie时，如果cookie的值没有包含诸如空格或者百分号这样的特设字符，可不对它进行编码；由于消息本身通常包含此类字符，需要使用Base64URL编码，以此来满足响应首部对cookie值的URL编码要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func showMessage(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c, err := r.Cookie(&quot;flash&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if err == http.ErrNoCookie &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;No message found)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rc := http.Cookie&#123;</span><br><span class="line">Name: &quot;flash&quot;,</span><br><span class="line">MaxAge:-1,</span><br><span class="line">Expires:time.Unix(1, 0),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;rc)</span><br><span class="line">val, _ := base64.URLEncoding.DecodeString(c.Value)</span><br><span class="line">fmt.Fprintln(w, string(val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>获取flash消息cookie，创建同名cookie并设置MacAge值为负数、Expires值为已经过去的时间，将同名cookie发送至客户端，相当于命令浏览器删除这个cookie。将flash消息解码，通过响应返回这条消息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数cookie都可以被划分为会话cookie和持久cookie两种类型。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Go与cookie&quot;&gt;&lt;a href=&quot;#Go与cookie&quot; class=&quot;headerlink&quot; title=&quot;Go与cookie&quot;&gt;&lt;/a&gt;Go与cooki
      
    
    </summary>
    
      <category term="Golang" scheme="bighua.top/categories/Golang/"/>
    
    
      <category term="Golang" scheme="bighua.top/tags/Golang/"/>
    
      <category term="cookie" scheme="bighua.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>HTTP简记</title>
    <link href="bighua.top/2018/08/21/HTTP%E7%AE%80%E8%AE%B0/"/>
    <id>bighua.top/2018/08/21/HTTP简记/</id>
    <published>2018-08-21T12:49:31.000Z</published>
    <updated>2018-10-30T11:56:56.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>请求行（request-line）；</li><li>零个或任意多个请求首部（header）；</li><li>一个空行；</li><li>可选的报文主体（body）。</li></ul><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP 1.1要求必须实现的只有GET方法和HEAD方法，其他方法（包括POST）方法是可选的。</p><ul><li>GET——命令服务器返回指定的资源。</li><li>HEAD——类似GET，不同于此方法不要求服务器返回报文的主体。用于在不获取报文主体的情况下取得相应的首部。</li><li>POST——命令服务器将报文主体中的数据传递给URI指定的资源。</li><li>PUT——命令服务器将报文主体中的数据设置为URI指定的资源，若URI指定的位置上已有数据存在，则使用报文主体中的数据去代替已有的数据，若资源未存在，则在URI指定的位置上新创建一个资源。</li><li>DELETE——命令服务器删除URI指定的资源。</li><li>TRACE——命令服务器返回请求本身，了解介于客户端和服务器之间的其他服务器是如何处理请求的。</li><li>OPTIONS——命令服务器返回它支持的HTTP方法列表。</li><li>CONNECT——命令服务器与客户端建立一个网络连接，用于设置SSL隧道以开启HTTPS功能。</li><li>PATCH——命令服务器使用报文主体中的数据对URI指定的资源进行修改。</li></ul><h4 id="常见的请求首部"><a href="#常见的请求首部" class="headerlink" title="常见的请求首部"></a>常见的请求首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">客户端在HTTP相应中能够接收的内容类型。如Accept: text/html</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">客户端要求服务器使用的字符集编码。如Accept-Charset: utf-8。</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">用于向服务器发送基本的身份验证证书</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">客户端在此首部中把服务器之前设置的所有cookie回传给服务器。如Cookie: my-first_cookie=hello; my_second_cookie=world</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">请求主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">请求包含主体的时候用于记录主体内容的类型。发送POST或GET请求时默认为x-www-form-urlen-coded，上传文件时应设置为multipart/form-data。</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">服务器的名字及端口号。无端口号表示使用80端口</td></tr><tr><td style="text-align:left">Referrer</td><td style="text-align:left">发起请求的页面所在的地址</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">对发起请求的客户端进行描述</td></tr></tbody></table><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>状态行；</li><li>零个或任意多个响应首部；</li><li>一个空行；</li><li>可选的报文主体。</li></ul><h4 id="5种类型的响应状态码"><a href="#5种类型的响应状态码" class="headerlink" title="5种类型的响应状态码"></a>5种类型的响应状态码</h4><table><thead><tr><th style="text-align:left">状态码类型</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">情报状态码。告知客户端已接收客户端发送的请求，并且已经对请求进行了处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">成功状态码。告知客户端已接收客户端发送的请求，并且已经成功地对请求进行了处理。标准响应为‘200 OK’</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">重定向状态码。告知客户端已接收客户端发送的请求，并且已经成功处理了请求，但为了完成请求指定的动作，客户端还需要再做一些其他的工作，大多用于实现URL重定向</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">客户端错误状态码。告知客户端发送的请求出现了某些问题。常见‘404 Not Found’表示服务器无法从请求指定的URL中找到客户端想要的资源</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">服务器错误状态码。当服务器因某些原因而无法正确地处理请求时，使用此类状态码告知客户端。</td></tr></tbody></table><h4 id="常见的响应首部"><a href="#常见的响应首部" class="headerlink" title="常见的响应首部"></a>常见的响应首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">告知客户端，服务器支持哪些请求方法</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">响应主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">若响应包含主体则为主体内容的类型</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">以格林尼治标准时间（GMT）格式记录的当前时间</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">仅在重定向时使用，告知客户端截下来应该向哪个URL发送请求。</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">返回响应的服务器的域名</td></tr><tr><td style="text-align:left">Set-Cookie</td><td style="text-align:left">在客户端里面设置一个Cookie，一个响应里面可以包含多个Set-Cookie首部</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">告知客户端在Authorization请求首部中应该提供哪种类型的身份验证信息。服务器常把此首部与“401 Unauthorized”状态行一同发送。此外还会向服务器许可的认证授权模式（schema）提供验证信息（challenge information） </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP请求&quot;&gt;&lt;a href=&quot;#HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求&quot;&gt;&lt;/a&gt;HTTP请求&lt;/h3&gt;&lt;p&gt;由一系列文本行组成，有顺序地进行排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求行（request-line）；&lt;/l
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="http" scheme="bighua.top/tags/http/"/>
    
      <category term="web" scheme="bighua.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>测试工具-siege</title>
    <link href="bighua.top/2018/08/03/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-siege/"/>
    <id>bighua.top/2018/08/03/测试工具-siege/</id>
    <published>2018-08-03T12:42:20.000Z</published>
    <updated>2018-10-30T11:56:56.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>mac下使用brew直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install siege</span><br></pre></td></tr></table></figure><p><code>siege -C</code>查看相关的配置参数，可以自行修改，比如是否显示log，超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">localhost:~ wuhua$ siege -C</span><br><span class="line">CURRENT  SIEGE  CONFIGURATION</span><br><span class="line">Mozilla/5.0 (apple-x86_64-darwin17.0.0) Siege/4.0.4</span><br><span class="line">Edit the resource file to change the settings.</span><br><span class="line">----------------------------------------------</span><br><span class="line">version:                        4.0.4</span><br><span class="line">verbose:                        true</span><br><span class="line">color:                          true</span><br><span class="line">quiet:                          false</span><br><span class="line">debug:                          false</span><br><span class="line">protocol:                       HTTP/1.1</span><br><span class="line">HTML parser:                    enabled</span><br><span class="line">get method:                     HEAD</span><br><span class="line">connection:                     close</span><br><span class="line">concurrent users:               25</span><br><span class="line">time to run:                    n/a</span><br><span class="line">repetitions:                    n/a</span><br><span class="line">socket timeout:                 30</span><br><span class="line">cache enabled:                  false</span><br><span class="line">accept-encoding:                gzip, deflate</span><br><span class="line">delay:                          0.000 sec</span><br><span class="line">internet simulation:            false</span><br><span class="line">benchmark mode:                 false</span><br><span class="line">failures until abort:           1024</span><br><span class="line">named URL:                      none</span><br><span class="line">URLs file:                      /usr/local/Cellar/siege/4.0.4/etc/urls.txt</span><br><span class="line">thread limit:                   10000</span><br><span class="line">logging:                        false</span><br><span class="line">log file:                       /Users/wuhua/var/siege.log</span><br><span class="line">resource file:                  /Users/wuhua/.siege/siege.conf</span><br><span class="line">timestamped output:             false</span><br><span class="line">comma separated output:         false</span><br><span class="line">allow redirects:                true</span><br><span class="line">allow zero byte data:           true</span><br><span class="line">allow chunked encoding:         true</span><br><span class="line">upload unique files:            true</span><br><span class="line">no-follow:</span><br><span class="line"> - ad.doubleclick.net</span><br><span class="line"> - pagead2.googlesyndication.com</span><br><span class="line"> - ads.pubsqrd.com</span><br><span class="line"> - ib.adnxs.com</span><br></pre></td></tr></table></figure><p>项目：<a href="https://github.com/JoeDog/siege" target="_blank" rel="noopener">siege</a></p><p>参考：<a href="https://blog.csdn.net/shangmingtao/article/details/73850292#1siege%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">siege压力测试工具安装和介绍</a>，<a href="https://www.cnblogs.com/lawlietfans/p/6873306.html" target="_blank" rel="noopener">如何使用siege测试服务器性能</a></p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>可在命令行中输入siege –help获取。</p><table><thead><tr><th style="text-align:left">输入参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:left">-V,–version</td><td style="text-align:left">打印版本号</td></tr><tr><td style="text-align:left">-h,–help</td><td style="text-align:left">打印帮助信息（输出这些命令参数及详情）</td></tr><tr><td style="text-align:left">-C,–config</td><td style="text-align:left">显示当前配置信息</td></tr><tr><td style="text-align:left">-v,–verbose</td><td style="text-align:left">将通知信息输出到屏幕</td></tr><tr><td style="text-align:left">-q,–quiet</td><td style="text-align:left">停止verbose并抑制输出</td></tr><tr><td style="text-align:left">-g,–get</td><td style="text-align:left">显示请求URL的HTTP头和返回详情，适用于调试</td></tr><tr><td style="text-align:left">-p,–print</td><td style="text-align:left">打印，类似GET一样，打印整个页面（response html）</td></tr><tr><td style="text-align:left">-c,–concurrent=NUM</td><td style="text-align:left">设置并发用户数，默认为10</td></tr><tr><td style="text-align:left">-r,-–reps=NUM</td><td style="text-align:left">设置测试次数</td></tr><tr><td style="text-align:left">-t,–time=NUMm</td><td style="text-align:left">设置测试时间，m修饰秒（S）、分（M）、时（H），例如–time=1H</td></tr><tr><td style="text-align:left">-d,-–delay=NUM</td><td style="text-align:left">时间延迟，每次请求之前的延迟随机</td></tr><tr><td style="text-align:left">-b,–benchmark</td><td style="text-align:left">基准测试，请求之间没有延迟</td></tr><tr><td style="text-align:left">-i,–internet</td><td style="text-align:left">用户模拟、随机访问url</td></tr><tr><td style="text-align:left">-f,-–file=FILE</td><td style="text-align:left">选择特定的URLS文件（读取文件选取其中的url进行访问）</td></tr><tr><td style="text-align:left">-R,–rc=FILE</td><td style="text-align:left">指定一个siegerc文件</td></tr><tr><td style="text-align:left">-l,–log[=FILE]</td><td style="text-align:left">记录测试日志到文件，如果未指定FILE，则使用默认值：PREFIX/var/siege.log</td></tr><tr><td style="text-align:left">-m,-–mark=”text”</td><td style="text-align:left">标记，用字符串标记测试日志，介于.001和NUM之间。（未计入统计数据）</td></tr><tr><td style="text-align:left">-H,-–header=”text”</td><td style="text-align:left">添加测试的请求头header，可以为多个</td></tr><tr><td style="text-align:left">-A, –user-agent=”text”</td><td style="text-align:left">在请求中设置User-Agent</td></tr><tr><td style="text-align:left">-T, –content-type=”text”</td><td style="text-align:left">在请求中设置Content-Type</td></tr><tr><td style="text-align:left">–no-parser</td><td style="text-align:left">没有PARSER，关闭HTML页面解析器</td></tr><tr><td style="text-align:left">–no-follow</td><td style="text-align:left">不遵循，不要遵循HTTP重定向</td></tr></tbody></table><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><table><thead><tr><th style="text-align:center">输出参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:center">Transactions</td><td style="text-align:left">总共测试次数</td></tr><tr><td style="text-align:center">Availability</td><td style="text-align:left">成功次数百分比</td></tr><tr><td style="text-align:center">Elapsed time</td><td style="text-align:left">总共耗时多少秒</td></tr><tr><td style="text-align:center">Data transferred</td><td style="text-align:left">总共数据传输</td></tr><tr><td style="text-align:center">Response time</td><td style="text-align:left">平均响应时间</td></tr><tr><td style="text-align:center">Transaction rate</td><td style="text-align:left">平均每秒处理请求数</td></tr><tr><td style="text-align:center">Throughput</td><td style="text-align:left">吞吐率</td></tr><tr><td style="text-align:center">Concurrency</td><td style="text-align:left">最高并发</td></tr><tr><td style="text-align:center">Successful transactions</td><td style="text-align:left">成功的请求数</td></tr><tr><td style="text-align:center">Failed transactions</td><td style="text-align:left">失败的请求数</td></tr><tr><td style="text-align:center">Longest transaction</td><td style="text-align:left">最长响应时间</td></tr><tr><td style="text-align:center">Shortest transaction</td><td style="text-align:left">最短响应时间</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>示例：</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数据</th></tr></thead><tbody><tr><td style="text-align:left"> 请求登陆接口</td><td style="text-align:left"><a href="http://bighua.com/login" target="_blank" rel="noopener">http://bighua.com/login</a></td></tr><tr><td style="text-align:left"> 请求类型</td><td style="text-align:left">POST</td></tr><tr><td style="text-align:left"> 请求参数</td><td style="text-align:left">{“_token”: “qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5”,”email”: “228944883 @qq.com”,”password”: “hualin123”,”remember”: “on”}</td></tr><tr><td style="text-align:left"> 请求次数</td><td style="text-align:left">10次</td></tr><tr><td style="text-align:left"> 请求并发数量</td><td style="text-align:left">150</td></tr></tbody></table><p>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siege &quot;http://bighua.com/login POST &#123;&quot;_token&quot;:&quot;qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5&quot;,&quot;email&quot;:&quot;228944883@qq.com&quot;,&quot;password&quot;:&quot;hualin123&quot;,&quot;remember&quot;:&quot;on&quot;&#125;&quot; -r 10 -c 150</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transactions:        1490 hits</span><br><span class="line">Availability:       99.33 %</span><br><span class="line">Elapsed time:       41.63 secs</span><br><span class="line">Data transferred:        2.16 MB</span><br><span class="line">Response time:        3.04 secs</span><br><span class="line">Transaction rate:       35.79 trans/sec</span><br><span class="line">Throughput:        0.05 MB/sec</span><br><span class="line">Concurrency:      108.82</span><br><span class="line">Successful transactions:           0</span><br><span class="line">Failed transactions:          10</span><br><span class="line">Longest transaction:       35.63</span><br><span class="line">Shortest transaction:        0.00</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>siege默认的线程数为255，与apache的默认值相对应，nginx的默认最大连接数为1024。不修改isege配置文件的话，-c的最大值只能为255。 只能测试并发量在255以下。</p><p>另外操作系统对打开文件的多少有限制，即限制socket打开的数量。可通过ulimit命令进行修改。参看博客：<a href="https://blog.csdn.net/z1134145881/article/details/52573441/" target="_blank" rel="noopener">Mac打开文件最大数限制修改</a>、<a href="https://blog.csdn.net/whereismatrix/article/details/50582919" target="_blank" rel="noopener">mac中修改系统限制量–ulimit和sysctl</a>。</p><p>对nginx设置参考<a href="https://blog.csdn.net/hjh15827475896/article/details/53442800" target="_blank" rel="noopener">单机 nginx 应对高并发处理</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;mac下使用brew直接安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="测试" scheme="bighua.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="siege" scheme="bighua.top/tags/siege/"/>
    
  </entry>
  
</feed>
