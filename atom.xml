<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木年华</title>
  
  <subtitle>行到水穷处,坐看云起时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="bighua.top/"/>
  <updated>2019-09-14T12:33:02.954Z</updated>
  <id>bighua.top/</id>
  
  <author>
    <name>cocowh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InnoDB存储引擎源代码的编译和调试</title>
    <link href="bighua.top/2019/09/18/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>bighua.top/2019/09/18/InnoDB存储引擎源代码的编译和调试/</id>
    <published>2019-09-18T06:30:31.000Z</published>
    <updated>2019-09-14T12:33:02.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">源码</a></p><h3 id="InnoDB源码结构"><a href="#InnoDB源码结构" class="headerlink" title="InnoDB源码结构"></a>InnoDB源码结构</h3><p>MySQL源码目录下storage文件夹下，文件夹名即为存储引擎名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:storage wuhua$ pwd</span><br><span class="line">/Users/wuhua/Downloads/mysql-8.0.17/storage</span><br><span class="line">wuhua:storage wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── archive</span><br><span class="line">├── blackhole</span><br><span class="line">├── csv</span><br><span class="line">├── example</span><br><span class="line">├── federated</span><br><span class="line">├── heap</span><br><span class="line">├── innobase</span><br><span class="line">├── myisam</span><br><span class="line">├── myisammrg</span><br><span class="line">├── ndb</span><br><span class="line">├── perfschema</span><br><span class="line">├── secondary_engine_mock</span><br><span class="line">└── temptable</span><br><span class="line"></span><br><span class="line">13 directories, 0 files</span><br></pre></td></tr></table></figure><p>InnoDB源码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">wuhua:innobase wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt   </span><br><span class="line">├── COPYING.Google</span><br><span class="line">├── COPYING.Percona</span><br><span class="line">├── Doxyfile</span><br><span class="line">├── api</span><br><span class="line">├── arch</span><br><span class="line">├── btr            //B+ tree的实现</span><br><span class="line">├── buf            //缓冲池的实现，包括LRU算法，Flush刷新算法</span><br><span class="line">├── clone</span><br><span class="line">├── data</span><br><span class="line">├── dict//InnoDB存储引擎中内存数据字典的实现</span><br><span class="line">├── eval</span><br><span class="line">├── fil//InnoDB存储引擎中文件数据结构及对文件的一些操作</span><br><span class="line">├── fsp//file space，对InnoDB engine物理文件的管理，如页、区、段等</span><br><span class="line">├── fts</span><br><span class="line">├── fut</span><br><span class="line">├── gis</span><br><span class="line">├── ha//哈希算法的实现</span><br><span class="line">├── handler//继承MySQL的handler，插件式存储引擎的实现</span><br><span class="line">├── ibuf//插入缓冲的实现</span><br><span class="line">├── include//头文件（.h，.ic）</span><br><span class="line">├── innodb.cmake</span><br><span class="line">├── lob</span><br><span class="line">├── lock//锁的实现，如S锁、X锁，以及定义锁的一系列算法</span><br><span class="line">├── log//日志缓冲和重做日志文件的实现</span><br><span class="line">├── mach</span><br><span class="line">├── mem//辅助缓冲池的实现，用来申请一些数据结构的内存</span><br><span class="line">├── mtr//事务的底层实现</span><br><span class="line">├── os//封装一些对于操作系统的操作</span><br><span class="line">├── page//页的实现</span><br><span class="line">├── pars</span><br><span class="line">├── que</span><br><span class="line">├── read</span><br><span class="line">├── rem</span><br><span class="line">├── row//对于各种类型行数据的操作</span><br><span class="line">├── srv//对于InnoDB engine参数的设计</span><br><span class="line">├── sync//InnoDB engine互斥量（Mutex）的实现</span><br><span class="line">├── trx//事务的实现</span><br><span class="line">├── usr</span><br><span class="line">└── ut//工具类</span><br></pre></td></tr></table></figure><h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>源码中及各存储引擎中README文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;InnoDB源码结构&quot;&gt;&lt;a href=&quot;#InnoDB源码结构&quot; clas
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>性能调优</title>
    <link href="bighua.top/2019/09/17/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>bighua.top/2019/09/17/性能调优/</id>
    <published>2019-09-17T06:27:16.000Z</published>
    <updated>2019-09-14T12:01:07.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择合适的CPU"><a href="#选择合适的CPU" class="headerlink" title="选择合适的CPU"></a>选择合适的CPU</h3><p>InnoDB eigine一般应用OLTP数据库应用，特点：</p><ul><li>用户操作并发量大</li><li>事务处理的时间一般比较短</li><li>查询的语句较为简单，一般都走索引</li><li>复杂的查询较少</li></ul><p>对CPU要求不是很高，复杂的查询操作如比较、排序、连接等消耗CPU的操作较少发生。OLAP是CPU密集型的操作，OLTP是IO密集型的操作。需注意提高IO。</p><p>未获得更多内存的支持，CPU必须是64位的。InnoDB设计架构，主要的后台操作在一个单独的master thread中完成，不能很好的支持多核的应用。多核CPU应选取InnoDB v1.1或更高版本。可通过参数<code>innodb_read_io_threads</code>和<code>innodb_write_io_threads</code>增大IO的线程，更有效地利用CPU的多核性能。</p><p>当前MySQl版本中，一条SQL语句只能在一个CPU中工作，不支持多CPU的处理。</p><h3 id="内存的重要性"><a href="#内存的重要性" class="headerlink" title="内存的重要性"></a>内存的重要性</h3><p>内存的大小最能直接反映数据库的性能。开发前应预估“活跃”数据库的大小，以此确定数据库服务器内存的大小。通过查看当前服务器的状态，比较物理磁盘的读取和内存读取的比例判断缓冲池的命中率，通常InnoDB engine的缓冲池命中率不应小于99%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show  global status like &apos;innodb%read%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_rnd</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_evicted</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_requests</span><br><span class="line">        Value: 5373</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_reads</span><br><span class="line">        Value: 488</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: Innodb_data_pending_reads</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: Innodb_data_read</span><br><span class="line">        Value: 8065536</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: Innodb_data_reads</span><br><span class="line">        Value: 549</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: Innodb_pages_read</span><br><span class="line">        Value: 487</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">Variable_name: Innodb_rows_read</span><br><span class="line">        Value: 120</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当前服务器的状态参数：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">Innodb_buffer_pool_reads</td><td style="text-align:center">表示从物理磁盘读取页的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead</td><td style="text-align:center">预读的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead_evicted</td><td style="text-align:center">预读的页，一般用于判断预读的效率</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_requests</td><td style="text-align:center">从缓冲池中读取页的次数</td></tr><tr><td style="text-align:center">Innodb_data_read</td><td style="text-align:center">总共读入的字节数</td></tr><tr><td style="text-align:center">Innodb_data_reads</td><td style="text-align:center">发起读取请求的次数，每次读取可能需要读取多个页</td></tr></tbody></table><p>缓冲池命中率 = Innodb_buffer_pool_read_requests / (Innodb_buffer_pool_read_requests +  Innodb_buffer_pool_read_ahead + Innodb_data_reads)</p><p>平均每次读取的字节数=Innodb_data_read /  Innodb_data_reads</p><h3 id="磁盘对数据库性能的影响"><a href="#磁盘对数据库性能的影响" class="headerlink" title="磁盘对数据库性能的影响"></a>磁盘对数据库性能的影响</h3><h4 id="传统机械硬盘"><a href="#传统机械硬盘" class="headerlink" title="传统机械硬盘"></a>传统机械硬盘</h4><p>服务器领域一般使用SAS或SATA接口的硬盘，服务器机械硬盘向小型化转型。</p><p>重要指标：寻道时间、转速。</p><p>通常可将多块机械硬盘组成RAID提高数据库的性能，也可将数据文件分布在不同的磁盘上来达到访问负载的均衡。</p><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><p>基于闪存的硬盘，内部由山村（Flash Memory）组成。具有低延时性、低功耗、防震性等。企业级应用一般使用固态硬盘，通过并联多块闪存进一步提高数据传输的吞吐量。</p><p>闪存是一个完全的电子设备，没有传统机械硬盘的读写磁盘。不需要耗费大量的时间进行磁头旋转和定位来查找数据。固态硬盘可以提供一致的随机访问时间。闪存中的数据是不可更新的，只能通过扇区的覆盖重写，在覆盖重写之前，需要执行耗时的擦除操作。擦除操作不能在所含扇区上完成，需要在删除整个被称为擦除块的基础上完成，擦除块的尺寸大于扇区的大小，通常为128KB或者256KB。每个擦除块有擦写次数限制（已有算法解决）。需要考虑固态硬盘在写入方面存在的问题。</p><p>闪存提供的读写速度是非对称的，读取速度远快于写入的速度。通过增加通道数量，可线性提高固态硬盘的性能。固态硬盘的访问延时一般小于0.1ms左右。</p><p>可通过增加参数<code>innodb_io_capacity</code>的值，充分利用固态硬盘带来高的IOPS特性。InnoSQL及InnoDB  v1.2可选择关闭邻接页的刷新，为数据库带来一定效果的提升。</p><p>可利用InnoSQL开发的L2 Cache解决方案，在内存缓冲池和传统存储层之间建立一层基于闪存固态硬盘的二级缓冲池，以此扩充缓冲池的容量，充分利用固态硬盘的超高速随机读写性能，提高数据库的性能。</p><h3 id="合理地设置RAID"><a href="#合理地设置RAID" class="headerlink" title="合理地设置RAID"></a>合理地设置RAID</h3><h4 id="RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"><a href="#RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。" class="headerlink" title="RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"></a>RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。</h4><p>RAID作用：</p><ul><li>增强数据集成度</li><li>增强容错功能</li><li>增加处理量或容量</li></ul><p>RAID组合方式：</p><ul><li>RAID 0:将多个磁盘合并成一个大的磁盘，不会有冗余，并行I/O，速度最快。也称为带区集，将多个磁盘并列起来，使之成为一个大磁盘，存放数据时，将数据按照磁盘的个数进行分段，同时将这些数据写进这些盘中。没有冗余功能，若一个磁盘损坏，所有的数据都会丢失。多磁盘效能受限于总I/O瓶颈，RAID效能随边际递减。</li><li>RAID 1:两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，写入速度略降低。除非拥有相同数据的主磁盘与镜像同时损坏，否则只要有一个磁盘正常的工作即可维持工作，可靠性最高，利用率最低。</li><li>RAID 5:兼顾存储性能、数据安全和存储成本。使用Disk Strping（硬盘分区）技术。至少需要三个磁盘，不对存储的数据进行备份，把数据和相对应的奇偶校验信息存储到组成RAID 5的各个磁盘上，奇偶校验信息和相应的数据分别存储于不同的磁盘上，有一个磁盘损坏后，利用剩下额数据相应的奇偶校验信息恢复被损坏的数据。</li><li>RAID 10和RAID 01:RAID 10先镜像再分区数据，将所有磁盘分为两组，视为RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 01于RAID 10程序相反，先分区再将数据镜射到两组硬盘。</li><li>RAID 50:镜像阵列条带，至少由六块硬盘组成，同RAID 0一样，数据被分区称条带，在同一时间内向多块磁盘写入；同RAID 5一样，以数据的校验保证数据的安全，校验条带均匀分布在各个磁盘上，目的在于提高RAID 5的读写性能。</li></ul><p>对数据库，RAID 10是最好的选择，同时兼顾RAID 1和RAID 0的特性。</p><h4 id="RAID-Write-Back功能"><a href="#RAID-Write-Back功能" class="headerlink" title="RAID Write Back功能"></a>RAID Write Back功能</h4><p>指RAID控制器能够将写入的数据放入自身的缓存中，并把他们安排到后面再执行。不同等待物理磁盘实际写入的完成，写入更快。</p><p>数据库或操作系统关机时，Write Back功能可能会破坏数据库的数据。因写入可能还在RAID卡的缓存中，没有完全写入磁盘。为解决此问题大部分硬件RAID卡提供电池备份单元。</p><p>没有启用Write Back功能，则RAID卡设置中显示为Write Through，没有缓冲写入。Write Through模式下，可通过参数<code>innodb_flush_log_at_trx_commit</code>设置为0提高执行存储过程的性能。</p><h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><ul><li>sysbench<a href="https://www.jianshu.com/p/4a37a6a452d9" target="_blank" rel="noopener">基准测试工具Sysbench</a></li><li>mysql-tpcc<a href="https://www.hi-linux.com/posts/38534.html" target="_blank" rel="noopener">TPCC-MySQL 的安装与使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;选择合适的CPU&quot;&gt;&lt;a href=&quot;#选择合适的CPU&quot; class=&quot;headerlink&quot; title=&quot;选择合适的CPU&quot;&gt;&lt;/a&gt;选择合适的CPU&lt;/h3&gt;&lt;p&gt;InnoDB eigine一般应用OLTP数据库应用，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="majorization" scheme="bighua.top/tags/majorization/"/>
    
  </entry>
  
  <entry>
    <title>备份与恢复</title>
    <link href="bighua.top/2019/09/17/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>bighua.top/2019/09/17/备份与恢复/</id>
    <published>2019-09-17T06:26:59.000Z</published>
    <updated>2019-09-14T10:45:06.507Z</updated>
    
    <content type="html"><![CDATA[<p>备份工具：mysqldump、ibbackup、replication、xtrabackup、LVM快照备份等。</p><h3 id="备份与恢复概述"><a href="#备份与恢复概述" class="headerlink" title="备份与恢复概述"></a>备份与恢复概述</h3><p>根据备份方法分：</p><ul><li>Hot Backup（热备份）：数据库运行中直接备份，对正在运行的数据库操作无任何影响，也称为Online Backup（在线备份）。</li><li>Cold Backup（冷备份）：数据库停止时备份，一般只需要复制相关的数据库物理文件，也称为Offline Backup（离线备份）。</li><li>Warm Backup（温备份）：数据库运行中进行备份，会对当前数据库操作有所影响，例如需要加全局读锁以保证备份数据的一致性。</li></ul><p>按备份后文件的内容分：</p><ul><li>逻辑备份：备份的文件可读，一般是文本文件，内容一般由一条条SQL语句或者是表内实际数据组成。可观察到出文件的内容，一般适用于数据库的升级、迁移等工作。恢复时间较长。</li><li>裸文件备份：复制数据库的物理文件，既可以是数据库运行中的复制，也可以是数据库停止运行时直接的数据文件复制，恢复时间较短。</li></ul><p>按备份数据的内容：</p><ul><li>完全备份：对数据库进行一个完成的备份。</li><li>增量备份：在上次完全备份的基础上，对于更改的数据进行备份。</li><li>日志备份：针对MySQL DB二进制日志的备份，通过对一个完全备份进行二进制日志的重做（replay）来完成数据库的point-in-time的恢复工作。</li></ul><p>MySQl数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave/standby）数据库。MySQL未提供真正的增量备份方法，大部分通过二进制日志完成增量备份的工作。效率较真正的增量备份低。</p><p>增量备份只需要记录当前每页最后的检查点的LSN，若大于之前全备份时的LSN，则备份该页，否则不用备份，是xtrabackup工具增量备份的原理。</p><p>数据库备份的一致性要求在备份的时间数据在这一时间点上是一致的。InnoDB engine支持MVCC，实现一致的备份比较简单。可先开启一个事务，然后导出一组相关的表，最后提交，事务的隔离级别必须设置为REPEATABLE READ。</p><p>mysqldump备份工具，可通过添加–single-transaction选项获得InnoDB存储引擎的一致性备份（必i 加选项）。</p><h3 id="冷备"><a href="#冷备" class="headerlink" title="冷备"></a>冷备</h3><p>InnoDB engine冷备需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.idb），重做日志文件。定期备份MySQL数据库的配置文件my.cnf，有利于恢复的操作。</p><p>优点：</p><ul><li>备份简单，只要复制相关文件即可。</li><li>备份文件易于在不同操作系统，不同MySQL版本上进行恢复。</li><li>恢复简单，只需要把文件恢复到指定位置。</li><li>恢复速度快，不需要执行任何SQL语句，不需要重建索引。</li></ul><p>缺点：</p><ul><li>冷备文件通常比逻辑文件大很大，表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。</li><li>不总是可以轻易跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式会成为问题。</li></ul><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>开始用于完成转存数据库备份及不同数据库之间的移植。</p><p>语法：</p><p><code>mysqldump [arguments] &gt; file_name</code></p><p>参数可通过mysqldump –help查看：</p><ul><li>–single-transaction：保证备份的一致性。备份开始前先执行START TRANSACTION命令，一次获得备份的一致性，只对InnoDB engine有效。启用该参数时需确保没有任何其他任何的DDL语句执行，一致性读并不能隔离DDL操作。</li><li>–lock-tables（-l）：备份过程中依次锁住每个架构下的所有表，一般用于MyISAM engine，当备份时只能对数据库进行读取操作，备份依然可以保证一致性。InnoDB engine不需要使用此参数，用–single-transaction， –lock-tables和–single-transaction互斥，不能同时使用。</li><li>–lock-all-tables（-x）：备份过程中对所有表上锁，避免–lock-tables不能同时锁住所有表的问题。</li><li>–add-drop-database：在CREATE DATABASE前先运行DROP DATABASE。需与–all-databases或–databases选型一起使用。默认情况下到处的文本文件中并不会有CREATE DATABASE，除非指定该参数。</li><li>–master-data [=value]：产生的备份转存文件主要用来建立一个replication。value为1时，转存文件中记录CHANGE MASTER语句，值为2时，CHANGE MASTER语句被写出SQL注释。默认值为空。会自动忽略–lock-tables选项，若没有选用–single-transaction则自动使用–lock-all-tables选项。</li><li>–enents（-E）：备份事件调度器。</li><li>–routines（-R）：备份存储过程和函数。</li><li>–triggers：备份触发器。</li><li>–hex-blob：将BINARY、VARBINARY、BLOG和BIT列类型备份为十六进制的格式。mysqldump文件导出的文本文件上述类型在文本文件模式下可能有些字符不可见，添加此选型会以十六进制的方式显示。</li><li>–tab=path（-T path）：产生TAB分割的数据文件。每张表，mysqldump创建一个包含CREATE TABLE语句的table_name.sql文件，和包含数据的tbl_name.txt文件。可使用–fields-terminated=…，–fields-enclosed-by=…，–fields-optionally-enclosed-by=…，–fields-escaped-by=…，–lines-terminated-by=…来改变默认的分隔符、换行符等。</li><li>–where=’where_condition’ (-w ‘where_condition’)：导出给定条件的数据。</li><li>–all-databases: 备份所有数据库</li><li>–databases： 备份指定数据库</li></ul><h4 id="SELECT…INTO-OUTFILE"><a href="#SELECT…INTO-OUTFILE" class="headerlink" title="SELECT…INTO OUTFILE"></a>SELECT…INTO OUTFILE</h4><p>逻辑备份方法，道出一张表中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT [column 1],[column 2] ...</span><br><span class="line">INTO</span><br><span class="line">OUTFILE &apos;file_name&apos;</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINES</span><br><span class="line">[SATRTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">FROM TABLE WHERE ...</span><br></pre></td></tr></table></figure><p>FIELDS[TERMINATED BY ‘string’]表示每个列的分隔符，[[OPTIONALLY] ENCLOSED BY ‘char’]表示对于字符串的包含符，[ESCAPED BY ‘char’]表示转义符。[STARTING BY ‘string’]表示每行的开始符号，[TERMINATED BY ‘string’]表示每行的结束符号。没指定FIELDS和LINES选型时的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLELDS TERMINATED BY &apos;\t&apos; ENCLOSED BY &apos;&apos; ESCAPED BY &apos;\\&apos;</span><br><span class="line">LINES TERMINATED BY &apos;\n&apos; STARTING BY &apos;&apos;</span><br></pre></td></tr></table></figure><p>file_name表示导出的文件，路径权限必须是mysql：mysql的。</p><h4 id="逻辑备份的恢复"><a href="#逻辑备份的恢复" class="headerlink" title="逻辑备份的恢复"></a>逻辑备份的恢复</h4><p>mysqldump只需执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p &lt; test_backup.sql</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>导入时包含了创建和删除数据库的SQL语句，须确保删除架构时，架构目录下没有其他与数据相关的文件。</p><p>mysqldump可导出存储过程、导出触发器、导出事件、导出数据，不能导出视图。需导出视图定义或备份视图定义的frm文件，在恢复时进行导入。</p><h4 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a>LOAD DATA INFILE</h4><p>通过mysqldump-tab或者SELECT INTO OUTFILE导出的数据，可通过命令LOAD DATA INFILE进行导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[REPLACE | IGNORE] </span><br><span class="line">INTO TABLE tbl_name</span><br><span class="line">[CHARACTER SET charset_name]</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINE </span><br><span class="line">[STARTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">[IGNORE number LINES]</span><br><span class="line">[(col_name_or_user_var,...)]</span><br><span class="line">[SET col_name=expr,...]</span><br></pre></td></tr></table></figure><p>需拥有INFILE权限。导入格式的选项同SELECT INTO OUTFILE命令一致。IGNORE number LINES可忽略导入的前几行。</p><h4 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h4><p>MySQL DB提供的命令行程序，时LOAD DATA INFILE的命令接口，大多数选项与LOAD DATA INFILE语法相同。</p><p><code>mysqlimport [option] db_name textfile1 [textfile2 ...]</code></p><p>该命令可用来导入多张表，通过–user-thread参数并发导入不同的文件。</p><h3 id="二进制日志备份与恢复"><a href="#二进制日志备份与恢复" class="headerlink" title="二进制日志备份与恢复"></a>二进制日志备份与恢复</h3><p>可通过二进制日志完成point-in-time的恢复工作。MySQL DB replication同样需要二进制日志。默认并不启用二进制日志，需先启用。在配置文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">sync-binlog=1</span><br><span class="line">innodb_support_xa=1</span><br></pre></td></tr></table></figure><p>备份二进制日志文件前，可通过FLUSH LOGS命令生成一个新的二进制日志文件，然后备份之前的二进制日志文件。</p><p>恢复二进制日志，通过mysqlbinlog：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log_file | mysql -u root -p</span><br></pre></td></tr></table></figure><p>恢复多个二进制日志文件应该同时恢复，而不是一个一个地恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.[0-10]* | mysql -u root -p</span><br></pre></td></tr></table></figure><p>可通过mysqlbinlog导入到一个文件再通过SOURCE命令导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog_file1 &gt; binglog_file</span><br><span class="line">mysqlbinlog binlog_file2 &gt;&gt; binlog_file</span><br><span class="line">mysql -u root -p -e &quot;scorce binlog_file&quot;</span><br></pre></td></tr></table></figure><p>–start-position和–stop-position选项可指定二进制日志的某个偏移量来进行恢复，可跳过某些不正确的语句。–start-datetime和–stop-datetime选项可用来指定从二进制的某个时间点进行恢复。用法一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinglog --start-position=199512 binlog_file | mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="热备"><a href="#热备" class="headerlink" title="热备"></a>热备</h3><h4 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h4><p>InnoDB engine提供的热备份工具，可同时备份MyISAM engine和InnoDB engine。</p><p>对InnoDB engine table备份工作原理：</p><ul><li>记录备份开始时，InnoDB engine重做日志文件检查点的LSN。</li><li>复制共享表空间文件以及独立表空间文件。</li><li>记录复制完成表空间文件后，InnoDB engine重做日志文件检查点的LSN。</li><li>复制在备份时产生的重做日志</li></ul><p>优点：</p><ul><li>在线备份，不阻塞任何SQL语句。</li><li>备份性能好，实质是复制数据库文件和重做日志文件。</li><li>支持压缩备份，通过选项，可支持不同级别的压缩。</li><li>跨平台支持，ibbackup可运行在Linux、Windows以及主流的Unix系统平台上。</li></ul><p>ibbackup恢复InnoDB engine table：</p><ul><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ul><p>xtrabackup实现了ibbackup的功能，拓展支持了真正的增量备份功能。</p><h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>网址：<a href="https://launchpad.net/percona-xtrabackup" target="_blank" rel="noopener">xtrabackup</a>。</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --backup | --prepare [OPTIONS]</span><br></pre></td></tr></table></figure><p>开始备份时，首先记录重做日志的位置，然后对备份的InnoDB engine table的物理文件，即共享表空间文件和独立表空间文件进行复制，最后记录备份完成后的重做日志位置。</p><h4 id="xtrabackup实现增量备份"><a href="#xtrabackup实现增量备份" class="headerlink" title="xtrabackup实现增量备份"></a>xtrabackup实现增量备份</h4><p>原理：</p><ol><li>先完成一个全备，记录下此时额检查点LSN。</li><li>增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，是则备份该页，同时记录当前检查点的LSN。</li></ol><h3 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h3><p>通过文件系统支持的快照功能对数据库进行备份。前提是将所有数据库文件放在同一文件分区中，然后对分区进行快照操作。支持快照功能的文件系统和设备有FreeBSD的UFS文件系统，Solaris的ZFS文件系统，GUN/Linux的逻辑管理器（Logical Volume Manager，LVM）等。UFS和ZFS的快照实现大致和LVM相似。</p><p>LVM使用写时复制（Copy-on-write）技术创建快照。</p><p>参阅<a href="https://www.cnblogs.com/kevingrace/p/6129660.html" target="_blank" rel="noopener">Mysql备份系列（4）–lvm-snapshot备份mysql数据(全量+增量）操作记录</a>。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制（replication）是MySQL DB提供的一种高可用高性能解决方案，一般用于建立大型应用。步骤：</p><ul><li>主服务器（master）把数据更改记录到二进制日志（binlog）中。</li><li>从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</li><li>从服务器重做中继日志中的重做日志，把更改应用到自己的数据库上，以达到数据的最终一致。</li></ul><p>实质是一个完全备份加上二进制日志备份的还原。复制是异步实时的，存在主动服务器之间的执行延时。可通过SHOW SLAVE STATUS和SHOW MASTE STATUS查看当前的延时。</p><p>主要变量：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Slave_IO_State</td><td style="text-align:center">当前IO线程的状态</td></tr><tr><td style="text-align:center">Master_Log_File</td><td style="text-align:center">当前同步的主服务器的二进制日志</td></tr><tr><td style="text-align:center">Read_Master_Log_Pos</td><td style="text-align:center">显示当前同步到主服务器上二进制日志的偏移量位置，单位字节。</td></tr><tr><td style="text-align:center">Relay_Master_Log_File</td><td style="text-align:center">当前中继日志同步的二进制日志</td></tr><tr><td style="text-align:center">Relay_Log_File</td><td style="text-align:center">显示当前写入的中继日志</td></tr><tr><td style="text-align:center">Relay_Log_Log</td><td style="text-align:center">显示当前执行到中继日志的便宜量位置</td></tr><tr><td style="text-align:center">Slave_IO_Running</td><td style="text-align:center">从服务器中IO线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Slave_SQL_Running</td><td style="text-align:center">从服务器中SQL线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Exec_Master_Log_Pos</td><td style="text-align:center">表示同步到主服务器的二进制日志偏移量的位置，Read_Master_Log_Pos-Exec_Master_Log_Pos可表示当前SQL线程运行的延时，单位是字节。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;备份工具：mysqldump、ibbackup、replication、xtrabackup、LVM快照备份等。&lt;/p&gt;
&lt;h3 id=&quot;备份与恢复概述&quot;&gt;&lt;a href=&quot;#备份与恢复概述&quot; class=&quot;headerlink&quot; title=&quot;备份与恢复概述&quot;&gt;&lt;/a&gt;备
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="backup" scheme="bighua.top/tags/backup/"/>
    
      <category term="recovery" scheme="bighua.top/tags/recovery/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="bighua.top/2019/09/16/%E4%BA%8B%E5%8A%A1/"/>
    <id>bighua.top/2019/09/16/事务/</id>
    <published>2019-09-16T06:26:40.000Z</published>
    <updated>2019-09-14T08:06:59.896Z</updated>
    
    <content type="html"><![CDATA[<p>事务把数据库从一种一致状态转换为另一种一致状态。</p><h3 id="认识事务"><a href="#认识事务" class="headerlink" title="认识事务"></a>认识事务</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是访问并更新数据库中各种数据项的一个程序执行单元。</p><p>A(Atomicity)，原子性。整个数据库事务是不可分割的工作单位。对只读操作发生错误，要么重试要么返回错误代码。但对于需要改变系统中状态的操作，若操作失败，需要保护系统中并发用户访问受影响的部分数据。</p><p>C(Consistency)，一致性。事务将数据库从一种状态转变为下一种一致的状态。事务开始前后，数据库的完整性约束没有被破坏。</p><p>I(Isolation)，隔离性。也称并发控制、锁、可串行化等。要求每个读写事务的对象对其他其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，通常用锁来实现。粒度锁（granular lock）策略，允许事务仅锁住一个实体对象的子集，以此提高事务之间的并发度。</p><p>D(Durability)，持久性。事务一旦提交，结果就是永久性的。持久性保证事务系统的高可靠性，非高可用性。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>事务理论角度：</p><ul><li>扁平事务（Flat transactions），使用最为频繁的事务。扁平事务中，所有操作都处于同一层次，由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。</li><li>带有保存点的扁平事务（Flat Transaction with Savepoints），除支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。保存点（Savepoint）通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。扁平事务隐式设置且整个事务中只有一个保存点，回滚只能回滚到事务开始时的状态。保存点SAVE WORK函数建立，通知系统当前的处理状态。出现问题时，保存点作为内部重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。保存点在事务内部递增，ROLLBACK不影响保存点的计数，递增编号能保持事务执行的整个历史过程。</li><li>链事务（Chained Transaction），保存点模式的变种。当系统崩溃时，扁平事务的保存点都将消失，恢复时，事务从开始处重新执行，不能从最近的一个点继续执行，保存点是易失的非持久的。链事务：在提交一个事务时，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作。扁平事务能回滚到任意正确的保存点，链事务回滚仅限于当前事务，只能恢复到最近一个的保存点。对于锁，链事务在执行COMMIT后释放当前事务所持有的锁，带保存点的扁平事务不影响其所持有的锁。</li><li>嵌套事务（Nested Transaction），层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（sub transaction），控制每一个局部的变换。</li><li>分布式事务（Distributed transaction），通常是一个在分布式环境下运行的扁平事务，需要根据数据所在的位置访问网络中的不同节点。</li></ul><p>Moss对嵌套事务的的定义：  </p><ol><li>由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。 </li><li>处在叶子节点的事务是扁平事务，每个子事务从根节点到叶节点的距离可以是不同的。</li><li>位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为（predecessor）为父事务（parent），事务的下一层为儿子事务（child）。</li><li>子事务既可以提交也可以回滚，并不会马上生效，需等待父事务提交。</li><li>书中任何一个事务的回滚会引起它的所有子事务一同回滚，子事务仅保留A、C、I特性，不具有D特性。</li></ol><p>Moss理论中实际工作由叶子节点来完成，只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。高层的事务仅负责逻辑控制，决定何时调用相关的子事务。</p><p>InnoDB支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的隔离性由锁实现。原子性、一致性、持久性通过数据库的redo log和undo log完成。redo log（重做日志）保证事务的原子性和持久性，undo log保证事务的一致性。</p><p>redo log恢复提交事务修改的页操作，undo log回滚记录到某个特定版本。两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行修改记录进行记录。</p><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>重做日志实现事务的持久性，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的。</p><p>InnoDB通过Force Log at Commit机制实现事务的持久性，当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成。此处日志分为redo log和undo log。前者宝成事务的持久性，后者帮助事务会回滚及MVCC的功能。redo log基本是顺序写的，undo log需要进行随机读写。</p><p>为确保每次日志写入重做日志文件，每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（同步内存中所有已修改的文件数据到存储设备）操作。重做日志文件打开没有使用O_DIRECT选项，重做日志缓冲先写入文件系统缓存。为确保重做日志写入磁盘，必须进行一次fsync操作。fsync的效率取决于磁盘的性能，磁盘的性能决定了事务提交的性能，即数据库的性能。</p><p>允许手工设置非持久性的情况发生，提高数据库的性能。此时事务提交时，日志不写入重做日志文件，等待下一个时间周期后再执行fsync操作。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，该参数的默认值为1，表示事务提交时必须调用一次fsync操作。可设置为0和2。0表示提交事务时不进行写入重做日志操作，操作仅在master thread中完成，master thread中每一秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入重做日志文件的缓存中，不进行fsync操作。</p><p>二进制日志文件bin log，用于进行POINT_IN_TIME（PIT）的恢复及主从复制（Replication）环境的建立。</p><p>重做日志在InnoDB存储引擎层产生，二进制日志在MySQL数据库的上层产生，二进制日志不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生二进制日志。MySQL上层的二进制日志是一种逻辑日志，记录的是对应的SQL语句，InnoDB存储引擎层的重做日志是物理格式日志，记录的是对于每个页的修改。二进制日志只在事务提交完成后进行一次写入，InnoDB存储引擎的重做日志在事务进行中不断地被写入，表现为日志并不是随事务提交的顺序进行写入的。</p><h5 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h5><p>InnoDB engine中重做日志以512字节进行存储的，意味着重做日志缓存、重做日志文件都是以块的方式进行保存的，称之为重做日志块（redo log block）。</p><p>若一个页产生的重做日志数量大于512字节，则需要分割为多个重做日志块进行存储。重做日志块的大小和扇区大小一样，重做日志的写入可保证原子性，不需要doublewrite技术。</p><p>重做日志块除日志本身外还由日志块头（log block header）及日志块尾（log block tailer）两部分组成。重做日志块头占用12字节，重做日志块尾占用8字节，每个重做日志块实际可存储的大小为492字节。</p><p>log block header由4个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用字节</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LOG_BLOCK_HDR_NO</td><td style="text-align:center">4</td><td style="text-align:center">标记log block在logbuffer中的位置，递增且循环使用，第一位用于判断是否是flush bit</td></tr><tr><td style="text-align:center">LOG_BLOCK_HDR_DATA_LEN</td><td style="text-align:center">2</td><td style="text-align:center">表示log block所占用的大小，当log block写满时，值为0x200，表示使用全部log block空间，即占用512字节</td></tr><tr><td style="text-align:center">LOG_BLOCK_FIRST_REC_GROUP</td><td style="text-align:center">2</td><td style="text-align:center">表示log block中第一个日志所在的偏移量，若等于LOG_BLOCK_HDR_DATA_LEN，表示当前log block不包含新的日志</td></tr><tr><td style="text-align:center">LOG_BLOCK_CHECKPOINT_NO</td><td style="text-align:center">4</td><td style="text-align:center">表示该log block最后被写入时检查点第4字节的值。</td></tr></tbody></table><p>log block tailer只由一个部分组成，值和LOG_BLOCK_CHECKPOINT_NO相同，并在函数log_block_init中被初始化。</p><h5 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h5><p>重做日志组，由多个重做日志文件。源码已支持log group的镜像功能，但在ha_innobase.cc文件中禁止该功能。InnoDB engine实际只有一个log group。</p><p>逻辑上的概念，并无实际物理文件表示log group信息。每个log group中日志文件大小相同，InnoDB v1.2前，重做日志文件总大小小于4GB，此版本开始大小限制提高为512GB。</p><p>重做日志文件中存储的是在log buffer中保存的log block，根据块的方式进行物理存储的管理，每个块大小与log block一样为512字节。log buffer根据一定规则将内存中的log block刷新到磁盘：</p><ul><li>事务提交时</li><li>log buffer中有一半的内存空间已经被使用时</li><li>log checkpoint时</li></ul><p>log block的写入为追加到redo log file的最后部分，当一个redo log被写满时，会接着写入下一个redo log file，使用方式为round-robin。redo log file除了保存log buffer刷新到磁盘的log block，还保存其他共占2KB大小的信息，每个redo log file的前2KB部分不保存log block信息。</p><p>log group中的第一个redo log file前2KB保存4个512字节大小的块，存放内容为：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小 </th></tr></thead><tbody><tr><td style="text-align:center">log file header</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint1</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint2</td><td style="text-align:center">512 </td></tr></tbody></table><p>仅在每个log group的第一个redo log file中进行存储，其余redo log file仅保留这些空间，但不保存上述信息。</p><p>写入redo log file时，除了log block的写入，还需要更新前2KB部分的信息，这些信息用于InnoDB engine恢复操作。log file header后面的部分为InnoBD存储引擎保存的checkpoint(检查点)值，设计为交替写入，避免因介质失败而导致无法找到可用的checkpoint的情况。</p><h5 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h5><p>InnoDB engine存储管理基于页，重做日志格式也是基于页的。其重做日志格式有着通用的头部格式。</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo log body</th></tr></thead><tbody><tr><td style="text-align:center">重做日志的类型</td><td style="text-align:center">表空间的ID</td><td style="text-align:center">页的偏移量</td><td style="text-align:center">存储内容  </td></tr></tbody></table><h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>Log Sequence Number的缩写，代表着日志序列号，InnoDB存储引擎中，占用8字节，单调递增。表示：</p><ul><li>重做日志写入的总量</li><li>checkpoint的位置</li><li>页的版本</li></ul><p>存在于每个页的头部，值FIL_PAGE_LSN，记录该页的LSN，表示该页最后刷新时LSN的大小。可用于根据重做日志的LSN比较页的LSN判断是否需要进行恢复操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5337425</span><br><span class="line">Log flushed up to   5337425</span><br><span class="line">Pages flushed up to 5337425</span><br><span class="line">Last checkpoint at  5337416</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">182 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Log sequence number表示当前的LSN，Log flushed up to表示刷新到重做日志文件的LSN，Pages flushed up to表示已经刷新到磁盘数据页上的LSN，Last checkpoint at表示刷新到磁盘的LSN。</p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>InnoDB eigine不管上次DB运行是否正常关闭，都会尝试进行恢复操作。</p><p>恢复过程中仅需恢复checkpoint开始的日志部分，即LSN记录开始的重做日志。</p><h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>利用undo信息对事务进行回滚到数据之前的样子。</p><p>undo存放在数据库内部的一个特殊段（segment）中，称为undo段（undo segment）。undo段位于共享表空间内。</p><p>undo是逻辑日志，只是将数据库逻辑地恢复到原来的样子，修改被逻辑地取消，由于可能存在其他用户对页上其他非锁定记录的修改，数据结构和页本身在回滚之后可能大不相同。</p><p>InnoDB engine回滚时，实际上做的是与先前相反的工作，对于每个INSERT，执行一个DELETE；对于每一个DELETE，会执行一个INSERT；对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。</p><p>undo的另一个作用是MVCC，当用户读取一行数据时，若该记录已经被其他事务占用，则当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><p>undo log会产生redo log，undo log需要持久性的保护。</p><h5 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h5><p>采用段的方式管理undo。InnoDB eigine有rollback segment，每个rollback segment记录了1024个undo log segment，每个undo log segment中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有的rollback segment header所在的页，页类型为FIL_PAGE_TYPE_SYS。</p><p>InnoDB v1.1前只有一个rollback segment，支持同时在线的事务限制为1024，1.1开始支持最大128个rollback segment，，支持同时在线的事务限制提高到128*1024.</p><p>InnoDB v1.2开始可通过参数对rollback segment进行设置：</p><ul><li><code>innodb_undo_directory</code>，设置rollback segment文件所在的路径，rollback segment可以存放在共享表空间之外的位置。</li><li><code>innodb_undo_logs</code>，设置rollback segment的个数，默认128，替换之前的参数<code>innodb_rollback_segments</code>。</li><li><code>innodb_undo_tablespaces</code>，设置构成rollback segment文件的数量，使rollback segment可以较平均分布在多个文件中。设置后可在路径<code>innodb_undo_directory</code>看到undo为前缀的文件，代表rollback segment文件。</li></ul><p>undo log segment分配页并写入undo log时同样需要写入重做日志，事务提交时，InnoDB会：</p><ul><li>将undo log放入列表，以供之后的purge操作。</li><li>判断undo log所在的页是否可以重用，若可以则分配给下一个事务使用。</li></ul><p>事务提交后不能马上删除undo log及undo log所在的页，可能有其他事务需要通过undo log取得行记录之前的版本，事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在的页由purge线程判断。</p><p>InnoDB engine中undo页可以进行重用，事务提交时，首先将undo log放入链表，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面。存放undo log的列表以记录进行组织，undo页可能存放着不同事务的undo log，purge操作需要涉及磁盘的离散读取操作，比较缓慢。</p><p>通过SHOW ENGINE INNODB STATUS查看链表中undo log的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46329</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>History list length代表undo log的数量，purge操作会减少该值。由于undo log所在的页可以被重用，操作后，改值也未必为0。</p><h5 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h5><p>参考<a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB undo log 漫游</a>。</p><p>分为：</p><ul><li>insert undo log，在insert操作过程中产生的undo log，insert操作只对事务本身可见，对其他事务不可见，事务提交后直接删除。不需要进行purge操作。</li><li>undapte undo log，对delete和update操作产生的undo log。可能需要提供MVCC机制，不能在事务提交后立即删除，提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul><p>undapte undo log较insert undo log记录的内容更多，占用的空间更大，undapte undo log又分为(type_cmpl值)：</p><ul><li>TRX_UNDO_UPD_EXIST_REC（=12），更新non-delete-mark的记录</li><li>TRX_UNDO_UPD_DEL_REC（=13），将delete的记录标记为not delete</li><li>TRX_UNDO_DEL_MARK_REC（=14）， 将记录标记为delete</li></ul><h5 id="查看undo信息"><a href="#查看undo信息" class="headerlink" title="查看undo信息"></a>查看undo信息</h5><p>InnoDB engine DBA只能通过原理和经验来判断。InnoSQL对information_schema拓展添加数据字典表<code>INNODB_TRX_ROLLBACK_SEGMENT</code>和<code>INNODB_TRX_UNDO</code>来查看undo信息，前者用于查看rollback segment，后者用于记录事务对应的undo log，方便了解事物产生的undo量。</p><p>delete操作并不直接删除记录，将记录标记为已删除（delete flag设置为1），记录的最终删除在purge中完成。update主键的操作分两步完成，先将原主键标记为已删除，需要产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log，之后插入一条新的记录，需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。</p><h4 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h4><p>purge最终完成delete和update操作，InnoDB支持MVCC，记录不能在事务提交时立即进行处理。因为其他事务可能正在引用这行，需要保存记录之前的版本。当该行记录不被任何其他事务引用，就可以进行真正的delete操作，清理之前行记录的版本。</p><p>InnoDB有一个histroy列表，根据事务提交的顺序，将undo log进行链接，先提交的事务总在尾端。</p><p>purge过程中，先在histroy list中找到第一个需要被清理的记录，清理之后会在被清除记录的undo log所在页继续寻找是否存在可以被清理的记录，有则清理，没有则返回histroy list中查找继续按此步骤清理。此法避免了大量的随机读取，提高purge效率。</p><p>动态参数<code>innodb_purge_batch_size</code>用于设置每次purge操作需要清理的undo page数量。InnoDB v1.2前默认20，此v开始默认300。动态参数<code>innodb_max_purge_lag</code>用于控制histroy list的长度，默认为0，表示不对其做限制，当大于0时，表示会延缓DML操作。延缓算法：<br><code>delay = ((length(histroy_list) - innodb_max_purge_lag) * 10) - 5</code></p><p>单位毫秒，对象是行，delay会在每次purge操作后重新计算。InnoDB v1.2后引入动态参数<code>innodb_max_purge_lag_delay</code>控制delay的最大毫秒数，当计算得到的delay值大于该值时，取<code>innodb_max_purge_lag_delay</code>，避免purge操作缓慢导致其他SQL线程无限制等待。</p><h4 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h4><p>非只读事务，每次事务提交时需要进行一次fsync操作，保证重做日志都已经写入磁盘。fsync性能有限，为提高效率，提供group commit功能，一次fsync可以刷新确保多个事务日志被写入文件。InnoDB事务提交时进行两个阶段操作：</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync将确保日志都从重做日志缓冲写入磁盘。</li></ol><p>步骤2相对步骤1慢，有事务进行步骤2时，其他事务可进行事务1，事务完成提交后，再次进行步骤2，将多个事务的重做日志通过一次fsync刷新到磁盘，减少磁盘的压力，提高性能。</p><p>InnoDB v1.2前，开启二进制日志InnoDB存储引擎的group commit功能会失效，导致性能下降。开启二进制日志为保证存储引擎层中事务和二进制日志的一致性，二者之间使用了两阶段事务：</p><ol><li>事务提交时InnoDB engine进行purge操作</li><li>MySQL数据库上层写入二进制日志。</li><li><p>InnoDB存储引擎将日志写入重做日志文件。</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync确保日志都从重做日志缓冲写入磁盘。</li></ol></li></ol><p>一旦步骤2完成，就确保了事务的提交，即使步骤3时发生宕机。但每个步骤都进行一次fsync操作才能保证上下两层数据的一致性。步骤2的fsync参数由参数<code>fsync_binlog</code>控制，步骤3的fsync由参数<code>innodb_flush_log_at_trx_commit</code>控制。MySQL内部使用<code>prepare_commit_mutex</code>锁保证上层二进制日志的写入顺序与InnoDB层事务提交顺序一致。启用锁后步骤3中的步骤1不可以在其他事务执行步骤3的步骤2时执行，导致group commit失效。</p><p>MySQL v5.6实现了Binary Log Group Commit（BLGC）解决此问题，在上层提交时先按顺序将其放入一个队列中，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。BLGC步骤：</p><ul><li>Flush阶段，将每个事务的二进制日志写入内存中。</li><li>Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，仅一次fsync操作完成二进制日志的写入，即BLGC。</li><li>Commit阶段，leader根据顺序调用存储引擎层事务的提交，修复由于锁<code>prepare_commit_mutex</code>导致group commit失效问题。</li></ul><p>当有一组事务提交时，其他新事务可以进行Flush阶段，使group commit不断生效。group commit的效果由队列中事务的数量决定，若每次队列中仅有一个事务，效果同之前可能会更差。提交的事务越多，group commit效果越明显。</p><p>参数<code>innodb_max_flush_queue_time</code>控制Flush阶段中等待的时间，即使之前的一组事务完成提交，当前一组事务也不马上进入Sync阶段，至少需要等待一段时间。使group commit的事务数量更多，可能导致事务响应时间变慢。参数默认值0，推荐设置也为0。</p><h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下，事务自动提交的，执行SQL语句后会马上执行COMMIT操作。</p><p>事务控制语句：</p><ul><li>START TRANSACTION | BEGIN：显示地开启一个事务。存储过程中，MySQL DB分析器会自动将BEGIN识别为BEGIN…END，存储过程中只能使用START TRANSACTION语句开启事务。</li><li>COMMIT：提交事务，使得已对数据库所做的所有修改称为永久性的。可直接发出COMMIT，也可写为等价语句COMMIT WORK。后者控制事务结束后的行为是CHAIN还是RELEASE的，是CHAIN方式，则事务变成链事务。通过参数<code>completion_type</code>进行控制，默认为0，表示没有任何操作，两者等价，设为1时，后者等价COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。</li><li>ROLLBACK：回滚结束事务，并撤销正在进行的所有未提交的修改。可直接发出ROLLBACK，也可写为等价语句ROLLBACK WORK。工作同上方语句。</li><li>SAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。</li><li>RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句会抛出一个异常。</li><li>ROLLBACK TO[SAVEPOINT] identifier：与SAVEPOINT命令一起使用，把事务回滚到标记点，而不回滚在此标记点之前任何工作。回滚到一个不存在的保存点会抛出异常。该语句并不是真正地结束一个事务，执行后任然需要显示地执行COMMIT或者ROLLBACK命令。</li><li>SET TRANSACTION：设置事务的隔离级别。InnoDB提供的隔离级别有：READ UNCOMMITTED、READCOMMITTD、REPEATABLE READ、SERIALIZABLE。</li></ul><p>事务是原子的，构成事务的每条语句都会提交或者所有语句都会回滚，一条语句要么完全成功要么完全回滚。一条语句失败并抛出异常时，并不会导致先前已执行的语句自动回滚，所有的执行都会得到保留， 由用户决定是否对事务进行提交或者回滚。</p><h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><p>执行语句后会有一个隐式的COMMIT操作的SQL语句：</p><ul><li>DDL语句：ALTER DATABASE…UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRUNCATE TABLE。</li><li>隐式修改MySQL机构操作：CREATE USER，DROP USER，GRANT，RENAME USER，REVOKE，SET PASSWORD。</li><li>管理语句：ANALYZE TABLE，CACHE INDEX，CHECK TABLE，LOAD INDEX INTO CACHE，OPTIMIZE TABLE，REPAIR TABLE。</li></ul><p>TRUNCATE TABLE语句是DDL，和对整张表执行DELETE操作结果一样，但不能被回滚。</p><h3 id="对事务操作的统计"><a href="#对事务操作的统计" class="headerlink" title="对事务操作的统计"></a>对事务操作的统计</h3><p>在考虑每秒请求数（Question Per Second，QPS）的同时，关注每秒事务处理（Transaction Per Second，TPS）的能力。</p><p>所有事务显示提交：<code>TPS = (com_commit + com_rollback) / time</code>，隐式提交和回滚不会计算到com_commit和com_rollback变量中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;com_commit&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_commit</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_rollback&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_rollback</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数handle_commit和handle_rollback用于事务统计。MySQL v5.1中可统计InnoDB engine显示和隐式的事务提交操作，在InnoDB Plugin中不准确。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL标准事务隔离级别：</p><ul><li>READ UNCOMMITTED：浏览访问。</li><li>READ COMMITTED：游标稳定。除唯一性的约束检查及外键约束的检查需要gap lock，engine 不会使用gap lock的锁算法。MySQl v5.1会导致主从数据不一致问题。</li><li>REPEATABLE READ：无幻读保护。</li><li>SERIALIZABLE：隔离。InnoDB为每个SELECT语句后自动加上LOCK IN SHARE MODE，即为读取加共享锁，对一致性的非锁定读不在于以支持。主要用于InnoDB engine的分布式事务。</li></ul><p>SQL和SQL2的默认事务隔离级别为SERIALIZABLE，InnoDB默认隔离级别为REPEATABLE READ，采用Next-Key Lock锁算法避免幻读。</p><p>级别越低事务请求锁越少或保持锁的时间越短。</p><p>设置当前回话或全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</span><br><span class="line">&#123;</span><br><span class="line">READ UNCOMMITTED</span><br><span class="line">| READ COMMITTED</span><br><span class="line">| REPEATABLE READ</span><br><span class="line">| SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过修改MySQL配置文件，在MySQL启动时设置事务默认隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">transaction-isolation = READ UNCOMMITTED</span><br></pre></td></tr></table></figure><p>查看当前事务隔离级别和全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务指允许多个独立的事务资源（transaction rescourcs）参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，对于事务原有的ACID要求有了提高。</p><h4 id="MySQL数据库分布式事务"><a href="#MySQL数据库分布式事务" class="headerlink" title="MySQL数据库分布式事务"></a>MySQL数据库分布式事务</h4><p>分布式事务</p><p>InnoDB engine提供对XA事务的支持，通过XA事务来支持分布式事务的实现。使用分布式事务时，InnoDB engine的事务隔离级别必须设置为SERIALIZABLE。</p><p>XA事务允许不同数据库之间的分布式事务，需要参与在全局事务中的每个节点都支持XA事务。XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p><ul><li>资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。</li><li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li><li>应用程序：定义事务边界，指定全局事务中的操作。</li></ul><p>MySQL DB分布式事务中，资源管理器是MySQL数据库，事务管理器为连接MySQL服务器的客户端。</p><p>分布式事务使用两段式提交（two-phase commit）的方式。第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好了。第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。若任何一个节点显示不能提交，则所有的节点都被告知需要回滚。与本地事务相比，分布式事务需要多一次PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或者ROLLBACK操作。</p><p>MySQL数据库XA事务的SQL语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XA &#123;START | BEGIN&#125; xid [JOIN | RESUME]</span><br><span class="line"></span><br><span class="line">XA END xid [SUSPEND [FOR MIGRATE]]</span><br><span class="line"></span><br><span class="line">XA PREPARE xid</span><br><span class="line"></span><br><span class="line">XA COMMIT xid [ONE PHASE]</span><br><span class="line"></span><br><span class="line">XA ROLLBACK xid</span><br><span class="line"></span><br><span class="line">XA RECOVER</span><br></pre></td></tr></table></figure><p>通过参数<code>innodb_support_xa</code>查看是否启用了XA事务的支持，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_support_xa&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_support_xa</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h4><p>外部事务：资源管理器是MySQL数据库本身。</p><p>内部XA事务：在存储引擎与插件之间，或者存储引擎与存储引擎之间</p><p>常见的内部XA事务存在于binlog与InnoDB存储引擎之间。事务提交时，InnoDB engine先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，若在InnoDB engine提交前宕机，MySQL DB重启后会先检查准备的UXID事务是否已经提交，若没有则在存储引擎层再进行一次提交操作。能够避免二进制日志写入后宕机，传给从数据库二进制日志并执行，导致主从数据库不一致问题。</p><h3 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h3><ul><li>在循环中提交：不论是现实的提交还是隐式的提交。</li><li>使用自动提交：应在程序端进行事务的开始和结束。对不同语言的API，自动提交不同。</li><li>使用自动回滚：InnoDB engine支持通过定义一个HANDLER来进行自动事务的回滚操作，如在一个存储过程中发生了错误会自动对其进行回滚操作。</li></ul><h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><p>执行时间较长的事务。对长事务，转化为小批量的事务进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事务把数据库从一种一致状态转换为另一种一致状态。&lt;/p&gt;
&lt;h3 id=&quot;认识事务&quot;&gt;&lt;a href=&quot;#认识事务&quot; class=&quot;headerlink&quot; title=&quot;认识事务&quot;&gt;&lt;/a&gt;认识事务&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="transaction" scheme="bighua.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="bighua.top/2019/09/11/%E9%94%81/"/>
    <id>bighua.top/2019/09/11/锁/</id>
    <published>2019-09-11T06:26:28.000Z</published>
    <updated>2019-09-12T11:37:26.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><p>InnoDB存储引擎在行级别上对表数据上锁，也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，锁保证一致性。</p><p>InnoDB锁的实现类似Oracle，提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，可以同时得到并发性和一致性。</p><h3 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h3><p>DB中，lock和latch都可以被称为“锁”。</p><p>latch一般称为闩锁（轻量级的锁），要求锁定的时间必须非常短，若持续的时间长，应用的性能会非常差。InnoDB中，latch分为mutex（互斥量）和rwlock（读写锁），目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或roolback后进行释放（不同事物隔离级别释放的时间可能不同）。</p><p>lock和latch的不同：</p><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">lock</th><th style="text-align:center">latch</th></tr></thead><tbody><tr><td style="text-align:center">对象</td><td style="text-align:center">事务</td><td style="text-align:center">线程</td></tr><tr><td style="text-align:center">保护</td><td style="text-align:center">数据库内容</td><td style="text-align:center">内存数据结构</td></tr><tr><td style="text-align:center">持续时间</td><td style="text-align:center">整个事务过程</td><td style="text-align:center">临界资源 </td></tr><tr><td style="text-align:center">模式</td><td style="text-align:center">行锁、表锁、意向锁</td><td style="text-align:center">读写锁、互斥量</td></tr><tr><td style="text-align:center">死锁</td><td style="text-align:center">通过waits-for graph、time out等机制进行死锁检测与处理</td><td style="text-align:center">无死锁检测与处理机制。仅通过应用程序加锁的顺序（lock leveling）保证无死锁的情况发生</td></tr><tr><td style="text-align:center">存在于</td><td style="text-align:center">Lock Manage的哈希表中</td><td style="text-align:center">每个数据结构的对象中</td></tr></tbody></table><p>通过命令<code>SHOW RNGINE INNODB MUTEX</code>查看InnoDB中的latch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb mutex;</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| Type   | Name                      | Status   |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:2730 | waits=2  |</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:1183 | waits=10 |</span><br><span class="line">| InnoDB | rwlock: log0log.cc:838    | waits=15 |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在Debug模式下Status列展示更多信息:</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">mutex被请求的次数</td></tr><tr><td style="text-align:center">spin_waits</td><td style="text-align:center">spin lock(自旋锁)的次数，InnoDB engine latch在不能获得锁时首先进行自旋，若自旋后还不能获得锁，则进入等待状态</td></tr><tr><td style="text-align:center">spin_rounds</td><td style="text-align:center">自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spain_waits表示平均每次所需的内部循环次数。</td></tr><tr><td style="text-align:center">os_waits</td><td style="text-align:center">表示操作系统等待的次数，当spin lock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒。</td></tr><tr><td style="text-align:center">os_yields</td><td style="text-align:center">进行os_thread_yield唤醒操作的次数</td></tr><tr><td style="text-align:center">os_wait_times</td><td style="text-align:center">操作系统等待的时间，单位ms</td></tr></tbody></table><p>可通过命令SHOW ENGINE INNODB STATUS及information_schema架构下的表INNODB_TRX，INNODB_LOCKS、INNODB_LOCK_WAITS观察锁的信息。</p><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或更新一行数据。</li></ul><p>X锁与任何锁都不兼容（变更行记录），S锁仅和S锁兼容（读取不更改行记录）。</p><p>意向将锁定的对象分为多个层次，意味着事务希望在更细粒度上进行加锁。支持多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在。 </p><p>InnoDB支持的意向锁为表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型。支持两种意向锁：</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</li></ul><p>意向锁不会阻塞除全表扫描以外的任何请求。意向锁和行级锁的兼容性：</p><table><thead><tr><th style="text-align:center">锁\兼容性</th><th style="text-align:center">IS</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center">IS</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N </td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><p>InnoDB v1.0前只能通过<code>SHOW ENGINE INNODB STATUS</code>、<code>SHOW FULL PROCESSLIST</code>命令查看当前锁请求的信息，之后可通过INFORMATION_SCHEMA架构下的表INNODB_LOCKS、INNODB_LOCK_TRX、INNODB_LOCK_WAITS更简单地监控当前事务并分析可能存在的锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46328</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_TRX;</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| Field                      | Type                | Null | Key | Default             | Extra |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| trx_id                     | varchar(18)         | NO   |     |                     |       |</span><br><span class="line">| trx_state                  | varchar(13)         | NO   |     |                     |       |</span><br><span class="line">| trx_started                | datetime            | NO   |     | 0000-00-00 00:00:00 |       |</span><br><span class="line">| trx_requested_lock_id      | varchar(81)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_wait_started           | datetime            | YES  |     | NULL                |       |</span><br><span class="line">| trx_weight                 | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_mysql_thread_id        | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_query                  | varchar(1024)       | YES  |     | NULL                |       |</span><br><span class="line">| trx_operation_state        | varchar(64)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_tables_in_use          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_tables_locked          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_structs           | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_memory_bytes      | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_locked            | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_modified          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_concurrency_tickets    | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_isolation_level        | varchar(16)         | NO   |     |                     |       |</span><br><span class="line">| trx_unique_checks          | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_foreign_key_checks     | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_last_foreign_key_error | varchar(256)        | YES  |     | NULL                |       |</span><br><span class="line">| trx_adaptive_hash_latched  | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_adaptive_hash_timeout  | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_is_read_only           | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_autocommit_non_locking | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCKS;</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| lock_id     | varchar(81)         | NO   |     |         |       |</span><br><span class="line">| lock_trx_id | varchar(18)         | NO   |     |         |       |</span><br><span class="line">| lock_mode   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_type   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_table  | varchar(1024)       | NO   |     |         |       |</span><br><span class="line">| lock_index  | varchar(1024)       | YES  |     | NULL    |       |</span><br><span class="line">| lock_space  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_page   | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_rec    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_data   | varchar(8192)       | YES  |     | NULL    |       |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCK_WAITS;</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field             | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| requesting_trx_id | varchar(18) | NO   |     |         |       |</span><br><span class="line">| requested_lock_id | varchar(81) | NO   |     |         |       |</span><br><span class="line">| blocking_trx_id   | varchar(18) | NO   |     |         |       |</span><br><span class="line">| blocking_lock_id  | varchar(81) | NO   |     |         |       |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参考<a href="https://dbarobin.com/2015/01/27/innodb-lock-wait-under-mysql-5.5/" target="_blank" rel="noopener">MySQL 5.5 InnoDB 锁等待</a></p><p>参考<a href="https://blog.winsky.wang/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E4%B8%8Einformation_schema%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A1%A8/" target="_blank" rel="noopener">锁等待超时与information_schema的三个表</a></p><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>指InnoDB engine通过行多版本控制的方式来读取当前执行时间数据库中行的数据。</p><p>若读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因为去等待行上锁的释放，会去读取行的一个快照数据。快照数据指该行的之前版本的数据，通过undo段来完成，undo用来在事务中回滚数据。</p><p>InnoDB默认读取方式，读取不会占用和等待表上的锁。在不同的事务隔离级别下读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读，对于快照数据的定义也各不相同。</p><p>事务隔离级别READ COMMITTED和REPEATABLE READ（默认隔离级别）下，使用非锁定的一致性读。前者对于快照数据，非一致性读总是读取被锁定的最新一份快照数据。后者对于快照数据，非一致性读总是读取事务开始时的行数据版本。前者违反了事务ACID中的I的特性，即隔离性。</p><h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB engine对SELECT语句支持两种一致性的锁定读（locking read）操作。</p><ul><li>SELECT … FOR UPDATE，对读取的行记录加一个X锁，其他的事务不能对已锁定行加上任何锁。</li><li>SELECT … LOCK IN SHARE MODE，对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，若加X，会被阻塞。</li></ul><p>已上两种操作必须在一个事务中，事务提交后，锁释放。</p><h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>InnoDB engine中，每个含有自增长的表都有一个自增长计数器，对含有自增长的计数器的表进行插入操作时，计数器会被初始化。</p><p>获取计算器的值：<code>SELECT MAX(auto_inc_col) FROM t FOR UPDATE</code>。</p><p>插入操作依据自增长的计数器值加1赋予自增长列，称为AUTO-INC Locking，采用一种特殊的表锁机制，为提高插入性能，锁在完成对自增长值插入的SQL语句后立即释放，并非在一个事务完成后才释放。</p><p>MySQL v5.1.22开始提供轻量级互斥量的自增长实现机制，提高自增长值插入的性能。提供参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，默认值为1.</p><p>自增长的插入分类：</p><table><thead><tr><th style="text-align:center">插入类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">insert-like</td><td style="text-align:center">指所有的插入语句，如INSERT、REPLACE、INSERT…SELECT，REPLACE…SELECT、LOAD DATA等</td></tr><tr><td style="text-align:center">simple inserts</td><td style="text-align:center">指能在插入前就确定插入行数的语句，包括INSERT、REPLACE等</td></tr><tr><td style="text-align:center">bulk inserts</td><td style="text-align:center">指在插入前不能确定得到插入行数的语句，如INSERT…SELECT、REPLACE…SELECT、LOAD DATA</td></tr><tr><td style="text-align:center">mixed-mode inserts</td><td style="text-align:center">指插入中有一部分的值是自增长的，有一部分是确定的。如INSERT INTO t1(c1,c2) VALUES (1,’a’),(NULL,’b’),(5,’c’),(NULL,’d’)；也可以指INSERT … ON DUPLICATE KEY UPDATE这类SQL语句</td></tr></tbody></table><p>参数<code>innodb_autoinc_lock_mode</code>的说明：</p><table><thead><tr><th style="text-align:center">innodb_autoinc_lock_mode</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">MySQL v5.1.22前的自增长实现方式，通过表锁的AUTO-INC Locking方式。不是新版本的首选项。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">默认值。对于simple inserts使用互斥量对于内存中的计数器进行累加操作，对于bulk inserts使用传统表锁的AUTO-INC Locking方式，不考虑回滚操作，对于自增列的增长是连续的。statement-based方式的replication还能很好地工作。若已经使用AUTO-INC Locking方式去产生自增长的值，而需要再进行simple inserts时，还是需要等待AUTO-INC Locking的释放。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">对于所有insert-like 自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。基于Statement-Base Replication会出现问题。该模式下任何时候都改使用row-base replication。保证最大的并发性能及replication主从数据的一致</td></tr></tbody></table><p>InnoDB engine中，自增长值的列必须是索引，同时必须时索引的第一个列，若不是第一个列，MySQL数据库会抛出异常。</p><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>外键用户完整性的约束检查，InnoDB对未显示加索引的外键列，会自动对其加以个索引，可避免表锁。</p><p>对外键值的插入或更新，首先会查询父表中的记录，对于父表的SELECT操作，不使用一致性非锁定读的方式，使用的是SELECT…LOCK IN SHARE MODE方式，主动对父表加一个S锁。若此时父表被加X锁，则子表上的操作会被阻塞。</p><h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><h4 id="锁的3种算法"><a href="#锁的3种算法" class="headerlink" title="锁的3种算法"></a>锁的3种算法</h4><p>InnoDB engine3种行锁算法：</p><ul><li>Record Lock：单个行记录上的锁。锁住索引记录，未设置索引则使用隐式的主键来进行锁定。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。阻止多个事务将记录插入到同一范围内。</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。为解决Phantom Problem（幻像问题），是谓词锁（predict lock）的一张改进。当查询的索引含有唯一属性时，查询所有的唯一索引列，InnoDB存储引擎会对Next-key Lock进行优化，将其降级为Record Lock，仅锁住索引本身，而不是范围。 </li></ul><p>若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，则查询其实是range类型查询，而不是point类型查询，依然使用Next-Key Lock进行锁定。</p><p>显式关闭Gap Lock：</p><ul><li>将事务隔离级别设置为READ COMMITTED</li><li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li></ul><p>此时除了外键约束和唯一性检查依然需要Gap Locl，其余情况仅使用Record Lock进行锁定。此时破坏了事务的隔离性，对于replication，会导致主从数据的不一致。性能上，READ COMMITTED不会优于默认事务隔离级别REPEATABLE READ。</p><h4 id="解决Phantom-Problem（幻像问题）"><a href="#解决Phantom-Problem（幻像问题）" class="headerlink" title="解决Phantom Problem（幻像问题）"></a>解决Phantom Problem（幻像问题）</h4><p>指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p><p>采用Next-Key Lock避免该问题，READ COMMITTED下仅采用Record Lock加锁，默认隔离级别REPEATABLE READ采用Next-Key Lock加锁。</p><h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏数据值事务对缓存池中行记录的修改，并且还没有被提交。</p><p>若读到脏数据，即一个事务可以读到另一个事务中未提交的数据，违反了数据库的隔离性。</p><p>脏读指在不同的事务下，当前事务可以读到另外事务未提交的数据，即可以读到脏数据。</p><p>脏读现象在生成环境中并不常发生，脏读发生的条件是需要事务隔离级别为READ UNCOMMITTED，目前大多至少设置成READ COMMITTED级别。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在一个事务内多次读取同一数据集合，事务还未结束时，另一个事务也访问该同一数据集合，并做了一些DML操作，导致第一个事务中的两次读取数据之间由第二个事务的修改，读取的数据不一致。</p><p>脏读读取的是未提交的数据，不可重复读读取的是已提交的数据，违反了事务的一致性要求。</p><p>MySQL将其定义为幻像问题（Phantom Problem），默认隔离级别下避免了该现象。</p><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作被另一个事务的更新操作覆盖，导致数据的不一致性。InnoDB对于行的DML操作需要对行或其他粗粒度级别的对象加锁，不会出现丢失更新问题。</p><p>基于B/S应用可能于业务层出现此现象。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，产生阻塞。阻塞为了确保事务可以并发且正常地运行。</p><p>参数<code>innodb_rollback_wait_timeout</code>控制等待的时间，参数<code>innodb_roolback_on_timeout</code>用来设定是否在等待超时时对进行中的事务进行回滚操作，默认OFF代表不回滚。参数<code>innodb_rollback_wait_timeout</code>是动态的，可以在MySQL DB运行时进行调整，参数<code>innodb_rollback_wait_timeout</code>是静态的，不可在启动后进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_rollback_wait_timeout&apos;\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_rollback_on_timeout&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_rollback_on_timeout</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>默认不会回滚超时引发的错误异常，在大部分情况下都不会对异常进行回滚。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互动等待的现象。</p><p>解决死锁最简单的方式时不要有等待，将任何等待都转化为回滚，并且事务重新开始。会导致并发性能的下降。</p><p>另一个解决方案是超时，当一个等待时间超过设置的某一阀值时，其中一个事务进行回滚，另一个事务获得资源继续进行。参数<code>innodb_lock_wait_timeout</code>用来设置超时的时间（默认50）。</p><p>目前普遍采用更为主动的wait-for graph（等待图）的方式来进行死锁的检测，要求数据库保存以下两种信息：</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述链表构造一张图，若图中存在回路，说明资源间互相发生等待，代表存在死锁。</p><p>wait-for graph中事务为图中的节点，图中T1指向T2边的定义为：</p><ul><li>事务T1等待事务T2所占用的资源</li><li>事务T1最终等待T2所占用的资源，事务之间等待相同的资源，而事务T1发生在事务T2的后面</li></ul><p>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常InnoDB存储引擎选择回滚undo量最小的事务。</p><p>wait-for graph的死锁检测通常采用深度优先的算法实现。InnoDB v1.2前采用递归实现，此版本开始采用非递归的方式实现。</p><h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁次数应少于等待，至少需要2次等待才会产生一次死锁。</p><p>事务发生死锁的概率影响因素：</p><ul><li>系统中事务的数量（n），数量越多发生死锁的概率越大。</li><li>每个事务操作的数量（r），每个事务操作的数量越多，发生死锁的概率越大。</li><li>操作数据的集合（R），越小发生死锁的概率越大。</li></ul><p>系统中任何一个事务发生死锁的概率～= (n^2*r^4)/4*R^2</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>指将当前锁粒度降低。可将一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</p><p>SQL Server认为锁是一种稀有资源，存在此现象。</p><p>InnoDB不存在锁升级问题，不是根据每个记录产生行锁， 而是根据每个事务访问的每个页对锁进行管理，采用位图的方式。不管一个事务锁住页中一个记录还是多个记录，开销是一致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是锁&quot;&gt;&lt;a href=&quot;#什么是锁&quot; class=&quot;headerlink&quot; title=&quot;什么是锁&quot;&gt;&lt;/a&gt;什么是锁&lt;/h3&gt;&lt;p&gt;锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="lock" scheme="bighua.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>索引与算法</title>
    <link href="bighua.top/2019/08/30/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>bighua.top/2019/08/30/索引与算法/</id>
    <published>2019-08-30T06:26:19.000Z</published>
    <updated>2019-09-11T13:51:00.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB支持的索引：</p><ul><li>B+ tree索引</li><li>全文索引</li><li>哈希索引</li></ul><p>InnoDB存储引擎支持的哈希索引是自适应的（见<a href="http://bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">自适应哈希索引</a>）。</p><p>B+ tree索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。</p><blockquote><p>B+ tree的B代表着平衡（balance），而非二叉（binary）。B+ tree从最早的平衡二叉树演变而来，但是不是一个二叉树。</p></blockquote><p>B+ tree index并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查到，最后得到要查找的数据。</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到。</p><h4 id="二分查找和平衡二叉树"><a href="#二分查找和平衡二叉树" class="headerlink" title="二分查找和平衡二叉树"></a>二分查找和平衡二叉树</h4><p>二叉查找树：左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p><p>若想最大性能地构造一棵二叉查找树，需要二叉查找树是平衡的——平衡二叉树（AVL树）。是二叉查找树，任何节点的两个子树的高度最大差为1。</p><p>维护一棵平衡二叉树需要一定的开销，多用于内存结构对象中，维护的开销相对较小。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质是B+树在数据库中的实现。B+树高扇出性，高度一般在2～4层，查找某一键值的行记录只需要2～4次IO。</p><p>B+树索引分为聚集索引（clustered index）和辅助索引（secondary index），内部都是B+树，高度平衡，叶子节点存放着所有的数据。聚集索引和辅助索引不同之处在于，叶子节点存放的是否是一整行的信息。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，表中的数据按照主键顺序存放。聚集索引按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表中存放的行记录数据，也将聚集索引的叶子节点称为数据页，决定了索引组织表中数据也是索引的一部分。每个数据页通过双向链表进行链接。</p><p>每张表只能拥有一个聚集索引，多数情况下，聚集索引能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询，查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>聚集索引非物理上连续，而是逻辑上连续。</p><ul><li>页通过双向链表链接，按照主键顺序排序</li><li>每个页中的记录通过双向链表进行维护，物理存储上可以同样不按照主键储存</li></ul><p>聚集索引对于主键排序查找和范围查找很快。</p><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>叶子节点不包含行记录的全部数据，除包含键值外，每个叶子节点中的索引行还包含一个书签。该书签告知InnoDB存储引擎哪里可以找到与索引相应的行数据。辅助索引的书签是相应的行数据的聚集索引键。</p><p>通过辅助索引查找数据，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>InnoDB存储引擎的Page Header中有以下几个部分用来保存插入的顺序信息：</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><p>决定向左还是向右进行分裂，决定将分裂点记录为哪一个。若插入随机，则取页的中间记录作为分裂点的记录，若往同一方向插入的记录数量为5，并且目前已经定位（cursor）到的记录（InnoDB存储引擎插入时，首先需要进行定位，定位到的记录为带插入记录的前一条记录）之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是带插入的记录。</p><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><h5 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h5><p>索引的创建和删除可通过两种方法，<code>ALTER TABLE</code>和<code>CREATE/DROP INDEX</code>。</p><p>ALTER TABLE创建索引语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option]...</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP PARIMARY KEY</span><br><span class="line">| DROP &#123;INDEX|KEY&#125; index_name</span><br></pre></td></tr></table></figure><p>CREATE/DROP INDEX语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line">[index_type]</span><br><span class="line">ON table_name (index_col_name,...)</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure><p>可设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据。</p><p>参见<a href="http://bighua.top/2018/07/30/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/">Mysql索引及优化</a></p><p>通过<code>SHOW INDEX FROM TABLE</code>查看索引信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from users_old\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_name_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_email_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: email</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: remember_token</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: remember_token</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 153</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>每列含义：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">  Table</td><td style="text-align:center">索引所在表名。</td></tr><tr><td style="text-align:center">  Non_unique</td><td style="text-align:center">非唯一的索引。</td></tr><tr><td style="text-align:center">  Key_name</td><td style="text-align:center">索引名。</td></tr><tr><td style="text-align:center">  Seq_in_index</td><td style="text-align:center">索引中该列的位置。</td></tr><tr><td style="text-align:center">  Column_name</td><td style="text-align:center">索引列的名称。</td></tr><tr><td style="text-align:center">  Collation</td><td style="text-align:center">列以什么方式存储在索引中，值为A或NULL。B+树索引总是A，即排序的。若使用Heap存储引擎，并建立了Hash索引，会显示NULL。Hash根据Hash桶存放索引数据，不对数据进行排序。</td></tr><tr><td style="text-align:center">  Cardinality</td><td style="text-align:center">表示索引中唯一值的数目的估计值。若非常小，可考虑是否删除此索引。</td></tr><tr><td style="text-align:center">  Sub_part</td><td style="text-align:center">是否是列的部分被索引，若索引整个列则值为NULL，否则为被索引字符长度。</td></tr><tr><td style="text-align:center">  Packed</td><td style="text-align:center">关键字如何被压缩，没被压缩值为NULL。</td></tr><tr><td style="text-align:center">  Null</td><td style="text-align:center">索引的列是否含有NULL值，列允许为NULL值则显示为Yes。</td></tr><tr><td style="text-align:center">  Index_type</td><td style="text-align:center">索引的类型，InnoDB只支持B+ Tree索引</td></tr><tr><td style="text-align:center">  Comment</td><td style="text-align:center">注释</td></tr></tbody></table><p>优化器会根据Cardinality值来判断是否使用这个索引，非实时更新，只是大概的值。可使用<code>ANALYZE TABLE</code>命令更新索引Cardinality信息，在非高峰期操作能使优化器更好的选择索引。</p><h5 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h5><p>MySQL v5.5之前，对于索引的添加或者删除类DDL操作过程：</p><ul><li>创建一张临时表，表结构为通过命令ALTER TABLE新定义的结构。</li><li>将原表数据导入到临时表。</li><li>删除原表。</li><li>把临时表重名为原来的表名。</li></ul><p>对大表进行索引的添加和删除操作耗时，大量访问时数据库服务不可用。</p><p>临时表的创建路径通过参数tmpdir进行设置，必须保证tmpdir有足够的空间存放临时表，否则会导致创建索引失败。</p><p>InnoDB v1.0.x开始支持Fast Index Creation（快速创建索引，FIC）的索引创建方式。 </p><p>辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁，在创建过程中不需要重建表。删除辅助索引，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL DB内部视图上对该表的索引定义。</p><p>加S锁操作导致过程中只能对表进行读操作，写操作不可用。FIC只限定于辅助索引的创建，主键的创建和删除同样需要重建一张表。</p><h5 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h5><p>Online Schema Change（在线架构改变，OSC）由Facebook采用PHP脚本实现的一种在线执行DDL的方式，在事务的创建过程中，可以有读写事务对表进行操作。</p><p>实现OSC步骤：</p><ul><li>init，初始化阶段，对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。</li><li>createCopyTable，创建和原始表结构一样的新表。</li><li>alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。</li><li>createDeltasTable，创建deltas表，为下一步创建的触发器所使用。之后对原表的所有的DML操作会被记录到createDeltasTable中。</li><li>createTirggers，对原表创建INSERT、UPDATE、DELETE操作的触发器，触发操作产生的记录被写入到deltas表。</li><li>startSnpshotXact，开始OSC操作的事务。</li><li>selectTableIntoOutfile，将原表中的数据写入到新表，通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中，分片大小可指定，默认500000。</li><li>dropNCIndexs，导入新表前，删除新表中所有的辅助索引。</li><li>loadCopyTable，将导出的分片文件导入到新表。</li><li>replayChanges，将OSC过程中原表DML操作的记录（被保存在deltas表中）应用到新表中。</li><li>recreateNCInedexes，创新创建辅助索引。</li><li>replayChanges，再次进行DML日志的回放操作，是上述创建辅助索引过程中新产生的日志。</li><li>swapTables，将原表和新表交换名字，操作过程需要锁定2张表，不允许新数据产生，改名操作很快，阻塞时间很短。</li></ul><p>要求进行修改表一定要有主键且表本身不能存在外键和触发器。进行OSC过程中，允许SET aql_bin_log=0，所在操作不会同步slave服务器，可能导致主从不一致。</p><h5 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h5><p>MySQL v5.6开始支持Online DDl（在线数据定义）操作，允许辅助索引创建的同时，进行其他诸如INSERT、UPDATE、DELETE这类DML操作。</p><p>可通过“在线”方式进行操作的DDL操作：</p><ul><li>辅助索引的创建和删除</li><li>改变自增长值</li><li>添加或删除外键约束</li><li>列的重命名</li></ul><p>通过新的ALTER TABLE语法，可选择索引的创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line">| ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option] ...</span><br><span class="line">ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</span><br><span class="line">LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure><p>ALGORITHM指定列创建或删除索引的算法，COPY表示按照MySQL v5.1之前的工作模式（创建临时表）。INPLACE表示索引创建或删除不需要创建临时表。DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，值默认为OFF，表示采用INPLACE方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;old_alter_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: old_alter_table</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>LOCK部分为索引创建或删除时对表加锁的情况，可为：</p><ol><li>NONE——执行索引创建或者删除操作时，对目标表不添加任何的锁，事务仍然可以进行读写操作，不会收到阻塞。可获得最大的并发度。</li><li>SHARE——类似FIC，执行索引创建或者删除操作时，对目标表加上一个S锁，不影响并发读事务，但是写事务会等待。若存储引擎不支持SHARE模式，会返回一个错误信息。</li><li>EXCLUSIVE——执行索引创建或删除操作时，对目标表加上一个X锁，读写事务都不能进行，会阻塞所有线程。</li><li>DEFAULT——通过判断事务的最大并发性来判断执行DDL的模式，选用顺序依次为NONE、SHARE、EXCLUSIVE。</li></ol><p>Online DDL原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。缓存的大小由参数<code>innodb_online_alter_log_max_size</code>控制，默认大小128MB。若更新表比较大，且创建过程中有大量写事务，空间不足会报错，需调大参数值，或者设置ALTER TABLE的模式为SHARE，在执行过程中不会有写事务发生。</p><h3 id="Cardinality-值"><a href="#Cardinality-值" class="headerlink" title="Cardinality 值"></a>Cardinality 值</h3><h4 id="Cardinality"><a href="#Cardinality" class="headerlink" title="Cardinality"></a>Cardinality</h4><p>并不是在所有的查询条件中出现的列都需要添加索引，一般在访问表中很少一部分时使用B+ Tree索引才有意义，对于性别字段、地区字段、类型字段可取范围小，称为低选择性。若字段取值范围广，几乎没有重复，属于高选择性，适合使用B+ Tree索引。</p><p>Cardinality列表示索引中不重复记录数量的预估值，而不是一个准确值，基本不可能得到一个确切值。实际应用中Cardinality/n_rows_in_table应尽可能接近1，若非常小则需要考虑是否还有必要创建这个索引。</p><h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>MySQL对Cardinality的统计放在存储引擎层进行的，通过采样的方法完成。</p><p>InnoDB中Cardinality统计信息的更新发生在INSERT和UPDATE操作中，策略为：</p><ul><li>表中1/16的数据已发生过变化。</li><li>stat_modified_counter&gt;2 000 000 000</li></ul><p>默认InnoDB存储引擎对8个叶子节点（Leaf Page）进行采样，采样过程：</p><ul><li>取得B+ Tree Index中叶子节点的数量记为A。</li><li>随机取得B+ Tree Index中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。</li><li>根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8）*A/8</li></ul><p>每次对Cardinality值的统计，都是随机取8个叶子节点得到的，每次得到的Cardinality值可能是不同的。</p><p>InnoDB v1.2之前可通过参数<code>innodb_stats_sample_pages</code>设置统计Cardinality时每次采样页的数量，默认为8。同时，参数<code>innodb_stats_method</code>用来判断如何对待索引中出现的NULL值记录，默认值为nulls_equal，表示将NULL值记录视为相等的记录，还可取nulls_unequal表示将NULL值视为不同的记录，取nulls_ignored表示忽略NULL值记录。</p><p>执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎重新计算索引的Cardinality值，表数据量过大且多个辅助索引时，执行可能会很慢。</p><p>InnoDB v1.2提供更多参数对Cardinality统计进行设置：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">innodb_stats_persistent</td><td style="text-align:center">是否将ANALYZE TABLE计算得到的Cardinality值存放到磁盘上，若是则可以减少重新计算每个索引的Cardinality值。也可通过命令CREATE TABLE和ALTER TABLE的选项STATS_PERSISTENT来对每张表进行控制。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_on_metadata</td><td style="text-align:center">通过SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时，是否需要重新计算索引的Cardinality值。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_persistent_sample_pages</td><td style="text-align:center">若innodb_stats_persistent设置为ON，该参数表示ANALYZE TABLE更新Cardinality值时每次采样页的数量。默认值为20。</td></tr><tr><td style="text-align:center">innodb_stats_transient_smaple_pages</td><td style="text-align:center">取代之前版本的参数innodb_stats_sample_pages，表示每次采样页的数量，默认值为8。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_on_metadata&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_on_metadata</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent_sample_pages</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_transient_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_transient_sample_pages</span><br><span class="line">        Value: 8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="B-Tree-Index的使用"><a href="#B-Tree-Index的使用" class="headerlink" title="B+ Tree Index的使用"></a>B+ Tree Index的使用</h3><h4 id="不同应用中B-Tree-Index的使用"><a href="#不同应用中B-Tree-Index的使用" class="headerlink" title="不同应用中B+ Tree Index的使用"></a>不同应用中B+ Tree Index的使用</h4><p>OLTP应用根据查询条件建立B+ Tree Index，取少部分数据走索引。</p><p>OLAP应用取大量数据视具体情况分析。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表上多个列进行索引。</p><p>本质上联合索引也是一棵B+ Tree，不同的是联合索引的键值的数量不是1，而是大于等于2。</p><p>对于联合索引（a,b），查询a或者a、b可走索引，查询b无法使用索引。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引（covering index，索引覆盖），从辅助索引中就可以得到查询的记录，不需要查询聚集索引中的记录。辅助索引不包含正行记录的所有信息，大小小于聚集索引，可减少大量的IO操作。</p><p>通常诸如（a，b）的联合索引，一般不会选择列b中所谓的查询条件，但若是统计操作，并且是覆盖索引，则优化器会进行选择。</p><h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>多发生于范围查找、JOIN链接操作等情况下。</p><p>要求访问的数据量很小，优化器会选择辅助索引，当访问的数据量占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。因为辅助索引中查询到指定数据后，还需要一次书签访问来查找整行数据的信息，辅助索引上的数据是顺序存放的，但再一次进行书签查找的数据是无序的，变为了磁盘上的离散读操作，顺序读远快于离散读，所以优化器直接选择聚集索引。</p><h4 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h4><p>MySQL DB支持索引提示（INDEX HINT），显示地告诉优化器使用哪个索引。</p><p>使用到INDEX HINTL的情况：</p><ul><li>MySQL DB的优化器错误滴选择了某个索引，导致SQL语句运行的很慢。非常少见。</li><li>某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。</li></ul><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tbl_name [[AS] alias] [index_hint_list]</span><br><span class="line">index_hint_list:</span><br><span class="line">index_hint [, index_hint] ...</span><br><span class="line">index_hint:</span><br><span class="line">USE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list])</span><br><span class="line">  | IGNORE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">  | FORCE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">index_list:</span><br><span class="line">index_name [, index_name] ...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://oceanbase.alipay.com/docs/oceanbase/OceanBase%20SQL%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BA%BA%E4%B8%BA%E6%8E%A7%E5%88%B6%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/hint" target="_blank" rel="noopener">11.1 优化器HINT</a></p><h4 id="Multi-Range-Read（MRR）优化"><a href="#Multi-Range-Read（MRR）优化" class="headerlink" title="Multi-Range Read（MRR）优化"></a>Multi-Range Read（MRR）优化</h4><p>MySQL v5.6开始支持Multi-Range Read（MRR）优化，减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于IO-bound类型的SQL查询语句可带来性能极大的提升，可适用于range，ref，eq_ref类型的查询。</p><p>MRR优化的好处：</p><ul><li>使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果按照主键进行排序，并按照主键排序的顺序进行书签查找。</li><li>减少缓冲池中页被替换的次数。</li><li>批量处理对键值的查询操作。</li></ul><p>对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR工作方式：</p><ul><li>将查询得到的辅助索引键值存放于一个缓存中，此时缓存中的数据是根据辅助索引键值排序的。</li><li>将缓存中的键值根据RowID进行排序。</li><li>根据RowID的排序顺序来访问实际的数据文件。</li></ul><p>当缓冲池不够大，离散读操作导致缓存中的页可能被重复替换出/读入缓冲池，按照主键顺序进行访问可将此行为降为最低。MRR还可将某些范围查询，拆分为键值对，以此来进行批量的数据查询。可以在拆分的过程中，直接过滤一些不符合查询条件的数据。</p><p>是否启用Multi-Range Read优化可通过参数<code>optimizer_switch</code>中的标记（flag）来控制。mrr为on时，表示启用Multi-Range Read优化。<code>mrr_cost_based</code>标记表示是否通过cost based的方式来选择是否启用mrr。</p><p>参数<code>read_rnd_buffer_size</code>用来控制键值的缓冲区大小，当大于该值时，则执行器对已经缓存的数据根据RowID进行排序，并通过RowID来取得行数据。默认为256K。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;optimizer_switch&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: optimizer_switch</span><br><span class="line">        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;read_rnd_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: read_rnd_buffer_size</span><br><span class="line">        Value: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown(ICP)优化"></a>Index Condition Pushdown(ICP)优化</h4><p>MySQL v5.6开始支持Index Condition Pushdown(ICP)优化。不支持前进行索引查询时，先根据索引来查找记录，然后再根据WHERE条件来过滤记录。支持后，会在取出索引的同时，判断是否可以进行WHERE条件的过滤，将WHERE的部分过滤操作放在存储引擎层。某些查询下可大大减少上层SQL层对记录的索取，提高数据库的整体性能。</p><p>ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>时间复杂度为O（1），不只存在于索引中，每个数据库应用中都存在该数据结构。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>也称散列表，由直接寻址表改进而来。</p><p>哈希函数h必须可以很好地进行散列，最好的情况下是能避免碰撞的发生，即使不能避免也应该使碰撞在最小程度下产生。一般都将关键字转换为自然数。然后通过除法散列、乘法散列或全域散列来实现。数据库一般采用除法散列的方法。</p><h4 id="InnoDB存储引擎中的哈希算法"><a href="#InnoDB存储引擎中的哈希算法" class="headerlink" title="InnoDB存储引擎中的哈希算法"></a>InnoDB存储引擎中的哈希算法</h4><p>InnoDB存储引擎使用哈希算法来对字典进行查找，冲突机制采用链表方式，哈希函数采用除法散列方式。</p><p>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，指向相同哈希函数值的页。</p><p>对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。</p><p>将要查找的页转换为自然数。InnoDB存储引擎的表空间有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，及偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，关键字K=space_id&lt;&lt;20+space_id+offset，然后通过除法散列到各个槽中去。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>采用哈希表的方式实现，仅是数据库自身创建并使用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询。其他类型查找如范围查找是不能使用哈希索引的。</p><p>通过参数<code>innodb_adaptive_hash_index</code>控制是否开启。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。可根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。</p><p>InnoDB v1.2.x开始支持全文索引，支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文索引通常使用倒排索（inverted index）引来实现，倒排索引同B+ 树索引一样，也是一种索引结构。在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现，其拥有两种表现形式：</p><ul><li>inverted file index, 表现为{单词，单词所在文档的ID}</li><li>full inverted index，表现为{单词，（单词所在文档的ID，在具体文档中的位置）}</li></ul><h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>InnoDB采用full inverted index的方式，将（DocumentId，Position）视为一个“list”。在全文检索的表中，有两个列，一个是word字段，另一个是ilist字段，并且在word字段上设有索引。在ilist字段中存放了Position信息，可进行Proximity Search。</p><p>倒序排序需要将word存放到一张表中，该表称为Auxiliary Table（辅助表）。在InnoDB存储引擎中，为提高全文检索的并行性能，共有6张Auxiliary Table，每张表根据word的Latin编码进行分区。</p><p>Auxiliary Table是持久的表存放于磁盘上。FTS Index Cache（全文检索索引缓存），用于提高全文检索的性能。</p><p>FTS Index Cache是一个红黑树结构，根据（word，ilist）进行排序。意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table可能还没有更新。InnoDB存储引擎会批量对Auxiliary Table进行更新，不是每次插入后更新一次Auxiliary Table。对全文检索进行查询时，Auxiliary Table会先将FTS Index Cache中对应的word字段合并到Auxiliary Table中，然后再进查询。</p><p>允许用户查看指定倒排索引的Auxiliary Table中分词的信息，可以通过设置参数<code>innodb_ft_aux_table</code>来观察倒排索引的Auxiliary Table。</p><p>InnoDB总在事务提交时将分词写入到FTS Index Cache，然后通过批量更新写入到磁盘。数据库关闭时，FTS Index Cache中的数据会同步到磁盘上的Auxiliary Table中。若数据库宕机时，一些FTS Index Cache中的数据可能未被同步到磁盘上，下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中。</p><p>参数<code>innodb_ft_cache_size</code>控制FTS Index Cache的大小，默认值为32MB。当该缓存满时，会将其中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大该参数可提高全文检索的性能，宕机时，未同步到磁盘中的索引信息可能需要更长的时间恢复。</p><p>为支持全文索引，必须有一个列与word进行映射，在InnoDB中该列被命名为FTS_DOC_ID，类型必须是BIGINT UNSIGNED NOT NULL，会自动在该列上加入一个名为FTS_DOC_ID_INDEX的Unique Index。</p><p>对于删除操作，在事务提交时，不删除磁盘Auxiliary Table中的记录，而只是删除FTS Cache Index中的记录。对于Auxiliary Table中被删除的记录，InnoDB存储引擎会记录其FTS Document ID，并将其保存在DELETED auxiliary table中，设置<code>innodb_ft_aux_table</code>后，同样可以访问information_schema架构下的表INNODB_FT_DELETED来观察删除的FTS Document<br>ID。</p><p>OPTIMIZE TABLE命令允许用户手工地将已经删除的记录从索引中彻底删除，该命令还进行一些其他操作如Cardinality的重新统计。若只对倒排索引进行操作，可通过参数<code>innodb_optimize_fulltext_only</code>进行设置。若被删除文档数量非常多，会占用非常多的时间，影响程序的并发性，降低用户响应时间，可通过参数<code>innnodb_ft_num_word_optimize</code>来限制每次实际删除的分词数量，默认值2000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from test.fts_a where FTS_DOC_ID&lt;7;</span><br><span class="line">Query OK, 6 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE fts_a (</span><br><span class="line">    -&gt; FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,</span><br><span class="line">    -&gt; body TEXT,</span><br><span class="line">    -&gt; PRIMARY KEY(FTS_DOC_ID)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE FULLTEXT INDEX idx_fts ON fts_a(body);</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          1 | I am a boy                                |</span><br><span class="line">|          2 | I am a bad boy                            |</span><br><span class="line">|          3 | I am a good boy                           |</span><br><span class="line">|          4 | I am a good boy,who love liwenqi          |</span><br><span class="line">|          5 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|          6 | where is my heart                         |</span><br><span class="line">|          7 | what a beautiful girl                     |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts_a&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_INDEX_TABLE;</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD      | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| bad       |            2 |           2 |         1 |      2 |        7 |</span><br><span class="line">| beautiful |            7 |           7 |         1 |      7 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      1 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      2 |       11 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      3 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      4 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      5 |       12 |</span><br><span class="line">| girl      |            7 |           7 |         1 |      7 |       17 |</span><br><span class="line">| good      |            3 |           5 |         3 |      3 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      4 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      5 |        7 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      5 |       36 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      6 |       12 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      4 |       25 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      5 |       25 |</span><br><span class="line">| love      |            4 |           5 |         2 |      4 |       20 |</span><br><span class="line">| love      |            4 |           5 |         2 |      5 |       20 |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">17 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>FIRST_DOC_ID、LAST_DOC_ID、DOC_COUNT分别代表该word第一次出现的文档ID，最后一次出现的文档ID，以及该word在多少个文档中存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;liwenqi,what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          8 | I am a boy                                |</span><br><span class="line">|          9 | I am a bad boy                            |</span><br><span class="line">|         10 | I am a good boy                           |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         13 | where is my heart                         |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_optimize_fulltext_only=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; optimize table test.fts_a;</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| Table      | Op       | Msg_type | Msg_text |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| test.fts_a | optimize | status   | OK       |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEGIN_DELETED;</span><br><span class="line">ERROR 1109 (42S02): Unknown table &apos;innodb_ft_begin_deleted&apos; in information_schema</span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEING_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>命令OPTIMIZE TABLE可将记录进行彻底的删除，并且彻底删除的文档ID会记录到表information_schema.INNODB_FT_BEING_DELETED中。已被删除的文档ID不允许被再次使用。</p><p>stopword列表（stopword list）表示该列表中的word不需要对其进行索引分词操作。InnoDB存储引擎有一张默认的stopword列表，在information_schema架构下，表名为INNODB_FT_DEFAULT_STOPWORD，默认共36个stopword。可通过参数<code>innodb_ft_server_stopword_table</code>来自定义stopword列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DEFAULT_STOPWORD;</span><br><span class="line">+-------+</span><br><span class="line">| value |</span><br><span class="line">+-------+</span><br><span class="line">| a     |</span><br><span class="line">| about |</span><br><span class="line">| an    |</span><br><span class="line">| are   |</span><br><span class="line">| as    |</span><br><span class="line">| at    |</span><br><span class="line">| be    |</span><br><span class="line">| by    |</span><br><span class="line">| com   |</span><br><span class="line">| de    |</span><br><span class="line">| en    |</span><br><span class="line">| for   |</span><br><span class="line">| from  |</span><br><span class="line">| how   |</span><br><span class="line">| i     |</span><br><span class="line">| in    |</span><br><span class="line">| is    |</span><br><span class="line">| it    |</span><br><span class="line">| la    |</span><br><span class="line">| of    |</span><br><span class="line">| on    |</span><br><span class="line">| or    |</span><br><span class="line">| that  |</span><br><span class="line">| the   |</span><br><span class="line">| this  |</span><br><span class="line">| to    |</span><br><span class="line">| was   |</span><br><span class="line">| what  |</span><br><span class="line">| when  |</span><br><span class="line">| where |</span><br><span class="line">| who   |</span><br><span class="line">| will  |</span><br><span class="line">| with  |</span><br><span class="line">| und   |</span><br><span class="line">| the   |</span><br><span class="line">| www   |</span><br><span class="line">+-------+</span><br><span class="line">36 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE user_stopword (</span><br><span class="line">    -&gt; value VARCHAR(30)</span><br><span class="line">    -&gt; ) ENGINE = INNODB;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_server_stopword_table = &quot;test/user_stopword&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_ft_server_stopword_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_ft_server_stopword_table</span><br><span class="line">        Value: test/user_stopword</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>InnoDB全文索引的限制：</p><ul><li>每张表只能有一个全文索引。</li><li>由多列组合而成的全文检索的索引必须使用相同的字符集与排序规则。</li><li>不支持没有单词界定符的语言，如中文、日语、韩语等。</li></ul><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL全文检索查询语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">IN NATURAL LANGUAGE MODE</span><br><span class="line">| IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line">| IN BOOLEAN MODE</span><br><span class="line">| WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MATCH 指定了需要被查询的列，AGAINST指定了使用何种方法去进行查询。</p><h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>通过MATCH函数进行查询，默认采用Natural Language模式，表示查询带有指定word的文档。</p><p>不使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a </span><br><span class="line">    -&gt; where match(body)</span><br><span class="line">    -&gt; against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type     | possible_keys | key     | key_len | ref   | rows | filtered | Extra                         |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | fulltext | idx_fts       | idx_fts | 0       | const |    1 |   100.00 | Using where; Ft_hints: sorted |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>NATURAL LANGUAGE MODE默认的全文检索查询模式，可省略查询修饰符。</p><p>type列显示fulltext表示使用全文检索的倒排索引，key显示了索引的名字，相对like查询，全文索引只进行了一次扫描。</p><p>查询返回的结果是根据相关性（Relevance）进行降序排序的，相关性最高的结果放在第一位。由一个非负的浮点数表示，0表示没有任何相关性。相关性计算依据的条件：</p><ul><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>有多少个文档包含该word。</li></ul><p>统计查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|        3 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+-------+</span><br><span class="line">| count |</span><br><span class="line">+-------+</span><br><span class="line">|     3 |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | index | NULL          | PRIMARY | 8       | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>第二句SQL执行速度更快，第一句SQL语句需要进行相关性的排序统计。</p><p>通过SQL查看相关性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select fts_doc_id,body, match(body) against(&apos;liwenqi&apos; in natural language mode) as relevance from fts_a;</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">| fts_doc_id | body                                      | relevance          |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">|          8 | I am a boy                                |                  0 |</span><br><span class="line">|          9 | I am a bad boy                            |                  0 |</span><br><span class="line">|         10 | I am a good boy                           |                  0 |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          | 0.0906190574169159 |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart | 0.0906190574169159 |</span><br><span class="line">|         13 | where is my heart                         |                  0 |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             | 0.0906190574169159 |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>需考虑因素：</p><ul><li>查询word在stopword列中，忽略该字符串的查询。</li><li>查询的word字符长度是否在区间[innodb_ft_min_token_size, innodb_ft_max_token_size]内。</li></ul><p>若词在stopword中，不对该词进行查询。</p><p>参数<code>innodb_ft_min_token_size</code>和<code>innodb_ft_max_token_size</code>控制InnoDB存储引擎查询字符的长度，当长度小于<code>innodb_ft_min_token_size</code>或者大于<code>innodb_ft_max_token_size</code>时，会忽略该词的搜索，InnoDB存储引擎中，前者值默认为3，后者值默认为84。</p><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>使用该修饰符时，查询字符串的前后缀字符会有特殊的含义，支持以下几种操作符：</p><ul><li>+表示该word必须存在。</li><li>-表示该word必须被排除。</li><li>（no operator）表示该word是可选的，但是如果出现，相关性会更高。</li><li>@distance表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。该全文检索的查询也称为Proximity Search。</li><li><blockquote><p>表示出现该单词时增加相关性。</p></blockquote></li><li><blockquote><p>表示出现该单词时降低相关性。</p></blockquote></li><li>～表示允许出现该单词，但是出现时的相关性为负。</li><li>*表示以该单词开头的单词。</li><li>“表示短语。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;liwenqi girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;+liwenqi -girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Query-Expansion"><a href="#Query-Expansion" class="headerlink" title="Query Expansion"></a>Query Expansion</h5><p>MySQL支持全文索引的拓展查询，通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。通过Query Expansion模式开启全文检索的implied knowledge。</p><p>通过在查询短语中添加WITH QUERY EXPANSION或者IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION可以开启blind query knowledge（又称为automatic relevance feedback）。该查询分为两个阶段：</p><ul><li>第一阶段：根据搜索的单词进行全文索引查询。</li><li>第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li></ul><p>Query Expansion的全文检索可能会带来许多非相关性的查询。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;InnoDB存储引擎索引概述&quot;&gt;&lt;a href=&quot;#InnoDB存储引擎索引概述&quot; class=&quot;headerlink&quot; title=&quot;InnoDB存储引擎索引概述&quot;&gt;&lt;/a&gt;InnoDB存储引擎索引概述&lt;/h3&gt;&lt;p&gt;InnoDB支持的索引：&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="index" scheme="bighua.top/tags/index/"/>
    
      <category term="alg" scheme="bighua.top/tags/alg/"/>
    
  </entry>
  
  <entry>
    <title>表</title>
    <link href="bighua.top/2019/08/19/%E8%A1%A8/"/>
    <id>bighua.top/2019/08/19/表/</id>
    <published>2019-08-19T06:26:08.000Z</published>
    <updated>2019-08-30T12:11:13.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：</p><ul><li>首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。</li><li>不符合上述条件则自动创建一个6字节大小的指针。</li></ul><p>若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。</p><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。</p><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>启用参数<code>innodb_file_per_table</code>，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。</p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。</p><p>InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数<code>KEY_BLOCK_SIZE</code>设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.</p><p>InnoDB v1.2.x新增参数<code>innodb_page_size</code>，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。</p><p>在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。</p><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为<code>innodb_page_size</code>，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p><p>常见的页类型：</p><ul><li>数据页（B-Tree Node）</li><li>undo页（undo LogPage）</li><li>系统页（System Page）</li><li>事务数据页（Transaction system Page）</li><li>插入缓冲位图页（Insert Buffer Bitmap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOG Page）</li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。</p><h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>书中介绍不完善，参考博客<a href="https://www.cnblogs.com/wilburxu/p/9435818.html" target="_blank" rel="noopener">MySQL InnoDB 行记录格式</a>。</p><h4 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h4><p>在MySQL 5.0中引入，设计目标是高效地存储数据。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">变长字段长度列表</th><th style="text-align:center">NULL标志位</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节</td><td style="text-align:center">有NULL值列用1表示，占1字节</td><td style="text-align:center">固定占用5字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息每位含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的排序记录</td></tr><tr><td style="text-align:center">record_type</td><td style="text-align:center">3</td><td style="text-align:center">记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimum，011表示Supermum、1xx表示保留</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相应位置</td></tr></tbody></table><p>数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。</p><p>InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。</p><h4 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h4><p>MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">字段长度偏移列表</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示</td><td style="text-align:center">占用六字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知   </td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的索引号</td></tr><tr><td style="text-align:center">n_flieds</td><td style="text-align:center">10</td><td style="text-align:center">记录中列的数量</td></tr><tr><td style="text-align:center">1 byte_offs_flag</td><td style="text-align:center">1</td><td style="text-align:center">偏移列表为1字节还是2字节</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相对位置</td></tr></tbody></table><p>对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。</p><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOG、LOB这类大对象列类型的存储会把数据存放在数据页面之外，但是BLOG可以不将数据放在溢出页面，即便VARCHAR列数据依然有可能被存放为行溢出数据。</p><p>存放VARCHAR类型的最大长度（所有VARCHAR列的长度总和）为65532字节，超出且将SQL_MODE设为严格模式，建表时会报错，没设置严格模式或许可以建表但是会抛出一个warning，会将VARCHAR类型转换为TEXT类型。</p><p>InnoDB存储引擎的页为16KB，一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，发生行溢出时，数据存放在页类型为Uncompress BLOG页中。</p><p>InnoDB存储引擎表是索引组织的（B+Tree结构），每个页至少应该有两条行记录（否则失去B+Tree意义变成链表）。若页中只能存放下一条记录，则InnoDB存储引擎会自动将行数据放到溢出页中。若能至少放入两行数据则VARCHAR类型的行数据不会存放到BLOG页中，阀值的长度为8098。</p><p>TEXT或BLOG的数据类型，存放在数据页还是BLOG页和VARCHAR原则一致。大多数情况下BLOG的行数据会发生行溢出，实际数据保存在BLOG页中，数据页只保存前768字节。</p><h4 id="Compressed和Dynamic行记录数据"><a href="#Compressed和Dynamic行记录数据" class="headerlink" title="Compressed和Dynamic行记录数据"></a>Compressed和Dynamic行记录数据</h4><p>InnoDB v1.0.x开始引入新的文件格式，以前支持的Compact和Redundant格式被称为Antelope文件格式，新的文件格式称为Barracuda文件格式，其拥有两种新的行记录格式：Compressed和Dynamic。</p><p>新的两种行记录格式对于存放在BLOG中的数据采用了完全的行溢出的方式，数据页中只存放20个字节的指针，实际数据都存放在Off Page中。</p><p>Compressed行记录格式的另一个功能是，存放在其中的行数据会已zlib的算法进行压缩，对BLOG、TEXT、VARCHAR类大长度类型的数据能够进行有效的存储。</p><h4 id="CHAR的行存储结构"><a href="#CHAR的行存储结构" class="headerlink" title="CHAR的行存储结构"></a>CHAR的行存储结构</h4><p>通常理解VARCHAR存储变长长度的字符类型，CHAR存储固定长度的字符类型。</p><p>MySQL v4.1开始，CHAR（N）中N指的是字符的长度，而非字节长度，在不同的字符集下，CHAR类型列内部存储的可能不是定长数据。</p><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度。在多字符集的存储情况下，CHAR和VARCHAR的实际存储基本没有区别。</p><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InoDB数据页组成：</p><ul><li>File Header（文件头）</li><li>Page Header（页头）</li><li>Infimum和Supermun Records</li><li>User Records（用户记录，即行记录）</li><li>Free Space（空闲空间）</li><li>Page Directory（页目录）</li><li>File Trailer（文件结尾信息）</li></ul><p>Flie Header、Page Header、File Trailer大小固定，分别为38、56、8字节，标记该页的一些信息，如Checksum，数据页所在B+ Tree索引的层等。User Records、Free Space、Page Directory为实际的行记录存储空间，大小是动态的。</p><table><thead><tr><th style="text-align:center">File Header</th><th style="text-align:center">Page Header</th><th style="text-align:center">Infimum + Supermum Records</th><th style="text-align:center">User Recodrds</th><th style="text-align:center">Free Space</th><th style="text-align:center">Page Directory</th><th style="text-align:center">File Trailer</th></tr></thead><tbody><tr><td style="text-align:center">38字节</td><td style="text-align:center">56字节</td><td style="text-align:center">行记录</td><td style="text-align:center">行记录</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">8字节</td></tr></tbody></table><h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>组成 ：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（字节）</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_SPACE_OR_CHKSUM</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.0.14之前值为0，之后代表页的checksum值</td></tr><tr><td style="text-align:center">FIL_PAGE_OFFSET</td><td style="text-align:center">4</td><td style="text-align:center">表空间中页的偏移量，表示当前页在表空间所有页中的位置</td></tr><tr><td style="text-align:center">FIL_PAGE_PREV</td><td style="text-align:center">4</td><td style="text-align:center">当前页的上一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_NEXT</td><td style="text-align:center">4</td><td style="text-align:center">当前页的下一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_LSN</td><td style="text-align:center">8</td><td style="text-align:center">最后被修改的日志序列位置LSN（Log Sequence Number）</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE</td><td style="text-align:center">2</td><td style="text-align:center">页的类型，见下表枚举</td></tr><tr><td style="text-align:center">FIL_PAGE_FILE_FLUSH_LSN</td><td style="text-align:center">8</td><td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间值为0</td></tr><tr><td style="text-align:center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.1开始代表页属于哪个表空间。</td></tr></tbody></table><p>InnoDB存储引擎中页的类型</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">十六进制</th><th style="text-align:center">解释 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_INDEX</td><td style="text-align:center">0x45BF</td><td style="text-align:center">B+树叶节点</td></tr><tr><td style="text-align:center">FIL_PAGE_UNDO_LOG</td><td style="text-align:center">0x0002</td><td style="text-align:center">Undo Log页</td></tr><tr><td style="text-align:center">FIL_PAGE_INODE</td><td style="text-align:center">0x0003</td><td style="text-align:center">索引节点</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_FREE_LIST</td><td style="text-align:center">0x0004</td><td style="text-align:center">Insert Buffer空闲列表</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_ALLOCATED</td><td style="text-align:center">0x0000</td><td style="text-align:center">该页为最新分配</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_BITMAP</td><td style="text-align:center">0x0005</td><td style="text-align:center">Insert Buffer位图</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_SYS</td><td style="text-align:center">0x0006</td><td style="text-align:center">系统页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_TRX_SYS</td><td style="text-align:center">0x0007</td><td style="text-align:center">事务系统数据</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_FSP_HDR</td><td style="text-align:center">0x0008</td><td style="text-align:center">File Space Header</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_XDES</td><td style="text-align:center">0x0009</td><td style="text-align:center">拓展描述页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_BLOG</td><td style="text-align:center">0x000A</td><td style="text-align:center">BLOG页</td></tr></tbody></table><h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>记录数据页的状态信息，由14个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">PAGE_N_DIR_SLOTS</td><td style="text-align:center">2</td><td style="text-align:center">在Page Directory（页目录）中的Slot（槽）数</td></tr><tr><td style="text-align:center">PAGE_HEAP_TOP</td><td style="text-align:center">2</td><td style="text-align:center">堆中第一个记录的指针、记录在页中是根据堆的形式存放的</td></tr><tr><td style="text-align:center">PAGE_N_HEAP</td><td style="text-align:center">2</td><td style="text-align:center">堆中的记录数，第15位表示行记录数</td></tr><tr><td style="text-align:center">PAGE_FREE</td><td style="text-align:center">2</td><td style="text-align:center">指向可重用空间的首指针</td></tr><tr><td style="text-align:center">PAGE_GARBAGE</td><td style="text-align:center">2</td><td style="text-align:center">已删除记录的字节数，行记录结构中delete flag为1的记录大小的总数</td></tr><tr><td style="text-align:center">PAGE_LAST_INSERT</td><td style="text-align:center">2</td><td style="text-align:center">最后插入记录的位置</td></tr><tr><td style="text-align:center">PAGE_DIRECTORY</td><td style="text-align:center">2</td><td style="text-align:center">最后插入的方向，可取：PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0x03)，PAGE_SAME_PAGE(0x04)，PAGE_NO_DIRECTION(0x05)</td></tr><tr><td style="text-align:center">PAGE_N_DIRECTION</td><td style="text-align:center">2</td><td style="text-align:center">一个方向连续插入数据的数量</td></tr><tr><td style="text-align:center">PAGE_N_RECS</td><td style="text-align:center">2</td><td style="text-align:center">该页中记录的数量</td></tr><tr><td style="text-align:center">PAGE_MAX_TEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">当前页的最大事务ID，仅在Secondary Index(辅助索引)中定义</td></tr><tr><td style="text-align:center">PAGE_LEVEL</td><td style="text-align:center">2</td><td style="text-align:center">当前页在索引树中的位置，0x00代表页节点，页节点总在第0层</td></tr><tr><td style="text-align:center">PAGE_INDEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">索引ID，表示当前页属于哪个索引</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_LEAF</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree树的Root页中定义，B+ Tree数据页非页节点所在段的seqment header</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_TOP</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree的Root页中定义，B+ Tree数据页所在段的segment header</td></tr></tbody></table><h4 id="Infimum和Supermum-Record"><a href="#Infimum和Supermum-Record" class="headerlink" title="Infimum和Supermum Record"></a>Infimum和Supermum Record</h4><p>Infimum记录比该页中任何主键值都要小得值，Supermum指比任何可能大的值还要大的值，在页创建时被建立，在任何情况下都不会被删除。在Compact和Redundant行格式下，两者占用的字节数各不相同。</p><h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record：实际存储行记录的内容。</p><p>Free Space：空闲空间，链表数据结构，在一条记录被删除后，该空间被加入到空闲链表中。</p><h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>页目录中存放记录的相对位置，有些时候这些记录指针被称为Slots（槽）或目录槽（Directory Slots）。</p><p>InnoDB的槽是一个稀疏目录（sparse directory），一个槽中可能包含多个记录。伪记录Infimum的n_owned值总是1，记录Supermum的n_owned的取值范围为[1, 8]，其他用户记录n_owned的取值范围为[4, 8]，当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。</p><p>Slots中记录按照索引键值顺序存放，可以利用二叉查找，查找结果只是一个粗略的结果，必须通过recorder header中的next_record继续查找相关记录。</p><p>B+ Tree索引找到记录所在的页，数据库把页载入内存，然后通过Page Directory再进行二叉查找。</p><h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>检测页是否已经完整地写入磁盘（可能发生在写入过程中磁盘损坏）。</p><p>只有以一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，后4字节和File Header中的FIL_PAGE_LSN相同。通过InnoDB的checksum函数将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致，保证页的完整行。</p><p>默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，即该页是否发生Corrupt，该检测会有一定的开销，可通过innodb_checksums来开启或关闭对这个页完整性的检查。</p><p>MySQL v5.6.6新增参数<code>innodb_checksum_algorithm</code>，控制检测checksum函数的算法，默认crc32，可设置：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_checksum%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_checksum_algorithm</span><br><span class="line">        Value: crc32</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_checksums</span><br><span class="line">        Value: ON</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>innodb为兼容之前版本的checksum检测方式，crc于v 5.6.6引入，有更高的性能。若表中所有页的checksum值都以strict算法保存，脚底版本MySQL数据库不能读取这些页。none表示不对页启用checksum检测。strict_*表示严格按照checksum算法进行页的检测，较低版本MySQL升级到MySQL5.6.6+版本，启用strict_crc32将不能读取表中的页。启用strict_crc32方式是最快的方式，其不再对innodb和crc32算法进行两次检测。数据库从低版本升级而来需进行mysql_upgrade操作。</p><h3 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h3><p>从InnoDB v1.0.x引入，通过Named File Formats机制解决不同版本下页结构兼容性问题。</p><p>通过参数<code>innodb_file_format</code>指定文件格式，通过参数<code>innodb_file_format_check</code>检测当前存储引擎文件格式的支持度，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_file_format&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_format</span><br><span class="line">        Value: Barracuda</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，文件系统一般需要在程序端进行控制。</p><p>数据完整性的三种形式：</p><ul><li>实体完整性保证表中有一个主键。通过Primary Key或Unique Key约束来保证实体的完整性。可通过编写一个触发器来保证数据的完整性。</li><li>域完整性保证数据每列的值满足特定的条件。域完整性保证途径：<ul><li>选择合适的数据类型确保一个数据值满足特定条件。</li><li>外键（Foreign key）约束。</li><li>编写触发器。</li><li>用DEFAULT约束强制域完整性</li></ul></li><li>参照完整性保证两张表之间的关系。InnoDB存储引擎支持外健，允许用户自定义外键以强制参照完整性，通过编写触发器以强制执行。</li></ul><p>InnoDB存储引擎本身提供约束：</p><ul><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL </li></ul><h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>采用两种方式：</p><ul><li>表建立时进行约束定义</li><li>利用ALTER TABLE命令来进行创建约束</li></ul><p>对Unique Key约束，还可通过命令CREATE UNIQUE INDEX来建立。主键约束默认名Primary，Unique Key约束默认约束名和列名一样，可指定Unique Key约束名。Foreign Key约束默认名称特殊。</p><p>可通过information_schema架构下的表TABLE_CONSTRAINTS查看当前MySQL库下所有的约束信息，通过表REFERENTIAL_CONSTRAINTS查看Foreign Key的约束命名和外健的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from information_schema.TABLE_CONSTRAINTS;</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field              | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from information_schema.REFERENTIAL_CONSTRAINTS;</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field                     | Type         | Null | Key | Default | Extra |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG        | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME           | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_NAME    | varchar(64)  | YES  |     | NULL    |       |</span><br><span class="line">| MATCH_OPTION              | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UPDATE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| DELETE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME                | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| REFERENCED_TABLE_NAME     | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>约束是逻辑概念，用来保证数据的完整性，索引是一个数据结构，在数据库中代表着物理存储的方式。</p><h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>默认设置下，MySQL允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL会将其更改为0再进行插入。</p><p>可通过设置参数<code>sql_mode</code>为STRICT_TRANS_TABLES，对输入值的合法性进行约束，用来严格审核输入的参数。sql_mode可设值参考MySQL官方手册。</p><h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><p>MySQL数据库不支持传统的CHECK约束，通过ENUM和SET类型解决。</p><p>对于传统CHECK约束支持的连续值的范围约束或更复杂的约束，可通过触发器来实现对于值域的约束。</p><h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。MySQL v5.1开始触发器相对稳定。</p><p>通过命令CREATE TRIGGER创建触发器，具备Super权限的MySQL数据库用户才可执行这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE | AFTER INSERT | UPDATE | DELETE</span><br><span class="line">ON tb1_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure><p>最多可为一个表建立6个触发器，分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。BEFORE和AFTER代表触发器发生的时间，表示在每行操作之前发生还是之后发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table usercash ( userid INT NOT NULL, cash INT UNSIGNED NOT NULL);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table usercash_err_log ( userid INT NOT NULL, old_cash INT UNSIGNED NOT NULL, new_cash INT UNSIGNED NOT NULL, user VARCHAR(30), time DATETIME);</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER $$ </span><br><span class="line">mysql&gt; create trigger tgr_usercash_update before update on usercash</span><br><span class="line">    -&gt; for each row</span><br><span class="line">    -&gt; begin </span><br><span class="line">    -&gt; if new.cash-old.cash &gt; 0 then</span><br><span class="line">    -&gt; insert into usercash_err_log</span><br><span class="line">    -&gt; select old.userid,old.cash,new.cash,USER(),NOW();</span><br><span class="line">    -&gt; set new.cash = old.cash;</span><br><span class="line">    -&gt; end if;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update usercash set cash=cash-(-20) where userid=1;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  userid: 1</span><br><span class="line">old_cash: 1000</span><br><span class="line">new_cash: 1020</span><br><span class="line">    user: root@localhost</span><br><span class="line">    time: 2019-08-23 15:18:08</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>保证参照的完整性，MyISAM引擎本身不支持外键，对于外键的定义只起注释的作用。InnoDB完整支持外键约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT [symbol]] FOREIGN KEY</span><br><span class="line">[index_name] (index_col_name, ...)</span><br><span class="line">REFERENCES tb1_name (index_col_name, ...)</span><br><span class="line">[ON DELETE reference_option]</span><br><span class="line">[ON UPDATE reference_option]</span><br><span class="line">reference_option:</span><br><span class="line">RESTRICT | CASCADE | SET NULL | NO ACTION</span><br></pre></td></tr></table></figure><p>可执行CREATE TABLE或者ALTER TABLE命令添加外健。</p><p>被引用的表为父表、引用的表称为子表，外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作，可定义字表操作有：</p><ul><li>CASCADE：父表发生DELETE或UPDATE操作时对相应字表中的数据也进行DELETE或UPDATE操作。</li><li>SET NULL：父表发生DELETE或UPDATE操作时，相应的字表中的数据被更新为NULL值，字表相应字段必须允许为NULL值。</li><li>NO ACTION：父表发生DELETE或UPDATE操作时，抛出错误，不允许此类操作发生。</li><li>RESTRICT：未定义ON DELETE或ON UPDATE时的默认外健设置。</li></ul><p>MySQL数据库的外键约束为及时检查，在SQL语句运行时进行检查。MySQL数据库中NO ACTION和RESTRICT的功能是相同的。</p><p>InnoDB在外键建立时会自动为该列加一个索引，可避免外键列上无索引而导致的死锁问题产生。</p><p>可通过参数<code>foreign_key_checks</code>设置是否开启外键检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;foreign_key_checks&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: foreign_key_checks</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，由一个SQL查询来定义，可当作表使用，没有实际的物理存储。</p><h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><p>被用作一个抽象装置，不需关心基表（base table）的结构，只需按视图定义来取数据或更新数据。一定程度上起到安全层作用。</p><p>MySQL v5.0开始支持视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[OR REPLACE]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">[SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>可对某些视图进行更新操作，本质是通过视图的定义来更新基本表。称可进行更新操作的视图为可更新视图（updatable view）。WITH CHECK OPTION针对于可更新视图更新的值是否需要检查。</p><p>通过SHOW TABLES命令显示结果包含基表和视图，只查询基表可通过information_schema架构下的TABLE表查询，并搜索类型为BASE TABLE的表。</p><p>查看视图的元数据（meta data）可访问information_schema架构下的VIEWS表，给出了视图的定义者（definer）、定义内容、是否是可更新视图、字符集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">+------------------+</span><br><span class="line">8 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create view v_users</span><br><span class="line">    -&gt; as</span><br><span class="line">    -&gt; select * from users where id&lt;10;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">| v_users          |</span><br><span class="line">+------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.VIEWS where table_schema=database()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       TABLE_CATALOG: def</span><br><span class="line">        TABLE_SCHEMA: login</span><br><span class="line">          TABLE_NAME: v_users</span><br><span class="line">     VIEW_DEFINITION: select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`sex` AS `sex` from `login`.`users` where (`login`.`users`.`id` &lt; 10)</span><br><span class="line">        CHECK_OPTION: NONE</span><br><span class="line">        IS_UPDATABLE: YES</span><br><span class="line">             DEFINER: root@localhost</span><br><span class="line">       SECURITY_TYPE: DEFINER</span><br><span class="line">CHARACTER_SET_CLIENT: utf8</span><br><span class="line">COLLATION_CONNECTION: utf8_general_ci</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果，在执行复杂查询时，可避免进行这些耗时的操作，从而快速得到结果，对于一些复杂的统计类查询能直接查处结果。</p><p>MySQL数据库不支持物化视图，可通过一些机制来实现物化视图的功能。例如可通过触发器维护一个结果状态副表，每当发生INSERT、UPDATE和DELETE操作时触发器更新结果状态表。</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h4><p>MySQL v5.1时添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对应用，逻辑上只有一个或一个索引，但在物理上表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p><p>MySQL支持水平分区（同一表中不同行的记录分配到不同的物理文件中），不支持垂直分区（同一表中不同列的记录分配到不同的物理文件中）。MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。全局分区指数据存放在各个分区中，但是所有数据的索引放在一个对象中。</p><p>可通过<code>SHOW VARIABLES LIKE &#39;%partition%&#39;\G</code> 和<code>SHOW PLUGINS\G</code>查看是否启用了分区功能。</p><p>MySQL数据库支持分区类型：</p><ul><li>RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区，v5.5开始支持RANGE COLUMNS的分区。</li><li>LIST分区：面向离散的值。v5.5开始支持LIST COLUMNS的分区。</li><li>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的哈希函数进行分区。</li></ul><p>若表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引允许NULL值，分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。若建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><h5 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h5><p>启用分区之后，表由建立分区时的各个分区ibd文件组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t</span><br><span class="line">    -&gt; (id INT) engine=innodb</span><br><span class="line">    -&gt; partition by range (id) (partition p0 values less than (10),partition p1 values less than (20));</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login | grep t</span><br><span class="line">total 2288</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 16:06 t.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    40B  8 23 14:49 tgr_usercash_update.TRN</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (9);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (15);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 30</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t add partition (partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.PARTITIONS where table_schema=database() and table_name=&apos;t&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p0</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 1</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 10</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:12</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p1</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 2</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 20</span><br><span class="line">                   TABLE_ROWS: 2</span><br><span class="line">               AVG_ROW_LENGTH: 8192</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:31</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询information_schema架构下的PARTITION表来查看每个分区的具体信息，TABLE_ROWS为每个分区中记录的数量，PARTITION_METHOD为分区的类型。插入一个不在分区中定义的值时，会抛出一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE sales ( money INT UNSIGNED NOT NULL, date DATETIME ) ENGINE=INNODB PARTITION by RANGE (YEAR(date)) ( PARTITION p2018 VALUES LESS THAN (2019), PARTITION p2019 VALUES LESS THAN (2020) );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-02-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2019-03-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2020-03-02&apos;);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 2020</span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2018-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 33.33</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2019-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018,p2019</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 25.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过EXPLAIN PARTITIONS可查看查询条件搜索的分区，SQL优化器会做分区修剪。可根据分区直接删除指定范围内的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from sales;·</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table sales drop partition p2018;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于RANGE分区的查询，优化器只能对YESR()、TO_DAYS()、TO_SECONDS()、UNIX_TIMESTAMP()这类函数进行优化选择。</p><h5 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h5><p>LIST分区相似于RANGE分区，分区列的值是离散的，而非连续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,1,2,4,6,8));</span><br><span class="line">ERROR 1495 (HY000): Multiple definition of same constant in list partitioning</span><br><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,2,4,6,8));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,6);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,7);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,10);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 10</span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 2</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 2</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>VALUES IN中的值又重复时创建表会报错，插入值不在其中会报错。</p><p>INSERT插入多个数据的过程中遇到分区未定义时，MyISAM和InnoDB存储引擎表现不同，MyISAM会将之前的行数据都插入，之后的数据不插入。InnoDB将其视为一个事务，没有任何数据插入。</p><h5 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h5><p>目的将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致都是一样的。需要基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_hash (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by hash (year(b))</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; insert into t_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>插入分区：mod(expr, num)</p><p>对于连续的值进行HASH分区，可以较好的将数据进行平均分区。</p><p>LINEAR HASH分区，使用更加复杂的算法确定新行插入到已经分区的表中的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_linear_hash ( a int, b datetime )engine=innodb partition by linear hash (year(b)) partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_linear_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_linear_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>计算分区：</p><ul><li>取大于分区数量4的下一个2的幂值V，V=POWER(2,CEILING(LOG(2,num)))=4</li><li>所在分区N=YEAR(‘010-04-01’)&amp;(V-1)=2</li></ul><p>LINEAR HASH分区的优势在于增加、删除、合并和拆分分区变得更加快捷，有利于处理含有大量数据的表。缺点在于各分区数据的分布可能不大均衡。</p><h5 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h5><p>与HASH分区相似，HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。对于NDB Cluster引擎，MySQL DB使用MD5函数来分区；其他存储引擎使用内部分哈希函数，这些函数基于PASSWORD()一样的运算法则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_key (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by key (b)</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>在key分区中使用关键字LINEAR和在HASH分区中使用具有相同的效果，分区编号通过2的幂算法得到而不是通过模数算法。</p><h5 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h5><p>RANGE、LIST、HASH、和KEY分区条件：数据必须是整型，或通过函数将其转化为整型。</p><p>MySQL v5.5开始支持COLUMNS分区，是RANGE分区和LIST分区的进化，可以直接使用非整型数据进行分区，分区根据类型直接比较而得，不需要转化为整型。RANGE COLUMNS分区可对多个列的值进行分区。</p><p>COLUMNS分区支持的数据类型：</p><ul><li>所有整型类型，如INT、SMALLINT、TINYINT、BIGINT。FLOAT和DECIMAL不支持。</li><li>日期类型，DATE和DATETIME。其余日期类型则不支持。</li><li>字符串类型，如CHAR、VARCHAR、BINARY和VARBINARY。BLOB和TEXT类型不支持。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_columns_range ( </span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b datetime</span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (b) (</span><br><span class="line">-&gt;partition p0 values less than (&apos;2019-01-01&apos;), </span><br><span class="line">-&gt;partition p1 values less than (&apos;2020-01-01&apos;) );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table rcx (</span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b int, </span><br><span class="line">-&gt;c char(3), </span><br><span class="line">-&gt;d int </span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (a,b,c) ( </span><br><span class="line">-&gt;partition p0 values less than (5,10,&apos;ggg&apos;),</span><br><span class="line">-&gt;partition p1 values less than (10,20,&apos;mmm&apos;), </span><br><span class="line">-&gt;partition p2 values less than (15,30,&apos;sss&apos;),</span><br><span class="line">-&gt;partition p3 values less than (maxvalue,maxvalue,maxvalue));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_columns_range&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;rcx&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h5 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h5><p>在分区的基础上再进行分区，也称符合分区。MySQL DB允许再RANGE和LIST的分区上再进行HASH或KEY的子分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table ts ( a int, b date)engine=innodb</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b))</span><br><span class="line">    -&gt; subpartitions 2 (</span><br><span class="line">    -&gt; partition p0 values less than (2019),</span><br><span class="line">    -&gt; partition p1 values less than (2020),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:27 ts.frm</span><br><span class="line"></span><br><span class="line">mysql&gt; create table ts_subpartition (a int,b date)engine=innodb                                                                                                                                                                                                                     </span><br><span class="line">    -&gt; partition by range (year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b)) (</span><br><span class="line">    -&gt; partition p0 values less than (2019) (subpartition s0, subpartition s1)</span><br><span class="line">    -&gt; ,partition p1 values less than (2020) (subpartition s2, subpartition s3)</span><br><span class="line">    -&gt; ,partition p2 values less than maxvalue (subpartition s4, subpartition s5));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts_subpartition</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s2.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s3.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s4.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s5.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:37 ts_subpartition.frm</span><br></pre></td></tr></table></figure><p>子分区建立：</p><ul><li>每个子分区的数量必须相同</li><li>要在一个分区表的任何分区上使用subpartition来明确定义任何子分区，就必须定义所有的子分区</li><li>每个subpartition子句必须包括子分区的一个名字</li><li>子分区的名字必须是唯一的</li></ul><p>子分区可用于特别大的表，在多个磁盘分别分配数据和索引。</p><h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MySQL允许对NULL值做分区，总是视NULL值小于任何一个非NULL的值，与MySQL DB中处理NULL值的ORDER BY操作是一样的。对于不同的分区类型，MySQL DB对NULL值的处理也各不相同。</p><p>对RANGE分区，若向分区列插入NULL值，则将该值放入最左边的分区。</p><p>在LIST分区下使用NULL值需要显式地指定哪个分区中放入NULL值，否则报错。</p><p>HASH和KEY分区处理NULL值时，任何分区函数都会将含有NULL值的记录返回为0。</p><h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>数据库应用分为：OLTP（在线事务处理），如Blog、电子商务、网络游戏等；OLAP（在线分析处理），如数据仓库、数据集市。</p><p>对OLAP应用，分区一般能很好地提高查询的性能。OLAP应用大多数查询需要频繁地扫描一张很大的表。</p><p>对OLTP应用，分区需要注意，用用通常不可能会获取一张大表中10%的数据，大部分都可通过索引返回几条记录即可。对一张大表，一般的B+ Tree需要2～3次的磁盘IO。设计时需要确认数据的访问模式，分析查询时使用分区是否能够比未使用分区减少IO访问次数。</p><h4 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h4><p>MySQL v5.6开始支持ALTER TABLE … EXCHANGE PARTITION语法。允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。若非分区表中的数据为空，则相当于将分区中的数据迁移到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。</p><p>使用语句条件：</p><ul><li>要交换的表需和分区表有着相同的表结构，但是表不能含有分区</li><li>在非分区表中数据必须在交换的分区定义内</li><li>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</li><li>用户除了需要ALTER、INSERT和CREATE权限外，还需要DROP的权限</li></ul><p>需要注意的细节：</p><ul><li>使用该语句不会触发交换表和被交换表上的触发器</li><li>AUTO_INCREMENT列将被重置</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引组织表&quot;&gt;&lt;a href=&quot;#索引组织表&quot; class=&quot;headerlink&quot; title=&quot;索引组织表&quot;&gt;&lt;/a&gt;索引组织表&lt;/h3&gt;&lt;p&gt;表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="table" scheme="bighua.top/tags/table/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="bighua.top/2019/08/16/%E6%96%87%E4%BB%B6/"/>
    <id>bighua.top/2019/08/16/文件/</id>
    <published>2019-08-16T06:20:30.000Z</published>
    <updated>2019-08-19T09:38:01.311Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB存储引擎表的各种类型文件。</p><ul><li>参数文件：告知MYSQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，介绍各种参数的类型。</li><li>日志文件：记录MySQL实例对某种条件做出响应时写入的文件，如错误的日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</li><li>socket文件：当用UNIX域套接字方式进行连接时需要的文件。</li><li>pid文件：MySQL实例的进程ID文件。</li><li>MySQL表结构文件：用来存放MySQL表结构定义文件。</li><li>存储引擎文件：每个存储引擎有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。</li></ul><h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><p>默认MySQL实例会按照一定的顺序在指定的位置进行读取，可通过<code>mysql --help | grep my.cnf</code>来寻找。</p><p>MySQL的mysql架构中记录了访问该实例的权限，当找不到这个架构时，MySQL实例不会启动成功。</p><h4 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h4><p>可以把数据参数看成一个键/值（Key/Value）对。</p><p>MySQL v5.1开始可以通过<code>information_schema</code>架构下的<code>GLOBAL_VARIABLES</code>试图来进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from global_variables where variable_name like &apos;innodb_buffer%&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_AT_STARTUP</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_FILENAME</span><br><span class="line">VARIABLE_VALUE: ib_buffer_pool</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_POPULATE</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_AT_SHUTDOWN</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_ABORT</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_INSTANCES</span><br><span class="line">VARIABLE_VALUE: 8</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_SIZE</span><br><span class="line">VARIABLE_VALUE: 4294967296</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_at_shutdown</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_filename</span><br><span class="line">        Value: ib_buffer_pool</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 8</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_abort</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_at_startup</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_populate</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 4294967296</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>各版本都支持<code>SHOW VARIABLES</code>命令。</p><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>可分为：</p><ul><li>动态参数（dynamic）参数，可在MySQL实例运行中进行更改</li><li>静态（static）参数，在整个实例生命周期内都不得进行更改</li></ul><p>可通过SET命令对动态参数值进行更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET | [global | session] system_var_name = expr | [@@global. | @@session. | @@]system_var_name= expr</span><br></pre></td></tr></table></figure><p>global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。有些参数如autocommit只能在会话中进行修改；有些参数如binlog_cache_size修改完后，在整个实例生命周期中都会生效；有些参数如read_buffer_size既可以在会话中修改又可以在整个实例的生命周期内生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set read_buffer_size=524288;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @@global.read_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>动态变量的可修改范围参考MySQL官方手册Dynamic System Variables。</p><p>修改静态变量报错，提示静态变量是只读的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set GLOBAL datadir=&apos;/db/mysql&apos;;</span><br><span class="line">ERROR 1238 (HY000): Variable &apos;datadir&apos; is a read only variable</span><br></pre></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>记录MySQL数据库的各种类型活动：</p><ul><li>错误日志（error log）</li><li>二进制日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>对MySQL的启动、运行、关闭过程进行了记录，可通过<code>SHOW VARIABLES LIKE ‘log_error’</code>来定位文件。可从中得到数据库优化的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_error&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_error</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.err</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system hostname</span><br><span class="line">wuhua</span><br></pre></td></tr></table></figure><p>默认情况下错误文件的文件名为服务器的主机名（自己mac下默认安装v5.7.22时使用了默认配置创建了_mysql用户，但是也有wuhua.err日志）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# ps aux | grep mysql | grep -v grep</span><br><span class="line">wuhua            27197   0.0  0.0  4301596   1628 s000  S+   二05下午   0:00.18 mysql -u root -p</span><br><span class="line">_mysql              95   0.0  0.1  4667136   8176   ??  Ss    8 819    0:50.48 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring --early-plugin-load=keyring_file=keyring_file.so</span><br><span class="line">sh-3.2# pwd</span><br><span class="line">/usr/local/mysql/data</span><br><span class="line">sh-3.2# ls -la</span><br><span class="line">total 390208</span><br><span class="line">drwxr-x---   17 _mysql  _mysql       544  8 13 17:50 .</span><br><span class="line">drwxr-xr-x   13 root    wheel        416 10 22  2018 ..</span><br><span class="line">-rw-r-----    1 _mysql  _mysql        56  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       559  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  79691776  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql       224  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql       512  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql      2464  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1493892  8 16 14:11 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql         3  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql      2880  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql      3456  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql       160 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    137797  8 13 17:50 wuhua.err</span><br><span class="line">sh-3.2# tail -n 10 mysqld.local.err </span><br><span class="line">2019-08-15T03:46:55.758211Z 4 [Note] Aborted connection 4 to db: &apos;unconnected&apos; user: &apos;root&apos; host: &apos;localhost&apos; (Got timeout reading communication packets)</span><br><span class="line">2019-08-15T05:57:18.115284Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 2089426ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T10:19:57.114776Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 591037ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T12:48:35.002866Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 257282ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T00:45:10.005256Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 42960754ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T02:30:30.003258Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 6316989ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T04:41:49.003687Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 1295395ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:09:32.002146Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 68711ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:11:12.002422Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 24552ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T07:44:47.528144Z 8 [Note] Access denied for user &apos;wuhua&apos;@&apos;localhost&apos; (using password: NO)</span><br></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。</p><p>可通过参数<code>long_query_time</code>来设置超时阀值，默认10，代表10秒，将运行超过该值的SQL语句记录到慢查询日志文件中。</p><p>默认不启动慢查询日志，需要手工将这个参数设置为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 10.000000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 2.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当设置了参数<code>log_queries_not_using_indexes</code>为开启时，会将没有使用索引的SQL语句记录到慢查询日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_queries_not_using_indexes&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_queries_not_using_indexes</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可通过参数<code>log_throttle_queries_not_using_indexes</code>设置每分钟允许记录到slow log的且未使用索引的SQL语句的次数。默认为0表示无限制。</p><p>可通过mysqldumpslow命令分析慢查询日志文件。使用参考<a href="http://www.dbhelp.net/2017/01/17/mysqldumpslow-%E8%AF%BB%E6%87%82mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.html" target="_blank" rel="noopener">mysqldumpslow – 读懂MySQL慢查询日志</a></p><p>v 5.1开始可以将慢查询的日志记录放入到一张表中，在mysql架构下的slow_log表，表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show create table mysql.slow_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: slow_log</span><br><span class="line">Create Table: CREATE TABLE `slow_log` (</span><br><span class="line">  `start_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  `user_host` mediumtext NOT NULL,</span><br><span class="line">  `query_time` time NOT NULL,</span><br><span class="line">  `lock_time` time NOT NULL,</span><br><span class="line">  `rows_sent` int(11) NOT NULL,</span><br><span class="line">  `rows_examined` int(11) NOT NULL,</span><br><span class="line">  `db` varchar(512) NOT NULL,</span><br><span class="line">  `last_insert_id` int(11) NOT NULL,</span><br><span class="line">  `insert_id` int(11) NOT NULL,</span><br><span class="line">  `server_id` int(10) unsigned NOT NULL,</span><br><span class="line">  `sql_text` mediumtext NOT NULL,</span><br><span class="line">  `thread_id` bigint(21) unsigned NOT NULL</span><br><span class="line">) ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT=&apos;Slow log&apos;</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>显示该表的引擎为CSV，对大数据量下的查询效率不高，可将其转换为MyISAM引擎并在start_time列上添加索引，但是已经启动了慢查询修改会报错，而且更改后会对数据库造成额外的开销。</p><p>参数log_output指定了慢查询输出的格式，默认为FILE，指定为TABLE即可将其输出到mysql架构下的slow_log表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_output&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_output</span><br><span class="line">        Value: FILE</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数<code>log_output</code>是动态全局的。</p><p>InnoSQl版本加强了对于SQL语句的捕获方式，在原版MySQL数据库的基础上在slow log中增加了对于物理读取（physical reads：从磁盘进行IO读取的次数）和逻辑读取（logic reads：所有的读取，无论磁盘还是缓冲池）的统计。可通过参数<code>long_query_io</code>将超过指定逻辑IO次数的SQL语句记录到slow log中，默认为100。为兼容原MySQL数据库的运行方式，还添加了参数<code>slow_query_type</code>用来表示启用slow log的方式，可选：</p><ul><li>0 表示不将SQL语句记录到slow log</li><li>1 表示根据运行时间将SQL语句记录到slow log</li><li>2 表示根据逻辑IO次数将SQL语句记录到slow log</li><li>3 表示根据运行时间及逻辑IO次数将SQL语句记录到slow log </li></ul><h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p>记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行，默认文件名为：主机名.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%general%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: general_log</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: general_log_file</span><br><span class="line">        Value: /usr/local/mysql/data/wuhua.log</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>本地没有开启查询日志。同slow log，v5.1开始可将查询日志放入mysql架构下的general_log表中。</p><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>binary log记录了对MySQL数据库执行更改的所有操作，不包括SELECT和SHOW这类操作。</p><p>作用：</p><ul><li>恢复：某些数据的恢复需要需要二进制日志。例如再一个数据库全备文件恢复后，可通过二进制日志进行ponit-in-time的恢复。</li><li>复制：原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般为slave或standby）与一台MySQL数据库（一般为master或primary）进行实时同步。</li><li>审计：可通过审计判断是否有对数据库进行注入的攻击。</li></ul><p>通过配置参数log-bin [=name]启动二进制日志，不指定name则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号，所在路径为数据库所在目录。</p><p>默认没启动，需要手动指定参数启动。影响二进制日志记录的信息和行为：</p><ul><li>max_binlog_size：指定单个二进制日志文件的最大值，超过该值产生新的二进制日志文件，后缀名加1，并记录到index文件。</li><li>binlog_cache_size：使用事务表存储引擎时，未提交的二进制日志会被记录到一个缓冲中去，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，缓冲的大小由binlog_cache_size决定，默认为32k。基于session，当一个线程开启事务时会分配一个大小为binlog_cache_seze的缓存，若一个事务的记录大于设定的binlog_cache_size，会将缓冲中的日志写入一个临时文件。可通过<code>SHOW GLOBAL STATUS</code>查看<code>binlog_cache_use</code>和<code>binlog_cache_disk_use</code>的状态判断当前的设置是否合适，前者记录使用缓冲写二进制日志的次数，后者记录使用临时文件写二进制日志的次数。</li><li>sync_binlog：表示每写缓冲多少次就同步到磁盘。值1表示采用同步写磁盘的方式来写二进制日志，但是若在事务发出commit之前发生宕机，此时二进制日志写入文件，但是提交还没有发生，在启动恢复时由于二进制日志已经记录了该事务信息，不能被回滚，可通过将参数innodb_support_xa设为1解决，能同时保证二进制日志和InnoDB存储引擎数据文件的同步；默认0。若使用InnoDB存储引擎进行复制，并且想得到最大的高可用行，建议将该值设置为ON。</li><li>binlog-do-db和binlog-ignore-db：表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</li><li>log-slave-update：若当前DB是复制中的slave角色，不会将从master取得并执行二进制日志写入自己的二进制日志文件中去，若需要写入则需设置log-slave-update。若搭建master=&gt;slave=&gt;slave架构的复制则必须设置该参数。</li><li>bin_format：二进制日志的格式。MySQL v5.1前无此参数，格式基于SQL语句级别，存在问题：若在主服务器上运行rand、uuid等函数或者使用触发器会导致主从服务器上表中数据的不一致；因为二进制日志文件格式的关系默认事务隔离级别为REPEATABLE READ，若使用READ COMMITTED的事务隔离级别会出现丢失更新的现象，出现主从数据库上的数据不一致。</li></ul><p>v5.1开始引入参数bin_format可设STATEMENT、ROW和MIXED。</p><ol><li>STATEMENT格式和之前的版本一样，二进制文件记录的是日志的逻辑SQL语句。</li><li>ROW格式下，二进制日志记录表的行更改情况，对Statement格式下的复制问题予以解决，若设置bin_format为ROW，可将InnoDB的事务隔离级别设为READ COMMITTED，以获得更好的并发行。</li><li>MIXED格式下，默认采用STATEMENT格式进行二进制日志文件的记录，但在一些情况下会使用ROW格式，可能有：<ul><li>表的存储引擎为NDB，对表的DML操作都会以ROW格式记录。</li><li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数。</li><li>使用了INSERT DELAY语句。</li><li>使用了用户定义函数（UDF）</li><li>使用了临时表（temeporary table）</li></ul></li></ol><p>binlog_format参数对于存储引擎的限制：</p><table><thead><tr><th style="text-align:center">存储引擎</th><th style="text-align:center">Row格式</th><th style="text-align:center">Statement格式</th></tr></thead><tbody><tr><td style="text-align:center">InnoDB</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MyISAM</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">HEAP</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MERGE</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">NDB</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">Archive</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">CSV</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Federate</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Blockhole</td><td style="text-align:center">N</td><td style="text-align:center">Y </td></tr></tbody></table><p>通常将参数binlog_format设置为ROW，可为数据库的恢复和复制带来更好的可靠性。有些语句下的ROW格式可能需要更大的容量，会带来二进制文件大小的增加。由于复制是采用传输二进制日志方式实现，复制的网络开销也有所增加。</p><p>二进制日志文件需要通过MySQL提供的工具mysqlbinlog工具查看。</p><p><a href="https://juejin.im/post/5a72c2daf265da3e5234d879" target="_blank" rel="noopener">腾讯工程师带你深入解析 MySQL binlog</a></p><h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3><p>UNIX系统下可采用UINX域套接字方式连接本地MySQL，需要一个套接字文件。</p><p>可由参数socket控制，一般在/tmp目录下，名为mysql.sock。</p><h3 id="pid-文件"><a href="#pid-文件" class="headerlink" title="pid 文件"></a>pid 文件</h3><p>MySQL实例启动时，会将进程ID写入一个文件——该文件即为pid文件，可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &apos;pid_file&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: pid_file</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.pid</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h3><p>MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储是根据表进行，每个表都有与之对应的文件。无论表采用何种引擎，都有一个以frm为后缀名的文件，记录了该表的表结构定义。frm文件还用来存放视图的定义，文件为文本文件。</p><p>查看时发现文件内容像加密过，一查果然，参考<a href="http://mysql.taobao.org/monthly/2018/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 表空间加密</a></p><h3 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h3><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>InnoDB采用存储的数据按表空间（tablespace）进行存放的设计，默认配置下会有一个初始大小为10M名为ibdata1的文件，其为默认的表空间文件，可通过参数innodb_data_file_path对其进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=datafile_spec1[;datafile_spec2]...</span><br></pre></td></tr></table></figure><p>可通过多个文件组成一个表空间文件，同时制定文件的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = /db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure><p>意味着将/db/ibdata1和/dr2/db/ibdata2两个文件用来组成表空间，大小都为2000MB，若用完可自动增长。若位于不同的磁盘上，磁盘的负载可能被平均，提高数据库的整体性能。</p><p>设置该参数后，所有基于InnoDB的表的数据都会记录到该共享表空间中，若设置了参数<code>innodb_file_pre_table</code>，则用户可以将每个基于InnoDB存储引擎的产生一个独立表空间，命令规则为：表名.idb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_file_per_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login</span><br><span class="line">total 1424</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.6K  8 16  2018 jobs.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  8 16  2018 jobs.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.5K  7 26  2018 user_profiles.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   128K  7 27  2018 user_profiles.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   100B  7 18 16:11 users.MYD</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   2.0K  7 24 09:58 users.MYI</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 18 15:55 users.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    13K  7 18 15:48 users_old.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   176K  7 18 15:48 users_old.ibd</span><br></pre></td></tr></table></figure><p>单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>默认情况下InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。记录了InnoDB存储引擎的事务日志。</p><p>当实例或介质失败（media failure）时，InnoDB存储引擎会根据重做日志恢复到掉电前的时刻，以此来保证数据的完整性。</p><p>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。可设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。</p><p>影响重做日志文件的属性：</p><ul><li>innodb_log_file_size：指定每个重做日志文件的大小，InnnoDB v1.2.x前总大小小于等于4GB，v1.2.x将限制扩大为512GB。</li><li>innodb_log_files_in_group：指定日志文件组中重做日志文件的数量，默认为2。</li><li>innodb_mirrored_log_groups：指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像。若磁盘本身已做了高可用方案，如磁盘列阵，则可以不开启重做日志镜像的功能。</li><li>innodb_log_group_home_dir：指定了日志文件组所在的路径，默认为./，表示在MySQL数据库的数据目录下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data</span><br><span class="line">Password:</span><br><span class="line">total 390208</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    56B  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   559B  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    76M  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    12M  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql   224B  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql   512B  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql   2.4K  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1.4M  8 19 13:43 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql     3B  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql   2.8K  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql   3.4K  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql   160B 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   135K  8 13 17:50 wuhua.err</span><br></pre></td></tr></table></figure><p>重做日志文件设置过大会导致恢复需要很长的时间，太小会导致一个事务需要多次切换重做日志文件。此外太小会导致频繁地发生async checkpoint，导致性能的抖动。</p><p>二进制日志记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志，InnoDB存储引擎的重做日志只记录有关该存储引擎本身的事务日志。二进制日志记录的是关于一个事务的具体操作内容，该日志是逻辑日志，InnoDB存储引擎的重做日志记录的是关于每个页的更改的物理情况。二进制日志文件仅在事务提交前进行提交，只写磁盘一次，不论该事务多大，在事务进行的过程中，不断有重做日志被写入到重做日志文件中。</p><p>到InnoDB v1.2.x版本为止，共定义了51种重做日志类型，基本格式相同：</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo_log_body</th></tr></thead><tbody><tr><td style="text-align:center">占用1字节，表示重做日志的类型</td><td style="text-align:center">表示表空间的ID，采用压缩的方式，占用空间可能小于4字节</td><td style="text-align:center">表示页的偏移量，采用压缩的方式</td><td style="text-align:center">表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析</td></tr></tbody></table><p>从重做日志缓冲往磁盘写入时按照512个字节（一个扇区）的大小进行写入，因为扇区是写入的最小单位，可以保证写入必定是成功的。重做日志的写入过程中不需要有doublewrite。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>控制在提交时，处理重做日志的方式：</p><ul><li>0 ：表示当事务提交时，不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</li><li>1 ：执行commit时将重做日志缓冲同步写到缓存中，伴有fsync的调用。</li><li>2 ：表示将重做日志异步写到磁盘，即写到文件系统的缓存中，不能完全保证执行commit时肯定会写入重做日志文件，只是有这个动作发生。</li></ul><p>为保证ACID中的持久性，必须将innodb_flush_log_at_trx_commit设为1，即每档事务提交时就必须确保事务已经写入重做日志文件，当数据库意外宕机时可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。设为0或2时，都有可能发生恢复时部分事务的丢失，但是设置为2若MySQL数据库宕机而操作系统及服务器没有宕机时，由于此时为写入磁盘的事务日志保存在文件系统缓冲中，恢复时同样能保证数据不丢失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB存储引擎表的各种类型文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数文件：告知MYSQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，介绍各种参数的类型。&lt;/li&gt;
&lt;li&gt;日志文件：记录MySQL实例对某种条件做出响
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
      <category term="file" scheme="bighua.top/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-命令</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/"/>
    <id>bighua.top/2019/04/06/Docker学习-命令/</id>
    <published>2019-04-06T08:07:44.000Z</published>
    <updated>2019-04-29T06:59:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><p>EXAMPLES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">//绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h4 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h4><p>docker start :启动一个或多个已经被停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker stop :停止一个运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker restart :重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">//停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">//重启容器myrunoob</span><br><span class="line"></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>docker kill :杀掉一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-s :向容器发送一个信号</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//杀掉运行中的容器mynginx</span><br><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>docker rm ：删除一个或多少容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">//移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line">//删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h4 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h4><p>docker pause :暂停容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker unpause :恢复容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//暂停数据库容器db01提供服务。</span><br><span class="line">docker pause db01</span><br><span class="line"></span><br><span class="line">//恢复数据库容器db01提供服务。</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>docker create ：创建一个新的容器但不启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>同<code>docker run</code><br>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>docker exec ：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">//在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>docker ps : 列出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//列出所有在运行的容器信息</span><br><span class="line">wuhua:blog wuhua$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>####inspect<br>docker inspect : 获取容器/镜像的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li><li>-s :显示总的文件大小。</li><li>–type :为指定类型返回JSON。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取镜像mysql:5.6的元信息</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">//获取正在运行的容器mymysql的 IP</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>docker attach :连接到正在运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><p>docker events : 从服务器获取实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示docker 2016年7月1日后的所有事件</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">//显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</span><br></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p><p>OPTIONS:</p><ul><li>-f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>-t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">//查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :将输入内容写到文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure><p>###容器rootfs命令</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>docker commit :从容器创建一个新的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>docker cp :用于容器与主机之间的数据拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-L :保持源目标中的链接</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">//将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>docker diff : 检查容器里文件结构的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看容器mymysql的文件结构更改。</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><h4 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h4><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker logout [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-u :登陆的用户名</li><li>-p :登陆的密码</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">//登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :拉取所有 tagged 镜像</li><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从Docker Hub下载java最新版镜像。</span><br><span class="line">docker pull java</span><br><span class="line">//从Docker Hub下载REPOSITORY为java的所有镜像。</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>docker search : 从Docker Hub查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–automated :只列出 automated build类型的镜像；</li><li>–no-trunc :显示完整的镜像描述；</li><li>-s :列出收藏数不小于指定值的镜像。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:blog wuhua$ docker search -s 10 java</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                         Node.js is a JavaScript-based platform for s…   7238                [OK]                </span><br><span class="line">tomcat                                       Apache Tomcat is an open source implementati…   2333                [OK]                </span><br><span class="line">java                                         Java is a concurrent, class-based, and objec…   1967                [OK]                </span><br><span class="line">openjdk                                      OpenJDK is an open-source implementation of …   1599                [OK]                </span><br><span class="line">ghost                                        Ghost is a free and open source blogging pla…   951                 [OK]                </span><br><span class="line">anapsix/alpine-java                          Oracle Java 8 (and 7) with GLIBC 2.28 over A…   402                                     [OK]</span><br><span class="line">jetty                                        Jetty provides a Web server and javax.servle…   294                 [OK]                </span><br><span class="line">couchdb                                      CouchDB is a database that uses JSON for doc…   269                 [OK]                </span><br><span class="line">ibmjava                                      Official IBM® SDK, Java™ Technology Edition …   67                  [OK]                </span><br><span class="line">groovy                                       Apache Groovy is a multi-faceted language fo…   66                  [OK]                </span><br><span class="line">tomee                                        Apache TomEE is an all-Apache Java EE certif…   64                  [OK]                </span><br><span class="line">lwieske/java-8                               Oracle Java 8 Container - Full + Slim - Base…   43                                      [OK]</span><br><span class="line">cloudbees/jnlp-slave-with-java-build-tools   Extends cloudbees/java-build-tools docker im…   25                                      [OK]</span><br><span class="line">zabbix/zabbix-java-gateway                   Zabbix Java Gateway                             16                                      [OK]</span><br><span class="line">frekele/java                                 docker run --rm --name java frekele/java        13                                      [OK]</span><br><span class="line">davidcaste/alpine-java-unlimited-jce         Oracle Java 8 (and 7) with GLIBC 2.21 over A…   11                                      [OK]</span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>docker images : 列出本地镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID.</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">//列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure><h4 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h4><p>docker rmi : 删除本地一个或多少镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制删除本地镜像runoob/ubuntu:v4。</span><br><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>docker tag : 标记本地镜像，将其归入某一仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>docker build 命令用于使用 Dockerfile 创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–build-arg=[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label=[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置/dev/shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line">//使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">//通过 -f Dockerfile 文件的位置</span><br><span class="line"> docker build -f /path/to/a/Dockerfile .</span><br><span class="line">//在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回</span><br><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>docker history : 查看指定镜像的创建历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-H :以可读的格式打印镜像大小和日期，默认为true；</li><li>–no-trunc :显示完整的提交记录；</li><li>-q :仅列出提交记录ID。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>docker save : 将指定镜像保存成 tar 归档文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :输出到的文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>docker import : 从归档文件中创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-c :应用docker 指令创建镜像；</li><li>-m :提交时的说明文字；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info [OPTIONS]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-11T12:27:47.5699614Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>docker version :显示 Docker 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器生命周期管理&quot;&gt;&lt;a href=&quot;#容器生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;容器生命周期管理&quot;&gt;&lt;/a&gt;容器生命周期管理&lt;/h3&gt;&lt;h4 id=&quot;run&quot;&gt;&lt;a href=&quot;#run&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
      <category term="命令" scheme="bighua.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习-安装配置</title>
    <link href="bighua.top/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>bighua.top/2019/04/06/Docker学习-安装配置/</id>
    <published>2019-04-06T07:50:07.000Z</published>
    <updated>2019-04-11T12:33:14.177Z</updated>
    
    <content type="html"><![CDATA[<p>mac环境桌面版</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ brew search docker</span><br><span class="line">==&gt; Formulae</span><br><span class="line">docker                                   docker-machine-completion</span><br><span class="line">docker-clean                             docker-machine-driver-hyperkit</span><br><span class="line">docker-cloud                             docker-machine-driver-vultr</span><br><span class="line">docker-completion                        docker-machine-driver-xhyve</span><br><span class="line">docker-compose                           docker-machine-nfs</span><br><span class="line">docker-compose-completion                docker-machine-parallels</span><br><span class="line">docker-credential-helper                 docker-squash</span><br><span class="line">docker-credential-helper-ecr             docker-swarm</span><br><span class="line">docker-gen                               docker2aci</span><br><span class="line">docker-ls                                dockerize</span><br><span class="line">docker-machine</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">docker                                   homebrew/cask-versions/docker-edge</span><br><span class="line">docker-toolbox</span><br><span class="line">wuhua:src wuhua$ brew cask install docker</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/31259/Docker.dmg</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask &apos;docker&apos;.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App &apos;Docker.app&apos; to &apos;/Applications/Docker.app&apos;.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure><p>点<code>访达</code>边的<code>启动台</code> 可看到下载好的桌面版docker，点击启动按步骤操作输入密码授权</p><p>配置后启动查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Error response from daemon: Bad response from Docker engine</span><br><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 51</span><br><span class="line"> System Time: 2019-04-06T07:47:49.465200315Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><p>第一次<code>docker info</code>查询失败是因为未启动完毕。</p><p>关于docker命令参考<a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></p><p>关于设置docker国内镜像参考<a href="https://www.cnblogs.com/anliven/p/6218741.html" target="_blank" rel="noopener">Docker国内镜像</a></p><p>关于其他系统Doker安装参考<a href="http://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">MacOS Docker 安装</a></p><p>关于<code>brew</code>和<code>brew cask</code>参考<a href="https://blog.csdn.net/yanxiaobo1991/article/details/78455908" target="_blank" rel="noopener">mac brew和brew cask的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac环境桌面版&lt;/p&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="Docker" scheme="bighua.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="bighua.top/tags/Docker/"/>
    
      <category term="mac" scheme="bighua.top/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="bighua.top/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>bighua.top/2019/02/02/2018年终总结/</id>
    <published>2019-02-01T17:19:30.000Z</published>
    <updated>2019-02-04T17:17:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。</p><h3 id="上半年-大学毕业"><a href="#上半年-大学毕业" class="headerlink" title="上半年-大学毕业"></a>上半年-大学毕业</h3><p>从17年11月份确定毕设课题开始，毕设导师就开始积极联系我们进行相关课题的研究工作。可能是由于导师也是第一年回校园工作，对之前的毕设流程不了解，对我们的要求可以说是有点太过严谨。在10月末确定工作签好三方后，本想去公司实习一段时间，了解公司和相关技术，但是导师以毕设为由，建议将毕设弄差不多后再去实习。</p><p>17年末，过的很轻松，结束掉了大学最后的几门课程考试。这段时间， 每天基本睡到自然醒，中午一点多去梦泽园吃顿饭，回宿舍打游戏，晚上玩手机熬夜到很晚，第二天循环如此。这一段时间，应该是大学过的最爽的一段时间，不用再顾虑学习，确定好了工作，混吃等死。每天重复的事情——打游戏、睡觉、一切其他感兴趣的事情。有点遗憾是经济不支持，没能实现出去旅游四处走走的心愿。有点不爽的是，考试结束本来可以回家的，导师要求留校十天，进行毕设课题相关的工作。其实这十天完全没做多少毕设相关的工作，大多数时间依旧堕落的生活。放假前的例会，发给我们相关软硬件，让我们回家摸索。然而，春节期间谁会想到这玩意呢，怎么样带回去，再怎么样的带回来，再在例会前几天突击了解一下。</p><p>春节期间，由于工作的<code>理想工资</code>，自己快有点飘了，在各个房产软件上查看洛阳、信阳等各处楼盘的信息，心里决定一定要靠自己买到理想的、位置合适的一套房子。现在想想，当时的想法还有点太遥远，想要去实现，还远得很。</p><p>18年开学，晚来了一周多，如果不是导师要求例会，完全不想再返回学校。到学校后，发现很多同学已经开始或打算去实习了，这时有个换毕设课题的机会，跟与学校合作的企业去开发<code>养猪</code>项目，当作毕设课题，当时爽妈还建议我一起报，可以想着搞定毕设去公司实习，拒绝了，结合后来苦逼的毕设过程、没能够去公司实习、看他们<code>养猪</code>玩的不亦乐乎，简直想抽自己两巴掌，后悔得要死。后来18年大四最后一学期的前几个月——3月中旬至五月中旬——就如前面所说。每天在导师给找的办公室里做毕设相关——看资料、翻译、看源代码、记录，枯燥无聊。四月初感觉毕设做的差不多了想去实习，联系hr后反馈没有实习名额了，然后<code>养猪</code>的同学四处游山玩水，简直心里不爽到极点。不爽的最后也是有些收获的，阅读项目底层C语言源码，收获有一些，在18年的一篇日志中有些记录，这里就不重记了。到5月中旬，毕设论文准备的差不多了，就趁二姐回家，回家过了半个月，陪可爱的外甥女玩，很是惬意开心。6月初返校，修修改改准备最后的论文终稿、答辩PPT，10号答辩顺利通过，其实感觉我是通过的最顺利的一个，整个过程不到5分钟，没有安全相关的老师，没问什么问题，对做的工作进行了一些了解性提问，最后甚至还有个老师想要推优我的毕设论文。还好最终没推优，省去了一些麻烦事。作为一条咸鱼，已经不对大学再抱有任何幻想，只想着顺利毕业结束这不怎么样的四年。</p><p>这半年沉寂了N久的和尚之心也随着与李老师的几次会面交流在18年春天有了一些蠢蠢欲动，也是在枯燥的毕设过程中多了一些点缀。但是毕竟多年修炼有素，内心抑制住了，对于没有把握的事情不再轻易尝试。在四月时，自己曾一人骑着小蓝车再一次逛了一遍校园。从图书馆出发，骑到24节气看观赏的游客，骑到油菜田拍一片金黄、骑过基本建成养猪厂、骑过坟场前面旁边开的鲜花正盛的小户人家、骑过柳树随着春风摇曳着枝条的南湖边、骑过情侣经常约会的小树林、起过吐槽了四年的环湖跑路线、起过茶叶地、骑过种满各种花卉和作物的研究圆、起过二运篮球场旁边开满紫色小花的小树林、骑到清真食堂再感受一遍不怎么喜欢的饭菜最终还是照旧选择了炒饭，最后在慢慢走回去，体验这最后的悠闲时光。六月中旬班级毕业晚饭到毕设典礼以及最后的毕业离校时间，其实还是挺想留下来感受下这最后的相聚时光的，虽然回家过端午节并送二姐回家是提前离校原因之一，但是更过的原因是不想再见那些隔阂了很久的同学，想早点逃离这不爽快的生活。</p><p>总的来说，18年的上半年，生活的主要节奏是毕设，心中住进的人在毕设枯燥的生活中增添了一些别样色彩，可爱的外甥女，毕设离别。在技术上，学习了go的一点皮毛，复习一些c相关的东西，遗忘了PHP。</p><h3 id="下半年-参入工作"><a href="#下半年-参入工作" class="headerlink" title="下半年-参入工作"></a>下半年-参入工作</h3><p>拿到小强寄回的毕业证后，迟迟不想离家，想在家多待几天，定的火车票也很晚，直到日期到达不得不收拾行李开始北漂生活。六月二十八下午到北京，出站后马上办理了一卡通，先坐地铁去上班的地方看了一眼，拍了一张北大的竺可桢大楼，由于之前没租好房，然后立刻拖着行李开始去附近找中介看房子，然后这附近的房子符合心里价位预期的不是小就是破旧，最终没能定下，看完房子吃完晚饭差不多六点了，才开始考虑宾馆的事情。这个时候才开始去美团上看附近的青旅，基本上家家都爆满了。最后花了100多大洋找到一家<code>招待所</code>，直到七绕八绕问了路人才找到这家在地下二层的<code>招待所</code>。是的，地下室，很多间，里面住着不少人，看着有晾晒衣服的，其中不少工作服，例如交通协助员服、清洁工服等，虽然这里并没有阳关。里面用的公用的洗漱间和卫生间，有点高中公共卫生间的感觉，但是要比那糟糕多了，这里没有阳光，通气靠中央空调，异常潮湿，老旧残破。这个地下室在中关村靠近苏州街那边，具体的位置记不太清了。那天晚上才确认到，原来还真有在这种环境中常驻生活的人的，体会到生活的不易。虽然环境差了些，但我还是睡着了，因为太困了，拖着大行李箱跑了好久。</p><p>29号早晨离开地下室、拖着行李箱开始坐四号线往南走到自如上房价相对便宜点的站点下，但一下地铁，计算下路上消耗的时间就打消了租房的念头，然后又坐四号线往北走，到安河桥北下，计算公司地铁站点到安河桥北消耗的时间。下地铁后，之前在自如上关注的房源负责的中介联系上了我，说是十六号线永丰南有房源要马上释放了，想帮我抢，这个时候拖着行李跑了老半天的我简直感动到不行，然后立刻提供了账号，可惜她并没有帮我抢到，她甚至怀疑他们内部有挂，也是很有趣。然后从安河桥北站向外面忘了几眼，合计下地铁时间，就开始重新进站，向hr推荐的十六号线上的几点地点去，根据通勤时间以及自如上的房价，最终选择了在马连洼站下，然后开始搜索附近的中介，最后拖着行李先找了链家，他们的房源与自如上的是统一的，中介也是根据需求在自如上查找，最后给推荐了一个在圆明园别墅的将要退租的房源，但是到30号才能看房。出了链家，又找了一家不远的我爱我家，才知道他们的房源与平台展示的是不同步的，给推荐了三处房源，最终选择了30号可马上入住的肖家河，思考再三签了合同，交了12500元，花了人生中最大的一笔钱。这一晚，在同是应届生的同事租好的房子里打地铺凑合了一晚，他刚好租在隔壁小区，感谢这位热心广东同事。30号早去办完交接手续，就开始布置房子，正式入住了。七月一号，和这位广东同事一起去逛了故宫，但是实在太大了，我们只走了一条线就结束了，然后骑自行经过天安门，去同事推荐的美食街吃了碗面，坐地铁回家。</p><p>七月二号，正式入职，去总部本办理入职手续，花了一上午时间，吃完午饭去办公地点，由hr领着带到每个人的小组，交给组长。我们组长帆哥再带领我们去见经理、和前端负责人打招呼，然后给我们安排工位。接着hr带领我们熟悉办公环境，介绍我们所在的组，以及生活上的日常。</p><p>七月和八月这两个月算事这半年最轻松的，跟着新人培养计划熟悉相关技术和工具，做一个内部项目，每晚都能八点左右甚至吃完晚饭后直接回去，这两个月回去后还经常再开几把lol。到了九月份开始熟悉正在开发的正式项目X，就慢慢开始忙起来了。这两个月我们组有些人事变动，七月中旬刚聚餐完，下旬组长就开始离职前的最后休假了，到了九月中旬及十月中旬，陆续又有三名同事离开。技术上完全是学习状态，虽然之前撸项目PHP用的挺多，但是也快有大半年未接触过了，这大半年都投入到毕设和了解Go上去了，其他相关的技术如mysql、nginx、redis等也是学习使用状态。</p><p>刚开始接触正式项目X，有些吃力，没有从一开始就关注这个项目，业务完全不了解，读相关产品文档、wiki、代码都有些吃力。这时正值这个正式项目第一次上线，离职同事负责的模块留下了很多待解决bug，这时他的模块交给了另一个同事，待解决bug也基本都有这位交接的同事慢慢解决完了。他带着我开始熟悉这部分的业务，从一些新增的简单接口开始，慢慢熟悉了解整个模块。这时候也大部分都是在学习状态，跟着了解业务，跟着学会排查bug，解决bug。十月下旬述职转正，可能是不适应经理的冷脸，心里总是很紧张，比笔毕设答辩时还紧张，表现很差，最后顺序转正，算是正式员工可以有绩效了。</p><p>九月到十一月还不是很忙，基本上是熟悉业务写些小接口的状态，还可以有些时间进行其他的学习。十一月过的很糟心，三叔的离世。十一月末回来后，正式开始了这半年最繁忙的两个月。</p><p>十一月时接了一个评审中的项目A，十二月开始进入开发，但是十二月上旬，同事由于有其他工作需求解决，交给了我另一个项目B。还好的是老项目逻辑可以参考，坏的是时间很紧，根据排期只有一周多的时间就要体测，没有参入评审，对很多细节不了解，也给后来埋了不少坑。这一两周每天都回去很晚，整理老项目逻辑，开发，调试，该bug。十二月初，十一月评审的项目A也正式进入排期阶段，在做项目B的同时整理项目A相关产品文档，确定需求接口，再向被人要接口要排期。同时，十二月初，之前负责的项目X需要改版，之前写的接口基本不能复用，好在接口不多，在十二月中旬花了三四天完成。完成项目X的接口后，项目A也开始进入开发阶段，同时还要排查修改项目X和项目B的相关bug，直到项目A接口交付deadline的前一天——圣诞后两天，项目A需要的10个接口还有一半未完成，而在圣诞节这天项目X改版上线，通宵到四五点才回去。睡到中午醒，立刻开始项目A未完成的接口开发，一直到交付日期五点基本开发完。这两天简直有点吃不消，一直影响到一月，脸上又开始出现很多痘痘，脸色也很不好。一开始以为项目A只有刚开始需求的十多个新接口，其他的可以复用老接口，后来发现我错了，一月份的整个工作都消耗在了老接口的调试重写上，被提N多BUG，每天在改bug、熟悉老代码逻辑、调试接口中度过。目前还有一个遗留bug未解决，需要年后继续联调。在一月中旬，接了哟哥小工具的开发工作，开始以为是一个简单的小功能，最开始的产品需求也比较简单，可是后来出现一些问题后就突然麻烦起来，虽然目前给了一个折中解决方案，年后估计还有好一整。</p><p>这半年，也和几个老同学们聚过几次，去过北京几个地儿。技术上的状态，目前仍然是学习阶段，这半年大多时间都在用php撸业务去了，上半年了解的go也基本忘差不多了。上半年住进心里的李老师，我也终于鼓起勇气直面内心了一回，希望在新的一年里能有更多时间去争取。</p><p>一会就到站了，希望自己在新的一年里一切顺利，家人身体健康～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。&lt;/p&gt;
&lt;h3 id=&quot;上半年-大学毕业&quot;&gt;&lt;a href=&quot;#上半年-大学毕业&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="bighua.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql的character_set变量</title>
    <link href="bighua.top/2019/01/25/%E5%85%B3%E4%BA%8Emysql%E7%9A%84character-set%E5%8F%98%E9%87%8F/"/>
    <id>bighua.top/2019/01/25/关于mysql的character-set变量/</id>
    <published>2019-01-25T08:08:27.000Z</published>
    <updated>2019-03-31T15:20:02.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show full columns from table_name;</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">| Field              | Type                | Collation       | Null | Key | Default | Extra          | Privileges           | Comment     |</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">...</span><br><span class="line">| user_name          | varchar(100)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ????        |</span><br><span class="line">| chapter_name       | varchar(255)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ?????       |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看数据库字符集设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;char%&apos;;</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| Variable_name            | Value                               |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| character_set_client     | latin1                              |</span><br><span class="line">| character_set_connection | latin1                              |</span><br><span class="line">| character_set_database   | utf8                                |</span><br><span class="line">| character_set_filesystem | binary                              |</span><br><span class="line">| character_set_results    | latin1                              |</span><br><span class="line">| character_set_server     | utf8                                |</span><br><span class="line">| character_set_system     | utf8                                |</span><br><span class="line">| character_sets_dir       | /usr/share/percona-server/charsets/ |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>大致感觉到原因是由于数据表相关字段字符集设置为utf8，以utf8编码存储，但是查询结果以latin1编码输出，导致汉字出现乱码。</p><p>搜索得解决办法，在查询语句中对出现乱码字段字符集编码进行转换，具体转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(unhex(hex(convert(user_name using utf8))) using latin1) as user_name,convert(unhex(hex(convert(chapter_name using utf8))) using latin1) as chapter_name</span><br></pre></td></tr></table></figure><p>最终得到正确无乱码的查询结果。</p><h3 id="各character-set变量的含义"><a href="#各character-set变量的含义" class="headerlink" title="各character_set变量的含义"></a>各character_set变量的含义</h3><p>参考博客<a href="http://www.laruence.com/2008/01/05/12.html" target="_blank" rel="noopener">深入Mysql字符集设置</a>,<br><a href="https://hk.saowen.com/a/9c46af2db75e4f83be2d3eecd0d8de1246c3a69aed5facfbebe19ad46ca2600c" target="_blank" rel="noopener">Mysql中各種與字符編碼集（character_set）有關的變量含義</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="mysql" scheme="bighua.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="character_set" scheme="bighua.top/tags/character-set/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/15/InnoDB存储引擎/</id>
    <published>2019-01-15T07:33:37.000Z</published>
    <updated>2019-08-16T06:33:03.699Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。</p><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池，负责工作：</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构。</li><li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li><li>重做日志（redo log）缓冲。 </li></ul><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据。将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB是多线程模型，后台有多个不同的后台线程，负责处理不同的任务。</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>使用AIO（Async IO）来处理写IO请求，提高数据库的性能。IO Thread负责这些IO请求的回调（call back）处理。InnoDB V1.0前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。Linux下IO Thread的数量不能进行调整，Win下可以通过参数<code>innodb_file_io_threads</code>来增大IO Thread。InnoDB V1.0开始，read thread和write thread分别增大到了4个，不再使用<code>innodb_file_io_threads</code>参数，分别使用<code>inodb_read_io_threads</code>和<code>innodb_write_io_threads</code>参数进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_%io_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_read_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_write_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-23 00:22:55 0x7000078ef000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 30 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3 srv_active, 0 srv_shutdown, 261512 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 261494</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 9</span><br><span class="line">OS WAIT ARRAY INFO: signal count 9</span><br><span class="line">RW-shared spins 0, rounds 9, OS waits 2</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 9.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 23555</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479475189552, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for i/o request (log thread)</span><br><span class="line">I/O thread 2 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 3 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 4 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 5 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 6 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 7 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 8 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 9 state: waiting for i/o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&apos;s:, sync i/o&apos;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">432 OS file reads, 59 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 4861558</span><br><span class="line">Log flushed up to   4861558</span><br><span class="line">Pages flushed up to 4861558</span><br><span class="line">Last checkpoint at  4861549</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 137933</span><br><span class="line">Buffer pool size   8191</span><br><span class="line">Free buffers       7760</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 42</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=94, Main thread ID=123145423732736, state: sleeping</span><br><span class="line">Number of rows inserted 90, updated 0, deleted 0, read 98</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.08 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p><code>show engine innodb status</code>观察IO Thread。读线程的ID总是小于写线程。</p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>事务被提交后，其所使用的undolog可能不再需要，需要Purge Thread回收已经使用并分配的undo页，V1.1之前，purge操作仅在InnoDB存储引擎的Master Thread中完成，V1.1开始，可以单独到独立的线程中进行，减轻Master Thread的工作，提高CPU使用率、提升存储引擎的性能。</p><p>在数据库配置文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=1</span><br></pre></td></tr></table></figure><p>来启用独立的Purge Thread。</p><blockquote><p>查看配置文件位置  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ /usr/local/mysql/bin/mysql --verbose --help |grep -A 1 &apos;Default options&apos;</span><br><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf </span><br><span class="line">wuhua:~ wuhua$ mysql --help|grep &apos;my.cnf&apos;</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>设置后重启mysql（<code>sudo /usr/local/mysql/support-files/mysql.server restart</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>V1.1即使将<code>innodb_purge_threads</code>设为大于一，启动时也会将其设为1。V1.2开始，为进一步加快undo页的回收，支持多个Purge Thread。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 4</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>于V1.2.x版本引入，为减轻原Master Thread的工作及对于用户查询线程的阻塞、进一步提高InnoDB存储引擎的性能，将之前版本中脏页的刷新操作放到单独的线程中来完成。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>InnoDB存储引擎基于磁盘存储，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。因CPU速度与磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。</p><p>数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，过程称为将页‘FIX’在缓冲池中。下一次再读取相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取页，否则读取磁盘上的页。</p><p>进行页的修改操作时，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，通过一种称为Checkpoint的机制刷新回磁盘。为提高数据库的整体性能。</p><p>缓冲池的大小直接影响着数据库的整体性能。32位系统下该值为3G，可打开操作系统的PAE选项来获得32位操作系统下最大64GB内存的支持。为使数据库使用更多的内存，建议数据库服务器采用64位操作系统。</p><p>缓存池的配置通过参数<code>innodb_buffer_pool_size</code>来设置，默认值是128M，最小5M(当小于该值时会设置成5M)，最大为LLONG_MAX。</p><p>修改前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 134217728</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 268435456</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>缓冲池中缓冲的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。索引页和数据页占缓冲池很大一部分。</p><p>从V1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。可以减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数<code>innodb_buffer_pool_instances</code>来进行设置，默认值为1，设置大于1时需保证缓冲池大小（<code>innodb_buffer_pool_size</code>）最小为1G。</p><p>设置前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>设置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=1028M</span><br><span class="line">innodb_buffer_pool_instances=2</span><br></pre></td></tr></table></figure><p>多种方式查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema</span><br><span class="line">mysql&gt; select pool_id,pool_size,free_buffers,database_pages from innodb_buffer_pool_stats\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       pool_id: 0</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40724</span><br><span class="line">database_pages: 231</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">       pool_id: 1</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40755</span><br><span class="line">database_pages: 200</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 2</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40724</span><br><span class="line">Database pages     231</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 196, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 231, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40755</span><br><span class="line">Database pages     200</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 200, created 0, written 0</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 200, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h5><p>通常数据库中的缓冲池通过LRU（Latest Recent Used）算法来进行管理。InnoDB缓冲池中页的大小默认为16KB，使用LRU算法管理。但对LRU算法做了一些优化，在LRU列表中增加了midpoint位置，新读取到的页放入到LRU列表的midpoint位置。默认配置下，该位置在LRU列表长度的5/8处。可由参数<code>innodb_old_blocks_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p>表示新读取的页插入到LRU列表尾端37%（3/8）的位置，把midpoint之后的列表称为old表，之前的列表称为new列表。引入另一个参数<code>innodb_old_blocks_time</code>进一步管理LRU列表，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 1000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">mysql&gt; set global innodb_old_blocks_time=999;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 999</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>若预估活跃的热点数据不止63%，可以在执行SQL前，通过设置<code>innodb_old_blocks_pct</code>的值减少热点页可能被刷出来的概率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_old_blocks_pct=20;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>LRU列表管理已经读取的页，当数据库刚启动时，LRU列表是空的，此时页存放在Free列表中。从缓冲池中分页时，先从Free列表中查找可用的空闲页，有则从Free列表中删除，放入到LRU列表中，否则根据LRU算法淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p><p>通过<code>show engine innodb status</code>观察LRU列表及Free列表的使用情况和运行状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-24 21:13:11 0x700007d13000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 53 seconds</span><br><span class="line">-----------------</span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Free buffers与Database pages的数量之和可能不等于Buffer pool size，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页。Buffer pool hit rate表示缓冲池命中率，小于95%需要观察是否由于全表扫描引起的LRU列表被污染问题。</p><blockquote><p>该命令显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。<code>Per second averages calculated from the last 53 seconds</code></p></blockquote><p>可通过<code>INNODB_BUFFER_PAGE_LRU</code>来观察每个LRU列表中每个页的具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where space=189;</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| table_name | space | page_number | page_type         |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| NULL       |   189 |           0 | FILE_SPACE_HEADER |</span><br><span class="line">| NULL       |   189 |           1 | IBUF_BITMAP       |</span><br><span class="line">| NULL       |   189 |           2 | INODE             |</span><br><span class="line">| NULL       |   189 |           3 | INDEX             |</span><br><span class="line">| NULL       |   189 |           4 | INDEX             |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br></pre></td></tr></table></figure><p>V1.0.x开始支持压缩页的功能，可将原本16KB的页压缩为1KB、2KB、4KB和8KB，非16KB的页，通过unzip_LRU列表进行管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure><p>LRU中的页包含了unzip_LRU列表中的页。</p><p>unzip_LRU列表中对不同压缩页大小的风进行分别管理，通过伙伴算法进行内存的分配。例如从缓冲池中申请页为4KB的大小，过程为：</p><ul><li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</li><li>若有，直接使用；</li><li>否则检查8KB的unzip_LRU列表；</li><li>若有空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</li><li>否则从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ul><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察unzip_LRU列表中的项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,compressed_size from innodb_buffer_page_lru where compressed_size&lt;&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flu</span><br></pre></td></tr></table></figure><p><code>Modified db pages</code>显示了脏页的数量。</p><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察脏页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where oldest_modification&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p><code>TABLE_NAME</code>为NULL表示该页属于系统表空间。</p></blockquote><h5 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h5><p>InnoDB存储引擎的内存区域除缓冲池外还有重做日志缓存（redo log buffer），InnoDB先将重做日志信息先放入到这个缓冲区，然后按一定的频率将其刷新到重做日志文件，一般每秒都会将重做日志缓冲刷新到日志文件，用户只需保证每秒产生的事务量在这个缓冲大小之内，不需要将其设置的很大。该值可由配置参数innodb_log_buffer_size控制，默认为8M（mac v5.7.22 默认16M）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_log_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_log_buffer_size</span><br><span class="line">        Value: 16777216</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在以下三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p><ul><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件；</li><li>每个事物提交时会将重做日志缓冲刷新到重做日志文件；</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5><p>InnoDB对内存的管理是通过堆内存（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓存（frame buffer）还有对应的缓冲控制对象（buffer control block：记录一些诸如LRU、锁、等待等信息），对象的内存需要从额外内存池中申请。在申请了很大的InnoDB缓冲池时，也应考虑相应地增加额外内存池的大小。</p><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>页的操作首先都是在缓冲池中完成的，若一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本比磁盘的新，数据库将新版本的页从缓冲池刷新到磁盘。</p><p>为避免数据丢失问题，当前事物数据库系统普遍都采用了Write Ahead Log策略，即当事物提交时，先写重做日志，再修改页。当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。事务ACID中D（Durability持久性）的要求。</p><p>Checkpoint（检查点）技术的目的：</p><ul><li>缩短数据库的恢复时间；</li><li>缓冲池不够用时，将脏数据刷新到磁盘；</li><li>重做日志不可用时，刷新脏页。</li></ul><p> 数据库发生宕机时，数据库不需要重做所有的日志，Checkpoint之前的页都已经刷新回磁盘，数据库只需对Checkpoint后的重做日志进行恢复。</p><p> 当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</p><p> 重做日志不可用的情况是因为在当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，这部分可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p> InnoDB存储引擎通过LSN（Log Sequence Number）来标记版本，LSN是8字节数字，单位是字节。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5009487</span><br><span class="line">Log flushed up to   5009487</span><br><span class="line">Pages flushed up to 5009487</span><br><span class="line">Last checkpoint at  5009478</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1。</p><p>数据库运行时在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即指刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p><p>在InnoDB存储引擎中可能发生Fuzzy Checkpoint的情况：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async/Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><p>Master Thread中发生的Checkpoint，每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。过程异步，用户查询线程不会阻塞。</p><p>FLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，在v1.1.x之前检查LRU列表中是否有足够可用空间操作发生在<br>用户查询线程中，会阻塞用户查询操作。若无100个可用空闲页，会将LRU列表尾端的页移除，若其中有脏页，则进行Checkpoint。</p><p>InnoDB v1.2.x（MySQL 5.6）开始检查被放在Page Cleaner Thread中进行，可通过参数<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认1024。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_lru_scan_depth&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_lru_scan_depth</span><br><span class="line">        Value: 1024</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>Async/Sync Flush Checkpoint指的是重做日志不可用的情况下，需要强制将一些页刷新回磁盘，此时脏页是从脏页列表中选取。将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则：</p><blockquote><p>checkpoint_age = redo_lsn - checkpoint_lsn</p><p>async_water_mark = 75% * total_redo_log_file_size</p><p>sync_water_mark = 90% * total_redo_log_file_size</p></blockquote><ul><li>checkpoint_age &lt; async_water_mark，不需要刷新任何脏页到磁盘</li><li>async_water_mark &lt; checkpoint_age &lt; sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark</li><li>checkpoint_age &gt; sync_water_mark很少发生除非设置的重做日志文件太小，在进行类似LOAD DATA的BULK INSETRT操作，触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark。</li></ul><p>Async/Sync Flush Checkpoint保证重做日志循环使用的可用性，v1.2.x之前，Async Flush Checkpoint阻塞发现问题的用户查询线程，Sync Flush Checkpoint阻塞所有用户的查询线程，并且等待脏页刷新的完成。v1.2.x开始，放入到单独的Page Cleaner Thread中。</p><p>MySQL官版不能查看刷新页是从Flush列表中还是从LRU列表中进行Checkpoint的，不知道因为重做日志而产生的Async/Sync Flush的次数。InnoSQL版本可通过命令<code>show engine innodb status</code>来观察。</p><p>Dirty Page too much Checkpoint是因为脏页数量太多，导致InnoDB存储引擎强制进行Checkpoint。目的为了保证缓冲池中有足够可用的页。可由参数<code>innodb_max_dirty_page_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_max_dirty_pages_pct&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_max_dirty_pages_pct</span><br><span class="line">        Value: 75.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>75表示缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分脏页到磁盘，InnoDB v1.0.x之前是90，之后是75。</p><h3 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h3><h4 id="InnoDB-1-0-x之前的Master-Thread"><a href="#InnoDB-1-0-x之前的Master-Thread" class="headerlink" title="InnoDB 1.0.x之前的Master Thread"></a>InnoDB 1.0.x之前的Master Thread</h4><p>具有最高的线程优先级别。内部由多个loop组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。根据数据库运行状态进行切换。</p><p>主循环有两大部分操作——每秒钟的操作和每10秒钟的操作。</p><p>每秒钟的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是），因此再大的事务提交时间也是很短的；</li><li>合并插入缓冲（可能），判断上一秒内发生的IO次数是否小于5次，若小于5次，认为当前的IO压力很小，可以住行合并插入缓冲的操作；</li><li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能），判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认90，代表90%），若超过，认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</li></ul><p>每10秒的操作：</p><ul><li>刷新100个脏页到磁盘（可能的情况下），若过去10秒内磁盘的IO操作小于200次，则认为有足够的磁盘IO能力，将100个脏个刷新到磁盘；</li><li>合并至多5个插入缓冲（总是）；</li><li>将日志缓冲刷新到磁盘（总是）；</li><li>删除无用的undo页（总是），full purge操作，每次最多尝试回收20个undo页，对表进行updae、delete操作时，原行被标记为删除，因一致性读（consistent read）需要保留这些行版本的信息，在full purge过程中，判断当前事务系统中已被删除的行是否可以删除（可能有查询操作需要读取之前版本的undo信息），若可以则立即删除；</li><li>刷新100个或10个脏页到磁盘（总是），判断缓冲池中脏页的比例（buf_get_modified_ratio_pct），若有超过70%的脏页，则刷新100个脏页到磁盘，若小于70%则只刷新10个脏页到磁盘。</li></ul><p>若当前没有用户活动（数据库空闲）或者数据库关闭（shutdown），切换到background loop，执行的操作：</p><ul><li>删除无用的undo页（总是）；</li><li>合并20个插入缓冲（总是）；</li><li>跳回到主循环（总是）；</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</li></ul><p>若flush loop中也无事可做，则切换到suspend_loop，将Master Thread挂起，等待事情的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起状态。</p><h4 id="InnoDB-1-2-x版本之前的Master-Thread"><a href="#InnoDB-1-2-x版本之前的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本之前的Master Thread"></a>InnoDB 1.2.x版本之前的Master Thread</h4><p>v1.0.x对于IO有限制，向磁盘刷新时做了一定的硬编码（刷新数固定值），限制了对磁盘IO的性能，尤其是写入性能。v1.0.x开始提供参数innnodb_io_capacity，用来表示磁盘IO的吞吐量，默认值200，对于刷新到磁盘的页的数量，按照innnodb_io_capacity的百分比来进行控制：</p><ul><li>合并插入缓冲时，合并插入缓冲的数量为innnodb_io_capacity值的5%；</li><li>从缓冲区刷新脏页到时，刷新脏页的数量为innnodb_io_capacity。</li></ul><p>参数innodb_max_dirty_pages_pct默认值为90，当内存很大，或者数据库服务的压力很大，刷新脏页的速度会降低，数据库恢复时需要更多的时间。设置过低时会增加磁盘IO压力。v1.0.x开始，默认值设置为75，和Google测试的最优值80接近。</p><p>引入参数innodb_adaptive_flushing（自适应刷新）。愿刷新规则：大于innodb_max_dirty_pages_pct时，刷新100个脏页， 否则不刷新脏页。引入后通过名为buf_flush_get_desired_flush_rate函数（通过判断产生重做日志redo log的速度来决定最合适的刷新脏页数量）判断需要刷新脏页最合适的数量。当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。</p><p>引入参数innodb_purge_batch_size，控制每次full purge回收的Undo页的数量，之前最多回收20个Undo页，该参数默认值20(用的mysql 5.7.22，默认值300)，可动态地对其进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 300</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; set global innodb_purge_batch_size=320;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 320</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可由命令<code>SHOW ENGINE INNODB STATUS</code>查看当前Master Thread的状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">...</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 2 srv_active, 0 srv_shutdown, 139324 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 139319</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="InnoDB-1-2-x版本的Master-Thread"><a href="#InnoDB-1-2-x版本的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本的Master Thread"></a>InnoDB 1.2.x版本的Master Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if InnoDD is idle</span><br><span class="line">  srv_master_do_idle_tasks(); //每10s的操作</span><br><span class="line">else </span><br><span class="line">  srv_master_do_active_tasks(); //每秒的操作</span><br></pre></td></tr></table></figure><p>刷新脏页的操作，从Master Thread线程分离到单独的Page Cleaner Thread。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>和数据页一样，是物理页的一个组成部分。</p><p>插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取，这类插入操作速度是非常快的。但并不是所有的主键插入都是顺序的，若主键是UUID类，则插入和辅助索引一样，同样是随机的。即使主键是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。</p><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作（在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><p>Insert Buffer的使用需要同时满足两个条件：</p><ul><li>索引是辅助索引（secondary index）；</li><li>索引不是唯一（unique）的。</li></ul><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看插入缓冲的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行：size代表已合并记录页的数量；free list len代表空闲列表的长度；seg size显示当前Insert Buffer的大小为14*16k；merges代表合并的次数。</p><p>写密集情况下，插入缓冲会占用过多的缓冲池内存，默认最大可占用1/2。可通过修改<code>IBUF_POOL_SIZE_PER_MAX_SIZE</code>对插入缓冲的大小进行控制。将其修改为3则最大只能使用1/3的缓冲池内存。</p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p><p>同Insert Buffer，Change Buffer适用的对象依然是非唯一的辅助索引。</p><p>对一条记录进行UPDATE操作可能分为两个过程：</p><ul><li>将记录标记为已删除；</li><li>真正将记录删除。</li></ul><p>Delete Buffer对应操作的第一个过程，Purge Buffer对应操作的第二个过程。通过参数<code>innodb_change_buffering</code>开启各种Buffer的选项，可选：inserts、deletes、purges、changes、all、none。changes表示启用inserts和deletes、all表示启用所有，none表示都不启用。</p><p>通过<code>innodb_change_buffer_max_size</code>来控制Change Buffer最大使用内存的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_change_buffer_max_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_change_buffer_max_size</span><br><span class="line">        Value: 25</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>默认值为25，表示最多使用1/4（25%）的缓冲池内存空间，最大有效值50。</p><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>insert表示Insert Buffer；delete mark表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时无需再将记录合并到辅助索引中。</p><h5 id="Insert-Buffer的内部实现"><a href="#Insert-Buffer的内部实现" class="headerlink" title="Insert Buffer的内部实现"></a>Insert Buffer的内部实现</h5><p>Insert Buffer的数据结构是一棵B+树，MySQL v4.1前每张表有一棵Insert Buffer B+树，现版本全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。存放在共享表空间中，默认ibdata1中。在试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败，因为表的辅助索引中的数据可能还在Insert Buffer中，即共享表空间中。</p><p>Insert Buffer非叶节点存放查询的search key（键值）。</p><p>search key一共占用9个字节，space表示待插入记录所在表的表空间id，InnoDB存储引擎中每个表有一个唯一的space id，可通过space id查询得知是哪张表。space占用4字节。marker占用1字节，用于兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。</p><p>当辅助索引要插入到页（space，offset）时，若页不在缓冲池中，则首先根据上述规则构造一个search key，然后查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。<br>插入到Insert Buffer B+树叶子节点的记录，需要根据规则进行构造。</p><blockquote><p>space | marker | offset | metadata |{ secondary index record}|</p></blockquote><p>metadata占用4字节，存储内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">字节 </th></tr></thead><tbody><tr><td style="text-align:center">IBUF_REC_OFFSET_COUNT</td><td style="text-align:center">2 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_TYPE</td><td style="text-align:center">1 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_FLAGS</td><td style="text-align:center">1  </td></tr></tbody></table><p>IBUF_REC_OFFSET_COUNT保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。第五列开始是实际插入记录的各个字段。</p><p>启用Insert Buffer索引后，辅助索引页中的记录可能被插入到Insert Buffer B+树中，为保证每次Merge Insert Buffer页必须成功，需要特殊页用来标记每个辅助索引页（sapce，page_no）的可用空间。该页类型为Insert Buffer Bitamp。</p><p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）。每个Insert Buffer Bitmap页在16384个页的第二个页中。</p><p>每个辅助索引页在Insert Buffer Bitmap页中占用4位，由三部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">IBUF_BITMAP_FREE</td><td style="text-align:center">2</td><td style="text-align:center">表示该辅助索引页中的可用空间数量，可取值0，1，2，3。0表示无可用剩余空间；1表示剩余空间大于1/32页（512字节）</td></tr><tr><td style="text-align:center">IBUF_BITMAP_BUFFERED</td><td style="text-align:center">1</td><td style="text-align:center">1表示该辅助索引页有记录被缓存在Insert Buffer B+树中</td></tr><tr><td style="text-align:center">IBUF_BITMAP_IBUF</td><td style="text-align:center">1</td><td style="text-align:center">1表示该页为Insert Buffer B+树的索引页</td></tr></tbody></table><h5 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h5><p>Merge Insert Buffer的操作发生在：</p><ul><li>辅助索引页被读取到缓冲池时，例如执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中，若有则将Insert Buffer B+树中该页的记录插入到该辅助索引页中；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时，若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则强制进行一个合并操作（强制读取辅助索引页），将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中；</li><li>Master Thread，每秒和每10秒进行一次的Merger Insert Buffer操作。</li></ul><p>Mater Thread根据<code>srv_innodb_io_capactity</code>的百分比来决定真正要合并多少个辅助索引页。</p><p>Insert Buffer B+ Tree中，辅助索引页根据（space，offset）都已排序好，根据（space，offset）的排序顺序进行页的选择。</p><h4 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h4><p>doublewrite保障InnoDB存储引擎数据页的可靠性。</p><p>若发生写失效，可以通过重做日志进行恢复，但重做日志记录的是对页的物理操作，若页本身已损坏，则再对其重做是无意义的。在应用重做日志之前，需要一个页的副本，当写失效发生时，先通过页的副本还原页，在进行重做，即doublewrite。</p><p>doublewrite由两部分组成：内存中的doublewrite buffer，大小为2MB；物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小为2MB。</p><p>在对缓冲池的脏页进行刷行时，并不直接写磁盘，会先通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。因为doublewrite页连续，过程是顺序写的，开销不大。完成doublewrite页的写入后，再将doublewrite buufer中的页写入各个表空间文件中，此时写入则是离散的，</p><p>通过<code>SHOW GLOBAL STATUS LIKE &#39;innodb_dblwr%&#39;</code>观察doublewrite的运行情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;innodb_dblwr%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 269936</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 26401</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>表示一共写了269936个页，实际写入次数26401，<code>Innodb_dblwr_pages_written:Innodb_dblwr_writes</code>比例10:1。若系统高峰时远小于64:1，说明系统写入压力不是很高。</p><p>若操作系统在写入磁盘过程发生崩溃，在恢复时InnoDB先从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p><p>通过命令<code>SHOW BLOBAL STATUS like &#39;Innodb_buffer_pool_pages_flushed&#39;</code>查看当前从缓冲池中刷新到磁盘页的数量。该变量和<code>Innodb_dblwr_pages_written</code>一致。MySQL 5.5.24版本之前，<code>Innodb_buffer_pool_pages_flushed</code>总是<code>Innodb_dblwr_pages_written</code>的2倍，之后才被修复，统计数据库在生产环境中写入的量，最安全的方法是根据<code>Innodb_dblwr_pages_written</code>来进行统计。</p><p>参数<code>skip_innnodb_doublewrite</code>可以禁用doublewrite功能，可能发生写失效问题，若有多个从服务器（slave server），需要提供较快的性能（在slave server上做RAID0），启用该参数是一个办法。对于需要提供数据高可用性的主服务器（master server），任何时候都应确保开启doublewrite功能。</p><p>有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统，可不用开启doublewrite。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希一般查找的时间复杂度为O(1)，B+ Tree的查找次数取决于B+ tree的高度，一般为3～4层。</p><p>InnoDB会监控对表上各索引页的查询，若观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI通过缓冲池的B+ tree构建而来，建立的速度很快，不需要对整张表构建哈希索引。InnoDB会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><p>AHI要求这个页的连续访问模式必须是一样的。如对（a，b）这样的联合索引页，访问模式可以是：</p><ul><li>WHERE a=xxx</li><li>WHERE a=xxx and b=xxx</li></ul><p>访问模式指查询条件一样，若交替上述两种查询，则不会对该页构造AHI。AHI还要求：</p><ul><li>以该模式访问了100次</li><li>页通过该模式访问了N次，其中N=页中记录*1/16</li></ul><p>启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。其为数据库自由化，可通过命令<code>SHOW ENGINE INNODB STATUS</code>查看当前AHI的使用状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 347 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1702, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">1.04 hash searches/s, 4.33 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询，如SELECT * FROM table WHERE index_col=’xxx’。其他如范围查找不能使用哈希索引。通过hash searches:non-hash searches可以了解使用哈希索引后的效率。</p><p>可通过<code>SHOW ENGINE INNODB STATUS</code>的结果及参数<code>innodb_adaptive_hash_index</code>来考虑是禁用或启动，默认AHI开启。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>用户发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，AIO。AIO可以进行IO Merge操作。</p><p>Linux通过<code>iostat</code>动态监视系统的磁盘操作活动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[work~]$ iostat -x</span><br><span class="line">Linux 2.6.32-754.9.1.el6.x86_64 08/16/2019 _x86_64_(8 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">          18.99    0.00   16.12    1.36    0.00   63.53</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.08     7.78    0.29    4.19    16.15    93.35    24.46     0.01    2.39    4.96    2.22   0.94   0.42</span><br><span class="line">vdb               4.07   405.85   10.49    7.69  2980.62  3309.01   345.87     0.72   39.40   26.06   57.61   2.08   3.78</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>InnoDB v1.1.x前，AIO通过InnoDB存储引擎中的代码来模拟实现，v1.1.x开始提供了内核级别AIO的支持，Native AIO，依赖libaio库。Native AIO需要操作系统提供支持，Win OS和Linux OS都提供Native AIO支持，Mac OSX未提供，只能使用原模拟的方式。</p><p>参数<code>innodb_use_native_aio</code>用来控制是否启用Native AIO，Linux OS下默认为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Mac OS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>InnoDB中read ahead方式的读取都是AIO完成，脏页的刷新也是通过AIO完成。</p><h4 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h4><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，若是脏页，则一起进行刷新。通过将多个IO写入操作合并为一个IO操作，在传统机械磁盘下有着显著优势。</p><p>需要考虑：</p><ul><li>将不怎么脏的页进行了写入，该页之后又会很快变成脏页；</li><li>固态硬盘有着较高的IOPS，是否需要该特性。</li></ul><p>所以从v 1.2.x版本开始提供了参数<code>innodb_flush_neighbors</code>，用来控制是否启用该特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_flush_neighbors&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_flush_neighbors</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="启动、关闭与恢复"><a href="#启动、关闭与恢复" class="headerlink" title="启动、关闭与恢复"></a>启动、关闭与恢复</h3><p>MySQL实例在启动过程中对InnoDB存储引擎的处理过程。</p><p>关闭时，参数<code>innodb_fast_shutdown</code>影响着表的存储引擎为InnoDB的行为。该参数可取0，1，2。默认1。</p><ul><li>0：在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。需要一些时间，在进行InnoDB升级时，必须将此参数设置为0，然后关闭数据库。</li><li>1:表示不需要完成full purge和merge insert buffer操作，但是缓冲池中的一些数据脏页还是会刷新回磁盘。</li><li>2:表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志写入日志文件。不会有事务的丢失，在下次MySQL数据库启动时，会进行恢复操作。</li></ul><p>若没有正常的关闭数据库，例如使用kill命令关闭数据库、MySQL运行中重启服务器，或者关闭数据库时将参数<code>innodb_fast_shutdown</code>设为2，下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数<code>innodb_force_recovery</code>影响整个InnoDB存储引擎恢复的状况，默认为0，代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机，并把错误写入错误日志。还可以设置6个非零值，大的数字表示包含了前面所有小数字表示的影响：</p><ul><li>1（SRV_FORCE_IGNORE_CORRUPT）：忽略检查到的corrupt页。</li><li>2（SRV_FORCE_NO_BACKGROUND）：阻止Master Thread线程的运行，如Master Thread线程需要进行full merge操作，会导致crash。</li><li>3（SRV_FORCE_NO_TRX_UNDO）：不进行事务的回滚操作。</li><li>4（SRV_FORCE_NO_IBUF_MERGE）：不进行插入缓冲的合并操作。</li><li>5（SRV_FORCE_NO_UNDO_LOG_SCAN）：不查看撤销日志（Undo Log），将未提交的事务视为已提交。</li><li>6（SRV_FORCE_NO_LOG_SCAN）：不进行前滚的操作。</li></ul><p>在设置了<code>innodb_force_recovery</code>大于0后，可进行select、create和drop操作，但insert、update和delete操作是不允许的。（修改表涉及到脏页的刷新、undo log等）</p><p>START TRANSACTION语句开启了事务，防止了自动提交的发生，UPDATE操作会产生大量的UNDO日志。人为通过kill命令杀掉MySQL数据库，下次MySQL数据库启动会对之前的UPDATE事务进行回滚操作，这些信息会记录在错误日志文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。&lt;/p&gt;
&lt;h3 id=&quot;InnoDB体系架构&quot;&gt;&lt;a href=&quot;#InnoDB体系架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系架构&quot;&gt;&lt;/a&gt;Inno
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
      <category term="innodb" scheme="bighua.top/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构和存储引擎</title>
    <link href="bighua.top/2019/01/10/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>bighua.top/2019/01/10/MySQL体系结构和存储引擎/</id>
    <published>2019-01-10T09:07:34.000Z</published>
    <updated>2019-01-15T07:27:51.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h3><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>实例：MySQL数据库由后台线程以及一个共享内存区组成。</li></ul><p>MySQL设计为单进程多线程架构，数据库实例在系统上表现为一个进程。</p><p>启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例，没有配置文件时，按照编译时的默认参数设置启动实例。使用<code>mysql --help | grep my.cnf</code>查看启动时从哪些位置查找配置文件。当几个配置文件都有同一个参数，MySQL数据库以读取到的最后一个配置文件中的参数为准。</p><p>配置文件参数<code>datadir</code>指定了数据库所在的路径。linux操作系统下默认为<code>/usr/local/mysql/data</code>，该路径只是一个链接，指向<code>/opt/mysql_data</code>目录，必须保证该目录的用户和权限使mysql用户和组可以访问。</p><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>MySQL组成部分：  </p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（cache）组件</li><li>插件式存储引擎</li><li><p>物理文件</p><p>区别于其他数据库的重要特点是插件式的表存储引擎。MySQL插件式存储引擎架构提供一系列标准的管理和服务支持，这些标准与存储引擎本身无关，存储引擎是底层物理结构的实现。存储引擎是基于表的，而不是数据库。</p></li></ul><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。用户可以根据MySQL预定义的存储引擎接口编写自己的存储引擎。</p><p>通过<code>SHOW ENGINES</code>语句或者通过查找<code>information_schema</code>架构下的ENGINES表，查看当前使用的MySQL数据库所支持的存储引擎。</p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，设计目标面向在线事务处理的应用。行锁设计、支持外键，支持类似Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB存储引擎将数据放在一个逻辑的表空间中，表空间由InnoDB存储引擎自身进行管理。每个InnoDB存储引擎的表单独存放到一个ibd文件中。InnoDB存储引擎支持用裸设备（row disk）来建立其表空间。</p><p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发，实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。使用被称为next-key locking策略避免幻读现象的产生。还提供了插入缓存（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p><p>InnoDB存储引擎采用聚集（clustered）的方式存储表中的数据，每张表的存储都是按主键的顺序进行存放。当没有显示的指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务，支持全文索引，表锁设计，主要面向一些OLAP数据库应用。MyISAM存储引擎的缓冲池只缓存索引文件，而不缓存数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用<code>myisampack</code>工具进一步压缩数据文件，因myisampack工具使用哈夫曼编码静态算法来压缩数据，所以压缩后的表是只读的，也可以使用myisampack工具解压数据文件。</p><p>V5.0前MyISAM默认支持的表大小为4GB，制定MAX_ROWS和AVG_ROW_LENGTH属性拓展为大于4GB的表。V5.0及以后，默认支持256TB的表单数据。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。</p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -h 127.0.0.1 -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>通过TCP/IP连接到MySQL实例时，MySQL会先检查一张权限视图，判断发起请求的客户端IP是否允许连接到MySQL实例。视图在mysql结构下，表名为<code>user</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show columns from user;</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</span><br><span class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Insert_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Update_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Delete_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Drop_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Reload_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Shutdown_priv          | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Process_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| File_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Grant_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| References_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Index_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_db_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Super_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tmp_table_priv  | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Lock_tables_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Execute_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_slave_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_client_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_view_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_view_priv         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_routine_priv    | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_routine_priv     | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_user_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Event_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Trigger_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| ssl_type               | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO   |     |                       |       |</span><br><span class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</span><br><span class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</span><br><span class="line">| password_expired       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</span><br><span class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</span><br><span class="line">| account_locked         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">45 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host,user,password_expired FROM user;</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| host      | user          | password_expired |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| localhost | root          | N                |</span><br><span class="line">| localhost | mysql.session | N                |</span><br><span class="line">| localhost | mysql.sys     | N                |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h4><p>Win 2000、Win XP、Win 2003和Win Vista以及在此之上的平台，若两个需要进程通信的进程在同一台服务器上，可以使用命名管道。MySQL数据库须在配置文件中启用–enable-named-pipe。V4.1后提供共享内存的连接方式，须在配置文件中添加–shared-memory，在连接时客户端还必须使用–protocol=memory选项。</p><h4 id="UNIX套接字"><a href="#UNIX套接字" class="headerlink" title="UNIX套接字"></a>UNIX套接字</h4><p>Linux和UNIX环境下，可以使用UNIX域套接字，因其非网络协议，只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径<code>--socket=/tmp/mysql.sock</code>。</p><p>查询UNIX域套接字文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;socket&apos;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| socket        | /tmp/mysql.sock |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用UNIX域套接字方式进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -uroot -S /tmp/mysql.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义数据库和实例&quot;&gt;&lt;a href=&quot;#定义数据库和实例&quot; class=&quot;headerlink&quot; title=&quot;定义数据库和实例&quot;&gt;&lt;/a&gt;定义数据库和实例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库：物理操作系统文件或其他形式文件类型的集合。&lt;/li&gt;
&lt;li&gt;实例：My
      
    
    </summary>
    
      <category term="MySQL技术内幕-InnoDB存储引擎" scheme="bighua.top/categories/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="mysql" scheme="bighua.top/tags/mysql/"/>
    
      <category term="note" scheme="bighua.top/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战笔记</title>
    <link href="bighua.top/2018/11/19/Netty%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>bighua.top/2018/11/19/Netty实战笔记/</id>
    <published>2018-11-19T06:30:29.000Z</published>
    <updated>2018-11-19T06:35:14.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写Echo服务器"><a href="#编写Echo服务器" class="headerlink" title="编写Echo服务器"></a>编写Echo服务器</h2><h3 id="ChannelHandler和业务逻辑"><a href="#ChannelHandler和业务逻辑" class="headerlink" title="ChannelHandler和业务逻辑"></a>ChannelHandler和业务逻辑</h3><p>响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编写Echo服务器&quot;&gt;&lt;a href=&quot;#编写Echo服务器&quot; class=&quot;headerlink&quot; title=&quot;编写Echo服务器&quot;&gt;&lt;/a&gt;编写Echo服务器&lt;/h2&gt;&lt;h3 id=&quot;ChannelHandler和业务逻辑&quot;&gt;&lt;a href=&quot;#Channe
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>世事无常</title>
    <link href="bighua.top/2018/11/04/%E4%B8%96%E4%BA%8B%E6%97%A0%E5%B8%B8/"/>
    <id>bighua.top/2018/11/04/世事无常/</id>
    <published>2018-11-04T12:54:26.000Z</published>
    <updated>2019-03-31T15:20:05.855Z</updated>
    
    <content type="html"><![CDATA[<p>记2018-11-04，悼念三叔！</p><p>总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无常的世界，然后一点一点平息自己的思绪，使自己接受现实，最后慢慢的消化在内心，做到不外露一点情绪！</p><p>我不敢想象老家没有你了会是怎样，高三的堂弟、初入社会心思单纯的堂妹、年迈的爷爷、指望不上的大爹家，远离老家很多事帮不上忙的我们，以后三婶在老家要承担怎样的重担渡过这些日子，想想就揪心。</p><p>如果可以在身边选择一个最适合父亲的角色，我觉得是你。只有你最关注子辈的内心，在意孩子的想法，注重子辈多方面的培养教育。对比常年在外打工只给予我生活费关怀的老爸，可以说是你，在我心目中对父亲的角色有了该有的模样。对堂弟寄予厚望的你，怎么忍心被这次意外带走，还有好多次成绩没向你汇报、还没为他操心高考后的学校和专业、还没同意他找女朋友呢…</p><p>还想着以后能再回老家过元宵节，再跟着你去认祖坟送亮；过春节中午在我家吃，然后去你家吃年夜饭；跟着你去拜年走亲戚，去看斗地主炸金花；跟着你去山里伐几颗松树用作冬天取暖的柴火，然后交给我一颗小的背回家；跟着你学习人生经验，如何处理好人和事…可是这以后都没有了，都停留在回忆里了。</p><p>中午收到老爸发过来的消息，震惊意外，不敢相信。大姐打过来的视频，猜到肯定是为了此事，不愿意接听，宁愿今天是做了一个梦，而我还没醒。直到晚上二姐多次挂过来视频，才交谈起此事，聊起话题一想起这个事实，鼻子不由自主的酸楚。</p><p>记得13年秋，我高三时，突然接到通知家里有事，在回家的车上，虽然没有任何人告知我发生了什么，但我知道肯定是我某个亲人不在了，心中异常忐忑，眼泪止不住的流。直到车停在家门口，看到一个个花圈，搭起的灵台，奶奶的遗像，此时声音也控制不住了，眼泪也肆无忌惮起来。如今是你，还有很多的事情等着你去解决去承担，怎么舍得离去，我不敢相信，也不能接受…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记2018-11-04，悼念三叔！&lt;/p&gt;
&lt;p&gt;总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无
      
    
    </summary>
    
      <category term="随笔" scheme="bighua.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="天堂安好" scheme="bighua.top/tags/%E5%A4%A9%E5%A0%82%E5%AE%89%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>Netty的核心组件</title>
    <link href="bighua.top/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>bighua.top/2018/11/02/Netty的核心组件/</id>
    <published>2018-11-02T06:42:46.000Z</published>
    <updated>2018-11-19T06:31:51.902Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《netty实战》，初识netty的一些笔记。</p><p>异步、事件驱动。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Java NIO的一个基本构造。</p><blockquote><p>代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。</p></blockquote><p>可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>一个指向已经被提供给另一个方法的方法的引用。使得后者可以调用前者。</p><p>Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interface ChannelHandler的实现处理。</p><p>当一个新的连接已经被建立，ChannelHandler的channelActive()回调方法将会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>提供了另一种在操作完成时通知应用程序的方式。可以看作是一个异步操作的结果的占位符；将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK预置的interface java.util.concurrent.Future提供的实现只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供额外的方法，使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个Netty的出站I/O操作都将返回一个ChannelFuture，它们都不会阻塞。</p><p>ChannelFuture作为一个I/O操作的一部分返回。connect()方法将会直接返回，而不会阻塞，调用将会在后台完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"></span><br><span class="line">ChannelFuture future = Channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));</span><br></pre></td></tr></table></figure><p>利用ChannelFutureListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));异步连接到远程节点</span><br><span class="line">future.addListener(new ChannelFutureListener() &#123;//注册一个ChannelFutureListener，在操作完成时获得通知</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;//检查操作的状态</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="事件和ChannelHandler"><a href="#事件和ChannelHandler" class="headerlink" title="事件和ChannelHandler"></a>事件和ChannelHandler</h4><p>Netty使用不同的事件来通知状态的改变或者是操作的状态。能够基于已经发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据流转换；</li><li>流控制；</li><li>应用程序逻辑。</li></ul><p>Netty的事件是按照它们与入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：</p><ul><li>连接已被激活或者连接失活；</li><li>数据读取；</li><li>用户事件；</li><li>错误事件。</li></ul><p>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：</p><ul><li>打开或者关闭到远程节点的连接；</li><li>将数据写到或者冲刷到套接字。</li></ul><p>每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法（将事件驱动范式直接转换为应用程序构件块）。</p><p> Netty的ChannelHandler为处理器提供了基本的抽象。每个ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="Future、回调和ChannelHandler"><a href="#Future、回调和ChannelHandler" class="headerlink" title="Future、回调和ChannelHandler"></a>Future、回调和ChannelHandler</h4><p>Netty异步编程模型建立在Future和回调之上，将事件派发到ChannelHandler的方法发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，需要提供回调或者利用操作所返回的Future。</p><h4 id="选择器、事件和EventLoop"><a href="#选择器、事件和EventLoop" class="headerlink" title="选择器、事件和EventLoop"></a>选择器、事件和EventLoop</h4><p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来将需要手动编写的派发代码。在内部，会为每个Channel分配一个EventLoop，用以处理所有事件，包括：</p><ul><li>注册感兴趣的事件；</li><li>将事件派发给ChannelHandler；</li><li>安排进一步的动作。</li></ul><p>EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。此设计消除了可能有的在ChannelHandler实现中需要进行同步的任何顾虑，只需专注于提供正确的逻辑，用来在感兴趣的数据要处理的时候执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读《netty实战》，初识netty的一些笔记。&lt;/p&gt;
&lt;p&gt;异步、事件驱动。&lt;/p&gt;
&lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Channel
      
    
    </summary>
    
      <category term="netty" scheme="bighua.top/categories/netty/"/>
    
    
      <category term="笔记" scheme="bighua.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="bighua.top/tags/java/"/>
    
      <category term="netty" scheme="bighua.top/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>web服务</title>
    <link href="bighua.top/2018/10/12/web%E6%9C%8D%E5%8A%A1/"/>
    <id>bighua.top/2018/10/12/web服务/</id>
    <published>2018-10-12T06:41:00.000Z</published>
    <updated>2019-03-31T15:20:08.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h3><blockquote><p>一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互操作机器间交互提供支持。每个web服务都拥有一套自己的接口，由一种名为Web服务描述语言的机器可处理格式描述。其他系统需要根据Web服务的描述，适用SOAP消息与Web服务交互。SOAP消息常被序列化为XML并通过HTTP传输。</p></blockquote><p>存在着多种不同类型的Web服务，其中包括基于SOAP的、基于REST的以及基于XML-RPC的，基于REST的和基于SOAP的Web服务最为流行。企业级系统大多数都是基于SOAP的Web服务实现，公开可访问的Web服务更青睐基于REST的Web服务。</p><p>基于SOAP的Web服务由功能驱动，基于REST的Web服务由数据驱动。基于SOAP的Web服务往往是RPC风格；基于REST的Web服务关注的是资源，HTTP方法是对这些资源执行操作的动词。</p><h3 id="基于SOAP的Web服务"><a href="#基于SOAP的Web服务" class="headerlink" title="基于SOAP的Web服务"></a>基于SOAP的Web服务</h3><p>SOAP（Simple Object Access Protocol：简单对象访问协议）是一种协议，用于交换定义在XML里面的结构化数据。能够跨越不同的网络协议并在不同的编程模式中使用，其处理的并不是对象，已经不再代表Simple Object Access Protocol。</p><p>SOAP高度结构化，需要严格地进行定义，用于传输数据的XML可能会变的非常复杂。WSDL是客户端与服务器之间的契约，定义了服务提供的功能以及提供这些功能的方式，服务的每个操作以及输入/输出都需要由WSDL明确地定义。</p><p>SOAP将报文内容放入到信封里面，信封相当于一个运输容器，并且它还能够独立于实际的数据传输方式存在。</p><p>经过简化的SOAP请求报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /GetComment HTTP/1.1</span><br><span class="line">Host: www.chitchatcom</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.chitchat.com/forum&quot;&gt;</span><br><span class="line">&lt;m:GetCommentRequest&gt;</span><br><span class="line">&lt;m:CommentId&gt;123&lt;/m:CommentID&gt;</span><br><span class="line">&lt;/m:GetCommentRequest&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>简化后的SOAP响应报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3/org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">&lt;m:GetCommentResponse&gt;</span><br><span class="line">&lt;m:Text&gt;Hello World!&lt;/m:Text&gt;</span><br><span class="line">&lt;/m:GetCommentResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:envelope&gt;</span><br></pre></td></tr></table></figure><p>SOAP 1.2允许通过HTTP的Get方法发送SOAP报文，但大多数基于SOAP的Web服务都是通过HTTP的POST方法发送SOAP报文的。</p><p>一个基于SOAP的Web服务越复杂，对应的WSDL报文就越冗长。实际中SOAP请求报文通常会由WSDL生成的SOAP客户端负责生成，SOAP响应报文通常也是由WSDL生成的SOAP服务器负责生成。</p><h3 id="基于REST的Web服务"><a href="#基于REST的Web服务" class="headerlink" title="基于REST的Web服务"></a>基于REST的Web服务</h3><p>REST（Representational State transfer，具象状态传输）是一种设计理念，用于设计通过标准的几个动作来操纵资源，并以此来进行互相交流的程序（将操纵资源的动作称为“动词”，即verb）。</p><p>REST并不把函数暴露为可调用的服务，而是以资源（resource）的名义把模型暴露出来，允许通过少数几个称为动词的动作来操纵这些资源。</p><p>使用HTTP协议实现REST服务，URL将用于表示资源，HTTP方法则会用作操纵资源的动词。如表所示：</p><table><thead><tr><th style="text-align:left">HTTP方法</th><th style="text-align:left">作用</th><th style="text-align:left">使用实例</th></tr></thead><tbody><tr><td style="text-align:left">POST</td><td style="text-align:left">在一项资源尚未存在的情况下创建该资源</td><td style="text-align:left">POST /users</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">获取一项资源</td><td style="text-align:left">GET /users/1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">重新给定URL上的资源</td><td style="text-align:left">PUT /users/1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除一项资源</td><td style="text-align:left">DELETE /users/1</td></tr></tbody></table><p>POST和PUT的区别在于，PUT需要准确地知道哪一项资源将会被替换，使用POST只会创建出一项新资源以及一个新的URL。POST用于创建一项全新的资源，PUT用于替换一项已经存在的资源。</p><p>REST不经只能通过这几个HTTP方法实现，如可以使用PATCH方法对一项资源进行部分更新。使用REST API的时候通常都是返回JSON，或者返回一些比SOAP报文要简单得多的XML，很少返回SOAP报文。</p><p>基于REST的Web服务也拥有相应的WADL（Web Applicaton Description Language，Web应用描述语言），可以对基于REST的Web服务进行描述，能够生成访问这些服务的客户端。</p><p>REST设计理念适用于只执行简单的CURD操作的应用，适用于更为复杂的服务可以通过如下两个方法对过程或者动作进行建模。</p><h4 id="将动作转化为资源"><a href="#将动作转化为资源" class="headerlink" title="将动作转化为资源"></a>将动作转化为资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /user/123/activation HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;data&quot;:&quot;2018-10-13T17:12:12Z&quot; &#125;</span><br></pre></td></tr></table></figure><p>将创建一个被激活的资源（activation resource），表示用户的激活状态，可以为激活的资源添加额外的属性。</p><h4 id="将动作转换为资源的属性"><a href="#将动作转换为资源的属性" class="headerlink" title="将动作转换为资源的属性"></a>将动作转换为资源的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH /user/123 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;active&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>把用户的active属性设置为true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web服务&quot;&gt;&lt;a href=&quot;#web服务&quot; class=&quot;headerlink&quot; title=&quot;web服务&quot;&gt;&lt;/a&gt;web服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="web服务" scheme="bighua.top/tags/web%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOAP" scheme="bighua.top/tags/SOAP/"/>
    
      <category term="REST" scheme="bighua.top/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>jenkins初探</title>
    <link href="bighua.top/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/"/>
    <id>bighua.top/2018/10/08/jenkins初探/</id>
    <published>2018-10-08T11:33:45.000Z</published>
    <updated>2018-10-30T11:56:56.982Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档<a href="https://www.kancloud.cn/louis1986/jenkins/481896" target="_blank" rel="noopener">Jenkins学习文档</a>，<a href="https://blog.csdn.net/sms15732621690/article/details/71336224" target="_blank" rel="noopener">CentOS7Jenkins安装</a></p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget http://soft.51yuki.cn/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo vim /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_131/</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib.tools.jar</span><br><span class="line">PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  sudo sh /etc/profile.d/jdk.sh</span><br><span class="line">[wuhua@VM_0_10_centos local]$ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>浏览器中输入<code>ip:8080</code></p><p>获取登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>参考<a href="https://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文档&lt;a href=&quot;https://www.kancloud.cn/louis1986/jenkins/481896&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins学习文档&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
      <category term="web杂记" scheme="bighua.top/categories/web%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="持续集成" scheme="bighua.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="jenkins" scheme="bighua.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>redis-整数集合</title>
    <link href="bighua.top/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>bighua.top/2018/09/13/redis-整数集合/</id>
    <published>2018-09-13T13:42:03.000Z</published>
    <updated>2019-09-16T12:05:51.438Z</updated>
    
    <content type="html"><![CDATA[<p>是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>是redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>由intset.h/intset结构表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">unint32_t encoding;//编码方式</span><br><span class="line">unint32_t length;//集合包含的元素数量</span><br><span class="line">int8_t contents[];//保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，数组中各项按值从小到大排列，且数组中不包含重复项。</p><p>length属性记录整数集合包含的元素数量，即contents数组的长度。</p><p>contents数组的真正类型取决于encoding属性的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * intset 的编码方式</span><br><span class="line"> */</span><br><span class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</span><br></pre></td></tr></table></figure><p>根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>将新元素添加到整数集合里面且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后将新元素添加到整数集合里面。</p><p>升级过程：</p><ul><li>根据新元素的类型，拓展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置上，在放置的过程中维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组中。</li></ul><p>引发升级的新元素的长度总是比整数集合现在所有元素的长度都大，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。前者将新元素放置在底层数组的最开头（索引0），后者将新元素放置在底层数组的最末尾（索引length-1）。</p><blockquote><p>升级策略能提升整数集合的灵活性，尽可能地节约内存。</p></blockquote><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><p>整数集合操作API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">intsetNew</td><td style="text-align:left">创建一个新的压缩列表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetAdd</td><td style="text-align:left">将给定元素添加到整数集合里</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetRemove</td><td style="text-align:left">从整数集合中移除给定元素</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetFind</td><td style="text-align:left">检查给定值是否存在于集合</td><td style="text-align:left">O(logN)，二分查找法</td></tr><tr><td style="text-align:left">intsetRandom</td><td style="text-align:left">从整数集合中随机返回一个元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetGet</td><td style="text-align:left">取出底层数组在给定索引上的元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetLen</td><td style="text-align:left">返回整数集合包含的元素的个数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetBlobLen</td><td style="text-align:left">返回整数集合占用的内存字节数</td><td style="text-align:left">O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;
      
    
    </summary>
    
      <category term="redis" scheme="bighua.top/categories/redis/"/>
    
    
      <category term="redis" scheme="bighua.top/tags/redis/"/>
    
      <category term="intset" scheme="bighua.top/tags/intset/"/>
    
  </entry>
  
</feed>
