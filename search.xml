<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Golang学习笔记-语法基础篇(三)</title>
      <link href="/2018/04/12/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/"/>
      <url>/2018/04/12/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="数据的使用"><a href="#数据的使用" class="headerlink" title="数据的使用"></a>数据的使用</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>若值x可以被赋给类型为T的变量，则：</p><ul><li>值x的类型是T。</li><li>值x的类型是V，V和T具有相同的潜在类型，V和T至少有一个是未命名的类型。</li><li>类型T是一个接口类型，值x的类型实现了T。</li><li>值x是一个双向通道类型的值，T是一个通道类型。</li><li>值x是预定义标识符nil，可赋给切片、字典、函数、接口、指针、通道等类型的变量。</li><li>值x是一个由某个数据类型的值代表的无类型的常量，可以被赋给该数据类型的变量。</li><li>所有值都可以赋给空标识符“_”。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ints = []int&#123;1, 2, 3&#125;</span><br><span class="line">ints[1], ints[2] = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], _ = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], ints[2] = (ints[1] * (ints[0] + 1)), (ints[2] * (ints[0] + 2))</span><br><span class="line">i1 += 1 //i1 = i1 + 2</span><br><span class="line">i2 &amp;= 2 &lt;&lt; 3 //i2 = i2 &amp; (2&lt;&lt;3)</span><br></pre></td></tr></table></figure><p>“=”两边的表达式的数量不相等，左边可以有多个，对于右边的唯一表达式有：  </p><ul><li>表达式是一个调用会返回多个结果的函数或者方法的表达式。</li><li>表达式是一个应用于字典之上的索引表达式。v, ok := map[“k”]。</li><li>表达式是一个类型断言表达式。v, ok ：= x.(string)。</li><li>表达式是一个由接收操作符和通道类型值组成的表达式。v,ok := &lt;-ch。  </li></ul><p>除此之外赋值操作符两边的表达式数量必须一致，并都都是单值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">s := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</span><br><span class="line">i,s[i-1] = 2, &quot;Z&quot;</span><br></pre></td></tr></table></figure></p><p>s值是[]string{“Z”, “B”, “C”}而不是[]string{“A”, “Z”, “C”}，对表达式i-1的求值先于赋值，在赋值之前，第二个赋值对象被确定为s[0]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a             //交换变量值</span><br><span class="line">x := []int&#123;1, 2, 3&#125;     //切片初始化</span><br><span class="line">x[0], x[0] = 1, 2       //从做到有执行最终x[0=2</span><br><span class="line">x[2], x[3] = 4, 5       //索引超范围引发恐慌，但x[2]=4已被变更</span><br></pre></td></tr></table></figure></p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>某量保持不变称为常量，否则称为变量。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量在编译期间被创建，作为局部变量被定义在函数内部，由字面量或常量表达式赋值。<br>分为布尔常量、rune常量（字符常量）、整数常量、浮点数常量、复数常量和字符串常量。<br>常量可以是有类型的也可以是无类型，可以被显式地给定类型，也可以被隐含地给定类型。  </p><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><p>仅以常量作为操作数的表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 + 3.0         //无类型的浮点数常量5.0</span><br><span class="line">15 / 4.0        //无类型的浮点数常量3.75</span><br><span class="line">&apos;w&apos; + 1         //无类型的rune常量&apos;x&apos;</span><br><span class="line">---</span><br><span class="line">1 &lt;&lt; 3.0        //无类型整数常量8</span><br><span class="line">1.0 &lt;&lt;3         //无类型整数常量8</span><br><span class="line">1 &lt;&lt; 100        //无类型的整数常量1267650600228229401496703205376超出范围</span><br><span class="line">---</span><br><span class="line">&quot;A&quot; &gt; &quot;C&quot;       //无类型的布尔常量false</span><br></pre></td></tr></table></figure></p><h5 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h5><p>使用关键字const将字面常量或常量表达式与标识符绑定在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const untypedConstant = 10.0    //无类型常量</span><br><span class="line">const typedConstant int64 = 1024  //类型为int64的常量</span><br><span class="line"></span><br><span class="line">const tc1, tc2, tc3 int64 = 1024, -10, 88 //平行赋值</span><br></pre></td></tr></table></figure></p><p>左侧只允许插入一个类型字面量，规定作则标识符的类型，右侧的常量类型需与其一致，未给定类型，则右侧常量类型彼此独立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const utc1, utc2, utc3 = 6.3, false, &quot;C&quot;</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc  = 6.3</span><br><span class="line">    utc2 = false</span><br><span class="line">    utc3 = &quot;c&quot;</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;c&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>并不需要显式的对所有常量赋值，被省略赋值的常量，会被隐含地赋与其上面的、最近的且被显式赋值的那个常量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false恒等</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4</span><br><span class="line">    utc5 </span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4       = &quot;C&quot;</span><br><span class="line">    utc5       = &quot;C&quot;</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    utc1         =       6.3</span><br><span class="line">    utc2, ytc3   =   false, &quot;C&quot;</span><br><span class="line">    utc4, utc5</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line">对此有规则：  </span><br><span class="line">* 若有未被显式赋值的常量，同一行的常量的赋值都必须被省略。</span><br><span class="line">* 未显式赋值的那一行的常量声明中的常量标识符数量必须与在它上面的、最近的且显式赋值的那一行常量声明中的常量标识符的数量相等。</span><br><span class="line"></span><br><span class="line">iota代表了连续的、无类型的整数常量，第一次出现在一个以const开始的常量声明语句中的时候总会表示整数常量0。随着在同一条常量声明语句中包含iota的常量的递增，iota所表示的整数值也会递增。</span><br><span class="line">```code</span><br><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    c = 2</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; iota</span><br><span class="line">    v</span><br><span class="line">    w</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; 0</span><br><span class="line">    v = 1 &lt;&lt; 1</span><br><span class="line">    w = 1 &lt;&lt; 2恒等</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1</span><br><span class="line">    v = 2</span><br><span class="line">    w = 4</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    e, f = 0, 1</span><br><span class="line">    g, h = 1, 2</span><br><span class="line">    i, j = 2, 4 </span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    _, _</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">     e, f = 0, 1</span><br><span class="line">     g, h = 2, 4</span><br><span class="line">     i, j = 3, 8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>在同一条常量声明语句中，iota代表的整数常量的是否递增取决于是否又有一个常量声明包含了它，而不是它是否又在常量声明中出现了一次。可用空标识符“_”跳过iota表示的递增序列中的某个或某些值。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在声明之后可以被赋值任意次，值在程序运行期间才被计算。</p><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>以关键字var开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v int64 = 0 //声明变量的类型</span><br><span class="line">var x = 0       //省略变量的类型</span><br></pre></td></tr></table></figure></p><p>变量的类型未被显示指定将由变量值推导得出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    v1 = 0</span><br><span class="line">    v2 = -1</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">var v3, v4, v5 float64</span><br><span class="line">=</span><br><span class="line">var v3, v4, v5 float64 = 0.0, 0.0, 0.0</span><br></pre></td></tr></table></figure></p><p>隐式赋值在变量声明中不可用，未被显示赋值的变量值将会是与改变量的类型相对应的零值，此时变量的类型不可省略。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>变量声明可以作为源码文件中的顶级元素，也可以称为函数体内容的一部分，前者全局变量，后者局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">var v6 bool //全局变量</span><br><span class="line">func main()&#123;</span><br><span class="line">    var v6 bool = true  //局部变量</span><br><span class="line">    fmt.Printf(&quot;v6: %v\n&quot;, v6)恒等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在函数体内部，局部变量会遮蔽与其同名的全局变量。<br>函数体内部的短变量声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v6 := true</span><br><span class="line">v7, v8 := &quot;Go&quot;, 1.2</span><br><span class="line">v8, v9 := 2.0, false    //v8重声明</span><br></pre></td></tr></table></figure></p><p>重声明为对在当前上下文环境中的已存在变量的又一次赋值，赋的值与改变量的类型之间应满足赋值规则。<br>重声明仅出现在短变量声明中，不能用普通的声明方式重新声明一个在当前上下文环境中已存在的变量，不论改变量是一个全局变量还是一个局部变量。<br>短变量声明条件：  </p><ul><li>仅能够在函数体内部声明变量的时候使用。     </li><li>:=的左边的标识符至少有一个代表在当前上下文环境中的新变量。</li></ul><p>空标识符“_”代表的不是新变量。短变量声明可以出现在if、for和switch等语句的初始化器中，并被用来声明仅存在于这些语句块中的局部临时变量。<br>在当前上下文环境中声明了某个局部变量但没有使用它，会造成一个编译错误，对变量的赋值不算对其使用。  </p><h3 id="可比性与有序性"><a href="#可比性与有序性" class="headerlink" title="可比性与有序性"></a>可比性与有序性</h3><h4 id="类型的恒等"><a href="#类型的恒等" class="headerlink" title="类型的恒等"></a>类型的恒等</h4><p>对于两个命名类型来说，名称不同，肯定不恒等，名称相同且源于相同的类型声明，则是恒等的。别名类型与它的源类型是两个完全不同的类型，命名类型和匿名类型总是不相等的。<br>恒等判断规则：  </p><ul><li>数组类型，长度一致且元素的数据类型一致。</li><li>切片类型，元素的数据类型一致。</li><li>结构体类型，字段声明的数量相同且对应位置上的字段具有相同的字段名称和恒等的数据类型。字段声明的标签实际上是一个字符串字面量，标签一致也为判断恒等的依据。</li><li>指针类型，基本类型（指向的那个类型）恒等。</li><li>函数，包含了相同数量的参数和结果声明，并且对应位置上的参数和类型都是恒等的。不关注参数和结果名称，只关注数量、顺序和类型。若为可变参函数则都为可变参函数。</li><li>接口类型，拥有相同的方法集合。</li><li>字典类型，具有恒等的元素类型和键类型。</li><li>通道类型，具有恒等的元素类型且方向相同。</li></ul><h4 id="数据的可比性和有序性"><a href="#数据的可比性和有序性" class="headerlink" title="数据的可比性和有序性"></a>数据的可比性和有序性</h4><p>可比性是可以判断相等与否，有序性是可以比较大小。  </p><ul><li>布尔值具有可比性。</li><li>整数类型值具有可比性和有序性。</li><li>浮点数类型值具有可比性和有序性。</li><li>复数类型值具有可比性。</li><li>字符串值具有可比性和有序性。</li><li>指针值具有可比性。指向同一个变量或者都为空值nil。</li><li>通道类型值具有可比性。元素类型和缓冲区大小都一致。</li><li>接口类型值具有可比性。拥有相等的动态类型和相同的动态值。若都为空值也相等。</li><li>非接口类型X的值可以与接口类型T的值t判断相等，当且仅当接口类型T具有可比性且类型性X式接口类型T的实现类型。</li><li>结构体类型中的所有字段都具有可比性，则结构体类型的值具有可比性。</li><li>数组类型值具有可比性。元素类型的值具有可比性。</li></ul><p>切片类型、字典类型和函数类型的值不具有可比性，这些值可以与空值nil进行判等。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>把一个类型的值转换为另一个类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T(x)</span><br><span class="line">---</span><br><span class="line">*string(v)</span><br><span class="line">---</span><br><span class="line">&lt;-chan int(v) = &lt;-(chan int(v))//将v转换为chan int类型的值，在从此通道中接收一个int类型的值</span><br><span class="line"></span><br><span class="line">(&lt;-chan int)(v) //将v转换成通道类&lt;-chan int的值</span><br><span class="line">---</span><br><span class="line">func()(v) //结果为v的无参数匿名函数</span><br><span class="line"></span><br><span class="line">(func())(v) //将v转换为函数类型的值</span><br><span class="line"></span><br><span class="line">func() int(v)  = (func() int)(v) //将v转换为函数结果为int类型的函数类型。</span><br></pre></td></tr></table></figure></p><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>…</p><h4 id="与string类型相关的转换"><a href="#与string类型相关的转换" class="headerlink" title="与string类型相关的转换"></a>与string类型相关的转换</h4><p>…</p><h4 id="别名类型值之间的转换"><a href="#别名类型值之间的转换" class="headerlink" title="别名类型值之间的转换"></a>别名类型值之间的转换</h4><p>…</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><p>只接受通道类型的值作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int,1)</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p><p>使作为参数的通道无法在接受任何元素值。若试图关闭一个仅能接受元素值的通道，则造成一个编译错误。通道关闭之后再向它发送元素值或者试图再次关闭它，都会引发一个运行时恐慌。试图关闭一个nil的通道值也会引发一个运行时恐慌。<br>关闭一个通道不会影响关闭之前已经发送的那些元素值，关闭之后所有的接收操作都会立即返回一个该通道的元素类型的零值。</p><h4 id="len函数和cap函数"><a href="#len函数和cap函数" class="headerlink" title="len函数和cap函数"></a>len函数和cap函数</h4><p>len的使用：</p><blockquote><p>参数类型为字符串类型，返回string类型值的字节长度；<br>参数类型为数组类型或数组指针类型，返回数组类型值的长度；<br>参数类型为切片类型，返回切片类型的长度；<br>参数类型为字典类型，返回字典类型值的长度，即其中已包含的键的数量；<br>参数类型为通道类型，返回通道类型值当前包含的元素的数量。</p></blockquote><p>cap的使用：</p><blockquote><p>参数类型为数组类型或数组类型指针，返回数组类型的长度；<br>参数类型为切片类型，返回切片类型值的容量；<br>参数类型为通道类型，返回通道类型值的容量。</p></blockquote><h4 id="new函数和make函数"><a href="#new函数和make函数" class="headerlink" title="new函数和make函数"></a>new函数和make函数</h4><p>参见<a href="/2018/04/12/Golang学习笔记-语法基础篇-二/" title="Golang学习笔记-语法基础篇(二)">Golang学习笔记-语法基础篇(二)</a>数据初始化部分。</p><h4 id="append函数和copy函数"><a href="#append函数和copy函数" class="headerlink" title="append函数和copy函数"></a>append函数和copy函数</h4><p>参见<a href="/2018/04/12/Golang学习笔记-语法基础篇-二/" title="Golang学习笔记-语法基础篇(二)">Golang学习笔记-语法基础篇(二)</a>切片部分。</p><h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><p>专用于删除一个字典类型之中的某个键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, k)//m为字典类型值，k为要删除键值对的键</span><br></pre></td></tr></table></figure></p><ul><li>参数k与m的键之间必须满足赋值规则。</li><li>m是nil或者k所代表的键值对不存在与m中时，delete(m, k)不会做任何操作，删除操作被忽略，这种删除失败不会被反馈。<h4 id="complex函数、real函数和imag函数"><a href="#complex函数、real函数和imag函数" class="headerlink" title="complex函数、real函数和imag函数"></a>complex函数、real函数和imag函数</h4>专用于操作复数类型值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cplx128 complex128 = complex(2,-2) //根据浮点数类型的实部和虚部来构造复数类型值</span><br><span class="line"></span><br><span class="line">var im64 = imag(cplx128) //从浮点数类型值中抽取浮点数的虚部部分</span><br><span class="line">var r64 = imag(cplx128)  //从 浮点数类型值中抽取浮点数的实部部分</span><br></pre></td></tr></table></figure></li></ul><h4 id="panic函数和recover函数"><a href="#panic函数和recover函数" class="headerlink" title="panic函数和recover函数"></a>panic函数和recover函数</h4><p>分别用于报告和处理运行时恐慌。  </p><blockquote><p>panic只接受一个参数，参数可以是任意类型的值。要生成和报告一个运行时的恐慌可以直接调用此函数并传递给他一个用以描述恐慌细节的值。参数的类型常常是接口类型error的某个实现类型。        </p></blockquote><blockquote><p>recover不接受任何参数，返回一个interface{}类型的结果值。即其结果值可能是任何类型的，可能是nil。为nil时可能是因为： </p><ul><li>传递给panic函数的参数值就是nil。</li><li>运行时的恐慌根本没有发生，即panic没有被调用。</li><li>函数recover并没有在defer语句中被调用。</li></ul></blockquote><h4 id="print和println函数"><a href="#print和println函数" class="headerlink" title="print和println函数"></a>print和println函数</h4><p>把参数值在标准输出上打印出来且不返回任何结果值。<br>print的作用是依次（从左到右）打印传递给它的参数值，每个参数值对应的打印内容都由它们的具体实现决定。peintln函数在print函数打印的内容基础上在每个参数只见加入空格“ ”，并在最后加入换行符。</p><blockquote><p>Go语言不保证会在以后每个版本中保留和则两个函数，尽量不要使用这两个函数，使用标准库代码包fmt中的函数Print和Println替代。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言的语法和C/C++、Java等有很大的不同，较类似于C。语法设计更为复杂，好处是使用起来会更加方便快捷。Go通过结构类和接口形成面向对象思想，吸取了Python中的切片、字典等数据类型。新增了通道，Go中非常重要的一种数据类型。将函数也作为一等数据类型，能够实现闭包，通过语法特性可以很方便的实现策略模式、泛型等。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang学习笔记-语法基础篇(二)</title>
      <link href="/2018/04/12/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/"/>
      <url>/2018/04/12/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、<br> complex64、complex128  </p></blockquote><p> 分为三类。</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><pre><code>&gt;bool：true、false</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p> 特殊rune</p><blockquote><p>类型rune的值由rune类型字面量代表，专用于存储经过Unicode编码的字符。<br>    一个rune常量即是一个Unicode编码值，使用十六进制表示法来表示与Unicode对应的数字值，并使用“U+”作为前缀。<br>    一个rune字面量由外层的单引号和内层的一个或多个字符组成，在包裹字符的单引号中不能出现单引号“’”和换行符“\n”。    </p></blockquote><p>可以用5种方式来表示一个rune字面量  </p><ol><li>该rune字面量所对应的字符。如：’a’、’-‘，字符必须是Unicode编码规范所支持。</li><li>使用“\x”为前导并后跟两位十六进制数。可以表示宽度为一个字皆的值，即一个ASCII编码值。  </li><li>使用“\”为前导并后跟三位八进制数。宽度限制为一个字皆，只能用于表示对应数值在0和255之间的值。</li><li>使用“\u”为前导并后跟四位十六进制数。只能用于表示两个字节宽度的值，为Unicode编码规范中的UCS-2表示法。</li><li>使用“\U”为前导并后跟八位十六进制数。为Unicode编码规范中的UCS-4表示法。为Unicode编码规范和相关国际标准中的规范编码格式。 </li></ol><p> rune字面量可以支持转义符，有固定的几个，在规定之外的以“\”为前导的字符序列都是不合法的，转义符“\””也不能出现在rune字面量中。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串的长度即是底层字节序列中字节的个数，一个字符串常量的长度在编译期间就能够确定。<br>字符串代表了一个连续的字符序列，每一个字符都会被隐含地以Unicode编码规范的UTF-8编码个是编码为若干字节。<br>字符串字面量的两种表示格式：原生字符串字面量和解释型字符串字面量。    </p><blockquote><p>原生字符串字面量在两个反引号“`”之间的字符序列。在反引号之间，除了反引号之外的其他字符都是合法的，两个反引号之间的所有内容都看作是这个原生字符串字面量的值，其内容由在编译期间就可以确定的字符（非解释型字符）组成。原生字符串字面量中，不存在任何转义字符，所有内容都是所见即所得，也包括换行符。原生字符串字面量中的回车符会被编译器移除。    </p></blockquote><blockquote><p>解释型字符串字面量是被两个双引号“””包含的字符序列。解释型字符串中的转义字符都会被成功转义。在解释型字符串字面量中，转义符“\’”是不合法的，而转义字符“\””却是合法的，与rune字面量相反。在字符串字面量中可以包含rune字面量。  </p></blockquote><p>字符串字面量与rune字面量的本质区别是在于他们所代表的Unicode字符的数量上。</p><blockquote><p>字符串值是不可变的，不可能改变一个字符串的内容，对字符串的操作只会返回一个新字符串，而不是改变原字符串并返回</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个数组就是一个由若干个相同类型的元素组成的序列。    </p><h4 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1. 类型表示法"></a>1. 类型表示法</h4><p> 声明要指明长度和元素类型<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[n]T  //[非负整数字面量]元素类型</span><br><span class="line">[2*3*4]byte</span><br><span class="line">[5]struct&#123;name,address string&#125; //自定义匿名结构体类型</span><br></pre></td></tr></table></figure></p><h4 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2. 值表示法"></a>2. 值表示法</h4><p>值由符合字面量表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125; </span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;.&quot;, 5:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;2:&quot;I&quot;, 1:&quot;am&quot;, 5:&quot;a&quot;, 4:&quot;loser&quot;, 0:&quot;.&quot;, 3:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;5:&quot;I&quot;, 0:&quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;&quot;, 5:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;1:&quot;I&quot;, &quot;am&quot;, 4:&quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;1:&quot;I&quot;, 2:&quot;am&quot;, 3:&quot;&quot;, 4:&quot;a&quot;, 5:&quot;loser&quot;&#125;</span><br><span class="line"></span><br><span class="line">[...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[4]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">``` </span><br><span class="line">* 默认第一个元素值对应索引值0，之后的每个元素值的索引值都是在前一个元素值的索引值的基础上再加1，可以显式的指定索引值。</span><br><span class="line">* 在数组中未指定的元素将会被填充为元素类型的零值，可以通过显式地指定索引值来改变被填充元素值的位置。</span><br><span class="line">* 用特殊标记“...”替换为数组长度，意为并不显式地指定数组值的长度，而让Go语言编辑器为我们计算该值所包含的元素值的数量并以此确定这个长度的值。可以避免由于指定的长度和元素值的实际数量不相符而导致的多于零值元素或编译错误。</span><br><span class="line">&gt;0 &lt;= 索引值 &lt; 数组长度  </span><br><span class="line">指定的索引值不能与其他元素值的索引值重复，不论其他元素值的索引值是隐含对应的还是显式对应的。  </span><br><span class="line">####  3. 属性和基本操作  </span><br><span class="line">使用函数len计算数组值长度</span><br><span class="line">```code</span><br><span class="line">len([...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot; &#125;)</span><br></pre></td></tr></table></figure></p><p>通过索引值访问元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;[0] =&gt; &quot;bighua&quot;</span><br></pre></td></tr></table></figure></p><p>通过索引值改变对应元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array1 := [...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array1[0] = &quot;cocowh.github&quot;</span><br><span class="line">array1[2] = &quot;io&quot;</span><br></pre></td></tr></table></figure></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>Slice可以看作是Array的一种包装形式，是针对其底层包装数组中某个连续片段的描述苻，包装的数组称为该切片的底层数组。</p><h4 id="类型表示法"><a href="#类型表示法" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>由一对中间没有任何内容的方括号和代表其元素类型的标识符组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]T</span><br></pre></td></tr></table></figure></p><p>长度并不是切片类型的一部分，不会出现在表示切片类型的类型字面量中，切片的长度是可变的，相同类型的切片值可能会有不同的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]rune</span><br><span class="line">[]struct&#123;name,department string&#125;</span><br></pre></td></tr></table></figure></p><p>切片类型声明中的元素类型可以是任意一个有效的Go语言数据类型。</p><h4 id="值表示法"><a href="#值表示法" class="headerlink" title="值表示法"></a>值表示法</h4><p>切片的零值为nil，在初始化之前，一个切片类型的变量值为nil。</p><blockquote><p>切片值的长度为其所含的元素值的实际数量，使用函数len获取切片值的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len([]string&#123;4:&quot;bighua&quot;, 2: &quot;.&quot;,  &quot;com&quot;&#125;)  ##= 5</span><br></pre></td></tr></table></figure><p>在切片类型的零值（即nil）上应用内建函数len将会得到0。</p><blockquote><p>一个切片一旦被初始化，就会与一个包含了其中元素值的数组相关联，即一个切片值总会持有一个对某个数组值的引用。</p></blockquote><p>多个切片值可能会共用同一个底层数组。把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的值，这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对其底层数组上的对应元素的修改，作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片之上。切片值类似于指向底层数组的指针。  </p><blockquote><p>切片值的容量是其能够访问到的当前底层数组中的元素值的最大数量，即从其中的指针指向的那个元素值到底层数组的最后一个元素值的计数值，用内建函数cap获取。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap([]string&#123;4:&quot;bighua&quot;, 2:&quot;.&quot;, &quot;com&quot;&#125;)   //=5</span><br></pre></td></tr></table></figure><p>此例中切片值的容量就等于它的长度，对切片类型的零值应用内建函数cap也会得到0。</p><blockquote><p>一个切片值的底层数据结构中包含一个指向底层数组的指针类型值、一个代表切片长度的int类型值和一个代表切片容量的int类型值。  </p></blockquote><blockquote><p>使用复合字面量初始化一个切片值的时候，首先创建的是这个切片值所引用的底层数组，该底层数组与这个切片值有相同的元素类型、元素值及其排列顺序和长度，因此切片值的长度和容量一定相同。  </p></blockquote><blockquote><p>切片表达式的作用不是复制数组值中某个连续片段所包含的元素值，而是创建一个新的切片值，新的切片值中包含了指向这个连续片段中的第一个元素值的指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;a&quot;, &quot;loser&quot;&#125;     //底层数组长度5，即切片容量5</span><br><span class="line">slice := array[:4]      //切片长度4，能够访问前4个元素值</span><br><span class="line">slice = slice[:cap(slice)] //扩大窗口，改变长度为容量，能够访问所有元素值</span><br></pre></td></tr></table></figure><p>通过切片的方式把slicede的窗口扩展到最大，此时slice的值的长度等于其容量，窗口只能向索引值递增的方向拓展。当一个切片的索引值不在切片的长度范围内时，会引起一个运行时恐慌。<br>使用内建函数append对切片值进行拓展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array[:4]</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">slice ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">长度扩展到最大容量7，此时array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">slice1 := append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">不会改变slice的值，声明并初始化一个新变量slice1</span><br><span class="line">slice1 ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>第一个参数为将要被拓展的切片，第二个可变长参数类型应与第一个参数元素类型相同，与作为拓展内容的一个或多个元素值绑定。此函数又返回结果，结果的类型与其第一个参数的类型完全一致。<br>append函数不是在原始切片值上进行拓展，而是创建一个新的切片值，在无需扩容时，此切片值与原切片值共用一个底层数组，指针类型值和容量值与原切片值保持一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">此时长度超出容量，会创建一个新的长度大于需要存储的元素值总和的底层数组，新切片指针、长度、容量改变。</span><br><span class="line">*/相似</span><br></pre></td></tr></table></figure></p><p>上例中slice长度超出容量，此时会有一个新的数组值被创建并初始化，新的数组值将作为在append函数新创建的切片值的底层数组，包含原切片之中的全部元素值以及作为拓展内容的所有元素值。此底层数组的长度总是大于需要存储的元素值的总和，新切片值中的指针将指向其底层数组的第一个元素值，长度和容量与其底层数组的长度相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice = append(slice, slice1...)</span><br><span class="line">---</span><br><span class="line">slice1 = nil</span><br><span class="line">slice1 = append(slice2, slice...)</span><br><span class="line">---</span><br><span class="line">var slice2 []string</span><br><span class="line">slice2 = append(slice2, slice...)</span><br></pre></td></tr></table></figure></p><p>运用“…”符号，集合追加方式。</p><blockquote><p>如果容量上限索引被指定，作为切片表达式的求值结果的新切片值的容量则为容量上界索引与元素下界索引之间的差值。指定容量上界索引的目的是为了缩小新切片值的容量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arrray = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">slice := array[2:6]</span><br><span class="line">/*可直接修改array对应索引值在[2,6)的元素值，通过扩大slice窗口，可修改array对应索引值[6,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice :=array[2:6:8]</span><br><span class="line">/*即使扩大长度也仅能访问修改array中对应索引值[2,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice = append(slice, []int&#123;10 ,11, 12, 13, 14, 15&#125;...)</span><br><span class="line">/*拓展超出容量创建新的底层数组，指针指向新底层数组，彻底无法访问修改array的元素值*/</span><br></pre></td></tr></table></figure><blockquote><p>使用容量上限索引能有效的精细控制切片值对其底层数组的访问权限。<br>指定容量上限索引时，元素上界索引时不能够省略的，可以省略元素下界索引。</p></blockquote><p>使用内建函数copy批量赋值切片值中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []string&#123;&quot;I&quot;, &quot;love&quot;, &quot;my&quot;, &quot;family&quot;&#125;</span><br><span class="line">slice2 := []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">n1 := copy(slice1,slice2)</span><br><span class="line">/*</span><br><span class="line">n1 = 3</span><br><span class="line">slice =&gt; []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;, &quot;family&quot;&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>把原切片值（参数二）中的元素值复制到目标切片值（参数一）中，返回被复制的元素值的数量。参数一和参数二的元素类型必须一致，实际复制的元素值的数量等于长度较短的切片值的长度。<br>切片类型相当于于其他编程语言中的动态数组类型，扩展机制也与动态数组类型相似。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典（Map）是哈希表（Hash Table）的一个实现。哈希表是一个实现了关联数组的数据结构，关联数组是用于代表键值对的集合的一种抽象数据类型，在一个键值对集合中，一个键最多能够出现一次。与这个抽象数据结构相关联的操作有：  </p><ul><li>向集合中添加键值对。</li><li>从集合中删除键值对。</li><li>修改集合中已存在的键值对的值。</li><li>查找一个特定键所对应的值。</li></ul><p>哈希表通过哈希函数建立键值对的内部关联，键值对之间是没有顺序关系的。</p><h4 id="类型表示法-1"><a href="#类型表示法-1" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>如果一个字典类型中的键的类型为K，且元素的类型为T，字典类型的类型字面量为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map[K]T</span><br><span class="line">---</span><br><span class="line">map[int]string</span><br><span class="line">map[string]struct&#123;name,department string&#125;</span><br><span class="line">map[string]interface&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>字典类型的键类型和元素类型都需要在其声明中指定，元素类型可以是任意一个有效的Go语言数据类型，键类型不能是函数类型、字典类型或切片类型，键类型必须是可比较的。若键类型是接口类型，在程序运行期间，该类型的字典值中的每一个键值的动态类型都必须是可比较的，否则引起运行时异常。</p><h4 id="值表示法-1"><a href="#值表示法-1" class="headerlink" title="值表示法"></a>值表示法</h4><p>由复合字面量表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]bool&#123;&quot;bighua&quot;:true, &quot;cool&quot;:true, &quot;smart&quot;:true, &quot;ugly&quot;:false&#125;</span><br><span class="line">---</span><br><span class="line">map[string]bool&#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>同指针类型和切片类型，字典类型是一个引用类型。字典会持有一个针对某个底层数据结构值的引用，将一个字典值传递给一个会改变它的函数，这个改变对于函数的调用方是可见的。  </p><blockquote><p>在Go语言中只有“传值”没有“传引用”，函数内部对参数值的改变是否会在该函数之外体现出来，只取决于这个被改变的值的类型是值类型还是引用类型。  </p></blockquote><p>字典的零值是nil，类似一个长度为零的字典，可对其进行读取操作，对其进行写操作引发运行时恐慌。为初始化的字典类型的变量的值为nil。<br>用内建函数len获取字典值的长度，代表当前所包含的键值对的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">editorSign := map[string]bool&#123;&quot;cool&quot;:true, &quot;smart&quot;:true, &quot;stupid&quot;:false&#125;</span><br><span class="line">editorSign[&quot;ugly&quot;] = false</span><br><span class="line">/*新增*/</span><br><span class="line">---</span><br><span class="line">sign1 := editorSign[&quot;smart&quot;]</span><br><span class="line">sign1,ok := editorSign[&quot;smart&quot;]</span><br><span class="line">/*查找获取，消除不存在歧义*/</span><br><span class="line">---</span><br><span class="line">delete(editorSign,&quot;stupid&quot;)</span><br><span class="line">/*删除键为&quot;stupid&quot;的键值对，无返回结果，即使不存在要删的键值对也不引起恐慌*/</span><br></pre></td></tr></table></figure></p><blockquote><p>字典类型不是并发安全的，官方认为在大多数使用字典值的地方并不需要多线程场景下的安全访问控制，为了少数的并发使用场景而强制要求所有的字典都满足互斥操作将会降低大多数程序的速度。  </p></blockquote><blockquote><p>对一个非并发安全的字典值进行不受控制的并发访问可能会导致程序行为错乱，可以使用标准库代码包sync中的结构体类型RWMutex扩展字典类来保证并发安全性。RWMutex是一个读写互斥量，常用于多线程环境下的并发读写控制。</p></blockquote><h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数类型是一等类型，可以把函数当作一个值来传递和使用，即可以作为其他函数的参数，也可以作为其他函数的结果，可以利用函数的和则以特性生成闭包。</p><h4 id="类型表示法-2"><a href="#类型表示法-2" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>函数类型指代了所有可以接受若干参数并能够返回若干结果的函数。<br>声明一个函数以关键字func作为开始，其后紧跟函数签名，包括参数声明列表和结果声明列表。参数声明一般参数名在前，参数类型在后，中间空格分隔，参数名称唯一。若相邻两个参数的类型一致，可以只写第二个参数的参数类型。可以在函数声明的参数列表中略去所有参数的名称。可添加可变长参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(name string, age int)</span><br><span class="line">---</span><br><span class="line">(name string, age, seniority int)</span><br><span class="line">---</span><br><span class="line">(string,int,int)</span><br><span class="line">---</span><br><span class="line">(name string,age int,seniority int,informations ...string)</span><br></pre></td></tr></table></figure></p><p>结果声明列表的编写规则与参数声明基本一致，区别于：  </p><ul><li>只存在可变长参数的声明不存在可变长结果的声明。</li><li>如果结果声明列表中只有一个结果声明且这个结果声明中并不包含结果的名称，则可以忽略圆括号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int, seniority int, informations ...string)bool</span><br><span class="line">-&gt;</span><br><span class="line">func (name string, age int, seniority int, informations ...string)(done bool)</span><br><span class="line">/*命名结果*/</span><br></pre></td></tr></table></figure><p>Go语言的函数可以有多个结果，为函数声明多个结果可以让每个结果的职责更单一。可以利用此特性将错误值作为结果返回给调用它的代码，而不是把错误抛出来，然后在调用它的地方编写代码处理这个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int , seniority int)(effected uint, err error)</span><br></pre></td></tr></table></figure></p><h4 id="值表示法-2"><a href="#值表示法-2" class="headerlink" title="值表示法"></a>值表示法</h4><p>函数类型的零值是nil，未被初始化的函数类型的变量的值为nil，在一个未被初始化的函数类型的变量上调用表达式会引发一个运行时的恐慌。<br>函数类型的值分为命名函数值和匿名函数值。<br>命名函数由关键字func、函数名、函数的签名和函数体组成。若签名中包含了结果声明列表，则在函数体中的任何可到达的流程分支的最后一条语句都必须是终止语句。终止语句有多种，return或goto开始的语句，针对内建函数panic的调用表达式的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Module(x, y int) int&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在关键字return之后的结果必须在数量上与该函数的结果声明列表中的内容完全一致，对应位置的结果的类型上存在可赋予的关系。</p><blockquote><p>函数的声明可以省略掉函数体，表示会由外部程序（如汇编语言程序）实现，而不会由Go语言程序实现。</p></blockquote><p>匿名函数由函数字面量表示，函数没有名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作-1"><a href="#属性和基本操作-1" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>函数类型是Go语言的基本类型，可以把函数类型作为一个变量的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var recoder func (name string, age int, seniority int) (done bool)</span><br></pre></td></tr></table></figure></p><p>之后所有符合这个函数的实现都可以被赋给变量recoder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recoder = func(name string, age int, seniority int) (done bool)&#123;</span><br><span class="line">    //tudo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被赋给变量recoder的函数字面量必须与recoder的类型拥有相同的函数签名。像“面向接口编程”原则的一种实现方式。可以在一个函数类型的变量上直接应用调用表达式来调用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done := recoder(&quot;Harry&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>可以把函数类型的变量的值看作是一个函数值，所有的函数值都可以被调用，函数字面量也是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(name tsring, age int, seniority)(done bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;(&quot;HuaGe&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>一个函数即可以作为其他函数的参数，也可以作为其他函数的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//声明加密算法函数类型</span><br><span class="line">type Encipher func(plaintext string) []byte</span><br><span class="line"></span><br><span class="line">//声明生成加密函数的函数</span><br><span class="line">func GenEncryptionFunc(encrypt Encipher) func(string) (ciphertest string)&#123;</span><br><span class="line">    return func(plaintext string) string&#123;</span><br><span class="line">        return fmt.Sprintf(&quot;%x&quot;,encrypt(plaintext))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">实现了闭包</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>函数GenEncryptionFunc的签名中包含一个参数声明和一个结果声明。参数声明“(encrypt Encipher)”中的参数类型是定义的用于封装加密算法的函数类型,结果声明“func(string)(ciphertext string)”表示了一个函数类型的结果，这个函数类型则是GetEncryptionFunc函数所生成的加密函数的类型，接收一个string类型的明文作为参数，并返回一个string类型的密文作为结果。<br>函数GenEncryptionFunc的函数体内直接返回了符合加密函数类型的匿名函数，匿名函数调用名称未encrypt的函数，把作为该匿名函数的参数的明文加密，然后使用标准代码库代码包fmt中的Sprintf函数，把encrypt的函数的调用结果转换成字符串。字符串内容是十六进制数表示的加密结果，是[]byte类型的。</p><blockquote><p>每一次调用GenEncryptionFunc函数，传递给它的加密算法函数都会一直被对应的加密函数引用着。只要生成的加密函数还可以被访问，其中的加密算法函数就会一直存在，不会被Go语言的垃圾回收期回收。</p></blockquote><p>只有当函数类型是一等类型并且其值可以作为其他函数的参数或结果的时候，才能够实现闭包。  </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法是附属于某个自定义的数据类型的函数，一个方法就是一个于某个接收者关联的函数。<br>方法的签名中不但包含了函数签名，还包含了一个与接收者有关的声明，即方法的声明包含了关键字func、接收者声明、方法名称、参数声明列表、结果声明列表和方法体。接收者由被圆括号括起来的两个标识符组成，标识符间空格分隔，左边标识符为接收者的值在当前方法中的名称，右边标识符代表接收者的类型，前者称为接收者标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type MyIntSlice []int</span><br><span class="line">func (self MyIntSlice) Max() (result) &#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收者声明编写规则</p><ul><li>接收者声明中的类型必须是某个自定义的数据类型，或者是一个与某个自定义数据类型对应的指针类型。接收者的类型既不能是一个指针类型，也不能是一个接口类型。</li><li>接受者声明中的类型必须由非限定标识符代表。</li><li>接收者标识符不能是空标识符“_”。</li><li>接收者的值未在当前方法体内被引用，可以将接收者标识符从当前方法的接受者声明中删除掉。（同参数声明不推荐</li></ul><p>方法的类型与从其声明中去掉函数接收者之后的函数的类型相似，把接收者声明中的两个标识符加到参数列表声明的首位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (self *MyIntSlice) Min() (result int)</span><br><span class="line">//类型为</span><br><span class="line">func Min()(self *MyIntSlice, result int)</span><br></pre></td></tr></table></figure></p><p>选择接收者的类型  </p><ul><li>在某个自定义数据类型上，值能够调用与这个数据类型相关联的值方法，在这个值的指针值上，能够调用与其数据类型相关联的值方法和指针方法。</li><li>在指针方法中能够改变接收者的值，在值的方法中，对接收者的值的改变对于该方法之一般是无效的。  </li></ul><p>接收者的类型如果是引用类型的别名类型，在该类型值的值方法中对该值的改变也是对外有效的。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> Go语言的接口由一个方法的集合代表。只要一个数据类型（或与其对应的指针类型）附带的方法集合是某一个接口的方法集合的超级，就可以判定该类型实现了这个接口。</p><h4 id="类型表示法-3"><a href="#类型表示法-3" class="headerlink" title="类型表示法"></a>类型表示法</h4><p> 接口由方法集合代表。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//标准库代码包sort中的接口类型Interface</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">   Len() int</span><br><span class="line">   Less(i, j int) bool</span><br><span class="line">   Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将一个接口类型嵌入到另一个接口类型中，亦接口间的继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Sortable interface &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Sort()</span><br><span class="line">&#125;</span><br><span class="line">//嵌入了sort中的接口类型Interface</span><br></pre></td></tr></table></figure></p><blockquote><p>接口的嵌入不能嵌入自身，包括直接的嵌入和间接的嵌入，当前接口类型中声明的方法也不能与任何被嵌入其中的接口类型的方法重名，错误的嵌入会造成编译错误。</p></blockquote><p>interface{}为空接口，不包含任何方法声明的接口，Go语言中所有数据类ixng都是它的实现。</p><h4 id="值表示法-3"><a href="#值表示法-3" class="headerlink" title="值表示法"></a>值表示法</h4><p>Go语言的接口没有相应的值表示法，接口是规范而不是实现。一个接口类型的变量可以被赋予任何实现了这个接口类型的数据类型的值，因此接口类型的值可以由任何其它数据类型的值来表示。</p><h4 id="属性和基本操作-2"><a href="#属性和基本操作-2" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>接口的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type SortableStrings [3]string</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Len() int &#123;</span><br><span class="line">    return Len(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Less(i, j int) bool &#123;</span><br><span class="line">    return self[i] &lt; self[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Swap(i, j int) &#123;</span><br><span class="line">    self[i],self[j] = self[j],self[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(sort.Interface)</span><br><span class="line">//类型断言SorableStrings类型是一个sort.Interface接口类型的实现。</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//断言SorableStrings类型实现了接口类型Sortable。</span><br><span class="line"></span><br><span class="line">func (self *SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(&amp;SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//验证方法接收对象规则值方法和指针方法</span><br></pre></td></tr></table></figure></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体类型既可以包含若干个命名元素（字段），又可以与若干个方法相关联。字段代表了该类型的属性，方法可以看作是针对这些属性的操作。</p><h4 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">    Sortable        // 匿名字段</span><br><span class="line">    sortableArray sort.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把类型相同的字段写在同一行中(不建议):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len, cap int</span><br></pre></td></tr></table></figure></p><p>只有类型而没有指定名称的字段叫做匿名字段，也称嵌入式的字段（结构体类型的嵌入类型），必须由一个数据类型的名称或者一个与非接口类型对应的指针类型类型的名称代表，代表匿名字段类型的非限定名称被隐含地作为该字段的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Anonymities struct &#123;</span><br><span class="line">    T1      //隐含名称T1</span><br><span class="line">    *T2     //隐含名称T2</span><br><span class="line">    P.T3    //隐含名称T3</span><br><span class="line">    *P.T4   //隐含名称T4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体自动地实现它包含的所有嵌入类型所实现的接口类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当Sequence类型中由与Sortable接口类型的Sort方法的名称和签名都相同的方法时，调用seq.Sort()是调用Sequence自身的Sort方法，嵌入类型Sortable的方法Sort被隐藏了。类似装饰器模式。若名称相同签名不同，Sortable的Sort方法依然被隐藏。此时调用Sequence自身的Sort方法需要依据Sort的签名来编写调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (self *Sequence) Sort (quicksort bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br><span class="line">seq.Sort(true) //调用自身</span><br><span class="line">seq.Sortable.Sort() //调用嵌入类型Sortable的Sort</span><br></pre></td></tr></table></figure></p><p>假设有结构体类型S和非指针类型的数据类型T，则：  </p><ul><li>S中包含一个嵌入类型T，S和<em>S的方法集合中都包含接收者类型为T的方法。</em>S的方法集合中还包含接收者类型为*T的方法。</li><li>S中包含了一个嵌入类型<em>T，S和</em>S的方法集合中都会包含接收者类型T或*T的所有方法。</li></ul><p>对于结构体的多层嵌入：  </p><ul><li>在被嵌入的结构体类型的值上像调用它自己的字段或方法那样调用任意深度的嵌入类型值的字段或方法。前提是这些嵌入类型的字段或者方法没有被隐藏，被隐藏则需要通过链式的选择表达式调用或者访问。</li><li>被嵌入的结构体类型的字段或者方法可以隐藏任意深度的嵌入类型的同名字段或方法。字段可以隐藏方法，方法可以隐藏字段，名称相同即可。</li></ul><p>匿名结构体类型比命名结构体类型少了关键字type和类型名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以在数组类型、切片类型活字典类型的声明中，将一个匿名的结构体类型作为它们的元素的类型。可以直接将匿名结构体作为一个变量的类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var anonym struct &#123;</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更常用的是在声明以匿名结构体类型为类型的变量的同时对其初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anonym := struct &#123;</span><br><span class="line">    a int </span><br><span class="line">    b string</span><br><span class="line">&#125;&#123;0, &quot;wuhua&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>匿名结构体类型不具有通用性，常常用在临时数据存储和传递的场景中。可以在结构体类型声明中的字段声明的后面添加一个字符串字面量标签，以作为对应字段的附加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Persion struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint   `json:&quot;age&quot; `</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常该标签对该结构体类型及其值的代码来说是不可见的，可以使用标准库代码包reflect中提供的函数查看到结构体类型中字段的标签。会在一些特殊的应用场景下使用，如标签库代码包encoding/json中的函数会根据这种标签的内容确定与该结构体中的字段对应的JSON节点的名称。</p><h4 id="值表示法-4"><a href="#值表示法-4" class="headerlink" title="值表示法"></a>值表示法</h4><p>一般由复合字面量表达。<br>对Sequence有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;Sortable:SortableStrings&#123;&quot;3&quot;,&quot;2&quot;,&quot;1&quot;&#125;,sorted:false &#125;</span><br></pre></td></tr></table></figure></p><p>可以忽略掉结构体字面量字段的名字，即不添加架构体字面量中的键值对的键。有限制：  </p><ul><li>要省略都省略。</li><li>字段值之间的顺序与结构体类型声明中的字段声明的顺序一致，不能省略对任何一字段的赋值。</li></ul><p>可以在结构体字面量中不指定任何字段的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>此时此值中的两个字段被赋予他们所属类型的零值。结构体类型属于值类型，零值为不为任何字段赋值的结构体字面量。<br>在字段访问权限允许下访问操作字段，字段名称首字母小写，只能在结构体类型声明所属的代码包中访问到该类型的值中的字段，或对其赋值。</p><h4 id="属性和基本操作-3"><a href="#属性和基本操作-3" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>结构体类型的属性既其所包含的字段和关联的方法。<br>只存在内嵌不存在继承的概念。<br>在结构体类型的别名类型的值上，既不能调用该结构体类型的方法，也不能调用该结构体类型对应的指针类型的方法。</p><blockquote><p>通过结构体中嵌入接口，嵌入的接口能够存储所有实现了该接口类型的数据类型的值，该结构体可以在一定程度上模拟泛型。</p></blockquote><p>很多预定义类型都属于泛型类型（数组、切片、字典、通道），不支持自定义的泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">type GenericSeq interface &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    Append(e interface&#123;&#125;) bool</span><br><span class="line">    Set(index int,e interface&#123;&#125;) bool</span><br><span class="line">    Delete(index int)(interface&#123;&#125;,bool)</span><br><span class="line">    ElemValue(index int)interface &#123;&#125;</span><br><span class="line">    ElemType() reflect.Type</span><br><span class="line">    Value() interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Sequence struct &#123;</span><br><span class="line">    GenericSeq</span><br><span class="line">    sorted bool</span><br><span class="line">    elemType reflect.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Sort()&#123;</span><br><span class="line">    self.GenericSeq.Sort()</span><br><span class="line">    self.sorted = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Append(e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Append(e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Set(index int, e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Set(index,e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) ElemType() reflect.Type&#123;</span><br><span class="line">    //todo</span><br><span class="line">    self.elemType = self.GenericSeq.ElemType()</span><br><span class="line">    //todo</span><br><span class="line">    return self.elemType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口类型GenericSeq中声明了用于添加、修改、删除、查询元素和获取元素类型的方法。实现GenericSeq接口类型，也必须实现Sortable接口类型。将嵌入到Sequence类型的Sortable接口类型改为GenericSeq接口类型，在类型声明中添加reflect.Type类型（标准库代码包reflect中的Type类型）的字段elemType，用于缓存GenericSeq字段中存储的值的元素类型。<br>通过创建与Sequence类型关联的方法，方法与接口GenericSeq或Sortable中声明的某个方法有着相同的方法名和方法签名，隐藏了GenericSeq字段中存储的值的同名方法，达到扩展效果。<br>结构体类型在多数场景中比预定义数据类型的别名类型更适合作为接口类型的实现，是Go语言支持面向对象编程的主要体现。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>代表着某个内存地址的值。是复合类型之一。</p><h4 id="类型表示法-4"><a href="#类型表示法-4" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>通过于有效数据类型的左边插入符号“*”获取与之对应的指针类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[]int</span><br><span class="line">*Sequence</span><br><span class="line">*sort.StringSlice</span><br></pre></td></tr></table></figure></p><p>专门用于存储内存地址的类型uintptr，与int和uint一样属于数值类型。其值能够保存一个指针值的32位或64位（与程序运行的计算机架构有关）无符号整数，亦称其值为指针类型值的位模式。</p><h4 id="值表示法-5"><a href="#值表示法-5" class="headerlink" title="值表示法"></a>值表示法</h4><p>若变量可寻址，使用取址操作符“&amp;”取对应指针值。</p><h4 id="属性和基本类型"><a href="#属性和基本类型" class="headerlink" title="属性和基本类型"></a>属性和基本类型</h4><p>指针类型属于引用类型，零值为nil。<br>标准库代码包unsafe提供不安全的操作绕过Go语言类型安全机制。<br>包中有个int类型的别名类型ArbitraryType，可以代表任意的Go语言表达式的结果类型。包中声明了一个名为Pointer的类型，unsafe.Pointer类型代表了ArbitarayType类型的指针类型。有特殊转换操作：  </p><ul><li><p>指向其他类型值的指针值可以被转换为unsafe.Pointer类型值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer := unsafe.Pointer(float32(32))</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型值可以被转换为对应的指针类型的值。对于内存上的同一段数据，将其作为int类型的值和float32类型的值来解析得出的结果不同，某些情况，会引起一个运行时的恐慌。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vptr := (*int)(pointer)</span><br><span class="line">---</span><br><span class="line">vptr := (*string)(pointer) //引发运行时恐慌</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型的值可以被转换为一个uintptr类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptr := uintptr(pointer)</span><br></pre></td></tr></table></figure></li><li><p>uintptr类型的值也可转换为unsafe.Pointer类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer2 ：= unsafe.Poniter(uptr)</span><br></pre></td></tr></table></figure></li></ul><p>可通过unsafe.Pointer绕过类型系统在任意的内存地址上进行读写操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint8  `json:&quot;age&quot;`</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br><span class="line">pp := &amp;Person&#123;&quot;Bighau&quot;,23,&quot;Henan,China&quot;&#125;</span><br><span class="line">var puptr = uintptr(unsafe.Pointer(pp))</span><br><span class="line">var npp uintptr = puptr + unsafe.Offsetof(pp.Name)</span><br><span class="line">var name *string = (*string)(unsafe.Pointer(npp))</span><br></pre></td></tr></table></figure></p><p>使用unsafe包中的Offsetof函数返回Name在Person中的存储偏移量，将Person的内存地址与Name的存储偏移量相加得Name的内存地址，可利用特殊转换操作的规则2和4还原指向Name字段值的指针类型值。最后通过*name直接获取Name字段的值。<br>总结为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unssafe.Pointer(&amp;s.f))</span><br></pre></td></tr></table></figure></p><h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>指对某个数据类型的值或变量的初始化。专门用于数据初始化的内建函数new和make。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>用于为值分配内存。不同于其他编程语言，此处不会初始化分配到的内存，只会清零。<br>调用new(T)意味着为T类型的新值分配并清零一块内存空间，将这块内存空间的地址作为结果返回。结果即为指向这个新的T类型值的指针值，指向一个T类型的零值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = new(string)     //s-&gt;&quot;&quot;</span><br><span class="line">[]int = new([3]int) //n -&gt;[3]int&#123;0,0,0&#125;</span><br></pre></td></tr></table></figure></p><p>标准库代码包sync中的结构体内类型Mutex是一个new后即用的数据类型，零值为一个处于未锁定状态的互斥量。</p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>只能被用于创建切片类型、字典类型和通道类型的值，并返回一个已经被初始化的（非零值）的对应类型的值。  在创建这三个引用类型的值的时候，将内存分配和数据初始化两个步骤绑定在一起。三个类型的零值都是nil，使用new得到的是一个指向空值nil的指针。<br>除了接受一个表示目标类型的类型字面量，还接受一个或两个额外的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 10, 100)</span><br><span class="line">make([]int, 10)</span><br><span class="line"></span><br><span class="line">=&gt;[]int&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;</span><br><span class="line">//创建一个新的[]int类型的值，长度为10、容量为100，可省略参数3，此时为不指定新值的容量。</span><br><span class="line">---</span><br><span class="line">make(map[string]int, 100)</span><br><span class="line">make(map[string]int)</span><br><span class="line"></span><br><span class="line">=&gt;map[string]int&#123;&#125;</span><br><span class="line">//可忽略用于表示底层数据结构长度的参数，不建议</span><br><span class="line">---</span><br><span class="line">make(chan int, 10)</span><br><span class="line">//参数一通道类型，参数二通道长度，参数二可省略</span><br></pre></td></tr></table></figure></p><p>make函数只能被应用在引用类型的值的创建上，其结果是第一个参数所代表的类型的值，而不是指向这个值的指针值。在调用make函数的表达式的求值结果上使用“&amp;”取址操作符获取指针值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]int, 100)</span><br><span class="line">mp := &amp;m</span><br></pre></td></tr></table></figure></p><p>规则总结：</p><ul><li><p>字面量可以被用于初始化除接口类型和通道类型外的所有数据类型的值，接口类型没有值，通道类型只能使用make函数创建。</p></li><li><p>内建函数new主要被用于创建值类型的值，不适合用来创建引用类型的值，其结果是指向被创建值的指针值。</p></li><li><p>内建函数make仅能被用于切片、字典和通道类型的值的创建，结果值是被创建的值本身。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang学习笔记-语法基础篇(一)</title>
      <link href="/2018/04/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%80)/"/>
      <url>/2018/04/10/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="基本词法"><a href="#基本词法" class="headerlink" title="基本词法"></a>基本词法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h4 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h4><ol><li>基本数据类型名称。  </li><li>接口类型error。  </li><li>常量true、false和iota。  </li><li>所有内建函数的名称，即append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、peintln、real和recover。</li></ol><h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>由一个下划线_表示。一般用在不需要引入一个新邦定的声明中。例如在代码中存在一个变量x，但是却不存在对它的使用。这样的代码会使编译器报错。在变量x的声明代码后添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = x</span><br></pre></td></tr></table></figure></p><p>可以绕过编译器检查，使它不产生任何编译错误。因为x在此处被使用到，但是对x未进行任何操作。在导入声明中，当我们只想执行一下某个代码包中的初始化函数，而不需要使用这个代码包中的任何程序实体的时候，可以编写导入语句为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;runtime/cgo&quot;</span><br></pre></td></tr></table></figure></p><p>引入了这个代码包所需的所有操作，没有绑定到一个具体的名称上，在当前的源码文件中，我们无法对这个代码包中的任何程序实体进行调用。<br>以上，”_”会导致赋值或导入操作的相关准备工作的进行。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-程序声明-："><a href="#1-程序声明-：" class="headerlink" title="1. 程序声明 ："></a>1. 程序声明 ：</h4><pre><code>&gt; import、package</code></pre><h4 id="2-程序实体声明和定义："><a href="#2-程序实体声明和定义：" class="headerlink" title="2. 程序实体声明和定义："></a>2. 程序实体声明和定义：</h4><pre><code>&gt;chan、const、func、interface、map、struct、type、var</code></pre><h4 id="3-程序流程控制："><a href="#3-程序流程控制：" class="headerlink" title="3. 程序流程控制："></a>3. 程序流程控制：</h4><pre><code>&gt;go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><p>用于表示基础数据类型值的各种字面量。基本数据类型。</p><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><p> 用于构造各种自定义的符合数据类型的类型字面量。自定义数据类型如结构体。</p><h4 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h4><p> 用于表示符合数据类型的值的符合字面量。会被用来构造类型Struct结构体、Array(数组)、Slice(切片)、Map(字典)的值。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="基本类型（预定义类型）："><a href="#基本类型（预定义类型）：" class="headerlink" title="基本类型（预定义类型）："></a>基本类型（预定义类型）：</h4><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、complex64、complex128</p></blockquote><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><blockquote><p>Array(数组)、Struct(结构体)、Function(函数)、Interface(接口)、Slice(切片)、Map(字典)、Channel(通道)、Pointer(指针)</p></blockquote><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><blockquote><p>在变量声明中示出的类型。动态类型，在运行时与改变量绑定在一起的实际类型，实际类型可以是实现了这个接口的任何类型。接口类型的变量既拥有静态类型，也有动态类型。接口类型的变量的动态类型可以在执行期间变化，但是变量的静态类型永远只能是它声明时被指定的那个类型。</p></blockquote><h4 id="潜在类型"><a href="#潜在类型" class="headerlink" title="潜在类型"></a>潜在类型</h4><blockquote><p>每一个类型都会有一个潜在类型，若是预定义类型或者由类型字面量构造的符合类型，潜在类型就是它自身。</p></blockquote><p>可以用type声明自定义类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">type iString MyString</span><br><span class="line">type MyStrings [3]string</span><br></pre></td></tr></table></figure></p><p>可以把MyString看作string类型的一个别名类型，MyStrings、iString和MyString的潜在类型都是string。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="与C语言基本一致。新增："><a href="#与C语言基本一致。新增：" class="headerlink" title="与C语言基本一致。新增："></a>与C语言基本一致。新增：</h4><blockquote><p>&amp;^     按位清除操作，即根据第二个操作数的二进制值对第一个操作数的二进制值进行相应的清零操作。二元操作符，属于算术操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 7       &amp;^ 13       = 2</span><br><span class="line">00000111 &amp;^ 00001101 = 00000010</span><br><span class="line">      00000111</span><br><span class="line">&amp;^    00001101</span><br><span class="line">=     00000010</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>&lt;- 接收操作，一元操作符，属于接收操作符。只作用于通道类型的值。对于通道ch，表达式&lt;-的含义是从此通道中接收一个值。前提是通道的方向必须允许接收操作，并且该操作的结果的类型必须与通道元素的类型之间存在可赋予的关系。这个表达式会被阻塞直到通道中有一个值可用。</p></blockquote><p>需要注意：</p><ul><li>从一个通道类型的空值（即nil）接收值的表达式将会永远阻塞.</li><li>从一个已经被关闭的通道类型值接收值会永远成功并且立即返回一个其元素类型的零值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">v,ok  = &lt;-ch</span><br><span class="line">v,ok := &lt;-ch</span><br></pre></td></tr></table></figure><blockquote><p>“=”用于将一个值赋给一个已被声明的变量或常量，”:=”用于在声明一个变量的同时对这个变量进行赋值，”:=”只能在函数体内使用。v1，v2，v用于接收值，ok为布尔类型的值，代表了接收操作的成功与否，可用来判断一个通道是否被关闭了，为false时表明通道已经关闭。</p></blockquote><p>操作符优先级：</p><blockquote><p>5      * / % &lt;&lt; &gt;&gt; &amp; &amp;^<br>4     + - | ^<br>3      == !=  &lt;  &lt;=  &gt;  &gt;=<br>2     &amp;&amp;<br>1     ||</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="1-基本表达式"><a href="#1-基本表达式" class="headerlink" title="1. 基本表达式"></a>1. 基本表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[2]</span><br><span class="line">int(v1) + v2</span><br><span class="line">len(v3)</span><br><span class="line">x.f</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3]</span><br><span class="line">interface&#123;&#125;(num).(int)</span><br><span class="line">os.Open(&quot;/etc/profile&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-选择符号和选择表达式"><a href="#2-选择符号和选择表达式" class="headerlink" title="2. 选择符号和选择表达式"></a>2. 选择符号和选择表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.f      //深度0</span><br><span class="line">x.f.f2   //深度1</span><br></pre></td></tr></table></figure><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>对于一个类型T或者对应的指针类型*T的值x，表达式x.f表示类型T的最浅深度（即深度0）的字段或者方法。前提是：T不能是接口类型；类型T必须要有名称为f的字段或者方法。  </li><li>对于一个接口类型I的变量x，表达式x.f表示赋给x的那个值(实现了接口类型I的那个类型的值)的方法f。如果接口类型I的方法法集合中不包含名称为f的方法，那么选择表达式x.f非法。</li></ul><h5 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h5><ul><li>如果x是一个与某个构体类型对应的指针类型的变量，并且它的值为nil，那么针对表达式x.f的赋值和求值都会引起一个运行时的恐慌。不论f是字段还是方法。</li><li>如果x是一个接口类型的变量且它的值为nil，那么针对表达式x.f的调用和求值都会引起一个运行时恐慌，前提是f是该接口类型的一个方法。</li></ul><p>自动解引用：如果x是一个结构体类型对应的指针类型的值，那么x.f就是表达式(<em>x).f的一个速记法，不论f代表的是一个字段还是一个方法，如果f代表了一个字段且也是一个与结构体类型对应的指针类型，那么x.f.f2就是表达式(</em>(*x.f).f2的一个速记法，不论f2是一个字段还是方法。</p><h4 id="3-索引符号和索引表达式"><a href="#3-索引符号和索引表达式" class="headerlink" title="3. 索引符号和索引表达式"></a>3. 索引符号和索引表达式</h4><p>一个索引表达式有一个基本表达式和一个索引符号组成，形如a[x]，会求索引值为x的a中的那个元素的值。  </p><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ul><li>a不是字典类型的值，x必须是一个int类型或者无类型的证书字面量，x大于0且小于a的长度。否则引起一个与越界有关的运行时的恐慌。  </li><li>a是一个数组类型A的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个切片S类型的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个字符串类型T的变量，x必须在a的长度的有效范围内，a[x]表示字符串a中索引值为x对应的那个字节类型值。不能对a[x]进行赋值操作，字符串类型值是不能改变的。</li><li>a是一个字典类型M的变量，x的类型必须是可以赋值给M的键的类型，即键x的类型可以通过类型推断符号判定为M的键的类型。a[x]表示a中的、与键x对应的那个值，且a[x]的类型与字典M的元素的类型相同。若a为nil或者其中不包含以x为键的键值对，那么a[x]的求值结果就会是字典M的元素的类型的零值。通过赋值语句<br>v,ok := a[x]<br>判断是因为上方原因导致的零值还是与键x对应的值本身就是这个零值。ok为true表示赋值成功，原本就是零值，为false则表明由上方情况引起。当a为nil时对a[x]赋值会引起一个运行时恐慌。</li></ul><h4 id="4-切片符号和切片表达式"><a href="#4-切片符号和切片表达式" class="headerlink" title="4. 切片符号和切片表达式"></a>4. 切片符号和切片表达式</h4><p>切片符号可以是操作字符串、数组、数组的指针以及切片类型的值。<br>对于这样一个类型的值a，切片表达式为a[x:y:z]。<br>x代表元素下界索引，y代表元素上界索引，z代表切片的容量上界索引。<br>有如下约束：</p><blockquote><p>0 &lt;= 元素下界索引 &lt;= 元素上界索引 &lt;= 容量上界索引 &lt;= 操作对象的容量  </p></blockquote><p>若不满足，则在表达式求值时造成一个越界错误并引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3] = []int&#123;2,3&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[3:] = []int&#123;1,2,3,4,5&#125;[3:5] = []int&#123;4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[:3] = []int&#123;1,2,3,4,5&#125;[0:3] = []int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></p><p>若a代表的是一个切片类型的值，那么表达式a[:]就等同于复制a所代表的值并将其作为此表达式的求值结果。否则表达式a[:]就意味着有一个包含了指向a的第一个元素的指针的切片类型值被创建。</p><h4 id="5-类型断言"><a href="#5-类型断言" class="headerlink" title="5. 类型断言"></a>5. 类型断言</h4><p>对于一个求值结果为接口类型值表达式x和一个类型T，对应的类型断言为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure></p><p>用于判断“x不为nil且存储在其中的值是T类型的”这一假设是否成立。如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致，即为关于“类型T是否为x的动态类型”的判断。  类型T必须是x的一个实现类型，x必须是一个接口类型的值。<br>int(123).(int)引发编译错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid type assertion: 123.(int)(non-interface type int on left )</span><br></pre></td></tr></table></figure></p><p>即表达式int(123)的求值结果是int类型，而int类型并不是一个接口类型。将表达式改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;(123).(int)</span><br></pre></td></tr></table></figure></p><p>则会顺利通过编译，表达式interface{}(123)将字面量123转换为interface{}类型的值。interface{}是一个特殊的接口类型，代表空接口，所有类型都是他的实现类型。<br>如果T不是一个接口类型且类型T不是x的类型的一个实现，那么类型断言x.(T)就是失败的，会引发一个运行时恐慌。</p><blockquote><p>只有在程序运行期间，x的动态类型才能够被获知，而在编译期间能够确定的只有T所代表的类型。  </p></blockquote><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v,ok := x.(T)</span><br><span class="line">``` </span><br><span class="line">断言成功v为已经被转换为T类型的表达式x的求值结果，否着为类型T的零值。ok可以判断断言是否成功，此时类型断言失败也不会引发运行时恐慌。</span><br><span class="line">#### 6. 调用</span><br><span class="line">如果由函数类型F的值f，表达式f(a1,a2,a3)表达了对函数f的调用，同时以a1、a2和a3作为参数传递给函数f。  </span><br><span class="line">方法是函数的一种，比函数多了一个接收者。接收者可以是该方法所属的结构体类型的值，或者与该结构体类型对应的那个指针类型的值。</span><br><span class="line">&gt;在求值一个表达式、赋值语句或者返回语句中包含的操作数的时候，所有的函数调用、方法调用和通信调用都会按照从左到右的顺序被求值。</span><br><span class="line">```code</span><br><span class="line">a := 10</span><br><span class="line">f := func()int&#123; a = a*2;return 5&#125;</span><br><span class="line">x := []int&#123;a,f()&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中，x的值可能是[]int{10,5},也可能是[]int{20,5}。（有待考证</p><h4 id="7-可变长参数"><a href="#7-可变长参数" class="headerlink" title="7. 可变长参数"></a>7. 可变长参数</h4><p>如果函数f可以接受的参数的数量是不固定的，那么函数f就是一个能够接受可变长参数的函数，简称为可变参函数。<br>在可变函数的参数列表的最后总会出现一个可变长参数，这个可变长参数的类型声明形如…T。用于接受数量不定但类型均为T或其实现类型的参数值。等同于一个元素类型为T的切片类型的参数。对于函数f的每一次调用，被传递给可变长参数的值实际上都是包含了实际参数、元素类型为T的切片类型值。对可变参函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func appendIfAbsent(s []string,t ...string)[]string</span><br></pre></td></tr></table></figure></p><p>可以这样编写针对他的调用表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,&quot;C&quot;,&quot;N&quot;,&quot;E&quot;)</span><br></pre></td></tr></table></figure></p><p>其中，与可变长参数t绑定的切片类型值为[]string{“C”,”B”,”E”}。<br>可以直接把一个类型T的切片类型值赋给…T类型的可变长参数，需要在欲赋予可变长参数的那个切片类型值的后面追加…。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,[]string&#123;&quot;C&quot;,&quot;B&quot;,&quot;E&quot;&#125;...)</span><br></pre></td></tr></table></figure></p><p>若有元素类型为string的切片类型的变量s，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,s...)</span><br></pre></td></tr></table></figure></p><p>此时可变长参数t的值就是变量s的值，即不会专门创建于个切片类型值来存储其中的实际参数。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启航</title>
      <link href="/2018/04/05/%E5%90%AF%E8%88%AA/"/>
      <url>/2018/04/05/%E5%90%AF%E8%88%AA/</url>
      <content type="html"><![CDATA[<h3 id="搭建缘由"><a href="#搭建缘由" class="headerlink" title="搭建缘由"></a>搭建缘由</h3><p> 在前段时间又重新搭建了一系列的开发环境，安装了数遍双系统和虚拟机，折腾ubuntu和centos，搭建php+nginx+go+mariadb+node等等，期间遇到了很多的新问题，也有一些老问题，学到了很多东西，越来越感觉到笔记的重要性。想要自己搭建一套博客，怕是ui丑到自己都下不去笔。另外耽误时间、服务器配置以及相关稳定性长久性等也是个问题。从今开始，将所学所得所感记录在此。</p><h3 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h3><p>本博客由hexo驱动，尝试过很多主题，例如yilia、material等，最终选择了next主题。之前也尝试过rubuy的jekyll，但是更偏向于比较熟悉的基于node的hexo。使用yilia主题时，强迫症改liyia的侧滑抖动动画，改侧滑背景颜色，最终还是感觉界面不理想，在移动端每个页面上都挂着个人prefile，有种特沙比的感觉，非常浪费空间影响阅读体验，而且作者留了个badjs report收集异常信息和用户信息，感觉很是不爽，并且对应的提交端口貌似没有在维护了，调试时一个红色的eroor简直逼死强迫症。</p><p>使用material主题时也有类似yilia冗余的一点，有个logo perfile简直累赘，而且对应的官方网站相应文档总是加载不出来，貌似被墙了，很遗憾，没搭建完美就放弃了。</p><p>后来用到next主题，对于用户来说要比前两个友好很多，简洁大方，留给了用户更多的配置项，在移动端浏览更简洁舒服，封装了更多的第三方插件。评论插件建议畅言，加载快多了。但是目前有个问题，编写tags、about等page页面时，在page页面配置comments为false，编译后对应的页面虽然不出现畅言插件，即没加入相应的html页面块，但是却加入了相应的js用，然后在控制台会一直报js未寻找到畅言对应html节点的错误。使用来必力虽然也加入了相应的js调用，但是不会出现此类错误，应该编译过程未处理好。等以后有机会再探究修改一番，作为强迫症，把所有的页面评论功能都打开了。。。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望自己能够</p><blockquote><p>勤操代码多读书，善用时间少偷懒。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>BUG制造师</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>姓名：吴桦</li><li>性别：男</li><li>出生年月：1995/02</li><li>Email： <a href="mailto:huaweiailin@foxmail.com" target="_blank" rel="noopener">huaweiailin@foxmail.com</a></li><li>博客： cocowh.github.io</li><li>GitHub： <a href="https://github.com/cocowh" target="_blank" rel="noopener">https://github.com/cocowh</a></li></ul><hr><h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><p>2014/09-2018/06</p><ul><li>学历：本科</li><li>学校：华中农业大学</li><li>专业: 计算机科学与技术</li></ul><hr><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>PHP+Golang+Swoole+Vue+Node</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
