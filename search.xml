<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>InnoDB存储引擎源代码的编译和调试</title>
      <link href="/2019/09/18/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2019/09/18/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">源码</a></p><h3 id="InnoDB源码结构"><a href="#InnoDB源码结构" class="headerlink" title="InnoDB源码结构"></a>InnoDB源码结构</h3><p>MySQL源码目录下storage文件夹下，文件夹名即为存储引擎名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:storage wuhua$ pwd</span><br><span class="line">/Users/wuhua/Downloads/mysql-8.0.17/storage</span><br><span class="line">wuhua:storage wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── archive</span><br><span class="line">├── blackhole</span><br><span class="line">├── csv</span><br><span class="line">├── example</span><br><span class="line">├── federated</span><br><span class="line">├── heap</span><br><span class="line">├── innobase</span><br><span class="line">├── myisam</span><br><span class="line">├── myisammrg</span><br><span class="line">├── ndb</span><br><span class="line">├── perfschema</span><br><span class="line">├── secondary_engine_mock</span><br><span class="line">└── temptable</span><br><span class="line"></span><br><span class="line">13 directories, 0 files</span><br></pre></td></tr></table></figure><p>InnoDB源码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">wuhua:innobase wuhua$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt   </span><br><span class="line">├── COPYING.Google</span><br><span class="line">├── COPYING.Percona</span><br><span class="line">├── Doxyfile</span><br><span class="line">├── api</span><br><span class="line">├── arch</span><br><span class="line">├── btr            //B+ tree的实现</span><br><span class="line">├── buf            //缓冲池的实现，包括LRU算法，Flush刷新算法</span><br><span class="line">├── clone</span><br><span class="line">├── data</span><br><span class="line">├── dict//InnoDB存储引擎中内存数据字典的实现</span><br><span class="line">├── eval</span><br><span class="line">├── fil//InnoDB存储引擎中文件数据结构及对文件的一些操作</span><br><span class="line">├── fsp//file space，对InnoDB engine物理文件的管理，如页、区、段等</span><br><span class="line">├── fts</span><br><span class="line">├── fut</span><br><span class="line">├── gis</span><br><span class="line">├── ha//哈希算法的实现</span><br><span class="line">├── handler//继承MySQL的handler，插件式存储引擎的实现</span><br><span class="line">├── ibuf//插入缓冲的实现</span><br><span class="line">├── include//头文件（.h，.ic）</span><br><span class="line">├── innodb.cmake</span><br><span class="line">├── lob</span><br><span class="line">├── lock//锁的实现，如S锁、X锁，以及定义锁的一系列算法</span><br><span class="line">├── log//日志缓冲和重做日志文件的实现</span><br><span class="line">├── mach</span><br><span class="line">├── mem//辅助缓冲池的实现，用来申请一些数据结构的内存</span><br><span class="line">├── mtr//事务的底层实现</span><br><span class="line">├── os//封装一些对于操作系统的操作</span><br><span class="line">├── page//页的实现</span><br><span class="line">├── pars</span><br><span class="line">├── que</span><br><span class="line">├── read</span><br><span class="line">├── rem</span><br><span class="line">├── row//对于各种类型行数据的操作</span><br><span class="line">├── srv//对于InnoDB engine参数的设计</span><br><span class="line">├── sync//InnoDB engine互斥量（Mutex）的实现</span><br><span class="line">├── trx//事务的实现</span><br><span class="line">├── usr</span><br><span class="line">└── ut//工具类</span><br></pre></td></tr></table></figure><h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>源码中及各存储引擎中README文档。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>性能调优</title>
      <link href="/2019/09/17/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2019/09/17/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h3 id="选择合适的CPU"><a href="#选择合适的CPU" class="headerlink" title="选择合适的CPU"></a>选择合适的CPU</h3><p>InnoDB eigine一般应用OLTP数据库应用，特点：</p><ul><li>用户操作并发量大</li><li>事务处理的时间一般比较短</li><li>查询的语句较为简单，一般都走索引</li><li>复杂的查询较少</li></ul><p>对CPU要求不是很高，复杂的查询操作如比较、排序、连接等消耗CPU的操作较少发生。OLAP是CPU密集型的操作，OLTP是IO密集型的操作。需注意提高IO。</p><p>未获得更多内存的支持，CPU必须是64位的。InnoDB设计架构，主要的后台操作在一个单独的master thread中完成，不能很好的支持多核的应用。多核CPU应选取InnoDB v1.1或更高版本。可通过参数<code>innodb_read_io_threads</code>和<code>innodb_write_io_threads</code>增大IO的线程，更有效地利用CPU的多核性能。</p><p>当前MySQl版本中，一条SQL语句只能在一个CPU中工作，不支持多CPU的处理。</p><h3 id="内存的重要性"><a href="#内存的重要性" class="headerlink" title="内存的重要性"></a>内存的重要性</h3><p>内存的大小最能直接反映数据库的性能。开发前应预估“活跃”数据库的大小，以此确定数据库服务器内存的大小。通过查看当前服务器的状态，比较物理磁盘的读取和内存读取的比例判断缓冲池的命中率，通常InnoDB engine的缓冲池命中率不应小于99%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show  global status like &apos;innodb%read%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_rnd</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_ahead_evicted</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_read_requests</span><br><span class="line">        Value: 5373</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: Innodb_buffer_pool_reads</span><br><span class="line">        Value: 488</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: Innodb_data_pending_reads</span><br><span class="line">        Value: 0</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: Innodb_data_read</span><br><span class="line">        Value: 8065536</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: Innodb_data_reads</span><br><span class="line">        Value: 549</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: Innodb_pages_read</span><br><span class="line">        Value: 487</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">Variable_name: Innodb_rows_read</span><br><span class="line">        Value: 120</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当前服务器的状态参数：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">Innodb_buffer_pool_reads</td><td style="text-align:center">表示从物理磁盘读取页的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead</td><td style="text-align:center">预读的次数</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_ahead_evicted</td><td style="text-align:center">预读的页，一般用于判断预读的效率</td></tr><tr><td style="text-align:center">Innodb_buffer_pool_read_requests</td><td style="text-align:center">从缓冲池中读取页的次数</td></tr><tr><td style="text-align:center">Innodb_data_read</td><td style="text-align:center">总共读入的字节数</td></tr><tr><td style="text-align:center">Innodb_data_reads</td><td style="text-align:center">发起读取请求的次数，每次读取可能需要读取多个页</td></tr></tbody></table><p>缓冲池命中率 = Innodb_buffer_pool_read_requests / (Innodb_buffer_pool_read_requests +  Innodb_buffer_pool_read_ahead + Innodb_data_reads)</p><p>平均每次读取的字节数=Innodb_data_read /  Innodb_data_reads</p><h3 id="磁盘对数据库性能的影响"><a href="#磁盘对数据库性能的影响" class="headerlink" title="磁盘对数据库性能的影响"></a>磁盘对数据库性能的影响</h3><h4 id="传统机械硬盘"><a href="#传统机械硬盘" class="headerlink" title="传统机械硬盘"></a>传统机械硬盘</h4><p>服务器领域一般使用SAS或SATA接口的硬盘，服务器机械硬盘向小型化转型。</p><p>重要指标：寻道时间、转速。</p><p>通常可将多块机械硬盘组成RAID提高数据库的性能，也可将数据文件分布在不同的磁盘上来达到访问负载的均衡。</p><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><p>基于闪存的硬盘，内部由山村（Flash Memory）组成。具有低延时性、低功耗、防震性等。企业级应用一般使用固态硬盘，通过并联多块闪存进一步提高数据传输的吞吐量。</p><p>闪存是一个完全的电子设备，没有传统机械硬盘的读写磁盘。不需要耗费大量的时间进行磁头旋转和定位来查找数据。固态硬盘可以提供一致的随机访问时间。闪存中的数据是不可更新的，只能通过扇区的覆盖重写，在覆盖重写之前，需要执行耗时的擦除操作。擦除操作不能在所含扇区上完成，需要在删除整个被称为擦除块的基础上完成，擦除块的尺寸大于扇区的大小，通常为128KB或者256KB。每个擦除块有擦写次数限制（已有算法解决）。需要考虑固态硬盘在写入方面存在的问题。</p><p>闪存提供的读写速度是非对称的，读取速度远快于写入的速度。通过增加通道数量，可线性提高固态硬盘的性能。固态硬盘的访问延时一般小于0.1ms左右。</p><p>可通过增加参数<code>innodb_io_capacity</code>的值，充分利用固态硬盘带来高的IOPS特性。InnoSQL及InnoDB  v1.2可选择关闭邻接页的刷新，为数据库带来一定效果的提升。</p><p>可利用InnoSQL开发的L2 Cache解决方案，在内存缓冲池和传统存储层之间建立一层基于闪存固态硬盘的二级缓冲池，以此扩充缓冲池的容量，充分利用固态硬盘的超高速随机读写性能，提高数据库的性能。</p><h3 id="合理地设置RAID"><a href="#合理地设置RAID" class="headerlink" title="合理地设置RAID"></a>合理地设置RAID</h3><h4 id="RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"><a href="#RAID（Redundant-Array-of-Independent-Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。" class="headerlink" title="RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。"></a>RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）基本思想是把多个相对便宜的磁盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。将多个硬盘组合成为一个逻辑扇区，RAID好比一个单独的硬盘或逻辑存储单元，操作系统只会把它当作一个硬盘。</h4><p>RAID作用：</p><ul><li>增强数据集成度</li><li>增强容错功能</li><li>增加处理量或容量</li></ul><p>RAID组合方式：</p><ul><li>RAID 0:将多个磁盘合并成一个大的磁盘，不会有冗余，并行I/O，速度最快。也称为带区集，将多个磁盘并列起来，使之成为一个大磁盘，存放数据时，将数据按照磁盘的个数进行分段，同时将这些数据写进这些盘中。没有冗余功能，若一个磁盘损坏，所有的数据都会丢失。多磁盘效能受限于总I/O瓶颈，RAID效能随边际递减。</li><li>RAID 1:两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，写入速度略降低。除非拥有相同数据的主磁盘与镜像同时损坏，否则只要有一个磁盘正常的工作即可维持工作，可靠性最高，利用率最低。</li><li>RAID 5:兼顾存储性能、数据安全和存储成本。使用Disk Strping（硬盘分区）技术。至少需要三个磁盘，不对存储的数据进行备份，把数据和相对应的奇偶校验信息存储到组成RAID 5的各个磁盘上，奇偶校验信息和相应的数据分别存储于不同的磁盘上，有一个磁盘损坏后，利用剩下额数据相应的奇偶校验信息恢复被损坏的数据。</li><li>RAID 10和RAID 01:RAID 10先镜像再分区数据，将所有磁盘分为两组，视为RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 01于RAID 10程序相反，先分区再将数据镜射到两组硬盘。</li><li>RAID 50:镜像阵列条带，至少由六块硬盘组成，同RAID 0一样，数据被分区称条带，在同一时间内向多块磁盘写入；同RAID 5一样，以数据的校验保证数据的安全，校验条带均匀分布在各个磁盘上，目的在于提高RAID 5的读写性能。</li></ul><p>对数据库，RAID 10是最好的选择，同时兼顾RAID 1和RAID 0的特性。</p><h4 id="RAID-Write-Back功能"><a href="#RAID-Write-Back功能" class="headerlink" title="RAID Write Back功能"></a>RAID Write Back功能</h4><p>指RAID控制器能够将写入的数据放入自身的缓存中，并把他们安排到后面再执行。不同等待物理磁盘实际写入的完成，写入更快。</p><p>数据库或操作系统关机时，Write Back功能可能会破坏数据库的数据。因写入可能还在RAID卡的缓存中，没有完全写入磁盘。为解决此问题大部分硬件RAID卡提供电池备份单元。</p><p>没有启用Write Back功能，则RAID卡设置中显示为Write Through，没有缓冲写入。Write Through模式下，可通过参数<code>innodb_flush_log_at_trx_commit</code>设置为0提高执行存储过程的性能。</p><h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><ul><li>sysbench<a href="https://www.jianshu.com/p/4a37a6a452d9" target="_blank" rel="noopener">基准测试工具Sysbench</a></li><li>mysql-tpcc<a href="https://www.hi-linux.com/posts/38534.html" target="_blank" rel="noopener">TPCC-MySQL 的安装与使用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> majorization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>备份与恢复</title>
      <link href="/2019/09/17/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2019/09/17/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>备份工具：mysqldump、ibbackup、replication、xtrabackup、LVM快照备份等。</p><h3 id="备份与恢复概述"><a href="#备份与恢复概述" class="headerlink" title="备份与恢复概述"></a>备份与恢复概述</h3><p>根据备份方法分：</p><ul><li>Hot Backup（热备份）：数据库运行中直接备份，对正在运行的数据库操作无任何影响，也称为Online Backup（在线备份）。</li><li>Cold Backup（冷备份）：数据库停止时备份，一般只需要复制相关的数据库物理文件，也称为Offline Backup（离线备份）。</li><li>Warm Backup（温备份）：数据库运行中进行备份，会对当前数据库操作有所影响，例如需要加全局读锁以保证备份数据的一致性。</li></ul><p>按备份后文件的内容分：</p><ul><li>逻辑备份：备份的文件可读，一般是文本文件，内容一般由一条条SQL语句或者是表内实际数据组成。可观察到出文件的内容，一般适用于数据库的升级、迁移等工作。恢复时间较长。</li><li>裸文件备份：复制数据库的物理文件，既可以是数据库运行中的复制，也可以是数据库停止运行时直接的数据文件复制，恢复时间较短。</li></ul><p>按备份数据的内容：</p><ul><li>完全备份：对数据库进行一个完成的备份。</li><li>增量备份：在上次完全备份的基础上，对于更改的数据进行备份。</li><li>日志备份：针对MySQL DB二进制日志的备份，通过对一个完全备份进行二进制日志的重做（replay）来完成数据库的point-in-time的恢复工作。</li></ul><p>MySQl数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave/standby）数据库。MySQL未提供真正的增量备份方法，大部分通过二进制日志完成增量备份的工作。效率较真正的增量备份低。</p><p>增量备份只需要记录当前每页最后的检查点的LSN，若大于之前全备份时的LSN，则备份该页，否则不用备份，是xtrabackup工具增量备份的原理。</p><p>数据库备份的一致性要求在备份的时间数据在这一时间点上是一致的。InnoDB engine支持MVCC，实现一致的备份比较简单。可先开启一个事务，然后导出一组相关的表，最后提交，事务的隔离级别必须设置为REPEATABLE READ。</p><p>mysqldump备份工具，可通过添加–single-transaction选项获得InnoDB存储引擎的一致性备份（必i 加选项）。</p><h3 id="冷备"><a href="#冷备" class="headerlink" title="冷备"></a>冷备</h3><p>InnoDB engine冷备需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件（*.idb），重做日志文件。定期备份MySQL数据库的配置文件my.cnf，有利于恢复的操作。</p><p>优点：</p><ul><li>备份简单，只要复制相关文件即可。</li><li>备份文件易于在不同操作系统，不同MySQL版本上进行恢复。</li><li>恢复简单，只需要把文件恢复到指定位置。</li><li>恢复速度快，不需要执行任何SQL语句，不需要重建索引。</li></ul><p>缺点：</p><ul><li>冷备文件通常比逻辑文件大很大，表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。</li><li>不总是可以轻易跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式会成为问题。</li></ul><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>开始用于完成转存数据库备份及不同数据库之间的移植。</p><p>语法：</p><p><code>mysqldump [arguments] &gt; file_name</code></p><p>参数可通过mysqldump –help查看：</p><ul><li>–single-transaction：保证备份的一致性。备份开始前先执行START TRANSACTION命令，一次获得备份的一致性，只对InnoDB engine有效。启用该参数时需确保没有任何其他任何的DDL语句执行，一致性读并不能隔离DDL操作。</li><li>–lock-tables（-l）：备份过程中依次锁住每个架构下的所有表，一般用于MyISAM engine，当备份时只能对数据库进行读取操作，备份依然可以保证一致性。InnoDB engine不需要使用此参数，用–single-transaction， –lock-tables和–single-transaction互斥，不能同时使用。</li><li>–lock-all-tables（-x）：备份过程中对所有表上锁，避免–lock-tables不能同时锁住所有表的问题。</li><li>–add-drop-database：在CREATE DATABASE前先运行DROP DATABASE。需与–all-databases或–databases选型一起使用。默认情况下到处的文本文件中并不会有CREATE DATABASE，除非指定该参数。</li><li>–master-data [=value]：产生的备份转存文件主要用来建立一个replication。value为1时，转存文件中记录CHANGE MASTER语句，值为2时，CHANGE MASTER语句被写出SQL注释。默认值为空。会自动忽略–lock-tables选项，若没有选用–single-transaction则自动使用–lock-all-tables选项。</li><li>–enents（-E）：备份事件调度器。</li><li>–routines（-R）：备份存储过程和函数。</li><li>–triggers：备份触发器。</li><li>–hex-blob：将BINARY、VARBINARY、BLOG和BIT列类型备份为十六进制的格式。mysqldump文件导出的文本文件上述类型在文本文件模式下可能有些字符不可见，添加此选型会以十六进制的方式显示。</li><li>–tab=path（-T path）：产生TAB分割的数据文件。每张表，mysqldump创建一个包含CREATE TABLE语句的table_name.sql文件，和包含数据的tbl_name.txt文件。可使用–fields-terminated=…，–fields-enclosed-by=…，–fields-optionally-enclosed-by=…，–fields-escaped-by=…，–lines-terminated-by=…来改变默认的分隔符、换行符等。</li><li>–where=’where_condition’ (-w ‘where_condition’)：导出给定条件的数据。</li><li>–all-databases: 备份所有数据库</li><li>–databases： 备份指定数据库</li></ul><h4 id="SELECT…INTO-OUTFILE"><a href="#SELECT…INTO-OUTFILE" class="headerlink" title="SELECT…INTO OUTFILE"></a>SELECT…INTO OUTFILE</h4><p>逻辑备份方法，道出一张表中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT [column 1],[column 2] ...</span><br><span class="line">INTO</span><br><span class="line">OUTFILE &apos;file_name&apos;</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINES</span><br><span class="line">[SATRTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">FROM TABLE WHERE ...</span><br></pre></td></tr></table></figure><p>FIELDS[TERMINATED BY ‘string’]表示每个列的分隔符，[[OPTIONALLY] ENCLOSED BY ‘char’]表示对于字符串的包含符，[ESCAPED BY ‘char’]表示转义符。[STARTING BY ‘string’]表示每行的开始符号，[TERMINATED BY ‘string’]表示每行的结束符号。没指定FIELDS和LINES选型时的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLELDS TERMINATED BY &apos;\t&apos; ENCLOSED BY &apos;&apos; ESCAPED BY &apos;\\&apos;</span><br><span class="line">LINES TERMINATED BY &apos;\n&apos; STARTING BY &apos;&apos;</span><br></pre></td></tr></table></figure><p>file_name表示导出的文件，路径权限必须是mysql：mysql的。</p><h4 id="逻辑备份的恢复"><a href="#逻辑备份的恢复" class="headerlink" title="逻辑备份的恢复"></a>逻辑备份的恢复</h4><p>mysqldump只需执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p &lt; test_backup.sql</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>导入时包含了创建和删除数据库的SQL语句，须确保删除架构时，架构目录下没有其他与数据相关的文件。</p><p>mysqldump可导出存储过程、导出触发器、导出事件、导出数据，不能导出视图。需导出视图定义或备份视图定义的frm文件，在恢复时进行导入。</p><h4 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a>LOAD DATA INFILE</h4><p>通过mysqldump-tab或者SELECT INTO OUTFILE导出的数据，可通过命令LOAD DATA INFILE进行导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[REPLACE | IGNORE] </span><br><span class="line">INTO TABLE tbl_name</span><br><span class="line">[CHARACTER SET charset_name]</span><br><span class="line">[</span><br><span class="line">&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &apos;char&apos;]</span><br><span class="line">[ESCAPED BY &apos;char&apos;]</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">LINE </span><br><span class="line">[STARTING BY &apos;string&apos;]</span><br><span class="line">[TERMINATED BY &apos;string&apos;]</span><br><span class="line">]</span><br><span class="line">[IGNORE number LINES]</span><br><span class="line">[(col_name_or_user_var,...)]</span><br><span class="line">[SET col_name=expr,...]</span><br></pre></td></tr></table></figure><p>需拥有INFILE权限。导入格式的选项同SELECT INTO OUTFILE命令一致。IGNORE number LINES可忽略导入的前几行。</p><h4 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h4><p>MySQL DB提供的命令行程序，时LOAD DATA INFILE的命令接口，大多数选项与LOAD DATA INFILE语法相同。</p><p><code>mysqlimport [option] db_name textfile1 [textfile2 ...]</code></p><p>该命令可用来导入多张表，通过–user-thread参数并发导入不同的文件。</p><h3 id="二进制日志备份与恢复"><a href="#二进制日志备份与恢复" class="headerlink" title="二进制日志备份与恢复"></a>二进制日志备份与恢复</h3><p>可通过二进制日志完成point-in-time的恢复工作。MySQL DB replication同样需要二进制日志。默认并不启用二进制日志，需先启用。在配置文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">sync-binlog=1</span><br><span class="line">innodb_support_xa=1</span><br></pre></td></tr></table></figure><p>备份二进制日志文件前，可通过FLUSH LOGS命令生成一个新的二进制日志文件，然后备份之前的二进制日志文件。</p><p>恢复二进制日志，通过mysqlbinlog：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log_file | mysql -u root -p</span><br></pre></td></tr></table></figure><p>恢复多个二进制日志文件应该同时恢复，而不是一个一个地恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog.[0-10]* | mysql -u root -p</span><br></pre></td></tr></table></figure><p>可通过mysqlbinlog导入到一个文件再通过SOURCE命令导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog binlog_file1 &gt; binglog_file</span><br><span class="line">mysqlbinlog binlog_file2 &gt;&gt; binlog_file</span><br><span class="line">mysql -u root -p -e &quot;scorce binlog_file&quot;</span><br></pre></td></tr></table></figure><p>–start-position和–stop-position选项可指定二进制日志的某个偏移量来进行恢复，可跳过某些不正确的语句。–start-datetime和–stop-datetime选项可用来指定从二进制的某个时间点进行恢复。用法一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinglog --start-position=199512 binlog_file | mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="热备"><a href="#热备" class="headerlink" title="热备"></a>热备</h3><h4 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h4><p>InnoDB engine提供的热备份工具，可同时备份MyISAM engine和InnoDB engine。</p><p>对InnoDB engine table备份工作原理：</p><ul><li>记录备份开始时，InnoDB engine重做日志文件检查点的LSN。</li><li>复制共享表空间文件以及独立表空间文件。</li><li>记录复制完成表空间文件后，InnoDB engine重做日志文件检查点的LSN。</li><li>复制在备份时产生的重做日志</li></ul><p>优点：</p><ul><li>在线备份，不阻塞任何SQL语句。</li><li>备份性能好，实质是复制数据库文件和重做日志文件。</li><li>支持压缩备份，通过选项，可支持不同级别的压缩。</li><li>跨平台支持，ibbackup可运行在Linux、Windows以及主流的Unix系统平台上。</li></ul><p>ibbackup恢复InnoDB engine table：</p><ul><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ul><p>xtrabackup实现了ibbackup的功能，拓展支持了真正的增量备份功能。</p><h4 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h4><p>网址：<a href="https://launchpad.net/percona-xtrabackup" target="_blank" rel="noopener">xtrabackup</a>。</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup --backup | --prepare [OPTIONS]</span><br></pre></td></tr></table></figure><p>开始备份时，首先记录重做日志的位置，然后对备份的InnoDB engine table的物理文件，即共享表空间文件和独立表空间文件进行复制，最后记录备份完成后的重做日志位置。</p><h4 id="xtrabackup实现增量备份"><a href="#xtrabackup实现增量备份" class="headerlink" title="xtrabackup实现增量备份"></a>xtrabackup实现增量备份</h4><p>原理：</p><ol><li>先完成一个全备，记录下此时额检查点LSN。</li><li>增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，是则备份该页，同时记录当前检查点的LSN。</li></ol><h3 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h3><p>通过文件系统支持的快照功能对数据库进行备份。前提是将所有数据库文件放在同一文件分区中，然后对分区进行快照操作。支持快照功能的文件系统和设备有FreeBSD的UFS文件系统，Solaris的ZFS文件系统，GUN/Linux的逻辑管理器（Logical Volume Manager，LVM）等。UFS和ZFS的快照实现大致和LVM相似。</p><p>LVM使用写时复制（Copy-on-write）技术创建快照。</p><p>参阅<a href="https://www.cnblogs.com/kevingrace/p/6129660.html" target="_blank" rel="noopener">Mysql备份系列（4）–lvm-snapshot备份mysql数据(全量+增量）操作记录</a>。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制（replication）是MySQL DB提供的一种高可用高性能解决方案，一般用于建立大型应用。步骤：</p><ul><li>主服务器（master）把数据更改记录到二进制日志（binlog）中。</li><li>从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</li><li>从服务器重做中继日志中的重做日志，把更改应用到自己的数据库上，以达到数据的最终一致。</li></ul><p>实质是一个完全备份加上二进制日志备份的还原。复制是异步实时的，存在主动服务器之间的执行延时。可通过SHOW SLAVE STATUS和SHOW MASTE STATUS查看当前的延时。</p><p>主要变量：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Slave_IO_State</td><td style="text-align:center">当前IO线程的状态</td></tr><tr><td style="text-align:center">Master_Log_File</td><td style="text-align:center">当前同步的主服务器的二进制日志</td></tr><tr><td style="text-align:center">Read_Master_Log_Pos</td><td style="text-align:center">显示当前同步到主服务器上二进制日志的偏移量位置，单位字节。</td></tr><tr><td style="text-align:center">Relay_Master_Log_File</td><td style="text-align:center">当前中继日志同步的二进制日志</td></tr><tr><td style="text-align:center">Relay_Log_File</td><td style="text-align:center">显示当前写入的中继日志</td></tr><tr><td style="text-align:center">Relay_Log_Log</td><td style="text-align:center">显示当前执行到中继日志的便宜量位置</td></tr><tr><td style="text-align:center">Slave_IO_Running</td><td style="text-align:center">从服务器中IO线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Slave_SQL_Running</td><td style="text-align:center">从服务器中SQL线程的运行状态，YES代表正常</td></tr><tr><td style="text-align:center">Exec_Master_Log_Pos</td><td style="text-align:center">表示同步到主服务器的二进制日志偏移量的位置，Read_Master_Log_Pos-Exec_Master_Log_Pos可表示当前SQL线程运行的延时，单位是字节。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> backup </tag>
            
            <tag> recovery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事务</title>
      <link href="/2019/09/16/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/09/16/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>事务把数据库从一种一致状态转换为另一种一致状态。</p><h3 id="认识事务"><a href="#认识事务" class="headerlink" title="认识事务"></a>认识事务</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是访问并更新数据库中各种数据项的一个程序执行单元。</p><p>A(Atomicity)，原子性。整个数据库事务是不可分割的工作单位。对只读操作发生错误，要么重试要么返回错误代码。但对于需要改变系统中状态的操作，若操作失败，需要保护系统中并发用户访问受影响的部分数据。</p><p>C(Consistency)，一致性。事务将数据库从一种状态转变为下一种一致的状态。事务开始前后，数据库的完整性约束没有被破坏。</p><p>I(Isolation)，隔离性。也称并发控制、锁、可串行化等。要求每个读写事务的对象对其他其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，通常用锁来实现。粒度锁（granular lock）策略，允许事务仅锁住一个实体对象的子集，以此提高事务之间的并发度。</p><p>D(Durability)，持久性。事务一旦提交，结果就是永久性的。持久性保证事务系统的高可靠性，非高可用性。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>事务理论角度：</p><ul><li>扁平事务（Flat transactions），使用最为频繁的事务。扁平事务中，所有操作都处于同一层次，由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。</li><li>带有保存点的扁平事务（Flat Transaction with Savepoints），除支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。保存点（Savepoint）通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。扁平事务隐式设置且整个事务中只有一个保存点，回滚只能回滚到事务开始时的状态。保存点SAVE WORK函数建立，通知系统当前的处理状态。出现问题时，保存点作为内部重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。保存点在事务内部递增，ROLLBACK不影响保存点的计数，递增编号能保持事务执行的整个历史过程。</li><li>链事务（Chained Transaction），保存点模式的变种。当系统崩溃时，扁平事务的保存点都将消失，恢复时，事务从开始处重新执行，不能从最近的一个点继续执行，保存点是易失的非持久的。链事务：在提交一个事务时，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作。扁平事务能回滚到任意正确的保存点，链事务回滚仅限于当前事务，只能恢复到最近一个的保存点。对于锁，链事务在执行COMMIT后释放当前事务所持有的锁，带保存点的扁平事务不影响其所持有的锁。</li><li>嵌套事务（Nested Transaction），层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（sub transaction），控制每一个局部的变换。</li><li>分布式事务（Distributed transaction），通常是一个在分布式环境下运行的扁平事务，需要根据数据所在的位置访问网络中的不同节点。</li></ul><p>Moss对嵌套事务的的定义：  </p><ol><li>由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。 </li><li>处在叶子节点的事务是扁平事务，每个子事务从根节点到叶节点的距离可以是不同的。</li><li>位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为（predecessor）为父事务（parent），事务的下一层为儿子事务（child）。</li><li>子事务既可以提交也可以回滚，并不会马上生效，需等待父事务提交。</li><li>书中任何一个事务的回滚会引起它的所有子事务一同回滚，子事务仅保留A、C、I特性，不具有D特性。</li></ol><p>Moss理论中实际工作由叶子节点来完成，只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。高层的事务仅负责逻辑控制，决定何时调用相关的子事务。</p><p>InnoDB支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的隔离性由锁实现。原子性、一致性、持久性通过数据库的redo log和undo log完成。redo log（重做日志）保证事务的原子性和持久性，undo log保证事务的一致性。</p><p>redo log恢复提交事务修改的页操作，undo log回滚记录到某个特定版本。两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行修改记录进行记录。</p><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>重做日志实现事务的持久性，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的。</p><p>InnoDB通过Force Log at Commit机制实现事务的持久性，当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成。此处日志分为redo log和undo log。前者宝成事务的持久性，后者帮助事务会回滚及MVCC的功能。redo log基本是顺序写的，undo log需要进行随机读写。</p><p>为确保每次日志写入重做日志文件，每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（同步内存中所有已修改的文件数据到存储设备）操作。重做日志文件打开没有使用O_DIRECT选项，重做日志缓冲先写入文件系统缓存。为确保重做日志写入磁盘，必须进行一次fsync操作。fsync的效率取决于磁盘的性能，磁盘的性能决定了事务提交的性能，即数据库的性能。</p><p>允许手工设置非持久性的情况发生，提高数据库的性能。此时事务提交时，日志不写入重做日志文件，等待下一个时间周期后再执行fsync操作。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，该参数的默认值为1，表示事务提交时必须调用一次fsync操作。可设置为0和2。0表示提交事务时不进行写入重做日志操作，操作仅在master thread中完成，master thread中每一秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入重做日志文件的缓存中，不进行fsync操作。</p><p>二进制日志文件bin log，用于进行POINT_IN_TIME（PIT）的恢复及主从复制（Replication）环境的建立。</p><p>重做日志在InnoDB存储引擎层产生，二进制日志在MySQL数据库的上层产生，二进制日志不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生二进制日志。MySQL上层的二进制日志是一种逻辑日志，记录的是对应的SQL语句，InnoDB存储引擎层的重做日志是物理格式日志，记录的是对于每个页的修改。二进制日志只在事务提交完成后进行一次写入，InnoDB存储引擎的重做日志在事务进行中不断地被写入，表现为日志并不是随事务提交的顺序进行写入的。</p><h5 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h5><p>InnoDB engine中重做日志以512字节进行存储的，意味着重做日志缓存、重做日志文件都是以块的方式进行保存的，称之为重做日志块（redo log block）。</p><p>若一个页产生的重做日志数量大于512字节，则需要分割为多个重做日志块进行存储。重做日志块的大小和扇区大小一样，重做日志的写入可保证原子性，不需要doublewrite技术。</p><p>重做日志块除日志本身外还由日志块头（log block header）及日志块尾（log block tailer）两部分组成。重做日志块头占用12字节，重做日志块尾占用8字节，每个重做日志块实际可存储的大小为492字节。</p><p>log block header由4个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用字节</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LOG_BLOCK_HDR_NO</td><td style="text-align:center">4</td><td style="text-align:center">标记log block在logbuffer中的位置，递增且循环使用，第一位用于判断是否是flush bit</td></tr><tr><td style="text-align:center">LOG_BLOCK_HDR_DATA_LEN</td><td style="text-align:center">2</td><td style="text-align:center">表示log block所占用的大小，当log block写满时，值为0x200，表示使用全部log block空间，即占用512字节</td></tr><tr><td style="text-align:center">LOG_BLOCK_FIRST_REC_GROUP</td><td style="text-align:center">2</td><td style="text-align:center">表示log block中第一个日志所在的偏移量，若等于LOG_BLOCK_HDR_DATA_LEN，表示当前log block不包含新的日志</td></tr><tr><td style="text-align:center">LOG_BLOCK_CHECKPOINT_NO</td><td style="text-align:center">4</td><td style="text-align:center">表示该log block最后被写入时检查点第4字节的值。</td></tr></tbody></table><p>log block tailer只由一个部分组成，值和LOG_BLOCK_CHECKPOINT_NO相同，并在函数log_block_init中被初始化。</p><h5 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h5><p>重做日志组，由多个重做日志文件。源码已支持log group的镜像功能，但在ha_innobase.cc文件中禁止该功能。InnoDB engine实际只有一个log group。</p><p>逻辑上的概念，并无实际物理文件表示log group信息。每个log group中日志文件大小相同，InnoDB v1.2前，重做日志文件总大小小于4GB，此版本开始大小限制提高为512GB。</p><p>重做日志文件中存储的是在log buffer中保存的log block，根据块的方式进行物理存储的管理，每个块大小与log block一样为512字节。log buffer根据一定规则将内存中的log block刷新到磁盘：</p><ul><li>事务提交时</li><li>log buffer中有一半的内存空间已经被使用时</li><li>log checkpoint时</li></ul><p>log block的写入为追加到redo log file的最后部分，当一个redo log被写满时，会接着写入下一个redo log file，使用方式为round-robin。redo log file除了保存log buffer刷新到磁盘的log block，还保存其他共占2KB大小的信息，每个redo log file的前2KB部分不保存log block信息。</p><p>log group中的第一个redo log file前2KB保存4个512字节大小的块，存放内容为：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小 </th></tr></thead><tbody><tr><td style="text-align:center">log file header</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint1</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">空</td><td style="text-align:center">512 </td></tr><tr><td style="text-align:center">checkpoint2</td><td style="text-align:center">512 </td></tr></tbody></table><p>仅在每个log group的第一个redo log file中进行存储，其余redo log file仅保留这些空间，但不保存上述信息。</p><p>写入redo log file时，除了log block的写入，还需要更新前2KB部分的信息，这些信息用于InnoDB engine恢复操作。log file header后面的部分为InnoBD存储引擎保存的checkpoint(检查点)值，设计为交替写入，避免因介质失败而导致无法找到可用的checkpoint的情况。</p><h5 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h5><p>InnoDB engine存储管理基于页，重做日志格式也是基于页的。其重做日志格式有着通用的头部格式。</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo log body</th></tr></thead><tbody><tr><td style="text-align:center">重做日志的类型</td><td style="text-align:center">表空间的ID</td><td style="text-align:center">页的偏移量</td><td style="text-align:center">存储内容  </td></tr></tbody></table><h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>Log Sequence Number的缩写，代表着日志序列号，InnoDB存储引擎中，占用8字节，单调递增。表示：</p><ul><li>重做日志写入的总量</li><li>checkpoint的位置</li><li>页的版本</li></ul><p>存在于每个页的头部，值FIL_PAGE_LSN，记录该页的LSN，表示该页最后刷新时LSN的大小。可用于根据重做日志的LSN比较页的LSN判断是否需要进行恢复操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5337425</span><br><span class="line">Log flushed up to   5337425</span><br><span class="line">Pages flushed up to 5337425</span><br><span class="line">Last checkpoint at  5337416</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">182 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Log sequence number表示当前的LSN，Log flushed up to表示刷新到重做日志文件的LSN，Pages flushed up to表示已经刷新到磁盘数据页上的LSN，Last checkpoint at表示刷新到磁盘的LSN。</p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>InnoDB eigine不管上次DB运行是否正常关闭，都会尝试进行恢复操作。</p><p>恢复过程中仅需恢复checkpoint开始的日志部分，即LSN记录开始的重做日志。</p><h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>利用undo信息对事务进行回滚到数据之前的样子。</p><p>undo存放在数据库内部的一个特殊段（segment）中，称为undo段（undo segment）。undo段位于共享表空间内。</p><p>undo是逻辑日志，只是将数据库逻辑地恢复到原来的样子，修改被逻辑地取消，由于可能存在其他用户对页上其他非锁定记录的修改，数据结构和页本身在回滚之后可能大不相同。</p><p>InnoDB engine回滚时，实际上做的是与先前相反的工作，对于每个INSERT，执行一个DELETE；对于每一个DELETE，会执行一个INSERT；对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。</p><p>undo的另一个作用是MVCC，当用户读取一行数据时，若该记录已经被其他事务占用，则当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><p>undo log会产生redo log，undo log需要持久性的保护。</p><h5 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h5><p>采用段的方式管理undo。InnoDB eigine有rollback segment，每个rollback segment记录了1024个undo log segment，每个undo log segment中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有的rollback segment header所在的页，页类型为FIL_PAGE_TYPE_SYS。</p><p>InnoDB v1.1前只有一个rollback segment，支持同时在线的事务限制为1024，1.1开始支持最大128个rollback segment，，支持同时在线的事务限制提高到128*1024.</p><p>InnoDB v1.2开始可通过参数对rollback segment进行设置：</p><ul><li><code>innodb_undo_directory</code>，设置rollback segment文件所在的路径，rollback segment可以存放在共享表空间之外的位置。</li><li><code>innodb_undo_logs</code>，设置rollback segment的个数，默认128，替换之前的参数<code>innodb_rollback_segments</code>。</li><li><code>innodb_undo_tablespaces</code>，设置构成rollback segment文件的数量，使rollback segment可以较平均分布在多个文件中。设置后可在路径<code>innodb_undo_directory</code>看到undo为前缀的文件，代表rollback segment文件。</li></ul><p>undo log segment分配页并写入undo log时同样需要写入重做日志，事务提交时，InnoDB会：</p><ul><li>将undo log放入列表，以供之后的purge操作。</li><li>判断undo log所在的页是否可以重用，若可以则分配给下一个事务使用。</li></ul><p>事务提交后不能马上删除undo log及undo log所在的页，可能有其他事务需要通过undo log取得行记录之前的版本，事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在的页由purge线程判断。</p><p>InnoDB engine中undo页可以进行重用，事务提交时，首先将undo log放入链表，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面。存放undo log的列表以记录进行组织，undo页可能存放着不同事务的undo log，purge操作需要涉及磁盘的离散读取操作，比较缓慢。</p><p>通过SHOW ENGINE INNODB STATUS查看链表中undo log的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46329</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>History list length代表undo log的数量，purge操作会减少该值。由于undo log所在的页可以被重用，操作后，改值也未必为0。</p><h5 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h5><p>参考<a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB undo log 漫游</a>。</p><p>分为：</p><ul><li>insert undo log，在insert操作过程中产生的undo log，insert操作只对事务本身可见，对其他事务不可见，事务提交后直接删除。不需要进行purge操作。</li><li>undapte undo log，对delete和update操作产生的undo log。可能需要提供MVCC机制，不能在事务提交后立即删除，提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul><p>undapte undo log较insert undo log记录的内容更多，占用的空间更大，undapte undo log又分为(type_cmpl值)：</p><ul><li>TRX_UNDO_UPD_EXIST_REC（=12），更新non-delete-mark的记录</li><li>TRX_UNDO_UPD_DEL_REC（=13），将delete的记录标记为not delete</li><li>TRX_UNDO_DEL_MARK_REC（=14）， 将记录标记为delete</li></ul><h5 id="查看undo信息"><a href="#查看undo信息" class="headerlink" title="查看undo信息"></a>查看undo信息</h5><p>InnoDB engine DBA只能通过原理和经验来判断。InnoSQL对information_schema拓展添加数据字典表<code>INNODB_TRX_ROLLBACK_SEGMENT</code>和<code>INNODB_TRX_UNDO</code>来查看undo信息，前者用于查看rollback segment，后者用于记录事务对应的undo log，方便了解事物产生的undo量。</p><p>delete操作并不直接删除记录，将记录标记为已删除（delete flag设置为1），记录的最终删除在purge中完成。update主键的操作分两步完成，先将原主键标记为已删除，需要产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log，之后插入一条新的记录，需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。</p><h4 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h4><p>purge最终完成delete和update操作，InnoDB支持MVCC，记录不能在事务提交时立即进行处理。因为其他事务可能正在引用这行，需要保存记录之前的版本。当该行记录不被任何其他事务引用，就可以进行真正的delete操作，清理之前行记录的版本。</p><p>InnoDB有一个histroy列表，根据事务提交的顺序，将undo log进行链接，先提交的事务总在尾端。</p><p>purge过程中，先在histroy list中找到第一个需要被清理的记录，清理之后会在被清除记录的undo log所在页继续寻找是否存在可以被清理的记录，有则清理，没有则返回histroy list中查找继续按此步骤清理。此法避免了大量的随机读取，提高purge效率。</p><p>动态参数<code>innodb_purge_batch_size</code>用于设置每次purge操作需要清理的undo page数量。InnoDB v1.2前默认20，此v开始默认300。动态参数<code>innodb_max_purge_lag</code>用于控制histroy list的长度，默认为0，表示不对其做限制，当大于0时，表示会延缓DML操作。延缓算法：<br><code>delay = ((length(histroy_list) - innodb_max_purge_lag) * 10) - 5</code></p><p>单位毫秒，对象是行，delay会在每次purge操作后重新计算。InnoDB v1.2后引入动态参数<code>innodb_max_purge_lag_delay</code>控制delay的最大毫秒数，当计算得到的delay值大于该值时，取<code>innodb_max_purge_lag_delay</code>，避免purge操作缓慢导致其他SQL线程无限制等待。</p><h4 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h4><p>非只读事务，每次事务提交时需要进行一次fsync操作，保证重做日志都已经写入磁盘。fsync性能有限，为提高效率，提供group commit功能，一次fsync可以刷新确保多个事务日志被写入文件。InnoDB事务提交时进行两个阶段操作：</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync将确保日志都从重做日志缓冲写入磁盘。</li></ol><p>步骤2相对步骤1慢，有事务进行步骤2时，其他事务可进行事务1，事务完成提交后，再次进行步骤2，将多个事务的重做日志通过一次fsync刷新到磁盘，减少磁盘的压力，提高性能。</p><p>InnoDB v1.2前，开启二进制日志InnoDB存储引擎的group commit功能会失效，导致性能下降。开启二进制日志为保证存储引擎层中事务和二进制日志的一致性，二者之间使用了两阶段事务：</p><ol><li>事务提交时InnoDB engine进行purge操作</li><li>MySQL数据库上层写入二进制日志。</li><li><p>InnoDB存储引擎将日志写入重做日志文件。</p><ol><li>修改内存中事务对应的信息，将日志写入重做日志缓冲。</li><li>调用fsync确保日志都从重做日志缓冲写入磁盘。</li></ol></li></ol><p>一旦步骤2完成，就确保了事务的提交，即使步骤3时发生宕机。但每个步骤都进行一次fsync操作才能保证上下两层数据的一致性。步骤2的fsync参数由参数<code>fsync_binlog</code>控制，步骤3的fsync由参数<code>innodb_flush_log_at_trx_commit</code>控制。MySQL内部使用<code>prepare_commit_mutex</code>锁保证上层二进制日志的写入顺序与InnoDB层事务提交顺序一致。启用锁后步骤3中的步骤1不可以在其他事务执行步骤3的步骤2时执行，导致group commit失效。</p><p>MySQL v5.6实现了Binary Log Group Commit（BLGC）解决此问题，在上层提交时先按顺序将其放入一个队列中，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。BLGC步骤：</p><ul><li>Flush阶段，将每个事务的二进制日志写入内存中。</li><li>Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，仅一次fsync操作完成二进制日志的写入，即BLGC。</li><li>Commit阶段，leader根据顺序调用存储引擎层事务的提交，修复由于锁<code>prepare_commit_mutex</code>导致group commit失效问题。</li></ul><p>当有一组事务提交时，其他新事务可以进行Flush阶段，使group commit不断生效。group commit的效果由队列中事务的数量决定，若每次队列中仅有一个事务，效果同之前可能会更差。提交的事务越多，group commit效果越明显。</p><p>参数<code>innodb_max_flush_queue_time</code>控制Flush阶段中等待的时间，即使之前的一组事务完成提交，当前一组事务也不马上进入Sync阶段，至少需要等待一段时间。使group commit的事务数量更多，可能导致事务响应时间变慢。参数默认值0，推荐设置也为0。</p><h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下，事务自动提交的，执行SQL语句后会马上执行COMMIT操作。</p><p>事务控制语句：</p><ul><li>START TRANSACTION | BEGIN：显示地开启一个事务。存储过程中，MySQL DB分析器会自动将BEGIN识别为BEGIN…END，存储过程中只能使用START TRANSACTION语句开启事务。</li><li>COMMIT：提交事务，使得已对数据库所做的所有修改称为永久性的。可直接发出COMMIT，也可写为等价语句COMMIT WORK。后者控制事务结束后的行为是CHAIN还是RELEASE的，是CHAIN方式，则事务变成链事务。通过参数<code>completion_type</code>进行控制，默认为0，表示没有任何操作，两者等价，设为1时，后者等价COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。</li><li>ROLLBACK：回滚结束事务，并撤销正在进行的所有未提交的修改。可直接发出ROLLBACK，也可写为等价语句ROLLBACK WORK。工作同上方语句。</li><li>SAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。</li><li>RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句会抛出一个异常。</li><li>ROLLBACK TO[SAVEPOINT] identifier：与SAVEPOINT命令一起使用，把事务回滚到标记点，而不回滚在此标记点之前任何工作。回滚到一个不存在的保存点会抛出异常。该语句并不是真正地结束一个事务，执行后任然需要显示地执行COMMIT或者ROLLBACK命令。</li><li>SET TRANSACTION：设置事务的隔离级别。InnoDB提供的隔离级别有：READ UNCOMMITTED、READCOMMITTD、REPEATABLE READ、SERIALIZABLE。</li></ul><p>事务是原子的，构成事务的每条语句都会提交或者所有语句都会回滚，一条语句要么完全成功要么完全回滚。一条语句失败并抛出异常时，并不会导致先前已执行的语句自动回滚，所有的执行都会得到保留， 由用户决定是否对事务进行提交或者回滚。</p><h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><p>执行语句后会有一个隐式的COMMIT操作的SQL语句：</p><ul><li>DDL语句：ALTER DATABASE…UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRUNCATE TABLE。</li><li>隐式修改MySQL机构操作：CREATE USER，DROP USER，GRANT，RENAME USER，REVOKE，SET PASSWORD。</li><li>管理语句：ANALYZE TABLE，CACHE INDEX，CHECK TABLE，LOAD INDEX INTO CACHE，OPTIMIZE TABLE，REPAIR TABLE。</li></ul><p>TRUNCATE TABLE语句是DDL，和对整张表执行DELETE操作结果一样，但不能被回滚。</p><h3 id="对事务操作的统计"><a href="#对事务操作的统计" class="headerlink" title="对事务操作的统计"></a>对事务操作的统计</h3><p>在考虑每秒请求数（Question Per Second，QPS）的同时，关注每秒事务处理（Transaction Per Second，TPS）的能力。</p><p>所有事务显示提交：<code>TPS = (com_commit + com_rollback) / time</code>，隐式提交和回滚不会计算到com_commit和com_rollback变量中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;com_commit&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_commit</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like &apos;com_rollback&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Com_rollback</span><br><span class="line">        Value: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数handle_commit和handle_rollback用于事务统计。MySQL v5.1中可统计InnoDB engine显示和隐式的事务提交操作，在InnoDB Plugin中不准确。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL标准事务隔离级别：</p><ul><li>READ UNCOMMITTED：浏览访问。</li><li>READ COMMITTED：游标稳定。除唯一性的约束检查及外键约束的检查需要gap lock，engine 不会使用gap lock的锁算法。MySQl v5.1会导致主从数据不一致问题。</li><li>REPEATABLE READ：无幻读保护。</li><li>SERIALIZABLE：隔离。InnoDB为每个SELECT语句后自动加上LOCK IN SHARE MODE，即为读取加共享锁，对一致性的非锁定读不在于以支持。主要用于InnoDB engine的分布式事务。</li></ul><p>SQL和SQL2的默认事务隔离级别为SERIALIZABLE，InnoDB默认隔离级别为REPEATABLE READ，采用Next-Key Lock锁算法避免幻读。</p><p>级别越低事务请求锁越少或保持锁的时间越短。</p><p>设置当前回话或全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL</span><br><span class="line">&#123;</span><br><span class="line">READ UNCOMMITTED</span><br><span class="line">| READ COMMITTED</span><br><span class="line">| REPEATABLE READ</span><br><span class="line">| SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过修改MySQL配置文件，在MySQL启动时设置事务默认隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">transaction-isolation = READ UNCOMMITTED</span><br></pre></td></tr></table></figure><p>查看当前事务隔离级别和全局事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.tx_isolation: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务指允许多个独立的事务资源（transaction rescourcs）参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，对于事务原有的ACID要求有了提高。</p><h4 id="MySQL数据库分布式事务"><a href="#MySQL数据库分布式事务" class="headerlink" title="MySQL数据库分布式事务"></a>MySQL数据库分布式事务</h4><p>分布式事务</p><p>InnoDB engine提供对XA事务的支持，通过XA事务来支持分布式事务的实现。使用分布式事务时，InnoDB engine的事务隔离级别必须设置为SERIALIZABLE。</p><p>XA事务允许不同数据库之间的分布式事务，需要参与在全局事务中的每个节点都支持XA事务。XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p><ul><li>资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。</li><li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li><li>应用程序：定义事务边界，指定全局事务中的操作。</li></ul><p>MySQL DB分布式事务中，资源管理器是MySQL数据库，事务管理器为连接MySQL服务器的客户端。</p><p>分布式事务使用两段式提交（two-phase commit）的方式。第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好了。第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。若任何一个节点显示不能提交，则所有的节点都被告知需要回滚。与本地事务相比，分布式事务需要多一次PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或者ROLLBACK操作。</p><p>MySQL数据库XA事务的SQL语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XA &#123;START | BEGIN&#125; xid [JOIN | RESUME]</span><br><span class="line"></span><br><span class="line">XA END xid [SUSPEND [FOR MIGRATE]]</span><br><span class="line"></span><br><span class="line">XA PREPARE xid</span><br><span class="line"></span><br><span class="line">XA COMMIT xid [ONE PHASE]</span><br><span class="line"></span><br><span class="line">XA ROLLBACK xid</span><br><span class="line"></span><br><span class="line">XA RECOVER</span><br></pre></td></tr></table></figure><p>通过参数<code>innodb_support_xa</code>查看是否启用了XA事务的支持，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_support_xa&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_support_xa</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h4><p>外部事务：资源管理器是MySQL数据库本身。</p><p>内部XA事务：在存储引擎与插件之间，或者存储引擎与存储引擎之间</p><p>常见的内部XA事务存在于binlog与InnoDB存储引擎之间。事务提交时，InnoDB engine先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，若在InnoDB engine提交前宕机，MySQL DB重启后会先检查准备的UXID事务是否已经提交，若没有则在存储引擎层再进行一次提交操作。能够避免二进制日志写入后宕机，传给从数据库二进制日志并执行，导致主从数据库不一致问题。</p><h3 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h3><ul><li>在循环中提交：不论是现实的提交还是隐式的提交。</li><li>使用自动提交：应在程序端进行事务的开始和结束。对不同语言的API，自动提交不同。</li><li>使用自动回滚：InnoDB engine支持通过定义一个HANDLER来进行自动事务的回滚操作，如在一个存储过程中发生了错误会自动对其进行回滚操作。</li></ul><h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><p>执行时间较长的事务。对长事务，转化为小批量的事务进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>锁</title>
      <link href="/2019/09/11/%E9%94%81/"/>
      <url>/2019/09/11/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><p>InnoDB存储引擎在行级别上对表数据上锁，也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，锁保证一致性。</p><p>InnoDB锁的实现类似Oracle，提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，可以同时得到并发性和一致性。</p><h3 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h3><p>DB中，lock和latch都可以被称为“锁”。</p><p>latch一般称为闩锁（轻量级的锁），要求锁定的时间必须非常短，若持续的时间长，应用的性能会非常差。InnoDB中，latch分为mutex（互斥量）和rwlock（读写锁），目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或roolback后进行释放（不同事物隔离级别释放的时间可能不同）。</p><p>lock和latch的不同：</p><table><thead><tr><th style="text-align:center">比较项</th><th style="text-align:center">lock</th><th style="text-align:center">latch</th></tr></thead><tbody><tr><td style="text-align:center">对象</td><td style="text-align:center">事务</td><td style="text-align:center">线程</td></tr><tr><td style="text-align:center">保护</td><td style="text-align:center">数据库内容</td><td style="text-align:center">内存数据结构</td></tr><tr><td style="text-align:center">持续时间</td><td style="text-align:center">整个事务过程</td><td style="text-align:center">临界资源 </td></tr><tr><td style="text-align:center">模式</td><td style="text-align:center">行锁、表锁、意向锁</td><td style="text-align:center">读写锁、互斥量</td></tr><tr><td style="text-align:center">死锁</td><td style="text-align:center">通过waits-for graph、time out等机制进行死锁检测与处理</td><td style="text-align:center">无死锁检测与处理机制。仅通过应用程序加锁的顺序（lock leveling）保证无死锁的情况发生</td></tr><tr><td style="text-align:center">存在于</td><td style="text-align:center">Lock Manage的哈希表中</td><td style="text-align:center">每个数据结构的对象中</td></tr></tbody></table><p>通过命令<code>SHOW RNGINE INNODB MUTEX</code>查看InnoDB中的latch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb mutex;</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| Type   | Name                      | Status   |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:2730 | waits=2  |</span><br><span class="line">| InnoDB | rwlock: dict0dict.cc:1183 | waits=10 |</span><br><span class="line">| InnoDB | rwlock: log0log.cc:838    | waits=15 |</span><br><span class="line">+--------+---------------------------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在Debug模式下Status列展示更多信息:</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">mutex被请求的次数</td></tr><tr><td style="text-align:center">spin_waits</td><td style="text-align:center">spin lock(自旋锁)的次数，InnoDB engine latch在不能获得锁时首先进行自旋，若自旋后还不能获得锁，则进入等待状态</td></tr><tr><td style="text-align:center">spin_rounds</td><td style="text-align:center">自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spain_waits表示平均每次所需的内部循环次数。</td></tr><tr><td style="text-align:center">os_waits</td><td style="text-align:center">表示操作系统等待的次数，当spin lock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒。</td></tr><tr><td style="text-align:center">os_yields</td><td style="text-align:center">进行os_thread_yield唤醒操作的次数</td></tr><tr><td style="text-align:center">os_wait_times</td><td style="text-align:center">操作系统等待的时间，单位ms</td></tr></tbody></table><p>可通过命令SHOW ENGINE INNODB STATUS及information_schema架构下的表INNODB_TRX，INNODB_LOCKS、INNODB_LOCK_WAITS观察锁的信息。</p><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据。</li><li>排他锁（X Lock），允许事务删除或更新一行数据。</li></ul><p>X锁与任何锁都不兼容（变更行记录），S锁仅和S锁兼容（读取不更改行记录）。</p><p>意向将锁定的对象分为多个层次，意味着事务希望在更细粒度上进行加锁。支持多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在。 </p><p>InnoDB支持的意向锁为表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型。支持两种意向锁：</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</li></ul><p>意向锁不会阻塞除全表扫描以外的任何请求。意向锁和行级锁的兼容性：</p><table><thead><tr><th style="text-align:center">锁\兼容性</th><th style="text-align:center">IS</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center">IS</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N </td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><p>InnoDB v1.0前只能通过<code>SHOW ENGINE INNODB STATUS</code>、<code>SHOW FULL PROCESSLIST</code>命令查看当前锁请求的信息，之后可通过INFORMATION_SCHEMA架构下的表INNODB_LOCKS、INNODB_LOCK_TRX、INNODB_LOCK_WAITS更简单地监控当前事务并分析可能存在的锁问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 46328</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 46249 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 33</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479642318640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_TRX;</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| Field                      | Type                | Null | Key | Default             | Extra |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">| trx_id                     | varchar(18)         | NO   |     |                     |       |</span><br><span class="line">| trx_state                  | varchar(13)         | NO   |     |                     |       |</span><br><span class="line">| trx_started                | datetime            | NO   |     | 0000-00-00 00:00:00 |       |</span><br><span class="line">| trx_requested_lock_id      | varchar(81)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_wait_started           | datetime            | YES  |     | NULL                |       |</span><br><span class="line">| trx_weight                 | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_mysql_thread_id        | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_query                  | varchar(1024)       | YES  |     | NULL                |       |</span><br><span class="line">| trx_operation_state        | varchar(64)         | YES  |     | NULL                |       |</span><br><span class="line">| trx_tables_in_use          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_tables_locked          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_structs           | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_lock_memory_bytes      | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_locked            | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_rows_modified          | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_concurrency_tickets    | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_isolation_level        | varchar(16)         | NO   |     |                     |       |</span><br><span class="line">| trx_unique_checks          | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_foreign_key_checks     | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_last_foreign_key_error | varchar(256)        | YES  |     | NULL                |       |</span><br><span class="line">| trx_adaptive_hash_latched  | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_adaptive_hash_timeout  | bigint(21) unsigned | NO   |     | 0                   |       |</span><br><span class="line">| trx_is_read_only           | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">| trx_autocommit_non_locking | int(1)              | NO   |     | 0                   |       |</span><br><span class="line">+----------------------------+---------------------+------+-----+---------------------+-------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCKS;</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| lock_id     | varchar(81)         | NO   |     |         |       |</span><br><span class="line">| lock_trx_id | varchar(18)         | NO   |     |         |       |</span><br><span class="line">| lock_mode   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_type   | varchar(32)         | NO   |     |         |       |</span><br><span class="line">| lock_table  | varchar(1024)       | NO   |     |         |       |</span><br><span class="line">| lock_index  | varchar(1024)       | YES  |     | NULL    |       |</span><br><span class="line">| lock_space  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_page   | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_rec    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| lock_data   | varchar(8192)       | YES  |     | NULL    |       |</span><br><span class="line">+-------------+---------------------+------+-----+---------+-------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc INNODB_LOCK_WAITS;</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field             | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">| requesting_trx_id | varchar(18) | NO   |     |         |       |</span><br><span class="line">| requested_lock_id | varchar(81) | NO   |     |         |       |</span><br><span class="line">| blocking_trx_id   | varchar(18) | NO   |     |         |       |</span><br><span class="line">| blocking_lock_id  | varchar(81) | NO   |     |         |       |</span><br><span class="line">+-------------------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参考<a href="https://dbarobin.com/2015/01/27/innodb-lock-wait-under-mysql-5.5/" target="_blank" rel="noopener">MySQL 5.5 InnoDB 锁等待</a></p><p>参考<a href="https://blog.winsky.wang/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E4%B8%8Einformation_schema%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A1%A8/" target="_blank" rel="noopener">锁等待超时与information_schema的三个表</a></p><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>指InnoDB engine通过行多版本控制的方式来读取当前执行时间数据库中行的数据。</p><p>若读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因为去等待行上锁的释放，会去读取行的一个快照数据。快照数据指该行的之前版本的数据，通过undo段来完成，undo用来在事务中回滚数据。</p><p>InnoDB默认读取方式，读取不会占用和等待表上的锁。在不同的事务隔离级别下读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读，对于快照数据的定义也各不相同。</p><p>事务隔离级别READ COMMITTED和REPEATABLE READ（默认隔离级别）下，使用非锁定的一致性读。前者对于快照数据，非一致性读总是读取被锁定的最新一份快照数据。后者对于快照数据，非一致性读总是读取事务开始时的行数据版本。前者违反了事务ACID中的I的特性，即隔离性。</p><h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB engine对SELECT语句支持两种一致性的锁定读（locking read）操作。</p><ul><li>SELECT … FOR UPDATE，对读取的行记录加一个X锁，其他的事务不能对已锁定行加上任何锁。</li><li>SELECT … LOCK IN SHARE MODE，对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，若加X，会被阻塞。</li></ul><p>已上两种操作必须在一个事务中，事务提交后，锁释放。</p><h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>InnoDB engine中，每个含有自增长的表都有一个自增长计数器，对含有自增长的计数器的表进行插入操作时，计数器会被初始化。</p><p>获取计算器的值：<code>SELECT MAX(auto_inc_col) FROM t FOR UPDATE</code>。</p><p>插入操作依据自增长的计数器值加1赋予自增长列，称为AUTO-INC Locking，采用一种特殊的表锁机制，为提高插入性能，锁在完成对自增长值插入的SQL语句后立即释放，并非在一个事务完成后才释放。</p><p>MySQL v5.1.22开始提供轻量级互斥量的自增长实现机制，提高自增长值插入的性能。提供参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，默认值为1.</p><p>自增长的插入分类：</p><table><thead><tr><th style="text-align:center">插入类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">insert-like</td><td style="text-align:center">指所有的插入语句，如INSERT、REPLACE、INSERT…SELECT，REPLACE…SELECT、LOAD DATA等</td></tr><tr><td style="text-align:center">simple inserts</td><td style="text-align:center">指能在插入前就确定插入行数的语句，包括INSERT、REPLACE等</td></tr><tr><td style="text-align:center">bulk inserts</td><td style="text-align:center">指在插入前不能确定得到插入行数的语句，如INSERT…SELECT、REPLACE…SELECT、LOAD DATA</td></tr><tr><td style="text-align:center">mixed-mode inserts</td><td style="text-align:center">指插入中有一部分的值是自增长的，有一部分是确定的。如INSERT INTO t1(c1,c2) VALUES (1,’a’),(NULL,’b’),(5,’c’),(NULL,’d’)；也可以指INSERT … ON DUPLICATE KEY UPDATE这类SQL语句</td></tr></tbody></table><p>参数<code>innodb_autoinc_lock_mode</code>的说明：</p><table><thead><tr><th style="text-align:center">innodb_autoinc_lock_mode</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">MySQL v5.1.22前的自增长实现方式，通过表锁的AUTO-INC Locking方式。不是新版本的首选项。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">默认值。对于simple inserts使用互斥量对于内存中的计数器进行累加操作，对于bulk inserts使用传统表锁的AUTO-INC Locking方式，不考虑回滚操作，对于自增列的增长是连续的。statement-based方式的replication还能很好地工作。若已经使用AUTO-INC Locking方式去产生自增长的值，而需要再进行simple inserts时，还是需要等待AUTO-INC Locking的释放。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">对于所有insert-like 自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。基于Statement-Base Replication会出现问题。该模式下任何时候都改使用row-base replication。保证最大的并发性能及replication主从数据的一致</td></tr></tbody></table><p>InnoDB engine中，自增长值的列必须是索引，同时必须时索引的第一个列，若不是第一个列，MySQL数据库会抛出异常。</p><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>外键用户完整性的约束检查，InnoDB对未显示加索引的外键列，会自动对其加以个索引，可避免表锁。</p><p>对外键值的插入或更新，首先会查询父表中的记录，对于父表的SELECT操作，不使用一致性非锁定读的方式，使用的是SELECT…LOCK IN SHARE MODE方式，主动对父表加一个S锁。若此时父表被加X锁，则子表上的操作会被阻塞。</p><h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><h4 id="锁的3种算法"><a href="#锁的3种算法" class="headerlink" title="锁的3种算法"></a>锁的3种算法</h4><p>InnoDB engine3种行锁算法：</p><ul><li>Record Lock：单个行记录上的锁。锁住索引记录，未设置索引则使用隐式的主键来进行锁定。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。阻止多个事务将记录插入到同一范围内。</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。为解决Phantom Problem（幻像问题），是谓词锁（predict lock）的一张改进。当查询的索引含有唯一属性时，查询所有的唯一索引列，InnoDB存储引擎会对Next-key Lock进行优化，将其降级为Record Lock，仅锁住索引本身，而不是范围。 </li></ul><p>若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，则查询其实是range类型查询，而不是point类型查询，依然使用Next-Key Lock进行锁定。</p><p>显式关闭Gap Lock：</p><ul><li>将事务隔离级别设置为READ COMMITTED</li><li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li></ul><p>此时除了外键约束和唯一性检查依然需要Gap Locl，其余情况仅使用Record Lock进行锁定。此时破坏了事务的隔离性，对于replication，会导致主从数据的不一致。性能上，READ COMMITTED不会优于默认事务隔离级别REPEATABLE READ。</p><h4 id="解决Phantom-Problem（幻像问题）"><a href="#解决Phantom-Problem（幻像问题）" class="headerlink" title="解决Phantom Problem（幻像问题）"></a>解决Phantom Problem（幻像问题）</h4><p>指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p><p>采用Next-Key Lock避免该问题，READ COMMITTED下仅采用Record Lock加锁，默认隔离级别REPEATABLE READ采用Next-Key Lock加锁。</p><h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏数据值事务对缓存池中行记录的修改，并且还没有被提交。</p><p>若读到脏数据，即一个事务可以读到另一个事务中未提交的数据，违反了数据库的隔离性。</p><p>脏读指在不同的事务下，当前事务可以读到另外事务未提交的数据，即可以读到脏数据。</p><p>脏读现象在生成环境中并不常发生，脏读发生的条件是需要事务隔离级别为READ UNCOMMITTED，目前大多至少设置成READ COMMITTED级别。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在一个事务内多次读取同一数据集合，事务还未结束时，另一个事务也访问该同一数据集合，并做了一些DML操作，导致第一个事务中的两次读取数据之间由第二个事务的修改，读取的数据不一致。</p><p>脏读读取的是未提交的数据，不可重复读读取的是已提交的数据，违反了事务的一致性要求。</p><p>MySQL将其定义为幻像问题（Phantom Problem），默认隔离级别下避免了该现象。</p><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作被另一个事务的更新操作覆盖，导致数据的不一致性。InnoDB对于行的DML操作需要对行或其他粗粒度级别的对象加锁，不会出现丢失更新问题。</p><p>基于B/S应用可能于业务层出现此现象。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，产生阻塞。阻塞为了确保事务可以并发且正常地运行。</p><p>参数<code>innodb_rollback_wait_timeout</code>控制等待的时间，参数<code>innodb_roolback_on_timeout</code>用来设定是否在等待超时时对进行中的事务进行回滚操作，默认OFF代表不回滚。参数<code>innodb_rollback_wait_timeout</code>是动态的，可以在MySQL DB运行时进行调整，参数<code>innodb_rollback_wait_timeout</code>是静态的，不可在启动后进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_rollback_wait_timeout&apos;\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_rollback_on_timeout&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_rollback_on_timeout</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>默认不会回滚超时引发的错误异常，在大部分情况下都不会对异常进行回滚。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互动等待的现象。</p><p>解决死锁最简单的方式时不要有等待，将任何等待都转化为回滚，并且事务重新开始。会导致并发性能的下降。</p><p>另一个解决方案是超时，当一个等待时间超过设置的某一阀值时，其中一个事务进行回滚，另一个事务获得资源继续进行。参数<code>innodb_lock_wait_timeout</code>用来设置超时的时间（默认50）。</p><p>目前普遍采用更为主动的wait-for graph（等待图）的方式来进行死锁的检测，要求数据库保存以下两种信息：</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述链表构造一张图，若图中存在回路，说明资源间互相发生等待，代表存在死锁。</p><p>wait-for graph中事务为图中的节点，图中T1指向T2边的定义为：</p><ul><li>事务T1等待事务T2所占用的资源</li><li>事务T1最终等待T2所占用的资源，事务之间等待相同的资源，而事务T1发生在事务T2的后面</li></ul><p>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常InnoDB存储引擎选择回滚undo量最小的事务。</p><p>wait-for graph的死锁检测通常采用深度优先的算法实现。InnoDB v1.2前采用递归实现，此版本开始采用非递归的方式实现。</p><h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁次数应少于等待，至少需要2次等待才会产生一次死锁。</p><p>事务发生死锁的概率影响因素：</p><ul><li>系统中事务的数量（n），数量越多发生死锁的概率越大。</li><li>每个事务操作的数量（r），每个事务操作的数量越多，发生死锁的概率越大。</li><li>操作数据的集合（R），越小发生死锁的概率越大。</li></ul><p>系统中任何一个事务发生死锁的概率～= (n^2*r^4)/4*R^2</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>指将当前锁粒度降低。可将一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</p><p>SQL Server认为锁是一种稀有资源，存在此现象。</p><p>InnoDB不存在锁升级问题，不是根据每个记录产生行锁， 而是根据每个事务访问的每个页对锁进行管理，采用位图的方式。不管一个事务锁住页中一个记录还是多个记录，开销是一致的。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>索引与算法</title>
      <link href="/2019/08/30/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/30/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB支持的索引：</p><ul><li>B+ tree索引</li><li>全文索引</li><li>哈希索引</li></ul><p>InnoDB存储引擎支持的哈希索引是自适应的（见<a href="http://bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">自适应哈希索引</a>）。</p><p>B+ tree索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。</p><blockquote><p>B+ tree的B代表着平衡（balance），而非二叉（binary）。B+ tree从最早的平衡二叉树演变而来，但是不是一个二叉树。</p></blockquote><p>B+ tree index并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查到，最后得到要查找的数据。</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到。</p><h4 id="二分查找和平衡二叉树"><a href="#二分查找和平衡二叉树" class="headerlink" title="二分查找和平衡二叉树"></a>二分查找和平衡二叉树</h4><p>二叉查找树：左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p><p>若想最大性能地构造一棵二叉查找树，需要二叉查找树是平衡的——平衡二叉树（AVL树）。是二叉查找树，任何节点的两个子树的高度最大差为1。</p><p>维护一棵平衡二叉树需要一定的开销，多用于内存结构对象中，维护的开销相对较小。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质是B+树在数据库中的实现。B+树高扇出性，高度一般在2～4层，查找某一键值的行记录只需要2～4次IO。</p><p>B+树索引分为聚集索引（clustered index）和辅助索引（secondary index），内部都是B+树，高度平衡，叶子节点存放着所有的数据。聚集索引和辅助索引不同之处在于，叶子节点存放的是否是一整行的信息。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB存储引擎表是索引组织表，表中的数据按照主键顺序存放。聚集索引按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表中存放的行记录数据，也将聚集索引的叶子节点称为数据页，决定了索引组织表中数据也是索引的一部分。每个数据页通过双向链表进行链接。</p><p>每张表只能拥有一个聚集索引，多数情况下，聚集索引能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询，查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>聚集索引非物理上连续，而是逻辑上连续。</p><ul><li>页通过双向链表链接，按照主键顺序排序</li><li>每个页中的记录通过双向链表进行维护，物理存储上可以同样不按照主键储存</li></ul><p>聚集索引对于主键排序查找和范围查找很快。</p><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>叶子节点不包含行记录的全部数据，除包含键值外，每个叶子节点中的索引行还包含一个书签。该书签告知InnoDB存储引擎哪里可以找到与索引相应的行数据。辅助索引的书签是相应的行数据的聚集索引键。</p><p>通过辅助索引查找数据，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>InnoDB存储引擎的Page Header中有以下几个部分用来保存插入的顺序信息：</p><ul><li>PAGE_LAST_INSERT</li><li>PAGE_DIRECTION</li><li>PAGE_N_DIRECTION</li></ul><p>决定向左还是向右进行分裂，决定将分裂点记录为哪一个。若插入随机，则取页的中间记录作为分裂点的记录，若往同一方向插入的记录数量为5，并且目前已经定位（cursor）到的记录（InnoDB存储引擎插入时，首先需要进行定位，定位到的记录为带插入记录的前一条记录）之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是带插入的记录。</p><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><h5 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h5><p>索引的创建和删除可通过两种方法，<code>ALTER TABLE</code>和<code>CREATE/DROP INDEX</code>。</p><p>ALTER TABLE创建索引语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option]...</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP PARIMARY KEY</span><br><span class="line">| DROP &#123;INDEX|KEY&#125; index_name</span><br></pre></td></tr></table></figure><p>CREATE/DROP INDEX语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line">[index_type]</span><br><span class="line">ON table_name (index_col_name,...)</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure><p>可设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据。</p><p>参见<a href="http://bighua.top/2018/07/30/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/">Mysql索引及优化</a></p><p>通过<code>SHOW INDEX FROM TABLE</code>查看索引信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from users_old\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_name_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: users_email_unique</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: email</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 158</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">        Table: users_old</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: remember_token</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: remember_token</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 153</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>每列含义：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">  Table</td><td style="text-align:center">索引所在表名。</td></tr><tr><td style="text-align:center">  Non_unique</td><td style="text-align:center">非唯一的索引。</td></tr><tr><td style="text-align:center">  Key_name</td><td style="text-align:center">索引名。</td></tr><tr><td style="text-align:center">  Seq_in_index</td><td style="text-align:center">索引中该列的位置。</td></tr><tr><td style="text-align:center">  Column_name</td><td style="text-align:center">索引列的名称。</td></tr><tr><td style="text-align:center">  Collation</td><td style="text-align:center">列以什么方式存储在索引中，值为A或NULL。B+树索引总是A，即排序的。若使用Heap存储引擎，并建立了Hash索引，会显示NULL。Hash根据Hash桶存放索引数据，不对数据进行排序。</td></tr><tr><td style="text-align:center">  Cardinality</td><td style="text-align:center">表示索引中唯一值的数目的估计值。若非常小，可考虑是否删除此索引。</td></tr><tr><td style="text-align:center">  Sub_part</td><td style="text-align:center">是否是列的部分被索引，若索引整个列则值为NULL，否则为被索引字符长度。</td></tr><tr><td style="text-align:center">  Packed</td><td style="text-align:center">关键字如何被压缩，没被压缩值为NULL。</td></tr><tr><td style="text-align:center">  Null</td><td style="text-align:center">索引的列是否含有NULL值，列允许为NULL值则显示为Yes。</td></tr><tr><td style="text-align:center">  Index_type</td><td style="text-align:center">索引的类型，InnoDB只支持B+ Tree索引</td></tr><tr><td style="text-align:center">  Comment</td><td style="text-align:center">注释</td></tr></tbody></table><p>优化器会根据Cardinality值来判断是否使用这个索引，非实时更新，只是大概的值。可使用<code>ANALYZE TABLE</code>命令更新索引Cardinality信息，在非高峰期操作能使优化器更好的选择索引。</p><h5 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h5><p>MySQL v5.5之前，对于索引的添加或者删除类DDL操作过程：</p><ul><li>创建一张临时表，表结构为通过命令ALTER TABLE新定义的结构。</li><li>将原表数据导入到临时表。</li><li>删除原表。</li><li>把临时表重名为原来的表名。</li></ul><p>对大表进行索引的添加和删除操作耗时，大量访问时数据库服务不可用。</p><p>临时表的创建路径通过参数tmpdir进行设置，必须保证tmpdir有足够的空间存放临时表，否则会导致创建索引失败。</p><p>InnoDB v1.0.x开始支持Fast Index Creation（快速创建索引，FIC）的索引创建方式。 </p><p>辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁，在创建过程中不需要重建表。删除辅助索引，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL DB内部视图上对该表的索引定义。</p><p>加S锁操作导致过程中只能对表进行读操作，写操作不可用。FIC只限定于辅助索引的创建，主键的创建和删除同样需要重建一张表。</p><h5 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h5><p>Online Schema Change（在线架构改变，OSC）由Facebook采用PHP脚本实现的一种在线执行DDL的方式，在事务的创建过程中，可以有读写事务对表进行操作。</p><p>实现OSC步骤：</p><ul><li>init，初始化阶段，对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。</li><li>createCopyTable，创建和原始表结构一样的新表。</li><li>alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。</li><li>createDeltasTable，创建deltas表，为下一步创建的触发器所使用。之后对原表的所有的DML操作会被记录到createDeltasTable中。</li><li>createTirggers，对原表创建INSERT、UPDATE、DELETE操作的触发器，触发操作产生的记录被写入到deltas表。</li><li>startSnpshotXact，开始OSC操作的事务。</li><li>selectTableIntoOutfile，将原表中的数据写入到新表，通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中，分片大小可指定，默认500000。</li><li>dropNCIndexs，导入新表前，删除新表中所有的辅助索引。</li><li>loadCopyTable，将导出的分片文件导入到新表。</li><li>replayChanges，将OSC过程中原表DML操作的记录（被保存在deltas表中）应用到新表中。</li><li>recreateNCInedexes，创新创建辅助索引。</li><li>replayChanges，再次进行DML日志的回放操作，是上述创建辅助索引过程中新产生的日志。</li><li>swapTables，将原表和新表交换名字，操作过程需要锁定2张表，不允许新数据产生，改名操作很快，阻塞时间很短。</li></ul><p>要求进行修改表一定要有主键且表本身不能存在外键和触发器。进行OSC过程中，允许SET aql_bin_log=0，所在操作不会同步slave服务器，可能导致主从不一致。</p><h5 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h5><p>MySQL v5.6开始支持Online DDl（在线数据定义）操作，允许辅助索引创建的同时，进行其他诸如INSERT、UPDATE、DELETE这类DML操作。</p><p>可通过“在线”方式进行操作的DDL操作：</p><ul><li>辅助索引的创建和删除</li><li>改变自增长值</li><li>添加或删除外键约束</li><li>列的重命名</li></ul><p>通过新的ALTER TABLE语法，可选择索引的创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line">| ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option] ...</span><br><span class="line">ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</span><br><span class="line">LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure><p>ALGORITHM指定列创建或删除索引的算法，COPY表示按照MySQL v5.1之前的工作模式（创建临时表）。INPLACE表示索引创建或删除不需要创建临时表。DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，值默认为OFF，表示采用INPLACE方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;old_alter_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: old_alter_table</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>LOCK部分为索引创建或删除时对表加锁的情况，可为：</p><ol><li>NONE——执行索引创建或者删除操作时，对目标表不添加任何的锁，事务仍然可以进行读写操作，不会收到阻塞。可获得最大的并发度。</li><li>SHARE——类似FIC，执行索引创建或者删除操作时，对目标表加上一个S锁，不影响并发读事务，但是写事务会等待。若存储引擎不支持SHARE模式，会返回一个错误信息。</li><li>EXCLUSIVE——执行索引创建或删除操作时，对目标表加上一个X锁，读写事务都不能进行，会阻塞所有线程。</li><li>DEFAULT——通过判断事务的最大并发性来判断执行DDL的模式，选用顺序依次为NONE、SHARE、EXCLUSIVE。</li></ol><p>Online DDL原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。缓存的大小由参数<code>innodb_online_alter_log_max_size</code>控制，默认大小128MB。若更新表比较大，且创建过程中有大量写事务，空间不足会报错，需调大参数值，或者设置ALTER TABLE的模式为SHARE，在执行过程中不会有写事务发生。</p><h3 id="Cardinality-值"><a href="#Cardinality-值" class="headerlink" title="Cardinality 值"></a>Cardinality 值</h3><h4 id="Cardinality"><a href="#Cardinality" class="headerlink" title="Cardinality"></a>Cardinality</h4><p>并不是在所有的查询条件中出现的列都需要添加索引，一般在访问表中很少一部分时使用B+ Tree索引才有意义，对于性别字段、地区字段、类型字段可取范围小，称为低选择性。若字段取值范围广，几乎没有重复，属于高选择性，适合使用B+ Tree索引。</p><p>Cardinality列表示索引中不重复记录数量的预估值，而不是一个准确值，基本不可能得到一个确切值。实际应用中Cardinality/n_rows_in_table应尽可能接近1，若非常小则需要考虑是否还有必要创建这个索引。</p><h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>MySQL对Cardinality的统计放在存储引擎层进行的，通过采样的方法完成。</p><p>InnoDB中Cardinality统计信息的更新发生在INSERT和UPDATE操作中，策略为：</p><ul><li>表中1/16的数据已发生过变化。</li><li>stat_modified_counter&gt;2 000 000 000</li></ul><p>默认InnoDB存储引擎对8个叶子节点（Leaf Page）进行采样，采样过程：</p><ul><li>取得B+ Tree Index中叶子节点的数量记为A。</li><li>随机取得B+ Tree Index中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，…，P8。</li><li>根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8）*A/8</li></ul><p>每次对Cardinality值的统计，都是随机取8个叶子节点得到的，每次得到的Cardinality值可能是不同的。</p><p>InnoDB v1.2之前可通过参数<code>innodb_stats_sample_pages</code>设置统计Cardinality时每次采样页的数量，默认为8。同时，参数<code>innodb_stats_method</code>用来判断如何对待索引中出现的NULL值记录，默认值为nulls_equal，表示将NULL值记录视为相等的记录，还可取nulls_unequal表示将NULL值视为不同的记录，取nulls_ignored表示忽略NULL值记录。</p><p>执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎重新计算索引的Cardinality值，表数据量过大且多个辅助索引时，执行可能会很慢。</p><p>InnoDB v1.2提供更多参数对Cardinality统计进行设置：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">innodb_stats_persistent</td><td style="text-align:center">是否将ANALYZE TABLE计算得到的Cardinality值存放到磁盘上，若是则可以减少重新计算每个索引的Cardinality值。也可通过命令CREATE TABLE和ALTER TABLE的选项STATS_PERSISTENT来对每张表进行控制。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_on_metadata</td><td style="text-align:center">通过SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时，是否需要重新计算索引的Cardinality值。默认值为OFF。</td></tr><tr><td style="text-align:center">innodb_stats_persistent_sample_pages</td><td style="text-align:center">若innodb_stats_persistent设置为ON，该参数表示ANALYZE TABLE更新Cardinality值时每次采样页的数量。默认值为20。</td></tr><tr><td style="text-align:center">innodb_stats_transient_smaple_pages</td><td style="text-align:center">取代之前版本的参数innodb_stats_sample_pages，表示每次采样页的数量，默认值为8。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_on_metadata&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_on_metadata</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_persistent_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_persistent_sample_pages</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_stats_transient_sample_pages&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_stats_transient_sample_pages</span><br><span class="line">        Value: 8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="B-Tree-Index的使用"><a href="#B-Tree-Index的使用" class="headerlink" title="B+ Tree Index的使用"></a>B+ Tree Index的使用</h3><h4 id="不同应用中B-Tree-Index的使用"><a href="#不同应用中B-Tree-Index的使用" class="headerlink" title="不同应用中B+ Tree Index的使用"></a>不同应用中B+ Tree Index的使用</h4><p>OLTP应用根据查询条件建立B+ Tree Index，取少部分数据走索引。</p><p>OLAP应用取大量数据视具体情况分析。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表上多个列进行索引。</p><p>本质上联合索引也是一棵B+ Tree，不同的是联合索引的键值的数量不是1，而是大于等于2。</p><p>对于联合索引（a,b），查询a或者a、b可走索引，查询b无法使用索引。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引（covering index，索引覆盖），从辅助索引中就可以得到查询的记录，不需要查询聚集索引中的记录。辅助索引不包含正行记录的所有信息，大小小于聚集索引，可减少大量的IO操作。</p><p>通常诸如（a，b）的联合索引，一般不会选择列b中所谓的查询条件，但若是统计操作，并且是覆盖索引，则优化器会进行选择。</p><h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>多发生于范围查找、JOIN链接操作等情况下。</p><p>要求访问的数据量很小，优化器会选择辅助索引，当访问的数据量占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。因为辅助索引中查询到指定数据后，还需要一次书签访问来查找整行数据的信息，辅助索引上的数据是顺序存放的，但再一次进行书签查找的数据是无序的，变为了磁盘上的离散读操作，顺序读远快于离散读，所以优化器直接选择聚集索引。</p><h4 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h4><p>MySQL DB支持索引提示（INDEX HINT），显示地告诉优化器使用哪个索引。</p><p>使用到INDEX HINTL的情况：</p><ul><li>MySQL DB的优化器错误滴选择了某个索引，导致SQL语句运行的很慢。非常少见。</li><li>某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。</li></ul><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tbl_name [[AS] alias] [index_hint_list]</span><br><span class="line">index_hint_list:</span><br><span class="line">index_hint [, index_hint] ...</span><br><span class="line">index_hint:</span><br><span class="line">USE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list])</span><br><span class="line">  | IGNORE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">  | FORCE &#123;INDEX|KEY&#125;</span><br><span class="line">  [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</span><br><span class="line">index_list:</span><br><span class="line">index_name [, index_name] ...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://oceanbase.alipay.com/docs/oceanbase/OceanBase%20SQL%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BA%BA%E4%B8%BA%E6%8E%A7%E5%88%B6%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/hint" target="_blank" rel="noopener">11.1 优化器HINT</a></p><h4 id="Multi-Range-Read（MRR）优化"><a href="#Multi-Range-Read（MRR）优化" class="headerlink" title="Multi-Range Read（MRR）优化"></a>Multi-Range Read（MRR）优化</h4><p>MySQL v5.6开始支持Multi-Range Read（MRR）优化，减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于IO-bound类型的SQL查询语句可带来性能极大的提升，可适用于range，ref，eq_ref类型的查询。</p><p>MRR优化的好处：</p><ul><li>使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果按照主键进行排序，并按照主键排序的顺序进行书签查找。</li><li>减少缓冲池中页被替换的次数。</li><li>批量处理对键值的查询操作。</li></ul><p>对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR工作方式：</p><ul><li>将查询得到的辅助索引键值存放于一个缓存中，此时缓存中的数据是根据辅助索引键值排序的。</li><li>将缓存中的键值根据RowID进行排序。</li><li>根据RowID的排序顺序来访问实际的数据文件。</li></ul><p>当缓冲池不够大，离散读操作导致缓存中的页可能被重复替换出/读入缓冲池，按照主键顺序进行访问可将此行为降为最低。MRR还可将某些范围查询，拆分为键值对，以此来进行批量的数据查询。可以在拆分的过程中，直接过滤一些不符合查询条件的数据。</p><p>是否启用Multi-Range Read优化可通过参数<code>optimizer_switch</code>中的标记（flag）来控制。mrr为on时，表示启用Multi-Range Read优化。<code>mrr_cost_based</code>标记表示是否通过cost based的方式来选择是否启用mrr。</p><p>参数<code>read_rnd_buffer_size</code>用来控制键值的缓冲区大小，当大于该值时，则执行器对已经缓存的数据根据RowID进行排序，并通过RowID来取得行数据。默认为256K。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;optimizer_switch&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: optimizer_switch</span><br><span class="line">        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;read_rnd_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: read_rnd_buffer_size</span><br><span class="line">        Value: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="Index-Condition-Pushdown-ICP-优化"><a href="#Index-Condition-Pushdown-ICP-优化" class="headerlink" title="Index Condition Pushdown(ICP)优化"></a>Index Condition Pushdown(ICP)优化</h4><p>MySQL v5.6开始支持Index Condition Pushdown(ICP)优化。不支持前进行索引查询时，先根据索引来查找记录，然后再根据WHERE条件来过滤记录。支持后，会在取出索引的同时，判断是否可以进行WHERE条件的过滤，将WHERE的部分过滤操作放在存储引擎层。某些查询下可大大减少上层SQL层对记录的索取，提高数据库的整体性能。</p><p>ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>时间复杂度为O（1），不只存在于索引中，每个数据库应用中都存在该数据结构。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>也称散列表，由直接寻址表改进而来。</p><p>哈希函数h必须可以很好地进行散列，最好的情况下是能避免碰撞的发生，即使不能避免也应该使碰撞在最小程度下产生。一般都将关键字转换为自然数。然后通过除法散列、乘法散列或全域散列来实现。数据库一般采用除法散列的方法。</p><h4 id="InnoDB存储引擎中的哈希算法"><a href="#InnoDB存储引擎中的哈希算法" class="headerlink" title="InnoDB存储引擎中的哈希算法"></a>InnoDB存储引擎中的哈希算法</h4><p>InnoDB存储引擎使用哈希算法来对字典进行查找，冲突机制采用链表方式，哈希函数采用除法散列方式。</p><p>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，指向相同哈希函数值的页。</p><p>对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。</p><p>将要查找的页转换为自然数。InnoDB存储引擎的表空间有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，及偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，关键字K=space_id&lt;&lt;20+space_id+offset，然后通过除法散列到各个槽中去。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>采用哈希表的方式实现，仅是数据库自身创建并使用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询。其他类型查找如范围查找是不能使用哈希索引的。</p><p>通过参数<code>innodb_adaptive_hash_index</code>控制是否开启。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。可根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。</p><p>InnoDB v1.2.x开始支持全文索引，支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文索引通常使用倒排索（inverted index）引来实现，倒排索引同B+ 树索引一样，也是一种索引结构。在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现，其拥有两种表现形式：</p><ul><li>inverted file index, 表现为{单词，单词所在文档的ID}</li><li>full inverted index，表现为{单词，（单词所在文档的ID，在具体文档中的位置）}</li></ul><h4 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h4><p>InnoDB采用full inverted index的方式，将（DocumentId，Position）视为一个“list”。在全文检索的表中，有两个列，一个是word字段，另一个是ilist字段，并且在word字段上设有索引。在ilist字段中存放了Position信息，可进行Proximity Search。</p><p>倒序排序需要将word存放到一张表中，该表称为Auxiliary Table（辅助表）。在InnoDB存储引擎中，为提高全文检索的并行性能，共有6张Auxiliary Table，每张表根据word的Latin编码进行分区。</p><p>Auxiliary Table是持久的表存放于磁盘上。FTS Index Cache（全文检索索引缓存），用于提高全文检索的性能。</p><p>FTS Index Cache是一个红黑树结构，根据（word，ilist）进行排序。意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table可能还没有更新。InnoDB存储引擎会批量对Auxiliary Table进行更新，不是每次插入后更新一次Auxiliary Table。对全文检索进行查询时，Auxiliary Table会先将FTS Index Cache中对应的word字段合并到Auxiliary Table中，然后再进查询。</p><p>允许用户查看指定倒排索引的Auxiliary Table中分词的信息，可以通过设置参数<code>innodb_ft_aux_table</code>来观察倒排索引的Auxiliary Table。</p><p>InnoDB总在事务提交时将分词写入到FTS Index Cache，然后通过批量更新写入到磁盘。数据库关闭时，FTS Index Cache中的数据会同步到磁盘上的Auxiliary Table中。若数据库宕机时，一些FTS Index Cache中的数据可能未被同步到磁盘上，下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中。</p><p>参数<code>innodb_ft_cache_size</code>控制FTS Index Cache的大小，默认值为32MB。当该缓存满时，会将其中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大该参数可提高全文检索的性能，宕机时，未同步到磁盘中的索引信息可能需要更长的时间恢复。</p><p>为支持全文索引，必须有一个列与word进行映射，在InnoDB中该列被命名为FTS_DOC_ID，类型必须是BIGINT UNSIGNED NOT NULL，会自动在该列上加入一个名为FTS_DOC_ID_INDEX的Unique Index。</p><p>对于删除操作，在事务提交时，不删除磁盘Auxiliary Table中的记录，而只是删除FTS Cache Index中的记录。对于Auxiliary Table中被删除的记录，InnoDB存储引擎会记录其FTS Document ID，并将其保存在DELETED auxiliary table中，设置<code>innodb_ft_aux_table</code>后，同样可以访问information_schema架构下的表INNODB_FT_DELETED来观察删除的FTS Document<br>ID。</p><p>OPTIMIZE TABLE命令允许用户手工地将已经删除的记录从索引中彻底删除，该命令还进行一些其他操作如Cardinality的重新统计。若只对倒排索引进行操作，可通过参数<code>innodb_optimize_fulltext_only</code>进行设置。若被删除文档数量非常多，会占用非常多的时间，影响程序的并发性，降低用户响应时间，可通过参数<code>innnodb_ft_num_word_optimize</code>来限制每次实际删除的分词数量，默认值2000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from test.fts_a where FTS_DOC_ID&lt;7;</span><br><span class="line">Query OK, 6 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE fts_a (</span><br><span class="line">    -&gt; FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,</span><br><span class="line">    -&gt; body TEXT,</span><br><span class="line">    -&gt; PRIMARY KEY(FTS_DOC_ID)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE FULLTEXT INDEX idx_fts ON fts_a(body);</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          1 | I am a boy                                |</span><br><span class="line">|          2 | I am a bad boy                            |</span><br><span class="line">|          3 | I am a good boy                           |</span><br><span class="line">|          4 | I am a good boy,who love liwenqi          |</span><br><span class="line">|          5 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|          6 | where is my heart                         |</span><br><span class="line">|          7 | what a beautiful girl                     |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts_a&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_INDEX_TABLE;</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD      | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| bad       |            2 |           2 |         1 |      2 |        7 |</span><br><span class="line">| beautiful |            7 |           7 |         1 |      7 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      1 |        7 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      2 |       11 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      3 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      4 |       12 |</span><br><span class="line">| boy       |            1 |           5 |         5 |      5 |       12 |</span><br><span class="line">| girl      |            7 |           7 |         1 |      7 |       17 |</span><br><span class="line">| good      |            3 |           5 |         3 |      3 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      4 |        7 |</span><br><span class="line">| good      |            3 |           5 |         3 |      5 |        7 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      5 |       36 |</span><br><span class="line">| heart     |            5 |           6 |         2 |      6 |       12 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      4 |       25 |</span><br><span class="line">| liwenqi   |            4 |           5 |         2 |      5 |       25 |</span><br><span class="line">| love      |            4 |           5 |         2 |      4 |       20 |</span><br><span class="line">| love      |            4 |           5 |         2 |      5 |       20 |</span><br><span class="line">+-----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">17 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>FIRST_DOC_ID、LAST_DOC_ID、DOC_COUNT分别代表该word第一次出现的文档ID，最后一次出现的文档ID，以及该word在多少个文档中存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a bad boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;I am a good boy,who love liwenqi in heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;where is my heart&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts_a  values (NULL,&apos;liwenqi,what a beautiful girl &apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|          8 | I am a boy                                |</span><br><span class="line">|          9 | I am a bad boy                            |</span><br><span class="line">|         10 | I am a good boy                           |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         13 | where is my heart                         |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_optimize_fulltext_only=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; optimize table test.fts_a;</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| Table      | Op       | Msg_type | Msg_text |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">| test.fts_a | optimize | status   | OK       |</span><br><span class="line">+------------+----------+----------+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEGIN_DELETED;</span><br><span class="line">ERROR 1109 (42S02): Unknown table &apos;innodb_ft_begin_deleted&apos; in information_schema</span><br><span class="line">mysql&gt; select * from information_schema.INNODB_FT_BEING_DELETED;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      2 |</span><br><span class="line">|      3 |</span><br><span class="line">|      4 |</span><br><span class="line">|      5 |</span><br><span class="line">|      6 |</span><br><span class="line">|      7 |</span><br><span class="line">+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>命令OPTIMIZE TABLE可将记录进行彻底的删除，并且彻底删除的文档ID会记录到表information_schema.INNODB_FT_BEING_DELETED中。已被删除的文档ID不允许被再次使用。</p><p>stopword列表（stopword list）表示该列表中的word不需要对其进行索引分词操作。InnoDB存储引擎有一张默认的stopword列表，在information_schema架构下，表名为INNODB_FT_DEFAULT_STOPWORD，默认共36个stopword。可通过参数<code>innodb_ft_server_stopword_table</code>来自定义stopword列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.INNODB_FT_DEFAULT_STOPWORD;</span><br><span class="line">+-------+</span><br><span class="line">| value |</span><br><span class="line">+-------+</span><br><span class="line">| a     |</span><br><span class="line">| about |</span><br><span class="line">| an    |</span><br><span class="line">| are   |</span><br><span class="line">| as    |</span><br><span class="line">| at    |</span><br><span class="line">| be    |</span><br><span class="line">| by    |</span><br><span class="line">| com   |</span><br><span class="line">| de    |</span><br><span class="line">| en    |</span><br><span class="line">| for   |</span><br><span class="line">| from  |</span><br><span class="line">| how   |</span><br><span class="line">| i     |</span><br><span class="line">| in    |</span><br><span class="line">| is    |</span><br><span class="line">| it    |</span><br><span class="line">| la    |</span><br><span class="line">| of    |</span><br><span class="line">| on    |</span><br><span class="line">| or    |</span><br><span class="line">| that  |</span><br><span class="line">| the   |</span><br><span class="line">| this  |</span><br><span class="line">| to    |</span><br><span class="line">| was   |</span><br><span class="line">| what  |</span><br><span class="line">| when  |</span><br><span class="line">| where |</span><br><span class="line">| who   |</span><br><span class="line">| will  |</span><br><span class="line">| with  |</span><br><span class="line">| und   |</span><br><span class="line">| the   |</span><br><span class="line">| www   |</span><br><span class="line">+-------+</span><br><span class="line">36 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE user_stopword (</span><br><span class="line">    -&gt; value VARCHAR(30)</span><br><span class="line">    -&gt; ) ENGINE = INNODB;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_server_stopword_table = &quot;test/user_stopword&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_ft_server_stopword_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_ft_server_stopword_table</span><br><span class="line">        Value: test/user_stopword</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>InnoDB全文索引的限制：</p><ul><li>每张表只能有一个全文索引。</li><li>由多列组合而成的全文检索的索引必须使用相同的字符集与排序规则。</li><li>不支持没有单词界定符的语言，如中文、日语、韩语等。</li></ul><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><p>MySQL全文检索查询语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">IN NATURAL LANGUAGE MODE</span><br><span class="line">| IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line">| IN BOOLEAN MODE</span><br><span class="line">| WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MATCH 指定了需要被查询的列，AGAINST指定了使用何种方法去进行查询。</p><h5 id="Natural-Language"><a href="#Natural-Language" class="headerlink" title="Natural Language"></a>Natural Language</h5><p>通过MATCH函数进行查询，默认采用Natural Language模式，表示查询带有指定word的文档。</p><p>不使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a where body like &apos;%liwenqi%&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用全文索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a </span><br><span class="line">    -&gt; where match(body)</span><br><span class="line">    -&gt; against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type     | possible_keys | key     | key_len | ref   | rows | filtered | Extra                         |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | fulltext | idx_fts       | idx_fts | 0       | const |    1 |   100.00 | Using where; Ft_hints: sorted |</span><br><span class="line">+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>NATURAL LANGUAGE MODE默认的全文检索查询模式，可省略查询修饰符。</p><p>type列显示fulltext表示使用全文检索的倒排索引，key显示了索引的名字，相对like查询，全文索引只进行了一次扫描。</p><p>查询返回的结果是根据相关性（Relevance）进行降序排序的，相关性最高的结果放在第一位。由一个非负的浮点数表示，0表示没有任何相关性。相关性计算依据的条件：</p><ul><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>有多少个文档包含该word。</li></ul><p>统计查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|        3 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from fts_a  where match(body) against(&apos;liwenqi&apos; in natural language mode);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+-------+</span><br><span class="line">| count |</span><br><span class="line">+-------+</span><br><span class="line">|     3 |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(if(match(body) against(&apos;liwenqi&apos; in natural language mode),1,NULL)) as count from fts_a;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | fts_a | NULL       | index | NULL          | PRIMARY | 8       | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>第二句SQL执行速度更快，第一句SQL语句需要进行相关性的排序统计。</p><p>通过SQL查看相关性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select fts_doc_id,body, match(body) against(&apos;liwenqi&apos; in natural language mode) as relevance from fts_a;</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">| fts_doc_id | body                                      | relevance          |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">|          8 | I am a boy                                |                  0 |</span><br><span class="line">|          9 | I am a bad boy                            |                  0 |</span><br><span class="line">|         10 | I am a good boy                           |                  0 |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          | 0.0906190574169159 |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart | 0.0906190574169159 |</span><br><span class="line">|         13 | where is my heart                         |                  0 |</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             | 0.0906190574169159 |</span><br><span class="line">+------------+-------------------------------------------+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>需考虑因素：</p><ul><li>查询word在stopword列中，忽略该字符串的查询。</li><li>查询的word字符长度是否在区间[innodb_ft_min_token_size, innodb_ft_max_token_size]内。</li></ul><p>若词在stopword中，不对该词进行查询。</p><p>参数<code>innodb_ft_min_token_size</code>和<code>innodb_ft_max_token_size</code>控制InnoDB存储引擎查询字符的长度，当长度小于<code>innodb_ft_min_token_size</code>或者大于<code>innodb_ft_max_token_size</code>时，会忽略该词的搜索，InnoDB存储引擎中，前者值默认为3，后者值默认为84。</p><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>使用该修饰符时，查询字符串的前后缀字符会有特殊的含义，支持以下几种操作符：</p><ul><li>+表示该word必须存在。</li><li>-表示该word必须被排除。</li><li>（no operator）表示该word是可选的，但是如果出现，相关性会更高。</li><li>@distance表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。该全文检索的查询也称为Proximity Search。</li><li><blockquote><p>表示出现该单词时增加相关性。</p></blockquote></li><li><blockquote><p>表示出现该单词时降低相关性。</p></blockquote></li><li>～表示允许出现该单词，但是出现时的相关性为负。</li><li>*表示以该单词开头的单词。</li><li>“表示短语。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;liwenqi girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         14 | liwenqi,what a beautiful girl             |</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts_a  where match(body) against(&apos;+liwenqi -girl&apos; in boolean mode);</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                      |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">|         11 | I am a good boy,who love liwenqi          |</span><br><span class="line">|         12 | I am a good boy,who love liwenqi in heart |</span><br><span class="line">+------------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Query-Expansion"><a href="#Query-Expansion" class="headerlink" title="Query Expansion"></a>Query Expansion</h5><p>MySQL支持全文索引的拓展查询，通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。通过Query Expansion模式开启全文检索的implied knowledge。</p><p>通过在查询短语中添加WITH QUERY EXPANSION或者IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION可以开启blind query knowledge（又称为automatic relevance feedback）。该查询分为两个阶段：</p><ul><li>第一阶段：根据搜索的单词进行全文索引查询。</li><li>第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。</li></ul><p>Query Expansion的全文检索可能会带来许多非相关性的查询。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> index </tag>
            
            <tag> alg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>表</title>
      <link href="/2019/08/19/%E8%A1%A8/"/>
      <url>/2019/08/19/%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：</p><ul><li>首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。</li><li>不符合上述条件则自动创建一个6字节大小的指针。</li></ul><p>若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。</p><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。</p><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>启用参数<code>innodb_file_per_table</code>，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。</p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。</p><p>InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数<code>KEY_BLOCK_SIZE</code>设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.</p><p>InnoDB v1.2.x新增参数<code>innodb_page_size</code>，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。</p><p>在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。</p><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为<code>innodb_page_size</code>，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p><p>常见的页类型：</p><ul><li>数据页（B-Tree Node）</li><li>undo页（undo LogPage）</li><li>系统页（System Page）</li><li>事务数据页（Transaction system Page）</li><li>插入缓冲位图页（Insert Buffer Bitmap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOG Page）</li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。</p><h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>书中介绍不完善，参考博客<a href="https://www.cnblogs.com/wilburxu/p/9435818.html" target="_blank" rel="noopener">MySQL InnoDB 行记录格式</a>。</p><h4 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h4><p>在MySQL 5.0中引入，设计目标是高效地存储数据。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">变长字段长度列表</th><th style="text-align:center">NULL标志位</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节</td><td style="text-align:center">有NULL值列用1表示，占1字节</td><td style="text-align:center">固定占用5字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息每位含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的排序记录</td></tr><tr><td style="text-align:center">record_type</td><td style="text-align:center">3</td><td style="text-align:center">记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimum，011表示Supermum、1xx表示保留</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相应位置</td></tr></tbody></table><p>数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。</p><p>InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。</p><h4 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h4><p>MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。</p><p>存储方式：</p><table><thead><tr><th style="text-align:center">字段长度偏移列表</th><th style="text-align:center">记录头信息</th><th style="text-align:center">列1数据</th><th style="text-align:center">列2数据</th><th style="text-align:center">……</th></tr></thead><tbody><tr><td style="text-align:center">按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示</td><td style="text-align:center">占用六字节</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td><td style="text-align:center">列数据</td></tr></tbody></table><p>记录头信息含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">（）</td><td style="text-align:center">1</td><td style="text-align:center">未知   </td></tr><tr><td style="text-align:center">deleted_flag</td><td style="text-align:center">1</td><td style="text-align:center">该行是否已被删除</td></tr><tr><td style="text-align:center">min_rec_flag</td><td style="text-align:center">1</td><td style="text-align:center">为1，若该记录是预先被定义为最小的记录</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4</td><td style="text-align:center">该记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13</td><td style="text-align:center">索引堆中该条记录的索引号</td></tr><tr><td style="text-align:center">n_flieds</td><td style="text-align:center">10</td><td style="text-align:center">记录中列的数量</td></tr><tr><td style="text-align:center">1 byte_offs_flag</td><td style="text-align:center">1</td><td style="text-align:center">偏移列表为1字节还是2字节</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16</td><td style="text-align:center">页中下一条记录的相对位置</td></tr></tbody></table><p>对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。</p><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOG、LOB这类大对象列类型的存储会把数据存放在数据页面之外，但是BLOG可以不将数据放在溢出页面，即便VARCHAR列数据依然有可能被存放为行溢出数据。</p><p>存放VARCHAR类型的最大长度（所有VARCHAR列的长度总和）为65532字节，超出且将SQL_MODE设为严格模式，建表时会报错，没设置严格模式或许可以建表但是会抛出一个warning，会将VARCHAR类型转换为TEXT类型。</p><p>InnoDB存储引擎的页为16KB，一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，发生行溢出时，数据存放在页类型为Uncompress BLOG页中。</p><p>InnoDB存储引擎表是索引组织的（B+Tree结构），每个页至少应该有两条行记录（否则失去B+Tree意义变成链表）。若页中只能存放下一条记录，则InnoDB存储引擎会自动将行数据放到溢出页中。若能至少放入两行数据则VARCHAR类型的行数据不会存放到BLOG页中，阀值的长度为8098。</p><p>TEXT或BLOG的数据类型，存放在数据页还是BLOG页和VARCHAR原则一致。大多数情况下BLOG的行数据会发生行溢出，实际数据保存在BLOG页中，数据页只保存前768字节。</p><h4 id="Compressed和Dynamic行记录数据"><a href="#Compressed和Dynamic行记录数据" class="headerlink" title="Compressed和Dynamic行记录数据"></a>Compressed和Dynamic行记录数据</h4><p>InnoDB v1.0.x开始引入新的文件格式，以前支持的Compact和Redundant格式被称为Antelope文件格式，新的文件格式称为Barracuda文件格式，其拥有两种新的行记录格式：Compressed和Dynamic。</p><p>新的两种行记录格式对于存放在BLOG中的数据采用了完全的行溢出的方式，数据页中只存放20个字节的指针，实际数据都存放在Off Page中。</p><p>Compressed行记录格式的另一个功能是，存放在其中的行数据会已zlib的算法进行压缩，对BLOG、TEXT、VARCHAR类大长度类型的数据能够进行有效的存储。</p><h4 id="CHAR的行存储结构"><a href="#CHAR的行存储结构" class="headerlink" title="CHAR的行存储结构"></a>CHAR的行存储结构</h4><p>通常理解VARCHAR存储变长长度的字符类型，CHAR存储固定长度的字符类型。</p><p>MySQL v4.1开始，CHAR（N）中N指的是字符的长度，而非字节长度，在不同的字符集下，CHAR类型列内部存储的可能不是定长数据。</p><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度。在多字符集的存储情况下，CHAR和VARCHAR的实际存储基本没有区别。</p><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InoDB数据页组成：</p><ul><li>File Header（文件头）</li><li>Page Header（页头）</li><li>Infimum和Supermun Records</li><li>User Records（用户记录，即行记录）</li><li>Free Space（空闲空间）</li><li>Page Directory（页目录）</li><li>File Trailer（文件结尾信息）</li></ul><p>Flie Header、Page Header、File Trailer大小固定，分别为38、56、8字节，标记该页的一些信息，如Checksum，数据页所在B+ Tree索引的层等。User Records、Free Space、Page Directory为实际的行记录存储空间，大小是动态的。</p><table><thead><tr><th style="text-align:center">File Header</th><th style="text-align:center">Page Header</th><th style="text-align:center">Infimum + Supermum Records</th><th style="text-align:center">User Recodrds</th><th style="text-align:center">Free Space</th><th style="text-align:center">Page Directory</th><th style="text-align:center">File Trailer</th></tr></thead><tbody><tr><td style="text-align:center">38字节</td><td style="text-align:center">56字节</td><td style="text-align:center">行记录</td><td style="text-align:center">行记录</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">8字节</td></tr></tbody></table><h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>组成 ：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（字节）</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_SPACE_OR_CHKSUM</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.0.14之前值为0，之后代表页的checksum值</td></tr><tr><td style="text-align:center">FIL_PAGE_OFFSET</td><td style="text-align:center">4</td><td style="text-align:center">表空间中页的偏移量，表示当前页在表空间所有页中的位置</td></tr><tr><td style="text-align:center">FIL_PAGE_PREV</td><td style="text-align:center">4</td><td style="text-align:center">当前页的上一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_NEXT</td><td style="text-align:center">4</td><td style="text-align:center">当前页的下一个页</td></tr><tr><td style="text-align:center">FIL_PAGE_LSN</td><td style="text-align:center">8</td><td style="text-align:center">最后被修改的日志序列位置LSN（Log Sequence Number）</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE</td><td style="text-align:center">2</td><td style="text-align:center">页的类型，见下表枚举</td></tr><tr><td style="text-align:center">FIL_PAGE_FILE_FLUSH_LSN</td><td style="text-align:center">8</td><td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间值为0</td></tr><tr><td style="text-align:center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td style="text-align:center">4</td><td style="text-align:center">MySQL v4.1开始代表页属于哪个表空间。</td></tr></tbody></table><p>InnoDB存储引擎中页的类型</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">十六进制</th><th style="text-align:center">解释 </th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_INDEX</td><td style="text-align:center">0x45BF</td><td style="text-align:center">B+树叶节点</td></tr><tr><td style="text-align:center">FIL_PAGE_UNDO_LOG</td><td style="text-align:center">0x0002</td><td style="text-align:center">Undo Log页</td></tr><tr><td style="text-align:center">FIL_PAGE_INODE</td><td style="text-align:center">0x0003</td><td style="text-align:center">索引节点</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_FREE_LIST</td><td style="text-align:center">0x0004</td><td style="text-align:center">Insert Buffer空闲列表</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_ALLOCATED</td><td style="text-align:center">0x0000</td><td style="text-align:center">该页为最新分配</td></tr><tr><td style="text-align:center">FIL_PAGE_IBUF_BITMAP</td><td style="text-align:center">0x0005</td><td style="text-align:center">Insert Buffer位图</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_SYS</td><td style="text-align:center">0x0006</td><td style="text-align:center">系统页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_TRX_SYS</td><td style="text-align:center">0x0007</td><td style="text-align:center">事务系统数据</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_FSP_HDR</td><td style="text-align:center">0x0008</td><td style="text-align:center">File Space Header</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_XDES</td><td style="text-align:center">0x0009</td><td style="text-align:center">拓展描述页</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE_BLOG</td><td style="text-align:center">0x000A</td><td style="text-align:center">BLOG页</td></tr></tbody></table><h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>记录数据页的状态信息，由14个部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">PAGE_N_DIR_SLOTS</td><td style="text-align:center">2</td><td style="text-align:center">在Page Directory（页目录）中的Slot（槽）数</td></tr><tr><td style="text-align:center">PAGE_HEAP_TOP</td><td style="text-align:center">2</td><td style="text-align:center">堆中第一个记录的指针、记录在页中是根据堆的形式存放的</td></tr><tr><td style="text-align:center">PAGE_N_HEAP</td><td style="text-align:center">2</td><td style="text-align:center">堆中的记录数，第15位表示行记录数</td></tr><tr><td style="text-align:center">PAGE_FREE</td><td style="text-align:center">2</td><td style="text-align:center">指向可重用空间的首指针</td></tr><tr><td style="text-align:center">PAGE_GARBAGE</td><td style="text-align:center">2</td><td style="text-align:center">已删除记录的字节数，行记录结构中delete flag为1的记录大小的总数</td></tr><tr><td style="text-align:center">PAGE_LAST_INSERT</td><td style="text-align:center">2</td><td style="text-align:center">最后插入记录的位置</td></tr><tr><td style="text-align:center">PAGE_DIRECTORY</td><td style="text-align:center">2</td><td style="text-align:center">最后插入的方向，可取：PAGE_LEFT(0x01)，PAGE_RIGHT(0x02)，PAGE_SAME_REC(0x03)，PAGE_SAME_PAGE(0x04)，PAGE_NO_DIRECTION(0x05)</td></tr><tr><td style="text-align:center">PAGE_N_DIRECTION</td><td style="text-align:center">2</td><td style="text-align:center">一个方向连续插入数据的数量</td></tr><tr><td style="text-align:center">PAGE_N_RECS</td><td style="text-align:center">2</td><td style="text-align:center">该页中记录的数量</td></tr><tr><td style="text-align:center">PAGE_MAX_TEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">当前页的最大事务ID，仅在Secondary Index(辅助索引)中定义</td></tr><tr><td style="text-align:center">PAGE_LEVEL</td><td style="text-align:center">2</td><td style="text-align:center">当前页在索引树中的位置，0x00代表页节点，页节点总在第0层</td></tr><tr><td style="text-align:center">PAGE_INDEX_ID</td><td style="text-align:center">8</td><td style="text-align:center">索引ID，表示当前页属于哪个索引</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_LEAF</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree树的Root页中定义，B+ Tree数据页非页节点所在段的seqment header</td></tr><tr><td style="text-align:center">PAGE_BTR_SEG_TOP</td><td style="text-align:center">10</td><td style="text-align:center">仅在B+ Tree的Root页中定义，B+ Tree数据页所在段的segment header</td></tr></tbody></table><h4 id="Infimum和Supermum-Record"><a href="#Infimum和Supermum-Record" class="headerlink" title="Infimum和Supermum Record"></a>Infimum和Supermum Record</h4><p>Infimum记录比该页中任何主键值都要小得值，Supermum指比任何可能大的值还要大的值，在页创建时被建立，在任何情况下都不会被删除。在Compact和Redundant行格式下，两者占用的字节数各不相同。</p><h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record：实际存储行记录的内容。</p><p>Free Space：空闲空间，链表数据结构，在一条记录被删除后，该空间被加入到空闲链表中。</p><h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>页目录中存放记录的相对位置，有些时候这些记录指针被称为Slots（槽）或目录槽（Directory Slots）。</p><p>InnoDB的槽是一个稀疏目录（sparse directory），一个槽中可能包含多个记录。伪记录Infimum的n_owned值总是1，记录Supermum的n_owned的取值范围为[1, 8]，其他用户记录n_owned的取值范围为[4, 8]，当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。</p><p>Slots中记录按照索引键值顺序存放，可以利用二叉查找，查找结果只是一个粗略的结果，必须通过recorder header中的next_record继续查找相关记录。</p><p>B+ Tree索引找到记录所在的页，数据库把页载入内存，然后通过Page Directory再进行二叉查找。</p><h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>检测页是否已经完整地写入磁盘（可能发生在写入过程中磁盘损坏）。</p><p>只有以一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，后4字节和File Header中的FIL_PAGE_LSN相同。通过InnoDB的checksum函数将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致，保证页的完整行。</p><p>默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，即该页是否发生Corrupt，该检测会有一定的开销，可通过innodb_checksums来开启或关闭对这个页完整性的检查。</p><p>MySQL v5.6.6新增参数<code>innodb_checksum_algorithm</code>，控制检测checksum函数的算法，默认crc32，可设置：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_checksum%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_checksum_algorithm</span><br><span class="line">        Value: crc32</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_checksums</span><br><span class="line">        Value: ON</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>innodb为兼容之前版本的checksum检测方式，crc于v 5.6.6引入，有更高的性能。若表中所有页的checksum值都以strict算法保存，脚底版本MySQL数据库不能读取这些页。none表示不对页启用checksum检测。strict_*表示严格按照checksum算法进行页的检测，较低版本MySQL升级到MySQL5.6.6+版本，启用strict_crc32将不能读取表中的页。启用strict_crc32方式是最快的方式，其不再对innodb和crc32算法进行两次检测。数据库从低版本升级而来需进行mysql_upgrade操作。</p><h3 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h3><p>从InnoDB v1.0.x引入，通过Named File Formats机制解决不同版本下页结构兼容性问题。</p><p>通过参数<code>innodb_file_format</code>指定文件格式，通过参数<code>innodb_file_format_check</code>检测当前存储引擎文件格式的支持度，默认为ON。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@version\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@version: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_file_format&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_format</span><br><span class="line">        Value: Barracuda</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，文件系统一般需要在程序端进行控制。</p><p>数据完整性的三种形式：</p><ul><li>实体完整性保证表中有一个主键。通过Primary Key或Unique Key约束来保证实体的完整性。可通过编写一个触发器来保证数据的完整性。</li><li>域完整性保证数据每列的值满足特定的条件。域完整性保证途径：<ul><li>选择合适的数据类型确保一个数据值满足特定条件。</li><li>外键（Foreign key）约束。</li><li>编写触发器。</li><li>用DEFAULT约束强制域完整性</li></ul></li><li>参照完整性保证两张表之间的关系。InnoDB存储引擎支持外健，允许用户自定义外键以强制参照完整性，通过编写触发器以强制执行。</li></ul><p>InnoDB存储引擎本身提供约束：</p><ul><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL </li></ul><h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>采用两种方式：</p><ul><li>表建立时进行约束定义</li><li>利用ALTER TABLE命令来进行创建约束</li></ul><p>对Unique Key约束，还可通过命令CREATE UNIQUE INDEX来建立。主键约束默认名Primary，Unique Key约束默认约束名和列名一样，可指定Unique Key约束名。Foreign Key约束默认名称特殊。</p><p>可通过information_schema架构下的表TABLE_CONSTRAINTS查看当前MySQL库下所有的约束信息，通过表REFERENTIAL_CONSTRAINTS查看Foreign Key的约束命名和外健的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from information_schema.TABLE_CONSTRAINTS;</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field              | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from information_schema.REFERENTIAL_CONSTRAINTS;</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field                     | Type         | Null | Key | Default | Extra |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG        | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME           | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UNIQUE_CONSTRAINT_NAME    | varchar(64)  | YES  |     | NULL    |       |</span><br><span class="line">| MATCH_OPTION              | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| UPDATE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| DELETE_RULE               | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME                | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| REFERENCED_TABLE_NAME     | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+---------------------------+--------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>约束是逻辑概念，用来保证数据的完整性，索引是一个数据结构，在数据库中代表着物理存储的方式。</p><h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>默认设置下，MySQL允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL会将其更改为0再进行插入。</p><p>可通过设置参数<code>sql_mode</code>为STRICT_TRANS_TABLES，对输入值的合法性进行约束，用来严格审核输入的参数。sql_mode可设值参考MySQL官方手册。</p><h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><p>MySQL数据库不支持传统的CHECK约束，通过ENUM和SET类型解决。</p><p>对于传统CHECK约束支持的连续值的范围约束或更复杂的约束，可通过触发器来实现对于值域的约束。</p><h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。MySQL v5.1开始触发器相对稳定。</p><p>通过命令CREATE TRIGGER创建触发器，具备Super权限的MySQL数据库用户才可执行这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE | AFTER INSERT | UPDATE | DELETE</span><br><span class="line">ON tb1_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure><p>最多可为一个表建立6个触发器，分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。BEFORE和AFTER代表触发器发生的时间，表示在每行操作之前发生还是之后发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table usercash ( userid INT NOT NULL, cash INT UNSIGNED NOT NULL);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table usercash_err_log ( userid INT NOT NULL, old_cash INT UNSIGNED NOT NULL, new_cash INT UNSIGNED NOT NULL, user VARCHAR(30), time DATETIME);</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER $$ </span><br><span class="line">mysql&gt; create trigger tgr_usercash_update before update on usercash</span><br><span class="line">    -&gt; for each row</span><br><span class="line">    -&gt; begin </span><br><span class="line">    -&gt; if new.cash-old.cash &gt; 0 then</span><br><span class="line">    -&gt; insert into usercash_err_log</span><br><span class="line">    -&gt; select old.userid,old.cash,new.cash,USER(),NOW();</span><br><span class="line">    -&gt; set new.cash = old.cash;</span><br><span class="line">    -&gt; end if;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; $$</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update usercash set cash=cash-(-20) where userid=1;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">userid: 1</span><br><span class="line">  cash: 1000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from usercash_err_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  userid: 1</span><br><span class="line">old_cash: 1000</span><br><span class="line">new_cash: 1020</span><br><span class="line">    user: root@localhost</span><br><span class="line">    time: 2019-08-23 15:18:08</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>保证参照的完整性，MyISAM引擎本身不支持外键，对于外键的定义只起注释的作用。InnoDB完整支持外键约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT [symbol]] FOREIGN KEY</span><br><span class="line">[index_name] (index_col_name, ...)</span><br><span class="line">REFERENCES tb1_name (index_col_name, ...)</span><br><span class="line">[ON DELETE reference_option]</span><br><span class="line">[ON UPDATE reference_option]</span><br><span class="line">reference_option:</span><br><span class="line">RESTRICT | CASCADE | SET NULL | NO ACTION</span><br></pre></td></tr></table></figure><p>可执行CREATE TABLE或者ALTER TABLE命令添加外健。</p><p>被引用的表为父表、引用的表称为子表，外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作，可定义字表操作有：</p><ul><li>CASCADE：父表发生DELETE或UPDATE操作时对相应字表中的数据也进行DELETE或UPDATE操作。</li><li>SET NULL：父表发生DELETE或UPDATE操作时，相应的字表中的数据被更新为NULL值，字表相应字段必须允许为NULL值。</li><li>NO ACTION：父表发生DELETE或UPDATE操作时，抛出错误，不允许此类操作发生。</li><li>RESTRICT：未定义ON DELETE或ON UPDATE时的默认外健设置。</li></ul><p>MySQL数据库的外键约束为及时检查，在SQL语句运行时进行检查。MySQL数据库中NO ACTION和RESTRICT的功能是相同的。</p><p>InnoDB在外键建立时会自动为该列加一个索引，可避免外键列上无索引而导致的死锁问题产生。</p><p>可通过参数<code>foreign_key_checks</code>设置是否开启外键检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;foreign_key_checks&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: foreign_key_checks</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，由一个SQL查询来定义，可当作表使用，没有实际的物理存储。</p><h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><p>被用作一个抽象装置，不需关心基表（base table）的结构，只需按视图定义来取数据或更新数据。一定程度上起到安全层作用。</p><p>MySQL v5.0开始支持视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[OR REPLACE]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">[SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>可对某些视图进行更新操作，本质是通过视图的定义来更新基本表。称可进行更新操作的视图为可更新视图（updatable view）。WITH CHECK OPTION针对于可更新视图更新的值是否需要检查。</p><p>通过SHOW TABLES命令显示结果包含基表和视图，只查询基表可通过information_schema架构下的TABLE表查询，并搜索类型为BASE TABLE的表。</p><p>查看视图的元数据（meta data）可访问information_schema架构下的VIEWS表，给出了视图的定义者（definer）、定义内容、是否是可更新视图、字符集等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">+------------------+</span><br><span class="line">8 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create view v_users</span><br><span class="line">    -&gt; as</span><br><span class="line">    -&gt; select * from users where id&lt;10;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_login  |</span><br><span class="line">+------------------+</span><br><span class="line">| jobs             |</span><br><span class="line">| migrations       |</span><br><span class="line">| password_resets  |</span><br><span class="line">| user_profiles    |</span><br><span class="line">| usercash         |</span><br><span class="line">| usercash_err_log |</span><br><span class="line">| users            |</span><br><span class="line">| users_old        |</span><br><span class="line">| v_users          |</span><br><span class="line">+------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.VIEWS where table_schema=database()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       TABLE_CATALOG: def</span><br><span class="line">        TABLE_SCHEMA: login</span><br><span class="line">          TABLE_NAME: v_users</span><br><span class="line">     VIEW_DEFINITION: select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`sex` AS `sex` from `login`.`users` where (`login`.`users`.`id` &lt; 10)</span><br><span class="line">        CHECK_OPTION: NONE</span><br><span class="line">        IS_UPDATABLE: YES</span><br><span class="line">             DEFINER: root@localhost</span><br><span class="line">       SECURITY_TYPE: DEFINER</span><br><span class="line">CHARACTER_SET_CLIENT: utf8</span><br><span class="line">COLLATION_CONNECTION: utf8_general_ci</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果，在执行复杂查询时，可避免进行这些耗时的操作，从而快速得到结果，对于一些复杂的统计类查询能直接查处结果。</p><p>MySQL数据库不支持物化视图，可通过一些机制来实现物化视图的功能。例如可通过触发器维护一个结果状态副表，每当发生INSERT、UPDATE和DELETE操作时触发器更新结果状态表。</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h4><p>MySQL v5.1时添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对应用，逻辑上只有一个或一个索引，但在物理上表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p><p>MySQL支持水平分区（同一表中不同行的记录分配到不同的物理文件中），不支持垂直分区（同一表中不同列的记录分配到不同的物理文件中）。MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。全局分区指数据存放在各个分区中，但是所有数据的索引放在一个对象中。</p><p>可通过<code>SHOW VARIABLES LIKE &#39;%partition%&#39;\G</code> 和<code>SHOW PLUGINS\G</code>查看是否启用了分区功能。</p><p>MySQL数据库支持分区类型：</p><ul><li>RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区，v5.5开始支持RANGE COLUMNS的分区。</li><li>LIST分区：面向离散的值。v5.5开始支持LIST COLUMNS的分区。</li><li>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的哈希函数进行分区。</li></ul><p>若表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引允许NULL值，分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。若建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><h5 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h5><p>启用分区之后，表由建立分区时的各个分区ibd文件组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t</span><br><span class="line">    -&gt; (id INT) engine=innodb</span><br><span class="line">    -&gt; partition by range (id) (partition p0 values less than (10),partition p1 values less than (20));</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login | grep t</span><br><span class="line">total 2288</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 16:06 t#P#p1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 16:06 t.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    40B  8 23 14:49 tgr_usercash_update.TRN</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (9);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (15);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 30</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t add partition (partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (id) values (30);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.PARTITIONS where table_schema=database() and table_name=&apos;t&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p0</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 1</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 10</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:12</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: login</span><br><span class="line">                   TABLE_NAME: t</span><br><span class="line">               PARTITION_NAME: p1</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 2</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: id</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 20</span><br><span class="line">                   TABLE_ROWS: 2</span><br><span class="line">               AVG_ROW_LENGTH: 8192</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: NULL</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2019-08-30 16:06:18</span><br><span class="line">                  UPDATE_TIME: 2019-08-30 16:28:31</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT: </span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询information_schema架构下的PARTITION表来查看每个分区的具体信息，TABLE_ROWS为每个分区中记录的数量，PARTITION_METHOD为分区的类型。插入一个不在分区中定义的值时，会抛出一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE sales ( money INT UNSIGNED NOT NULL, date DATETIME ) ENGINE=INNODB PARTITION by RANGE (YEAR(date)) ( PARTITION p2018 VALUES LESS THAN (2019), PARTITION p2019 VALUES LESS THAN (2020) );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-02-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2018-01-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2019-03-02&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into sales (money,date) values(100,&apos;2020-03-02&apos;);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 2020</span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2018-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 33.33</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain partitions select * from sales where date&gt;=&apos;2018-01-01&apos; and date&lt;=&apos;2019-12-31&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales</span><br><span class="line">   partitions: p2018,p2019</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 25.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过EXPLAIN PARTITIONS可查看查询条件搜索的分区，SQL优化器会做分区修剪。可根据分区直接删除指定范围内的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from sales;·</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2018-01-01 00:00:00 |</span><br><span class="line">|   100 | 2018-02-01 00:00:00 |</span><br><span class="line">|   100 | 2018-01-02 00:00:00 |</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table sales drop partition p2018;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from sales;</span><br><span class="line">+-------+---------------------+</span><br><span class="line">| money | date                |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">|   100 | 2019-03-02 00:00:00 |</span><br><span class="line">+-------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于RANGE分区的查询，优化器只能对YESR()、TO_DAYS()、TO_SECONDS()、UNIX_TIMESTAMP()这类函数进行优化选择。</p><h5 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h5><p>LIST分区相似于RANGE分区，分区列的值是离散的，而非连续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,1,2,4,6,8));</span><br><span class="line">ERROR 1495 (HY000): Multiple definition of same constant in list partitioning</span><br><span class="line">mysql&gt; create table t ( a int, b int)ENGINE=INNODB PARTITION BY LIST(b) ( PARTITION p0 VALUES in (1,3,5,7,9), PARTITION p1 VALUES in (0,2,4,6,8));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,6);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,7);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a,b) values (1,10);</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 10</span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 2</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 2</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>VALUES IN中的值又重复时创建表会报错，插入值不在其中会报错。</p><p>INSERT插入多个数据的过程中遇到分区未定义时，MyISAM和InnoDB存储引擎表现不同，MyISAM会将之前的行数据都插入，之后的数据不插入。InnoDB将其视为一个事务，没有任何数据插入。</p><h5 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h5><p>目的将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致都是一样的。需要基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_hash (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by hash (year(b))</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; insert into t_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>插入分区：mod(expr, num)</p><p>对于连续的值进行HASH分区，可以较好的将数据进行平均分区。</p><p>LINEAR HASH分区，使用更加复杂的算法确定新行插入到已经分区的表中的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_linear_hash ( a int, b datetime )engine=innodb partition by linear hash (year(b)) partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_linear_hash values (1,&apos;2010-04-01&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_linear_hash&apos; and table_schema=DATABASE()\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: t_linear_hash</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>计算分区：</p><ul><li>取大于分区数量4的下一个2的幂值V，V=POWER(2,CEILING(LOG(2,num)))=4</li><li>所在分区N=YEAR(‘010-04-01’)&amp;(V-1)=2</li></ul><p>LINEAR HASH分区的优势在于增加、删除、合并和拆分分区变得更加快捷，有利于处理含有大量数据的表。缺点在于各分区数据的分布可能不大均衡。</p><h5 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h5><p>与HASH分区相似，HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。对于NDB Cluster引擎，MySQL DB使用MD5函数来分区；其他存储引擎使用内部分哈希函数，这些函数基于PASSWORD()一样的运算法则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_key (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b datetime</span><br><span class="line">    -&gt; )engine=innodb</span><br><span class="line">    -&gt; partition by key (b)</span><br><span class="line">    -&gt; partitions 4;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure><p>在key分区中使用关键字LINEAR和在HASH分区中使用具有相同的效果，分区编号通过2的幂算法得到而不是通过模数算法。</p><h5 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h5><p>RANGE、LIST、HASH、和KEY分区条件：数据必须是整型，或通过函数将其转化为整型。</p><p>MySQL v5.5开始支持COLUMNS分区，是RANGE分区和LIST分区的进化，可以直接使用非整型数据进行分区，分区根据类型直接比较而得，不需要转化为整型。RANGE COLUMNS分区可对多个列的值进行分区。</p><p>COLUMNS分区支持的数据类型：</p><ul><li>所有整型类型，如INT、SMALLINT、TINYINT、BIGINT。FLOAT和DECIMAL不支持。</li><li>日期类型，DATE和DATETIME。其余日期类型则不支持。</li><li>字符串类型，如CHAR、VARCHAR、BINARY和VARBINARY。BLOB和TEXT类型不支持。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_columns_range ( </span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b datetime</span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (b) (</span><br><span class="line">-&gt;partition p0 values less than (&apos;2019-01-01&apos;), </span><br><span class="line">-&gt;partition p1 values less than (&apos;2020-01-01&apos;) );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table rcx (</span><br><span class="line">-&gt;a int, </span><br><span class="line">-&gt;b int, </span><br><span class="line">-&gt;c char(3), </span><br><span class="line">-&gt;d int </span><br><span class="line">-&gt;)engine=innodb </span><br><span class="line">-&gt;partition by range columns (a,b,c) ( </span><br><span class="line">-&gt;partition p0 values less than (5,10,&apos;ggg&apos;),</span><br><span class="line">-&gt;partition p1 values less than (10,20,&apos;mmm&apos;), </span><br><span class="line">-&gt;partition p2 values less than (15,30,&apos;sss&apos;),</span><br><span class="line">-&gt;partition p3 values less than (maxvalue,maxvalue,maxvalue));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;t_columns_range&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: t_columns_range</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name,partition_name,table_rows from information_schema.PARTITIONS where table_name=&apos;rcx&apos; and table_schema=DATABASE()\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p0</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p1</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p2</span><br><span class="line">    table_rows: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    table_name: rcx</span><br><span class="line">partition_name: p3</span><br><span class="line">    table_rows: 0</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h5 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h5><p>在分区的基础上再进行分区，也称符合分区。MySQL DB允许再RANGE和LIST的分区上再进行HASH或KEY的子分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table ts ( a int, b date)engine=innodb</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b))</span><br><span class="line">    -&gt; subpartitions 2 (</span><br><span class="line">    -&gt; partition p0 values less than (2019),</span><br><span class="line">    -&gt; partition p1 values less than (2020),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p0#SP#p0sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p1#SP#p1sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:27 ts#P#p2#SP#p2sp1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:27 ts.frm</span><br><span class="line"></span><br><span class="line">mysql&gt; create table ts_subpartition (a int,b date)engine=innodb                                                                                                                                                                                                                     </span><br><span class="line">    -&gt; partition by range (year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b)) (</span><br><span class="line">    -&gt; partition p0 values less than (2019) (subpartition s0, subpartition s1)</span><br><span class="line">    -&gt; ,partition p1 values less than (2020) (subpartition s2, subpartition s3)</span><br><span class="line">    -&gt; ,partition p2 values less than maxvalue (subpartition s4, subpartition s5));</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo ls -lh /usr/local/mysql/data/test | grep ts_subpartition</span><br><span class="line">Password:</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s0.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p0#SP#s1.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s2.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p1#SP#s3.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s4.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 30 19:37 ts_subpartition#P#p2#SP#s5.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  8 30 19:37 ts_subpartition.frm</span><br></pre></td></tr></table></figure><p>子分区建立：</p><ul><li>每个子分区的数量必须相同</li><li>要在一个分区表的任何分区上使用subpartition来明确定义任何子分区，就必须定义所有的子分区</li><li>每个subpartition子句必须包括子分区的一个名字</li><li>子分区的名字必须是唯一的</li></ul><p>子分区可用于特别大的表，在多个磁盘分别分配数据和索引。</p><h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MySQL允许对NULL值做分区，总是视NULL值小于任何一个非NULL的值，与MySQL DB中处理NULL值的ORDER BY操作是一样的。对于不同的分区类型，MySQL DB对NULL值的处理也各不相同。</p><p>对RANGE分区，若向分区列插入NULL值，则将该值放入最左边的分区。</p><p>在LIST分区下使用NULL值需要显式地指定哪个分区中放入NULL值，否则报错。</p><p>HASH和KEY分区处理NULL值时，任何分区函数都会将含有NULL值的记录返回为0。</p><h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>数据库应用分为：OLTP（在线事务处理），如Blog、电子商务、网络游戏等；OLAP（在线分析处理），如数据仓库、数据集市。</p><p>对OLAP应用，分区一般能很好地提高查询的性能。OLAP应用大多数查询需要频繁地扫描一张很大的表。</p><p>对OLTP应用，分区需要注意，用用通常不可能会获取一张大表中10%的数据，大部分都可通过索引返回几条记录即可。对一张大表，一般的B+ Tree需要2～3次的磁盘IO。设计时需要确认数据的访问模式，分析查询时使用分区是否能够比未使用分区减少IO访问次数。</p><h4 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h4><p>MySQL v5.6开始支持ALTER TABLE … EXCHANGE PARTITION语法。允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。若非分区表中的数据为空，则相当于将分区中的数据迁移到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。</p><p>使用语句条件：</p><ul><li>要交换的表需和分区表有着相同的表结构，但是表不能含有分区</li><li>在非分区表中数据必须在交换的分区定义内</li><li>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</li><li>用户除了需要ALTER、INSERT和CREATE权限外，还需要DROP的权限</li></ul><p>需要注意的细节：</p><ul><li>使用该语句不会触发交换表和被交换表上的触发器</li><li>AUTO_INCREMENT列将被重置</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件</title>
      <link href="/2019/08/16/%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/16/%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>InnoDB存储引擎表的各种类型文件。</p><ul><li>参数文件：告知MYSQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，介绍各种参数的类型。</li><li>日志文件：记录MySQL实例对某种条件做出响应时写入的文件，如错误的日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</li><li>socket文件：当用UNIX域套接字方式进行连接时需要的文件。</li><li>pid文件：MySQL实例的进程ID文件。</li><li>MySQL表结构文件：用来存放MySQL表结构定义文件。</li><li>存储引擎文件：每个存储引擎有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。</li></ul><h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><p>默认MySQL实例会按照一定的顺序在指定的位置进行读取，可通过<code>mysql --help | grep my.cnf</code>来寻找。</p><p>MySQL的mysql架构中记录了访问该实例的权限，当找不到这个架构时，MySQL实例不会启动成功。</p><h4 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h4><p>可以把数据参数看成一个键/值（Key/Value）对。</p><p>MySQL v5.1开始可以通过<code>information_schema</code>架构下的<code>GLOBAL_VARIABLES</code>试图来进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from global_variables where variable_name like &apos;innodb_buffer%&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_AT_STARTUP</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_FILENAME</span><br><span class="line">VARIABLE_VALUE: ib_buffer_pool</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_POPULATE</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_DUMP_AT_SHUTDOWN</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_ABORT</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_INSTANCES</span><br><span class="line">VARIABLE_VALUE: 8</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_SIZE</span><br><span class="line">VARIABLE_VALUE: 4294967296</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line"> VARIABLE_NAME: INNODB_BUFFER_POOL_LOAD_NOW</span><br><span class="line">VARIABLE_VALUE: OFF</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_at_shutdown</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_dump_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_filename</span><br><span class="line">        Value: ib_buffer_pool</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 8</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_abort</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_at_startup</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_load_now</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_populate</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 4294967296</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>各版本都支持<code>SHOW VARIABLES</code>命令。</p><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>可分为：</p><ul><li>动态参数（dynamic）参数，可在MySQL实例运行中进行更改</li><li>静态（static）参数，在整个实例生命周期内都不得进行更改</li></ul><p>可通过SET命令对动态参数值进行更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET | [global | session] system_var_name = expr | [@@global. | @@session. | @@]system_var_name= expr</span><br></pre></td></tr></table></figure><p>global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。有些参数如autocommit只能在会话中进行修改；有些参数如binlog_cache_size修改完后，在整个实例生命周期中都会生效；有些参数如read_buffer_size既可以在会话中修改又可以在整个实例的生命周期内生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set read_buffer_size=524288;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 131072</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @@global.read_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@global.read_buffer_size: 262144</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.read_buffer_size\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@session.read_buffer_size: 524288</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>动态变量的可修改范围参考MySQL官方手册Dynamic System Variables。</p><p>修改静态变量报错，提示静态变量是只读的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set GLOBAL datadir=&apos;/db/mysql&apos;;</span><br><span class="line">ERROR 1238 (HY000): Variable &apos;datadir&apos; is a read only variable</span><br></pre></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>记录MySQL数据库的各种类型活动：</p><ul><li>错误日志（error log）</li><li>二进制日志（binlog）</li><li>慢查询日志（slow query log）</li><li>查询日志（log）</li></ul><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>对MySQL的启动、运行、关闭过程进行了记录，可通过<code>SHOW VARIABLES LIKE ‘log_error’</code>来定位文件。可从中得到数据库优化的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_error&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_error</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.err</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system hostname</span><br><span class="line">wuhua</span><br></pre></td></tr></table></figure><p>默认情况下错误文件的文件名为服务器的主机名（自己mac下默认安装v5.7.22时使用了默认配置创建了_mysql用户，但是也有wuhua.err日志）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# ps aux | grep mysql | grep -v grep</span><br><span class="line">wuhua            27197   0.0  0.0  4301596   1628 s000  S+   二05下午   0:00.18 mysql -u root -p</span><br><span class="line">_mysql              95   0.0  0.1  4667136   8176   ??  Ss    8 819    0:50.48 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring --early-plugin-load=keyring_file=keyring_file.so</span><br><span class="line">sh-3.2# pwd</span><br><span class="line">/usr/local/mysql/data</span><br><span class="line">sh-3.2# ls -la</span><br><span class="line">total 390208</span><br><span class="line">drwxr-x---   17 _mysql  _mysql       544  8 13 17:50 .</span><br><span class="line">drwxr-xr-x   13 root    wheel        416 10 22  2018 ..</span><br><span class="line">-rw-r-----    1 _mysql  _mysql        56  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql       559  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  50331648  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  79691776  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql  12582912  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql       224  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql       512  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql      2464  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1493892  8 16 14:11 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql         3  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql      2880  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql      3456  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql       160 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    137797  8 13 17:50 wuhua.err</span><br><span class="line">sh-3.2# tail -n 10 mysqld.local.err </span><br><span class="line">2019-08-15T03:46:55.758211Z 4 [Note] Aborted connection 4 to db: &apos;unconnected&apos; user: &apos;root&apos; host: &apos;localhost&apos; (Got timeout reading communication packets)</span><br><span class="line">2019-08-15T05:57:18.115284Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 2089426ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T10:19:57.114776Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 591037ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-15T12:48:35.002866Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 257282ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T00:45:10.005256Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 42960754ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T02:30:30.003258Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 6316989ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T04:41:49.003687Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 1295395ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:09:32.002146Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 68711ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T06:11:12.002422Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 24552ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</span><br><span class="line">2019-08-16T07:44:47.528144Z 8 [Note] Access denied for user &apos;wuhua&apos;@&apos;localhost&apos; (using password: NO)</span><br></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。</p><p>可通过参数<code>long_query_time</code>来设置超时阀值，默认10，代表10秒，将运行超过该值的SQL语句记录到慢查询日志文件中。</p><p>默认不启动慢查询日志，需要手工将这个参数设置为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 10.000000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>测试服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: long_query_time</span><br><span class="line">        Value: 2.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;slow_query_log&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: slow_query_log</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>当设置了参数<code>log_queries_not_using_indexes</code>为开启时，会将没有使用索引的SQL语句记录到慢查询日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_queries_not_using_indexes&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_queries_not_using_indexes</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可通过参数<code>log_throttle_queries_not_using_indexes</code>设置每分钟允许记录到slow log的且未使用索引的SQL语句的次数。默认为0表示无限制。</p><p>可通过mysqldumpslow命令分析慢查询日志文件。使用参考<a href="http://www.dbhelp.net/2017/01/17/mysqldumpslow-%E8%AF%BB%E6%87%82mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.html" target="_blank" rel="noopener">mysqldumpslow – 读懂MySQL慢查询日志</a></p><p>v 5.1开始可以将慢查询的日志记录放入到一张表中，在mysql架构下的slow_log表，表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show create table mysql.slow_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: slow_log</span><br><span class="line">Create Table: CREATE TABLE `slow_log` (</span><br><span class="line">  `start_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  `user_host` mediumtext NOT NULL,</span><br><span class="line">  `query_time` time NOT NULL,</span><br><span class="line">  `lock_time` time NOT NULL,</span><br><span class="line">  `rows_sent` int(11) NOT NULL,</span><br><span class="line">  `rows_examined` int(11) NOT NULL,</span><br><span class="line">  `db` varchar(512) NOT NULL,</span><br><span class="line">  `last_insert_id` int(11) NOT NULL,</span><br><span class="line">  `insert_id` int(11) NOT NULL,</span><br><span class="line">  `server_id` int(10) unsigned NOT NULL,</span><br><span class="line">  `sql_text` mediumtext NOT NULL,</span><br><span class="line">  `thread_id` bigint(21) unsigned NOT NULL</span><br><span class="line">) ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT=&apos;Slow log&apos;</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>显示该表的引擎为CSV，对大数据量下的查询效率不高，可将其转换为MyISAM引擎并在start_time列上添加索引，但是已经启动了慢查询修改会报错，而且更改后会对数据库造成额外的开销。</p><p>参数log_output指定了慢查询输出的格式，默认为FILE，指定为TABLE即可将其输出到mysql架构下的slow_log表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_output&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: log_output</span><br><span class="line">        Value: FILE</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>参数<code>log_output</code>是动态全局的。</p><p>InnoSQl版本加强了对于SQL语句的捕获方式，在原版MySQL数据库的基础上在slow log中增加了对于物理读取（physical reads：从磁盘进行IO读取的次数）和逻辑读取（logic reads：所有的读取，无论磁盘还是缓冲池）的统计。可通过参数<code>long_query_io</code>将超过指定逻辑IO次数的SQL语句记录到slow log中，默认为100。为兼容原MySQL数据库的运行方式，还添加了参数<code>slow_query_type</code>用来表示启用slow log的方式，可选：</p><ul><li>0 表示不将SQL语句记录到slow log</li><li>1 表示根据运行时间将SQL语句记录到slow log</li><li>2 表示根据逻辑IO次数将SQL语句记录到slow log</li><li>3 表示根据运行时间及逻辑IO次数将SQL语句记录到slow log </li></ul><h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p>记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行，默认文件名为：主机名.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%general%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: general_log</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: general_log_file</span><br><span class="line">        Value: /usr/local/mysql/data/wuhua.log</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>本地没有开启查询日志。同slow log，v5.1开始可将查询日志放入mysql架构下的general_log表中。</p><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>binary log记录了对MySQL数据库执行更改的所有操作，不包括SELECT和SHOW这类操作。</p><p>作用：</p><ul><li>恢复：某些数据的恢复需要需要二进制日志。例如再一个数据库全备文件恢复后，可通过二进制日志进行ponit-in-time的恢复。</li><li>复制：原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般为slave或standby）与一台MySQL数据库（一般为master或primary）进行实时同步。</li><li>审计：可通过审计判断是否有对数据库进行注入的攻击。</li></ul><p>通过配置参数log-bin [=name]启动二进制日志，不指定name则默认二进制日志文件名为主机名，后缀名为二进制日志的序列号，所在路径为数据库所在目录。</p><p>默认没启动，需要手动指定参数启动。影响二进制日志记录的信息和行为：</p><ul><li>max_binlog_size：指定单个二进制日志文件的最大值，超过该值产生新的二进制日志文件，后缀名加1，并记录到index文件。</li><li>binlog_cache_size：使用事务表存储引擎时，未提交的二进制日志会被记录到一个缓冲中去，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，缓冲的大小由binlog_cache_size决定，默认为32k。基于session，当一个线程开启事务时会分配一个大小为binlog_cache_seze的缓存，若一个事务的记录大于设定的binlog_cache_size，会将缓冲中的日志写入一个临时文件。可通过<code>SHOW GLOBAL STATUS</code>查看<code>binlog_cache_use</code>和<code>binlog_cache_disk_use</code>的状态判断当前的设置是否合适，前者记录使用缓冲写二进制日志的次数，后者记录使用临时文件写二进制日志的次数。</li><li>sync_binlog：表示每写缓冲多少次就同步到磁盘。值1表示采用同步写磁盘的方式来写二进制日志，但是若在事务发出commit之前发生宕机，此时二进制日志写入文件，但是提交还没有发生，在启动恢复时由于二进制日志已经记录了该事务信息，不能被回滚，可通过将参数innodb_support_xa设为1解决，能同时保证二进制日志和InnoDB存储引擎数据文件的同步；默认0。若使用InnoDB存储引擎进行复制，并且想得到最大的高可用行，建议将该值设置为ON。</li><li>binlog-do-db和binlog-ignore-db：表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</li><li>log-slave-update：若当前DB是复制中的slave角色，不会将从master取得并执行二进制日志写入自己的二进制日志文件中去，若需要写入则需设置log-slave-update。若搭建master=&gt;slave=&gt;slave架构的复制则必须设置该参数。</li><li>bin_format：二进制日志的格式。MySQL v5.1前无此参数，格式基于SQL语句级别，存在问题：若在主服务器上运行rand、uuid等函数或者使用触发器会导致主从服务器上表中数据的不一致；因为二进制日志文件格式的关系默认事务隔离级别为REPEATABLE READ，若使用READ COMMITTED的事务隔离级别会出现丢失更新的现象，出现主从数据库上的数据不一致。</li></ul><p>v5.1开始引入参数bin_format可设STATEMENT、ROW和MIXED。</p><ol><li>STATEMENT格式和之前的版本一样，二进制文件记录的是日志的逻辑SQL语句。</li><li>ROW格式下，二进制日志记录表的行更改情况，对Statement格式下的复制问题予以解决，若设置bin_format为ROW，可将InnoDB的事务隔离级别设为READ COMMITTED，以获得更好的并发行。</li><li>MIXED格式下，默认采用STATEMENT格式进行二进制日志文件的记录，但在一些情况下会使用ROW格式，可能有：<ul><li>表的存储引擎为NDB，对表的DML操作都会以ROW格式记录。</li><li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数。</li><li>使用了INSERT DELAY语句。</li><li>使用了用户定义函数（UDF）</li><li>使用了临时表（temeporary table）</li></ul></li></ol><p>binlog_format参数对于存储引擎的限制：</p><table><thead><tr><th style="text-align:center">存储引擎</th><th style="text-align:center">Row格式</th><th style="text-align:center">Statement格式</th></tr></thead><tbody><tr><td style="text-align:center">InnoDB</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MyISAM</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">HEAP</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">MERGE</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">NDB</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">Archive</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">CSV</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Federate</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Blockhole</td><td style="text-align:center">N</td><td style="text-align:center">Y </td></tr></tbody></table><p>通常将参数binlog_format设置为ROW，可为数据库的恢复和复制带来更好的可靠性。有些语句下的ROW格式可能需要更大的容量，会带来二进制文件大小的增加。由于复制是采用传输二进制日志方式实现，复制的网络开销也有所增加。</p><p>二进制日志文件需要通过MySQL提供的工具mysqlbinlog工具查看。</p><p><a href="https://juejin.im/post/5a72c2daf265da3e5234d879" target="_blank" rel="noopener">腾讯工程师带你深入解析 MySQL binlog</a></p><h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3><p>UNIX系统下可采用UINX域套接字方式连接本地MySQL，需要一个套接字文件。</p><p>可由参数socket控制，一般在/tmp目录下，名为mysql.sock。</p><h3 id="pid-文件"><a href="#pid-文件" class="headerlink" title="pid 文件"></a>pid 文件</h3><p>MySQL实例启动时，会将进程ID写入一个文件——该文件即为pid文件，可由参数pid_file控制，默认位于数据库目录下，文件名为主机名.pid：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &apos;pid_file&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: pid_file</span><br><span class="line">        Value: /usr/local/mysql/data/mysqld.local.pid</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h3><p>MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储是根据表进行，每个表都有与之对应的文件。无论表采用何种引擎，都有一个以frm为后缀名的文件，记录了该表的表结构定义。frm文件还用来存放视图的定义，文件为文本文件。</p><p>查看时发现文件内容像加密过，一查果然，参考<a href="http://mysql.taobao.org/monthly/2018/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 表空间加密</a></p><h3 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h3><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>InnoDB采用存储的数据按表空间（tablespace）进行存放的设计，默认配置下会有一个初始大小为10M名为ibdata1的文件，其为默认的表空间文件，可通过参数innodb_data_file_path对其进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=datafile_spec1[;datafile_spec2]...</span><br></pre></td></tr></table></figure><p>可通过多个文件组成一个表空间文件，同时制定文件的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = /db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure><p>意味着将/db/ibdata1和/dr2/db/ibdata2两个文件用来组成表空间，大小都为2000MB，若用完可自动增长。若位于不同的磁盘上，磁盘的负载可能被平均，提高数据库的整体性能。</p><p>设置该参数后，所有基于InnoDB的表的数据都会记录到该共享表空间中，若设置了参数<code>innodb_file_pre_table</code>，则用户可以将每个基于InnoDB存储引擎的产生一个独立表空间，命令规则为：表名.idb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_file_per_table&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data/login</span><br><span class="line">total 1424</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    65B  7  5  2018 db.opt</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.6K  8 16  2018 jobs.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  8 16  2018 jobs.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 19  2018 migrations.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    96K  8 16  2018 migrations.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 26  2018 password_resets.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   112K  7 26  2018 password_resets.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.5K  7 26  2018 user_profiles.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   128K  7 27  2018 user_profiles.ibd</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   100B  7 18 16:11 users.MYD</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   2.0K  7 24 09:58 users.MYI</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   8.4K  7 18 15:55 users.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql    13K  7 18 15:48 users_old.frm</span><br><span class="line">-rw-r-----  1 _mysql  _mysql   176K  7 18 15:48 users_old.ibd</span><br></pre></td></tr></table></figure><p>单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>默认情况下InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。记录了InnoDB存储引擎的事务日志。</p><p>当实例或介质失败（media failure）时，InnoDB存储引擎会根据重做日志恢复到掉电前的时刻，以此来保证数据的完整性。</p><p>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。可设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。</p><p>影响重做日志文件的属性：</p><ul><li>innodb_log_file_size：指定每个重做日志文件的大小，InnnoDB v1.2.x前总大小小于等于4GB，v1.2.x将限制扩大为512GB。</li><li>innodb_log_files_in_group：指定日志文件组中重做日志文件的数量，默认为2。</li><li>innodb_mirrored_log_groups：指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像。若磁盘本身已做了高可用方案，如磁盘列阵，则可以不开启重做日志镜像的功能。</li><li>innodb_log_group_home_dir：指定了日志文件组所在的路径，默认为./，表示在MySQL数据库的数据目录下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; system sudo  ls -lh /usr/local/mysql/data</span><br><span class="line">Password:</span><br><span class="line">total 390208</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    56B  7  4  2018 auto.cnf</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   559B  8  8 17:25 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  8  8 17:25 ib_logfile0</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    48M  7  4  2018 ib_logfile1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    76M  8  8 17:25 ibdata1</span><br><span class="line">-rw-r-----    1 _mysql  _mysql    12M  8 16 15:12 ibtmp1</span><br><span class="line">drwxr-x---    7 _mysql  _mysql   224B  9 11  2018 local_test</span><br><span class="line">drwxr-x---   16 _mysql  _mysql   512B  7 18 15:55 login</span><br><span class="line">drwxr-x---   77 _mysql  _mysql   2.4K  7  4  2018 mysql</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   1.4M  8 19 13:43 mysqld.local.err</span><br><span class="line">-rw-r-----    1 _mysql  _mysql     3B  8  8 17:25 mysqld.local.pid</span><br><span class="line">drwxr-x---   90 _mysql  _mysql   2.8K  7  4  2018 performance_schema</span><br><span class="line">drwxr-x---  108 _mysql  _mysql   3.4K  7  4  2018 sys</span><br><span class="line">drwxr-x---    5 _mysql  _mysql   160B 11  8  2018 test</span><br><span class="line">-rw-r-----    1 _mysql  _mysql   135K  8 13 17:50 wuhua.err</span><br></pre></td></tr></table></figure><p>重做日志文件设置过大会导致恢复需要很长的时间，太小会导致一个事务需要多次切换重做日志文件。此外太小会导致频繁地发生async checkpoint，导致性能的抖动。</p><p>二进制日志记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志，InnoDB存储引擎的重做日志只记录有关该存储引擎本身的事务日志。二进制日志记录的是关于一个事务的具体操作内容，该日志是逻辑日志，InnoDB存储引擎的重做日志记录的是关于每个页的更改的物理情况。二进制日志文件仅在事务提交前进行提交，只写磁盘一次，不论该事务多大，在事务进行的过程中，不断有重做日志被写入到重做日志文件中。</p><p>到InnoDB v1.2.x版本为止，共定义了51种重做日志类型，基本格式相同：</p><table><thead><tr><th style="text-align:center">redo_log_type</th><th style="text-align:center">space</th><th style="text-align:center">page_no</th><th style="text-align:center">redo_log_body</th></tr></thead><tbody><tr><td style="text-align:center">占用1字节，表示重做日志的类型</td><td style="text-align:center">表示表空间的ID，采用压缩的方式，占用空间可能小于4字节</td><td style="text-align:center">表示页的偏移量，采用压缩的方式</td><td style="text-align:center">表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析</td></tr></tbody></table><p>从重做日志缓冲往磁盘写入时按照512个字节（一个扇区）的大小进行写入，因为扇区是写入的最小单位，可以保证写入必定是成功的。重做日志的写入过程中不需要有doublewrite。</p><p>参数<code>innodb_flush_log_at_trx_commit</code>控制在提交时，处理重做日志的方式：</p><ul><li>0 ：表示当事务提交时，不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</li><li>1 ：执行commit时将重做日志缓冲同步写到缓存中，伴有fsync的调用。</li><li>2 ：表示将重做日志异步写到磁盘，即写到文件系统的缓存中，不能完全保证执行commit时肯定会写入重做日志文件，只是有这个动作发生。</li></ul><p>为保证ACID中的持久性，必须将innodb_flush_log_at_trx_commit设为1，即每档事务提交时就必须确保事务已经写入重做日志文件，当数据库意外宕机时可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。设为0或2时，都有可能发生恢复时部分事务的丢失，但是设置为2若MySQL数据库宕机而操作系统及服务器没有宕机时，由于此时为写入磁盘的事务日志保存在文件系统缓冲中，恢复时同样能保证数据不丢失。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker学习-命令</title>
      <link href="/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><p>EXAMPLES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line">//绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line"></span><br><span class="line">//使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h4 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h4><p>docker start :启动一个或多个已经被停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker stop :停止一个运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker restart :重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line">//停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line">//重启容器myrunoob</span><br><span class="line"></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>docker kill :杀掉一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-s :向容器发送一个信号</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//杀掉运行中的容器mynginx</span><br><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>docker rm ：删除一个或多少容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line"></span><br><span class="line">//移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line">//删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h4 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h4><p>docker pause :暂停容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>docker unpause :恢复容器中所有的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//暂停数据库容器db01提供服务。</span><br><span class="line">docker pause db01</span><br><span class="line"></span><br><span class="line">//恢复数据库容器db01提供服务。</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>docker create ：创建一个新的容器但不启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>同<code>docker run</code><br>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>docker exec ：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">//在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>docker ps : 列出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :显示所有的容器，包括未运行的。</li><li>-f :根据条件过滤显示的内容。</li><li>–format :指定返回值的模板文件。</li><li>-l :显示最近创建的容器。</li><li>-n :列出最近创建的n个容器。</li><li>–no-trunc :不截断输出。</li><li>-q :静默模式，只显示容器编号。</li><li>-s :显示总的文件大小。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//列出所有在运行的容器信息</span><br><span class="line">wuhua:blog wuhua$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>####inspect<br>docker inspect : 获取容器/镜像的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li><li>-s :显示总的文件大小。</li><li>–type :为指定类型返回JSON。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取镜像mysql:5.6的元信息</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">//获取正在运行的容器mymysql的 IP</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>docker attach :连接到正在运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><p>docker events : 从服务器获取实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//显示docker 2016年7月1日后的所有事件</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">//显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</span><br></pre></td></tr></table></figure><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p><p>OPTIONS:</p><ul><li>-f : 跟踪日志输出</li><li>–since :显示某个开始时间的所有日志</li><li>-t : 显示时间戳</li><li>–tail :仅列出最新N条容器日志</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">//查看容器mynginx从2016年7月1日后的最新10条日志</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :将输入内容写到文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure><p>###容器rootfs命令</p><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>docker commit :从容器创建一个新的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>docker cp :用于容器与主机之间的数据拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-L :保持源目标中的链接</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">//将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">//将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span><br><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>docker diff : 检查容器里文件结构的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看容器mymysql的文件结构更改。</span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><h4 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h4><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><p>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker logout [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-u :登陆的用户名</li><li>-p :登陆的密码</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登陆到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">//登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :拉取所有 tagged 镜像</li><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从Docker Hub下载java最新版镜像。</span><br><span class="line">docker pull java</span><br><span class="line">//从Docker Hub下载REPOSITORY为java的所有镜像。</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>docker search : 从Docker Hub查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–automated :只列出 automated build类型的镜像；</li><li>–no-trunc :显示完整的镜像描述；</li><li>-s :列出收藏数不小于指定值的镜像。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:blog wuhua$ docker search -s 10 java</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">node                                         Node.js is a JavaScript-based platform for s…   7238                [OK]                </span><br><span class="line">tomcat                                       Apache Tomcat is an open source implementati…   2333                [OK]                </span><br><span class="line">java                                         Java is a concurrent, class-based, and objec…   1967                [OK]                </span><br><span class="line">openjdk                                      OpenJDK is an open-source implementation of …   1599                [OK]                </span><br><span class="line">ghost                                        Ghost is a free and open source blogging pla…   951                 [OK]                </span><br><span class="line">anapsix/alpine-java                          Oracle Java 8 (and 7) with GLIBC 2.28 over A…   402                                     [OK]</span><br><span class="line">jetty                                        Jetty provides a Web server and javax.servle…   294                 [OK]                </span><br><span class="line">couchdb                                      CouchDB is a database that uses JSON for doc…   269                 [OK]                </span><br><span class="line">ibmjava                                      Official IBM® SDK, Java™ Technology Edition …   67                  [OK]                </span><br><span class="line">groovy                                       Apache Groovy is a multi-faceted language fo…   66                  [OK]                </span><br><span class="line">tomee                                        Apache TomEE is an all-Apache Java EE certif…   64                  [OK]                </span><br><span class="line">lwieske/java-8                               Oracle Java 8 Container - Full + Slim - Base…   43                                      [OK]</span><br><span class="line">cloudbees/jnlp-slave-with-java-build-tools   Extends cloudbees/java-build-tools docker im…   25                                      [OK]</span><br><span class="line">zabbix/zabbix-java-gateway                   Zabbix Java Gateway                             16                                      [OK]</span><br><span class="line">frekele/java                                 docker run --rm --name java frekele/java        13                                      [OK]</span><br><span class="line">davidcaste/alpine-java-unlimited-jce         Oracle Java 8 (and 7) with GLIBC 2.21 over A…   11                                      [OK]</span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p>docker images : 列出本地镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID.</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">//列出本地镜像中REPOSITORY为ubuntu的镜像列表</span><br><span class="line">wuhua:blog wuhua$ docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br></pre></td></tr></table></figure><h4 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h4><p>docker rmi : 删除本地一个或多少镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :强制删除；</li><li>–no-prune :不移除该镜像的过程镜像，默认移除；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制删除本地镜像runoob/ubuntu:v4。</span><br><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>docker tag : 标记本地镜像，将其归入某一仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>docker build 命令用于使用 Dockerfile 创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>–build-arg=[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label=[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置/dev/shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line">//使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">//通过 -f Dockerfile 文件的位置</span><br><span class="line"> docker build -f /path/to/a/Dockerfile .</span><br><span class="line">//在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回</span><br><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>docker history : 查看指定镜像的创建历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-H :以可读的格式打印镜像大小和日期，默认为true；</li><li>–no-trunc :显示完整的提交记录；</li><li>-q :仅列出提交记录ID。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查看本地镜像runoob/ubuntu:v3的创建历史</span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>docker save : 将指定镜像保存成 tar 归档文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-o :输出到的文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>docker import : 从归档文件中创建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-c :应用docker 指令创建镜像；</li><li>-m :提交时的说明文字；</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span><br><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info [OPTIONS]</span><br></pre></td></tr></table></figure><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-11T12:27:47.5699614Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>docker version :显示 Docker 版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-f :指定返回值的模板文件。</li></ul><p>EXAMPLES:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> mac </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker学习-安装配置</title>
      <link href="/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/06/Docker%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>mac环境桌面版</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ brew search docker</span><br><span class="line">==&gt; Formulae</span><br><span class="line">docker                                   docker-machine-completion</span><br><span class="line">docker-clean                             docker-machine-driver-hyperkit</span><br><span class="line">docker-cloud                             docker-machine-driver-vultr</span><br><span class="line">docker-completion                        docker-machine-driver-xhyve</span><br><span class="line">docker-compose                           docker-machine-nfs</span><br><span class="line">docker-compose-completion                docker-machine-parallels</span><br><span class="line">docker-credential-helper                 docker-squash</span><br><span class="line">docker-credential-helper-ecr             docker-swarm</span><br><span class="line">docker-gen                               docker2aci</span><br><span class="line">docker-ls                                dockerize</span><br><span class="line">docker-machine</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">docker                                   homebrew/cask-versions/docker-edge</span><br><span class="line">docker-toolbox</span><br><span class="line">wuhua:src wuhua$ brew cask install docker</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/31259/Docker.dmg</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask &apos;docker&apos;.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App &apos;Docker.app&apos; to &apos;/Applications/Docker.app&apos;.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure><p>点<code>访达</code>边的<code>启动台</code> 可看到下载好的桌面版docker，点击启动按步骤操作输入密码授权</p><p>配置后启动查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Error response from daemon: Bad response from Docker engine</span><br><span class="line">wuhua:src wuhua$ docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: VWVF:EJP2:5EGI:AWPX:KD3K:5ILZ:KTJ6:CXKL:UBGN:XY5N:ZQUT:YDMB</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 51</span><br><span class="line"> System Time: 2019-04-06T07:47:49.465200315Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hqx51nri.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><p>第一次<code>docker info</code>查询失败是因为未启动完毕。</p><p>关于docker命令参考<a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></p><p>关于设置docker国内镜像参考<a href="https://www.cnblogs.com/anliven/p/6218741.html" target="_blank" rel="noopener">Docker国内镜像</a></p><p>关于其他系统Doker安装参考<a href="http://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">MacOS Docker 安装</a></p><p>关于<code>brew</code>和<code>brew cask</code>参考<a href="https://blog.csdn.net/yanxiaobo1991/article/details/78455908" target="_blank" rel="noopener">mac brew和brew cask的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年终总结</title>
      <link href="/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/02/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>时间真快，距离开始创建博客已经过去快一年了。这期间，大学毕业，结束了四年相对来说最悠闲的时光；初入职场，参入工作，体回到码农的苦逼加班生活。</p><h3 id="上半年-大学毕业"><a href="#上半年-大学毕业" class="headerlink" title="上半年-大学毕业"></a>上半年-大学毕业</h3><p>从17年11月份确定毕设课题开始，毕设导师就开始积极联系我们进行相关课题的研究工作。可能是由于导师也是第一年回校园工作，对之前的毕设流程不了解，对我们的要求可以说是有点太过严谨。在10月末确定工作签好三方后，本想去公司实习一段时间，了解公司和相关技术，但是导师以毕设为由，建议将毕设弄差不多后再去实习。</p><p>17年末，过的很轻松，结束掉了大学最后的几门课程考试。这段时间， 每天基本睡到自然醒，中午一点多去梦泽园吃顿饭，回宿舍打游戏，晚上玩手机熬夜到很晚，第二天循环如此。这一段时间，应该是大学过的最爽的一段时间，不用再顾虑学习，确定好了工作，混吃等死。每天重复的事情——打游戏、睡觉、一切其他感兴趣的事情。有点遗憾是经济不支持，没能实现出去旅游四处走走的心愿。有点不爽的是，考试结束本来可以回家的，导师要求留校十天，进行毕设课题相关的工作。其实这十天完全没做多少毕设相关的工作，大多数时间依旧堕落的生活。放假前的例会，发给我们相关软硬件，让我们回家摸索。然而，春节期间谁会想到这玩意呢，怎么样带回去，再怎么样的带回来，再在例会前几天突击了解一下。</p><p>春节期间，由于工作的<code>理想工资</code>，自己快有点飘了，在各个房产软件上查看洛阳、信阳等各处楼盘的信息，心里决定一定要靠自己买到理想的、位置合适的一套房子。现在想想，当时的想法还有点太遥远，想要去实现，还远得很。</p><p>18年开学，晚来了一周多，如果不是导师要求例会，完全不想再返回学校。到学校后，发现很多同学已经开始或打算去实习了，这时有个换毕设课题的机会，跟与学校合作的企业去开发<code>养猪</code>项目，当作毕设课题，当时爽妈还建议我一起报，可以想着搞定毕设去公司实习，拒绝了，结合后来苦逼的毕设过程、没能够去公司实习、看他们<code>养猪</code>玩的不亦乐乎，简直想抽自己两巴掌，后悔得要死。后来18年大四最后一学期的前几个月——3月中旬至五月中旬——就如前面所说。每天在导师给找的办公室里做毕设相关——看资料、翻译、看源代码、记录，枯燥无聊。四月初感觉毕设做的差不多了想去实习，联系hr后反馈没有实习名额了，然后<code>养猪</code>的同学四处游山玩水，简直心里不爽到极点。不爽的最后也是有些收获的，阅读项目底层C语言源码，收获有一些，在18年的一篇日志中有些记录，这里就不重记了。到5月中旬，毕设论文准备的差不多了，就趁二姐回家，回家过了半个月，陪可爱的外甥女玩，很是惬意开心。6月初返校，修修改改准备最后的论文终稿、答辩PPT，10号答辩顺利通过，其实感觉我是通过的最顺利的一个，整个过程不到5分钟，没有安全相关的老师，没问什么问题，对做的工作进行了一些了解性提问，最后甚至还有个老师想要推优我的毕设论文。还好最终没推优，省去了一些麻烦事。作为一条咸鱼，已经不对大学再抱有任何幻想，只想着顺利毕业结束这不怎么样的四年。</p><p>这半年沉寂了N久的和尚之心也随着与李老师的几次会面交流在18年春天有了一些蠢蠢欲动，也是在枯燥的毕设过程中多了一些点缀。但是毕竟多年修炼有素，内心抑制住了，对于没有把握的事情不再轻易尝试。在四月时，自己曾一人骑着小蓝车再一次逛了一遍校园。从图书馆出发，骑到24节气看观赏的游客，骑到油菜田拍一片金黄、骑过基本建成养猪厂、骑过坟场前面旁边开的鲜花正盛的小户人家、骑过柳树随着春风摇曳着枝条的南湖边、骑过情侣经常约会的小树林、起过吐槽了四年的环湖跑路线、起过茶叶地、骑过种满各种花卉和作物的研究圆、起过二运篮球场旁边开满紫色小花的小树林、骑到清真食堂再感受一遍不怎么喜欢的饭菜最终还是照旧选择了炒饭，最后在慢慢走回去，体验这最后的悠闲时光。六月中旬班级毕业晚饭到毕设典礼以及最后的毕业离校时间，其实还是挺想留下来感受下这最后的相聚时光的，虽然回家过端午节并送二姐回家是提前离校原因之一，但是更过的原因是不想再见那些隔阂了很久的同学，想早点逃离这不爽快的生活。</p><p>总的来说，18年的上半年，生活的主要节奏是毕设，心中住进的人在毕设枯燥的生活中增添了一些别样色彩，可爱的外甥女，毕设离别。在技术上，学习了go的一点皮毛，复习一些c相关的东西，遗忘了PHP。</p><h3 id="下半年-参入工作"><a href="#下半年-参入工作" class="headerlink" title="下半年-参入工作"></a>下半年-参入工作</h3><p>拿到小强寄回的毕业证后，迟迟不想离家，想在家多待几天，定的火车票也很晚，直到日期到达不得不收拾行李开始北漂生活。六月二十八下午到北京，出站后马上办理了一卡通，先坐地铁去上班的地方看了一眼，拍了一张北大的竺可桢大楼，由于之前没租好房，然后立刻拖着行李开始去附近找中介看房子，然后这附近的房子符合心里价位预期的不是小就是破旧，最终没能定下，看完房子吃完晚饭差不多六点了，才开始考虑宾馆的事情。这个时候才开始去美团上看附近的青旅，基本上家家都爆满了。最后花了100多大洋找到一家<code>招待所</code>，直到七绕八绕问了路人才找到这家在地下二层的<code>招待所</code>。是的，地下室，很多间，里面住着不少人，看着有晾晒衣服的，其中不少工作服，例如交通协助员服、清洁工服等，虽然这里并没有阳关。里面用的公用的洗漱间和卫生间，有点高中公共卫生间的感觉，但是要比那糟糕多了，这里没有阳光，通气靠中央空调，异常潮湿，老旧残破。这个地下室在中关村靠近苏州街那边，具体的位置记不太清了。那天晚上才确认到，原来还真有在这种环境中常驻生活的人的，体会到生活的不易。虽然环境差了些，但我还是睡着了，因为太困了，拖着大行李箱跑了好久。</p><p>29号早晨离开地下室、拖着行李箱开始坐四号线往南走到自如上房价相对便宜点的站点下，但一下地铁，计算下路上消耗的时间就打消了租房的念头，然后又坐四号线往北走，到安河桥北下，计算公司地铁站点到安河桥北消耗的时间。下地铁后，之前在自如上关注的房源负责的中介联系上了我，说是十六号线永丰南有房源要马上释放了，想帮我抢，这个时候拖着行李跑了老半天的我简直感动到不行，然后立刻提供了账号，可惜她并没有帮我抢到，她甚至怀疑他们内部有挂，也是很有趣。然后从安河桥北站向外面忘了几眼，合计下地铁时间，就开始重新进站，向hr推荐的十六号线上的几点地点去，根据通勤时间以及自如上的房价，最终选择了在马连洼站下，然后开始搜索附近的中介，最后拖着行李先找了链家，他们的房源与自如上的是统一的，中介也是根据需求在自如上查找，最后给推荐了一个在圆明园别墅的将要退租的房源，但是到30号才能看房。出了链家，又找了一家不远的我爱我家，才知道他们的房源与平台展示的是不同步的，给推荐了三处房源，最终选择了30号可马上入住的肖家河，思考再三签了合同，交了12500元，花了人生中最大的一笔钱。这一晚，在同是应届生的同事租好的房子里打地铺凑合了一晚，他刚好租在隔壁小区，感谢这位热心广东同事。30号早去办完交接手续，就开始布置房子，正式入住了。七月一号，和这位广东同事一起去逛了故宫，但是实在太大了，我们只走了一条线就结束了，然后骑自行经过天安门，去同事推荐的美食街吃了碗面，坐地铁回家。</p><p>七月二号，正式入职，去总部本办理入职手续，花了一上午时间，吃完午饭去办公地点，由hr领着带到每个人的小组，交给组长。我们组长帆哥再带领我们去见经理、和前端负责人打招呼，然后给我们安排工位。接着hr带领我们熟悉办公环境，介绍我们所在的组，以及生活上的日常。</p><p>七月和八月这两个月算事这半年最轻松的，跟着新人培养计划熟悉相关技术和工具，做一个内部项目，每晚都能八点左右甚至吃完晚饭后直接回去，这两个月回去后还经常再开几把lol。到了九月份开始熟悉正在开发的正式项目X，就慢慢开始忙起来了。这两个月我们组有些人事变动，七月中旬刚聚餐完，下旬组长就开始离职前的最后休假了，到了九月中旬及十月中旬，陆续又有三名同事离开。技术上完全是学习状态，虽然之前撸项目PHP用的挺多，但是也快有大半年未接触过了，这大半年都投入到毕设和了解Go上去了，其他相关的技术如mysql、nginx、redis等也是学习使用状态。</p><p>刚开始接触正式项目X，有些吃力，没有从一开始就关注这个项目，业务完全不了解，读相关产品文档、wiki、代码都有些吃力。这时正值这个正式项目第一次上线，离职同事负责的模块留下了很多待解决bug，这时他的模块交给了另一个同事，待解决bug也基本都有这位交接的同事慢慢解决完了。他带着我开始熟悉这部分的业务，从一些新增的简单接口开始，慢慢熟悉了解整个模块。这时候也大部分都是在学习状态，跟着了解业务，跟着学会排查bug，解决bug。十月下旬述职转正，可能是不适应经理的冷脸，心里总是很紧张，比笔毕设答辩时还紧张，表现很差，最后顺序转正，算是正式员工可以有绩效了。</p><p>九月到十一月还不是很忙，基本上是熟悉业务写些小接口的状态，还可以有些时间进行其他的学习。十一月过的很糟心，三叔的离世。十一月末回来后，正式开始了这半年最繁忙的两个月。</p><p>十一月时接了一个评审中的项目A，十二月开始进入开发，但是十二月上旬，同事由于有其他工作需求解决，交给了我另一个项目B。还好的是老项目逻辑可以参考，坏的是时间很紧，根据排期只有一周多的时间就要体测，没有参入评审，对很多细节不了解，也给后来埋了不少坑。这一两周每天都回去很晚，整理老项目逻辑，开发，调试，该bug。十二月初，十一月评审的项目A也正式进入排期阶段，在做项目B的同时整理项目A相关产品文档，确定需求接口，再向被人要接口要排期。同时，十二月初，之前负责的项目X需要改版，之前写的接口基本不能复用，好在接口不多，在十二月中旬花了三四天完成。完成项目X的接口后，项目A也开始进入开发阶段，同时还要排查修改项目X和项目B的相关bug，直到项目A接口交付deadline的前一天——圣诞后两天，项目A需要的10个接口还有一半未完成，而在圣诞节这天项目X改版上线，通宵到四五点才回去。睡到中午醒，立刻开始项目A未完成的接口开发，一直到交付日期五点基本开发完。这两天简直有点吃不消，一直影响到一月，脸上又开始出现很多痘痘，脸色也很不好。一开始以为项目A只有刚开始需求的十多个新接口，其他的可以复用老接口，后来发现我错了，一月份的整个工作都消耗在了老接口的调试重写上，被提N多BUG，每天在改bug、熟悉老代码逻辑、调试接口中度过。目前还有一个遗留bug未解决，需要年后继续联调。在一月中旬，接了哟哥小工具的开发工作，开始以为是一个简单的小功能，最开始的产品需求也比较简单，可是后来出现一些问题后就突然麻烦起来，虽然目前给了一个折中解决方案，年后估计还有好一整。</p><p>这半年，也和几个老同学们聚过几次，去过北京几个地儿。技术上的状态，目前仍然是学习阶段，这半年大多时间都在用php撸业务去了，上半年了解的go也基本忘差不多了。上半年住进心里的李老师，我也终于鼓起勇气直面内心了一回，希望在新的一年里能有更多时间去争取。</p><p>一会就到站了，希望自己在新的一年里一切顺利，家人身体健康～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于mysql的character_set变量</title>
      <link href="/2019/01/25/%E5%85%B3%E4%BA%8Emysql%E7%9A%84character-set%E5%8F%98%E9%87%8F/"/>
      <url>/2019/01/25/%E5%85%B3%E4%BA%8Emysql%E7%9A%84character-set%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天查寻数据时，发现结果中汉字都成了乱码，查看数据表相关乱码字段字符集结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show full columns from table_name;</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">| Field              | Type                | Collation       | Null | Key | Default | Extra          | Privileges           | Comment     |</span><br><span class="line">+--------------------+---------------------+-----------------+------+-----+---------+----------------+----------------------+-------------+</span><br><span class="line">...</span><br><span class="line">| user_name          | varchar(100)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ????        |</span><br><span class="line">| chapter_name       | varchar(255)        | utf8_general_ci | YES  |     | NULL    |                | select,insert,update | ?????       |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看数据库字符集设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;char%&apos;;</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| Variable_name            | Value                               |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">| character_set_client     | latin1                              |</span><br><span class="line">| character_set_connection | latin1                              |</span><br><span class="line">| character_set_database   | utf8                                |</span><br><span class="line">| character_set_filesystem | binary                              |</span><br><span class="line">| character_set_results    | latin1                              |</span><br><span class="line">| character_set_server     | utf8                                |</span><br><span class="line">| character_set_system     | utf8                                |</span><br><span class="line">| character_sets_dir       | /usr/share/percona-server/charsets/ |</span><br><span class="line">+--------------------------+-------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>大致感觉到原因是由于数据表相关字段字符集设置为utf8，以utf8编码存储，但是查询结果以latin1编码输出，导致汉字出现乱码。</p><p>搜索得解决办法，在查询语句中对出现乱码字段字符集编码进行转换，具体转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(unhex(hex(convert(user_name using utf8))) using latin1) as user_name,convert(unhex(hex(convert(chapter_name using utf8))) using latin1) as chapter_name</span><br></pre></td></tr></table></figure><p>最终得到正确无乱码的查询结果。</p><h3 id="各character-set变量的含义"><a href="#各character-set变量的含义" class="headerlink" title="各character_set变量的含义"></a>各character_set变量的含义</h3><p>参考博客<a href="http://www.laruence.com/2008/01/05/12.html" target="_blank" rel="noopener">深入Mysql字符集设置</a>,<br><a href="https://hk.saowen.com/a/9c46af2db75e4f83be2d3eecd0d8de1246c3a69aed5facfbebe19ad46ca2600c" target="_blank" rel="noopener">Mysql中各種與字符編碼集（character_set）有關的變量含義</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> character_set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>InnoDB存储引擎</title>
      <link href="/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle数据库的架构。</p><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池，负责工作：</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构。</li><li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li><li>重做日志（redo log）缓冲。 </li></ul><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据。将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>InnoDB是多线程模型，后台有多个不同的后台线程，负责处理不同的任务。</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>使用AIO（Async IO）来处理写IO请求，提高数据库的性能。IO Thread负责这些IO请求的回调（call back）处理。InnoDB V1.0前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。Linux下IO Thread的数量不能进行调整，Win下可以通过参数<code>innodb_file_io_threads</code>来增大IO Thread。InnoDB V1.0开始，read thread和write thread分别增大到了4个，不再使用<code>innodb_file_io_threads</code>参数，分别使用<code>inodb_read_io_threads</code>和<code>innodb_write_io_threads</code>参数进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_version&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line">        Value: 5.7.22</span><br><span class="line">1 row in set (0.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_%io_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_read_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: innodb_write_io_threads</span><br><span class="line">        Value: 4</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-23 00:22:55 0x7000078ef000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 30 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 3 srv_active, 0 srv_shutdown, 261512 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 261494</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 9</span><br><span class="line">OS WAIT ARRAY INFO: signal count 9</span><br><span class="line">RW-shared spins 0, rounds 9, OS waits 2</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 9.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 23555</span><br><span class="line">Purge done for trx&apos;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479475189552, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for i/o request (log thread)</span><br><span class="line">I/O thread 2 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 3 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 4 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 5 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 6 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 7 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 8 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 9 state: waiting for i/o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&apos;s:, sync i/o&apos;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">432 OS file reads, 59 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34673, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 4861558</span><br><span class="line">Log flushed up to   4861558</span><br><span class="line">Pages flushed up to 4861558</span><br><span class="line">Last checkpoint at  4861549</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 137933</span><br><span class="line">Buffer pool size   8191</span><br><span class="line">Free buffers       7760</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 42</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=94, Main thread ID=123145423732736, state: sleeping</span><br><span class="line">Number of rows inserted 90, updated 0, deleted 0, read 98</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.08 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p><code>show engine innodb status</code>观察IO Thread。读线程的ID总是小于写线程。</p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>事务被提交后，其所使用的undolog可能不再需要，需要Purge Thread回收已经使用并分配的undo页，V1.1之前，purge操作仅在InnoDB存储引擎的Master Thread中完成，V1.1开始，可以单独到独立的线程中进行，减轻Master Thread的工作，提高CPU使用率、提升存储引擎的性能。</p><p>在数据库配置文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=1</span><br></pre></td></tr></table></figure><p>来启用独立的Purge Thread。</p><blockquote><p>查看配置文件位置  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ /usr/local/mysql/bin/mysql --verbose --help |grep -A 1 &apos;Default options&apos;</span><br><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf </span><br><span class="line">wuhua:~ wuhua$ mysql --help|grep &apos;my.cnf&apos;</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>设置后重启mysql（<code>sudo /usr/local/mysql/support-files/mysql.server restart</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>V1.1即使将<code>innodb_purge_threads</code>设为大于一，启动时也会将其设为1。V1.2开始，为进一步加快undo页的回收，支持多个Purge Thread。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_threads&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_threads</span><br><span class="line">        Value: 4</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>于V1.2.x版本引入，为减轻原Master Thread的工作及对于用户查询线程的阻塞、进一步提高InnoDB存储引擎的性能，将之前版本中脏页的刷新操作放到单独的线程中来完成。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>InnoDB存储引擎基于磁盘存储，并将其中的记录按照页的方式进行管理，可将其视为基于磁盘的数据库系统。因CPU速度与磁盘速度之间的鸿沟，使用缓冲池技术来提高数据库的整体性能。</p><p>数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，过程称为将页‘FIX’在缓冲池中。下一次再读取相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取页，否则读取磁盘上的页。</p><p>进行页的修改操作时，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，通过一种称为Checkpoint的机制刷新回磁盘。为提高数据库的整体性能。</p><p>缓冲池的大小直接影响着数据库的整体性能。32位系统下该值为3G，可打开操作系统的PAE选项来获得32位操作系统下最大64GB内存的支持。为使数据库使用更多的内存，建议数据库服务器采用64位操作系统。</p><p>缓存池的配置通过参数<code>innodb_buffer_pool_size</code>来设置，默认值是128M，最小5M(当小于该值时会设置成5M)，最大为LLONG_MAX。</p><p>修改前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 134217728</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_size&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_size</span><br><span class="line">        Value: 268435456</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>缓冲池中缓冲的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。索引页和数据页占缓冲池很大一部分。</p><p>从V1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。可以减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过参数<code>innodb_buffer_pool_instances</code>来进行设置，默认值为1，设置大于1时需保证缓冲池大小（<code>innodb_buffer_pool_size</code>）最小为1G。</p><p>设置前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>设置后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ cat  .my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads=4</span><br><span class="line">innodb_buffer_pool_size=1028M</span><br><span class="line">innodb_buffer_pool_instances=2</span><br></pre></td></tr></table></figure><p>多种方式查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema</span><br><span class="line">mysql&gt; select pool_id,pool_size,free_buffers,database_pages from innodb_buffer_pool_stats\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       pool_id: 0</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40724</span><br><span class="line">database_pages: 231</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">       pool_id: 1</span><br><span class="line">     pool_size: 40955</span><br><span class="line">  free_buffers: 40755</span><br><span class="line">database_pages: 200</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_buffer_pool_instances&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_buffer_pool_instances</span><br><span class="line">        Value: 2</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40724</span><br><span class="line">Database pages     231</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 196, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 231, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   40955</span><br><span class="line">Free buffers       40755</span><br><span class="line">Database pages     200</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 200, created 0, written 0</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 200, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h5><p>通常数据库中的缓冲池通过LRU（Latest Recent Used）算法来进行管理。InnoDB缓冲池中页的大小默认为16KB，使用LRU算法管理。但对LRU算法做了一些优化，在LRU列表中增加了midpoint位置，新读取到的页放入到LRU列表的midpoint位置。默认配置下，该位置在LRU列表长度的5/8处。可由参数<code>innodb_old_blocks_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p>表示新读取的页插入到LRU列表尾端37%（3/8）的位置，把midpoint之后的列表称为old表，之前的列表称为new列表。引入另一个参数<code>innodb_old_blocks_time</code>进一步管理LRU列表，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 1000</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">mysql&gt; set global innodb_old_blocks_time=999;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_time&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_time</span><br><span class="line">        Value: 999</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>若预估活跃的热点数据不止63%，可以在执行SQL前，通过设置<code>innodb_old_blocks_pct</code>的值减少热点页可能被刷出来的概率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 37</span><br><span class="line">1 row in set (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_old_blocks_pct=20;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_old_blocks_pct&apos;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_old_blocks_pct</span><br><span class="line">        Value: 20</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>LRU列表管理已经读取的页，当数据库刚启动时，LRU列表是空的，此时页存放在Free列表中。从缓冲池中分页时，先从Free列表中查找可用的空闲页，有则从Free列表中删除，放入到LRU列表中，否则根据LRU算法淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p><p>通过<code>show engine innodb status</code>观察LRU列表及Free列表的使用情况和运行状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line">=====================================</span><br><span class="line">2019-01-24 21:13:11 0x700007d13000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 53 seconds</span><br><span class="line">-----------------</span><br><span class="line">...</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 396, created 35, written 39</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Free buffers与Database pages的数量之和可能不等于Buffer pool size，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insert Buffer等页。Buffer pool hit rate表示缓冲池命中率，小于95%需要观察是否由于全表扫描引起的LRU列表被污染问题。</p><blockquote><p>该命令显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。<code>Per second averages calculated from the last 53 seconds</code></p></blockquote><p>可通过<code>INNODB_BUFFER_PAGE_LRU</code>来观察每个LRU列表中每个页的具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where space=189;</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| table_name | space | page_number | page_type         |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br><span class="line">| NULL       |   189 |           0 | FILE_SPACE_HEADER |</span><br><span class="line">| NULL       |   189 |           1 | IBUF_BITMAP       |</span><br><span class="line">| NULL       |   189 |           2 | INODE             |</span><br><span class="line">| NULL       |   189 |           3 | INDEX             |</span><br><span class="line">| NULL       |   189 |           4 | INDEX             |</span><br><span class="line">+------------+-------+-------------+-------------------+</span><br></pre></td></tr></table></figure><p>V1.0.x开始支持压缩页的功能，可将原本16KB的页压缩为1KB、2KB、4KB和8KB，非16KB的页，通过unzip_LRU列表进行管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 431, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure><p>LRU中的页包含了unzip_LRU列表中的页。</p><p>unzip_LRU列表中对不同压缩页大小的风进行分别管理，通过伙伴算法进行内存的分配。例如从缓冲池中申请页为4KB的大小，过程为：</p><ul><li>检查4KB的unzip_LRU列表，检查是否有可用的空闲页；</li><li>若有，直接使用；</li><li>否则检查8KB的unzip_LRU列表；</li><li>若有空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；</li><li>否则从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。</li></ul><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察unzip_LRU列表中的项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,compressed_size from innodb_buffer_page_lru where compressed_size&lt;&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">...</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 1374289920</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   81910</span><br><span class="line">Free buffers       81479</span><br><span class="line">Database pages     431</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flu</span><br></pre></td></tr></table></figure><p><code>Modified db pages</code>显示了脏页的数量。</p><p>可通过表<code>INNODB_BUFFER_PAGE_LRU</code>来观察脏页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select table_name,space,page_number,page_type from innodb_buffer_page_lru where oldest_modification&gt;0;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p><code>TABLE_NAME</code>为NULL表示该页属于系统表空间。</p></blockquote><h5 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h5><p>InnoDB存储引擎的内存区域除缓冲池外还有重做日志缓存（redo log buffer），InnoDB先将重做日志信息先放入到这个缓冲区，然后按一定的频率将其刷新到重做日志文件，一般每秒都会将重做日志缓冲刷新到日志文件，用户只需保证每秒产生的事务量在这个缓冲大小之内，不需要将其设置的很大。该值可由配置参数innodb_log_buffer_size控制，默认为8M（mac v5.7.22 默认16M）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_log_buffer_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_log_buffer_size</span><br><span class="line">        Value: 16777216</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在以下三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p><ul><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件；</li><li>每个事物提交时会将重做日志缓冲刷新到重做日志文件；</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5><p>InnoDB对内存的管理是通过堆内存（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓存（frame buffer）还有对应的缓冲控制对象（buffer control block：记录一些诸如LRU、锁、等待等信息），对象的内存需要从额外内存池中申请。在申请了很大的InnoDB缓冲池时，也应考虑相应地增加额外内存池的大小。</p><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>页的操作首先都是在缓冲池中完成的，若一条DML语句改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本比磁盘的新，数据库将新版本的页从缓冲池刷新到磁盘。</p><p>为避免数据丢失问题，当前事物数据库系统普遍都采用了Write Ahead Log策略，即当事物提交时，先写重做日志，再修改页。当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。事务ACID中D（Durability持久性）的要求。</p><p>Checkpoint（检查点）技术的目的：</p><ul><li>缩短数据库的恢复时间；</li><li>缓冲池不够用时，将脏数据刷新到磁盘；</li><li>重做日志不可用时，刷新脏页。</li></ul><p> 数据库发生宕机时，数据库不需要重做所有的日志，Checkpoint之前的页都已经刷新回磁盘，数据库只需对Checkpoint后的重做日志进行恢复。</p><p> 当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</p><p> 重做日志不可用的情况是因为在当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，这部分可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p> InnoDB存储引擎通过LSN（Log Sequence Number）来标记版本，LSN是8字节数字，单位是字节。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 5009487</span><br><span class="line">Log flushed up to   5009487</span><br><span class="line">Pages flushed up to 5009487</span><br><span class="line">Last checkpoint at  5009478</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&apos;s done, 0.00 log i/o&apos;s/second</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在InnoDB存储引擎内部，有两种Checkpoint，分别为：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1。</p><p>数据库运行时在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即指刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p><p>在InnoDB存储引擎中可能发生Fuzzy Checkpoint的情况：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Async/Sync Flush Checkpoint</li><li>Dirty Page too much Checkpoint</li></ul><p>Master Thread中发生的Checkpoint，每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。过程异步，用户查询线程不会阻塞。</p><p>FLUSH_LRU_LIST Checkpoint是因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用，在v1.1.x之前检查LRU列表中是否有足够可用空间操作发生在<br>用户查询线程中，会阻塞用户查询操作。若无100个可用空闲页，会将LRU列表尾端的页移除，若其中有脏页，则进行Checkpoint。</p><p>InnoDB v1.2.x（MySQL 5.6）开始检查被放在Page Cleaner Thread中进行，可通过参数<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认1024。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_lru_scan_depth&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_lru_scan_depth</span><br><span class="line">        Value: 1024</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>Async/Sync Flush Checkpoint指的是重做日志不可用的情况下，需要强制将一些页刷新回磁盘，此时脏页是从脏页列表中选取。将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则：</p><blockquote><p>checkpoint_age = redo_lsn - checkpoint_lsn</p><p>async_water_mark = 75% * total_redo_log_file_size</p><p>sync_water_mark = 90% * total_redo_log_file_size</p></blockquote><ul><li>checkpoint_age &lt; async_water_mark，不需要刷新任何脏页到磁盘</li><li>async_water_mark &lt; checkpoint_age &lt; sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark</li><li>checkpoint_age &gt; sync_water_mark很少发生除非设置的重做日志文件太小，在进行类似LOAD DATA的BULK INSETRT操作，触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age &lt; async_water_mark。</li></ul><p>Async/Sync Flush Checkpoint保证重做日志循环使用的可用性，v1.2.x之前，Async Flush Checkpoint阻塞发现问题的用户查询线程，Sync Flush Checkpoint阻塞所有用户的查询线程，并且等待脏页刷新的完成。v1.2.x开始，放入到单独的Page Cleaner Thread中。</p><p>MySQL官版不能查看刷新页是从Flush列表中还是从LRU列表中进行Checkpoint的，不知道因为重做日志而产生的Async/Sync Flush的次数。InnoSQL版本可通过命令<code>show engine innodb status</code>来观察。</p><p>Dirty Page too much Checkpoint是因为脏页数量太多，导致InnoDB存储引擎强制进行Checkpoint。目的为了保证缓冲池中有足够可用的页。可由参数<code>innodb_max_dirty_page_pct</code>控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_max_dirty_pages_pct&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_max_dirty_pages_pct</span><br><span class="line">        Value: 75.000000</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>75表示缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分脏页到磁盘，InnoDB v1.0.x之前是90，之后是75。</p><h3 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h3><h4 id="InnoDB-1-0-x之前的Master-Thread"><a href="#InnoDB-1-0-x之前的Master-Thread" class="headerlink" title="InnoDB 1.0.x之前的Master Thread"></a>InnoDB 1.0.x之前的Master Thread</h4><p>具有最高的线程优先级别。内部由多个loop组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。根据数据库运行状态进行切换。</p><p>主循环有两大部分操作——每秒钟的操作和每10秒钟的操作。</p><p>每秒钟的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是），因此再大的事务提交时间也是很短的；</li><li>合并插入缓冲（可能），判断上一秒内发生的IO次数是否小于5次，若小于5次，认为当前的IO压力很小，可以住行合并插入缓冲的操作；</li><li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能），判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认90，代表90%），若超过，认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</li></ul><p>每10秒的操作：</p><ul><li>刷新100个脏页到磁盘（可能的情况下），若过去10秒内磁盘的IO操作小于200次，则认为有足够的磁盘IO能力，将100个脏个刷新到磁盘；</li><li>合并至多5个插入缓冲（总是）；</li><li>将日志缓冲刷新到磁盘（总是）；</li><li>删除无用的undo页（总是），full purge操作，每次最多尝试回收20个undo页，对表进行updae、delete操作时，原行被标记为删除，因一致性读（consistent read）需要保留这些行版本的信息，在full purge过程中，判断当前事务系统中已被删除的行是否可以删除（可能有查询操作需要读取之前版本的undo信息），若可以则立即删除；</li><li>刷新100个或10个脏页到磁盘（总是），判断缓冲池中脏页的比例（buf_get_modified_ratio_pct），若有超过70%的脏页，则刷新100个脏页到磁盘，若小于70%则只刷新10个脏页到磁盘。</li></ul><p>若当前没有用户活动（数据库空闲）或者数据库关闭（shutdown），切换到background loop，执行的操作：</p><ul><li>删除无用的undo页（总是）；</li><li>合并20个插入缓冲（总是）；</li><li>跳回到主循环（总是）；</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</li></ul><p>若flush loop中也无事可做，则切换到suspend_loop，将Master Thread挂起，等待事情的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起状态。</p><h4 id="InnoDB-1-2-x版本之前的Master-Thread"><a href="#InnoDB-1-2-x版本之前的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本之前的Master Thread"></a>InnoDB 1.2.x版本之前的Master Thread</h4><p>v1.0.x对于IO有限制，向磁盘刷新时做了一定的硬编码（刷新数固定值），限制了对磁盘IO的性能，尤其是写入性能。v1.0.x开始提供参数innnodb_io_capacity，用来表示磁盘IO的吞吐量，默认值200，对于刷新到磁盘的页的数量，按照innnodb_io_capacity的百分比来进行控制：</p><ul><li>合并插入缓冲时，合并插入缓冲的数量为innnodb_io_capacity值的5%；</li><li>从缓冲区刷新脏页到时，刷新脏页的数量为innnodb_io_capacity。</li></ul><p>参数innodb_max_dirty_pages_pct默认值为90，当内存很大，或者数据库服务的压力很大，刷新脏页的速度会降低，数据库恢复时需要更多的时间。设置过低时会增加磁盘IO压力。v1.0.x开始，默认值设置为75，和Google测试的最优值80接近。</p><p>引入参数innodb_adaptive_flushing（自适应刷新）。愿刷新规则：大于innodb_max_dirty_pages_pct时，刷新100个脏页， 否则不刷新脏页。引入后通过名为buf_flush_get_desired_flush_rate函数（通过判断产生重做日志redo log的速度来决定最合适的刷新脏页数量）判断需要刷新脏页最合适的数量。当脏页的比例小于innodb_max_dirty_pages_pct时，也会刷新一定量的脏页。</p><p>引入参数innodb_purge_batch_size，控制每次full purge回收的Undo页的数量，之前最多回收20个Undo页，该参数默认值20(用的mysql 5.7.22，默认值300)，可动态地对其进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 300</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; set global innodb_purge_batch_size=320;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_purge_batch_size</span><br><span class="line">        Value: 320</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可由命令<code>SHOW ENGINE INNODB STATUS</code>查看当前Master Thread的状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_purge_batch_size&apos;\G</span><br><span class="line">...</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 2 srv_active, 0 srv_shutdown, 139324 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 139319</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="InnoDB-1-2-x版本的Master-Thread"><a href="#InnoDB-1-2-x版本的Master-Thread" class="headerlink" title="InnoDB 1.2.x版本的Master Thread"></a>InnoDB 1.2.x版本的Master Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if InnoDD is idle</span><br><span class="line">  srv_master_do_idle_tasks(); //每10s的操作</span><br><span class="line">else </span><br><span class="line">  srv_master_do_active_tasks(); //每秒的操作</span><br></pre></td></tr></table></figure><p>刷新脏页的操作，从Master Thread线程分离到单独的Page Cleaner Thread。</p><h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><p>和数据页一样，是物理页的一个组成部分。</p><p>插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取，这类插入操作速度是非常快的。但并不是所有的主键插入都是顺序的，若主键是UUID类，则插入和辅助索引一样，同样是随机的。即使主键是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。</p><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作（在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><p>Insert Buffer的使用需要同时满足两个条件：</p><ul><li>索引是辅助索引（secondary index）；</li><li>索引不是唯一（unique）的。</li></ul><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看插入缓冲的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行：size代表已合并记录页的数量；free list len代表空闲列表的长度；seg size显示当前Insert Buffer的大小为14*16k；merges代表合并的次数。</p><p>写密集情况下，插入缓冲会占用过多的缓冲池内存，默认最大可占用1/2。可通过修改<code>IBUF_POOL_SIZE_PER_MAX_SIZE</code>对插入缓冲的大小进行控制。将其修改为3则最大只能使用1/3的缓冲池内存。</p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p><p>同Insert Buffer，Change Buffer适用的对象依然是非唯一的辅助索引。</p><p>对一条记录进行UPDATE操作可能分为两个过程：</p><ul><li>将记录标记为已删除；</li><li>真正将记录删除。</li></ul><p>Delete Buffer对应操作的第一个过程，Purge Buffer对应操作的第二个过程。通过参数<code>innodb_change_buffering</code>开启各种Buffer的选项，可选：inserts、deletes、purges、changes、all、none。changes表示启用inserts和deletes、all表示启用所有，none表示都不启用。</p><p>通过<code>innodb_change_buffer_max_size</code>来控制Change Buffer最大使用内存的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_change_buffer_max_size&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_change_buffer_max_size</span><br><span class="line">        Value: 25</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>默认值为25，表示最多使用1/4（25%）的缓冲池内存空间，最大有效值50。</p><p>通过<code>SHOW ENGINE INNODB STATUS</code>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 331 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1580, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">314.08 hash searches/s, 208.70 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>insert表示Insert Buffer；delete mark表示Delete Buffer；delete表示Purge Buffer；discarded operations表示当Change Buffer发生merge时，表已经被删除，此时无需再将记录合并到辅助索引中。</p><h5 id="Insert-Buffer的内部实现"><a href="#Insert-Buffer的内部实现" class="headerlink" title="Insert Buffer的内部实现"></a>Insert Buffer的内部实现</h5><p>Insert Buffer的数据结构是一棵B+树，MySQL v4.1前每张表有一棵Insert Buffer B+树，现版本全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。存放在共享表空间中，默认ibdata1中。在试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败，因为表的辅助索引中的数据可能还在Insert Buffer中，即共享表空间中。</p><p>Insert Buffer非叶节点存放查询的search key（键值）。</p><p>search key一共占用9个字节，space表示待插入记录所在表的表空间id，InnoDB存储引擎中每个表有一个唯一的space id，可通过space id查询得知是哪张表。space占用4字节。marker占用1字节，用于兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4字节。</p><p>当辅助索引要插入到页（space，offset）时，若页不在缓冲池中，则首先根据上述规则构造一个search key，然后查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的叶子节点中。<br>插入到Insert Buffer B+树叶子节点的记录，需要根据规则进行构造。</p><blockquote><p>space | marker | offset | metadata |{ secondary index record}|</p></blockquote><p>metadata占用4字节，存储内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">字节 </th></tr></thead><tbody><tr><td style="text-align:center">IBUF_REC_OFFSET_COUNT</td><td style="text-align:center">2 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_TYPE</td><td style="text-align:center">1 </td></tr><tr><td style="text-align:center">IBUF_REC_OFFSET_FLAGS</td><td style="text-align:center">1  </td></tr></tbody></table><p>IBUF_REC_OFFSET_COUNT保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。第五列开始是实际插入记录的各个字段。</p><p>启用Insert Buffer索引后，辅助索引页中的记录可能被插入到Insert Buffer B+树中，为保证每次Merge Insert Buffer页必须成功，需要特殊页用来标记每个辅助索引页（sapce，page_no）的可用空间。该页类型为Insert Buffer Bitamp。</p><p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）。每个Insert Buffer Bitmap页在16384个页的第二个页中。</p><p>每个辅助索引页在Insert Buffer Bitmap页中占用4位，由三部分组成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小（bit）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">IBUF_BITMAP_FREE</td><td style="text-align:center">2</td><td style="text-align:center">表示该辅助索引页中的可用空间数量，可取值0，1，2，3。0表示无可用剩余空间；1表示剩余空间大于1/32页（512字节）</td></tr><tr><td style="text-align:center">IBUF_BITMAP_BUFFERED</td><td style="text-align:center">1</td><td style="text-align:center">1表示该辅助索引页有记录被缓存在Insert Buffer B+树中</td></tr><tr><td style="text-align:center">IBUF_BITMAP_IBUF</td><td style="text-align:center">1</td><td style="text-align:center">1表示该页为Insert Buffer B+树的索引页</td></tr></tbody></table><h5 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h5><p>Merge Insert Buffer的操作发生在：</p><ul><li>辅助索引页被读取到缓冲池时，例如执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap页，然后确认该辅助索引页是否有记录存放于Insert Buffer B+树中，若有则将Insert Buffer B+树中该页的记录插入到该辅助索引页中；</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时，若插入辅助索引记录时检测到插入记录后可用空间会小于1/32页，则强制进行一个合并操作（强制读取辅助索引页），将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中；</li><li>Master Thread，每秒和每10秒进行一次的Merger Insert Buffer操作。</li></ul><p>Mater Thread根据<code>srv_innodb_io_capactity</code>的百分比来决定真正要合并多少个辅助索引页。</p><p>Insert Buffer B+ Tree中，辅助索引页根据（space，offset）都已排序好，根据（space，offset）的排序顺序进行页的选择。</p><h4 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h4><p>doublewrite保障InnoDB存储引擎数据页的可靠性。</p><p>若发生写失效，可以通过重做日志进行恢复，但重做日志记录的是对页的物理操作，若页本身已损坏，则再对其重做是无意义的。在应用重做日志之前，需要一个页的副本，当写失效发生时，先通过页的副本还原页，在进行重做，即doublewrite。</p><p>doublewrite由两部分组成：内存中的doublewrite buffer，大小为2MB；物理磁盘上共享表空间中连续的128个页，即两个区（extent），大小为2MB。</p><p>在对缓冲池的脏页进行刷行时，并不直接写磁盘，会先通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。因为doublewrite页连续，过程是顺序写的，开销不大。完成doublewrite页的写入后，再将doublewrite buufer中的页写入各个表空间文件中，此时写入则是离散的，</p><p>通过<code>SHOW GLOBAL STATUS LIKE &#39;innodb_dblwr%&#39;</code>观察doublewrite的运行情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;innodb_dblwr%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 269936</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 26401</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>表示一共写了269936个页，实际写入次数26401，<code>Innodb_dblwr_pages_written:Innodb_dblwr_writes</code>比例10:1。若系统高峰时远小于64:1，说明系统写入压力不是很高。</p><p>若操作系统在写入磁盘过程发生崩溃，在恢复时InnoDB先从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p><p>通过命令<code>SHOW BLOBAL STATUS like &#39;Innodb_buffer_pool_pages_flushed&#39;</code>查看当前从缓冲池中刷新到磁盘页的数量。该变量和<code>Innodb_dblwr_pages_written</code>一致。MySQL 5.5.24版本之前，<code>Innodb_buffer_pool_pages_flushed</code>总是<code>Innodb_dblwr_pages_written</code>的2倍，之后才被修复，统计数据库在生产环境中写入的量，最安全的方法是根据<code>Innodb_dblwr_pages_written</code>来进行统计。</p><p>参数<code>skip_innnodb_doublewrite</code>可以禁用doublewrite功能，可能发生写失效问题，若有多个从服务器（slave server），需要提供较快的性能（在slave server上做RAID0），启用该参数是一个办法。对于需要提供数据高可用性的主服务器（master server），任何时候都应确保开启doublewrite功能。</p><p>有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统，可不用开启doublewrite。</p><h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>哈希一般查找的时间复杂度为O(1)，B+ Tree的查找次数取决于B+ tree的高度，一般为3～4层。</p><p>InnoDB会监控对表上各索引页的查询，若观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI通过缓冲池的B+ tree构建而来，建立的速度很快，不需要对整张表构建哈希索引。InnoDB会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><p>AHI要求这个页的连续访问模式必须是一样的。如对（a，b）这样的联合索引页，访问模式可以是：</p><ul><li>WHERE a=xxx</li><li>WHERE a=xxx and b=xxx</li></ul><p>访问模式指查询条件一样，若交替上述两种查询，则不会对该页构造AHI。AHI还要求：</p><ul><li>以该模式访问了100次</li><li>页通过该模式访问了N次，其中N=页中记录*1/16</li></ul><p>启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。其为数据库自由化，可通过命令<code>SHOW ENGINE INNODB STATUS</code>查看当前AHI的使用状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G</span><br><span class="line">...</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 12, seg size 14, 347 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 1702, delete mark 3, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">1.04 hash searches/s, 4.33 non-hash searches/s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>哈希索引只能用来搜索等值的查询，如SELECT * FROM table WHERE index_col=’xxx’。其他如范围查找不能使用哈希索引。通过hash searches:non-hash searches可以了解使用哈希索引后的效率。</p><p>可通过<code>SHOW ENGINE INNODB STATUS</code>的结果及参数<code>innodb_adaptive_hash_index</code>来考虑是禁用或启动，默认AHI开启。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>用户发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，AIO。AIO可以进行IO Merge操作。</p><p>Linux通过<code>iostat</code>动态监视系统的磁盘操作活动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[work~]$ iostat -x</span><br><span class="line">Linux 2.6.32-754.9.1.el6.x86_64 08/16/2019 _x86_64_(8 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">          18.99    0.00   16.12    1.36    0.00   63.53</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.08     7.78    0.29    4.19    16.15    93.35    24.46     0.01    2.39    4.96    2.22   0.94   0.42</span><br><span class="line">vdb               4.07   405.85   10.49    7.69  2980.62  3309.01   345.87     0.72   39.40   26.06   57.61   2.08   3.78</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure><p>InnoDB v1.1.x前，AIO通过InnoDB存储引擎中的代码来模拟实现，v1.1.x开始提供了内核级别AIO的支持，Native AIO，依赖libaio库。Native AIO需要操作系统提供支持，Win OS和Linux OS都提供Native AIO支持，Mac OSX未提供，只能使用原模拟的方式。</p><p>参数<code>innodb_use_native_aio</code>用来控制是否启用Native AIO，Linux OS下默认为ON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Mac OS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_use_native_aio&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_use_native_aio</span><br><span class="line">        Value: OFF</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>InnoDB中read ahead方式的读取都是AIO完成，脏页的刷新也是通过AIO完成。</p><h4 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h4><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，若是脏页，则一起进行刷新。通过将多个IO写入操作合并为一个IO操作，在传统机械磁盘下有着显著优势。</p><p>需要考虑：</p><ul><li>将不怎么脏的页进行了写入，该页之后又会很快变成脏页；</li><li>固态硬盘有着较高的IOPS，是否需要该特性。</li></ul><p>所以从v 1.2.x版本开始提供了参数<code>innodb_flush_neighbors</code>，用来控制是否启用该特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_flush_neighbors&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_flush_neighbors</span><br><span class="line">        Value: 1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="启动、关闭与恢复"><a href="#启动、关闭与恢复" class="headerlink" title="启动、关闭与恢复"></a>启动、关闭与恢复</h3><p>MySQL实例在启动过程中对InnoDB存储引擎的处理过程。</p><p>关闭时，参数<code>innodb_fast_shutdown</code>影响着表的存储引擎为InnoDB的行为。该参数可取0，1，2。默认1。</p><ul><li>0：在MySQL数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。需要一些时间，在进行InnoDB升级时，必须将此参数设置为0，然后关闭数据库。</li><li>1:表示不需要完成full purge和merge insert buffer操作，但是缓冲池中的一些数据脏页还是会刷新回磁盘。</li><li>2:表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志写入日志文件。不会有事务的丢失，在下次MySQL数据库启动时，会进行恢复操作。</li></ul><p>若没有正常的关闭数据库，例如使用kill命令关闭数据库、MySQL运行中重启服务器，或者关闭数据库时将参数<code>innodb_fast_shutdown</code>设为2，下次MySQL数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数<code>innodb_force_recovery</code>影响整个InnoDB存储引擎恢复的状况，默认为0，代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL数据库可能发生宕机，并把错误写入错误日志。还可以设置6个非零值，大的数字表示包含了前面所有小数字表示的影响：</p><ul><li>1（SRV_FORCE_IGNORE_CORRUPT）：忽略检查到的corrupt页。</li><li>2（SRV_FORCE_NO_BACKGROUND）：阻止Master Thread线程的运行，如Master Thread线程需要进行full merge操作，会导致crash。</li><li>3（SRV_FORCE_NO_TRX_UNDO）：不进行事务的回滚操作。</li><li>4（SRV_FORCE_NO_IBUF_MERGE）：不进行插入缓冲的合并操作。</li><li>5（SRV_FORCE_NO_UNDO_LOG_SCAN）：不查看撤销日志（Undo Log），将未提交的事务视为已提交。</li><li>6（SRV_FORCE_NO_LOG_SCAN）：不进行前滚的操作。</li></ul><p>在设置了<code>innodb_force_recovery</code>大于0后，可进行select、create和drop操作，但insert、update和delete操作是不允许的。（修改表涉及到脏页的刷新、undo log等）</p><p>START TRANSACTION语句开启了事务，防止了自动提交的发生，UPDATE操作会产生大量的UNDO日志。人为通过kill命令杀掉MySQL数据库，下次MySQL数据库启动会对之前的UPDATE事务进行回滚操作，这些信息会记录在错误日志文件中。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
            <tag> innodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL体系结构和存储引擎</title>
      <link href="/2019/01/10/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/01/10/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="定义数据库和实例"><a href="#定义数据库和实例" class="headerlink" title="定义数据库和实例"></a>定义数据库和实例</h3><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>实例：MySQL数据库由后台线程以及一个共享内存区组成。</li></ul><p>MySQL设计为单进程多线程架构，数据库实例在系统上表现为一个进程。</p><p>启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例，没有配置文件时，按照编译时的默认参数设置启动实例。使用<code>mysql --help | grep my.cnf</code>查看启动时从哪些位置查找配置文件。当几个配置文件都有同一个参数，MySQL数据库以读取到的最后一个配置文件中的参数为准。</p><p>配置文件参数<code>datadir</code>指定了数据库所在的路径。linux操作系统下默认为<code>/usr/local/mysql/data</code>，该路径只是一个链接，指向<code>/opt/mysql_data</code>目录，必须保证该目录的用户和权限使mysql用户和组可以访问。</p><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>MySQL组成部分：  </p><ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（cache）组件</li><li>插件式存储引擎</li><li><p>物理文件</p><p>区别于其他数据库的重要特点是插件式的表存储引擎。MySQL插件式存储引擎架构提供一系列标准的管理和服务支持，这些标准与存储引擎本身无关，存储引擎是底层物理结构的实现。存储引擎是基于表的，而不是数据库。</p></li></ul><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。用户可以根据MySQL预定义的存储引擎接口编写自己的存储引擎。</p><p>通过<code>SHOW ENGINES</code>语句或者通过查找<code>information_schema</code>架构下的ENGINES表，查看当前使用的MySQL数据库所支持的存储引擎。</p><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>InnoDB存储引擎支持事务，设计目标面向在线事务处理的应用。行锁设计、支持外键，支持类似Oracle的非锁定读，即默认读取操作不会产生锁。</p><p>InnoDB存储引擎将数据放在一个逻辑的表空间中，表空间由InnoDB存储引擎自身进行管理。每个InnoDB存储引擎的表单独存放到一个ibd文件中。InnoDB存储引擎支持用裸设备（row disk）来建立其表空间。</p><p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发，实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。使用被称为next-key locking策略避免幻读现象的产生。还提供了插入缓存（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p><p>InnoDB存储引擎采用聚集（clustered）的方式存储表中的数据，每张表的存储都是按主键的顺序进行存放。当没有显示的指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p><h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4><p>MyISAM存储引擎不支持事务，支持全文索引，表锁设计，主要面向一些OLAP数据库应用。MyISAM存储引擎的缓冲池只缓存索引文件，而不缓存数据文件。</p><p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用<code>myisampack</code>工具进一步压缩数据文件，因myisampack工具使用哈夫曼编码静态算法来压缩数据，所以压缩后的表是只读的，也可以使用myisampack工具解压数据文件。</p><p>V5.0前MyISAM默认支持的表大小为4GB，制定MAX_ROWS和AVG_ROW_LENGTH属性拓展为大于4GB的表。V5.0及以后，默认支持256TB的表单数据。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。</p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP套接字方式是MySQL数据库在任何平台下都提供的连接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -h 127.0.0.1 -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>通过TCP/IP连接到MySQL实例时，MySQL会先检查一张权限视图，判断发起请求的客户端IP是否允许连接到MySQL实例。视图在mysql结构下，表名为<code>user</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show columns from user;</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</span><br><span class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Insert_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Update_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Delete_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Drop_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Reload_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Shutdown_priv          | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Process_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| File_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Grant_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| References_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Index_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_db_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Super_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tmp_table_priv  | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Lock_tables_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Execute_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_slave_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_client_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_view_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Show_view_priv         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_routine_priv    | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_routine_priv     | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_user_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Event_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Trigger_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| ssl_type               | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO   |     |                       |       |</span><br><span class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</span><br><span class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</span><br><span class="line">| password_expired       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</span><br><span class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</span><br><span class="line">| account_locked         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">45 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT host,user,password_expired FROM user;</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| host      | user          | password_expired |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">| localhost | root          | N                |</span><br><span class="line">| localhost | mysql.session | N                |</span><br><span class="line">| localhost | mysql.sys     | N                |</span><br><span class="line">+-----------+---------------+------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h4><p>Win 2000、Win XP、Win 2003和Win Vista以及在此之上的平台，若两个需要进程通信的进程在同一台服务器上，可以使用命名管道。MySQL数据库须在配置文件中启用–enable-named-pipe。V4.1后提供共享内存的连接方式，须在配置文件中添加–shared-memory，在连接时客户端还必须使用–protocol=memory选项。</p><h4 id="UNIX套接字"><a href="#UNIX套接字" class="headerlink" title="UNIX套接字"></a>UNIX套接字</h4><p>Linux和UNIX环境下，可以使用UNIX域套接字，因其非网络协议，只能在MySQL客户端和数据库实例在一台服务器上的情况下使用。用户可以在配置文件中指定套接字文件的路径<code>--socket=/tmp/mysql.sock</code>。</p><p>查询UNIX域套接字文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;socket&apos;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| socket        | /tmp/mysql.sock |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>使用UNIX域套接字方式进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ mysql -uroot -S /tmp/mysql.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.22 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL技术内幕-InnoDB存储引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty实战笔记</title>
      <link href="/2018/11/19/Netty%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/19/Netty%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="编写Echo服务器"><a href="#编写Echo服务器" class="headerlink" title="编写Echo服务器"></a>编写Echo服务器</h2><h3 id="ChannelHandler和业务逻辑"><a href="#ChannelHandler和业务逻辑" class="headerlink" title="ChannelHandler和业务逻辑"></a>ChannelHandler和业务逻辑</h3><p>响应传入的消息，需要实现ChannelInboundHandler接口，用来定义响应入站时间</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世事无常</title>
      <link href="/2018/11/04/%E4%B8%96%E4%BA%8B%E6%97%A0%E5%B8%B8/"/>
      <url>/2018/11/04/%E4%B8%96%E4%BA%8B%E6%97%A0%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>记2018-11-04，悼念三叔！</p><p>总想写下关于你的回忆，害怕时光一点一点慢慢擦除我的脑海中关于你的记忆。可是现在的心情，总感觉拙劣的文字怎么也体现不出自己想发泄的情绪。写了删，删了再写，我怕再过些日子，我就真的什么都接受了，接受没有你的大家庭，接受这个世事无常的世界，然后一点一点平息自己的思绪，使自己接受现实，最后慢慢的消化在内心，做到不外露一点情绪！</p><p>我不敢想象老家没有你了会是怎样，高三的堂弟、初入社会心思单纯的堂妹、年迈的爷爷、指望不上的大爹家，远离老家很多事帮不上忙的我们，以后三婶在老家要承担怎样的重担渡过这些日子，想想就揪心。</p><p>如果可以在身边选择一个最适合父亲的角色，我觉得是你。只有你最关注子辈的内心，在意孩子的想法，注重子辈多方面的培养教育。对比常年在外打工只给予我生活费关怀的老爸，可以说是你，在我心目中对父亲的角色有了该有的模样。对堂弟寄予厚望的你，怎么忍心被这次意外带走，还有好多次成绩没向你汇报、还没为他操心高考后的学校和专业、还没同意他找女朋友呢…</p><p>还想着以后能再回老家过元宵节，再跟着你去认祖坟送亮；过春节中午在我家吃，然后去你家吃年夜饭；跟着你去拜年走亲戚，去看斗地主炸金花；跟着你去山里伐几颗松树用作冬天取暖的柴火，然后交给我一颗小的背回家；跟着你学习人生经验，如何处理好人和事…可是这以后都没有了，都停留在回忆里了。</p><p>中午收到老爸发过来的消息，震惊意外，不敢相信。大姐打过来的视频，猜到肯定是为了此事，不愿意接听，宁愿今天是做了一个梦，而我还没醒。直到晚上二姐多次挂过来视频，才交谈起此事，聊起话题一想起这个事实，鼻子不由自主的酸楚。</p><p>记得13年秋，我高三时，突然接到通知家里有事，在回家的车上，虽然没有任何人告知我发生了什么，但我知道肯定是我某个亲人不在了，心中异常忐忑，眼泪止不住的流。直到车停在家门口，看到一个个花圈，搭起的灵台，奶奶的遗像，此时声音也控制不住了，眼泪也肆无忌惮起来。如今是你，还有很多的事情等着你去解决去承担，怎么舍得离去，我不敢相信，也不能接受…</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天堂安好 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty的核心组件</title>
      <link href="/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/11/02/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>阅读《netty实战》，初识netty的一些笔记。</p><p>异步、事件驱动。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>Channel</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Java NIO的一个基本构造。</p><blockquote><p>代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。</p></blockquote><p>可以把Channel看作是传入（入站）或者传出（出站）数据的载体。可以被打开或者被关闭，连接或者断开连接。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>一个指向已经被提供给另一个方法的方法的引用。使得后者可以调用前者。</p><p>Netty在内部使用回调来处理事件，当一个回调被触发时，相关的事件可以被一个interface ChannelHandler的实现处理。</p><p>当一个新的连接已经被建立，ChannelHandler的channelActive()回调方法将会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>提供了另一种在操作完成时通知应用程序的方式。可以看作是一个异步操作的结果的占位符；将在未来的某个时刻完成，并提供对其结果的访问。</p><p>JDK预置的interface java.util.concurrent.Future提供的实现只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。Netty提供了自己的实现——ChannelFuture，用于在执行异步操作的时候使用。</p><p>ChannelFuture提供额外的方法，使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。</p><p>每个Netty的出站I/O操作都将返回一个ChannelFuture，它们都不会阻塞。</p><p>ChannelFuture作为一个I/O操作的一部分返回。connect()方法将会直接返回，而不会阻塞，调用将会在后台完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"></span><br><span class="line">ChannelFuture future = Channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));</span><br></pre></td></tr></table></figure><p>利用ChannelFutureListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));异步连接到远程节点</span><br><span class="line">future.addListener(new ChannelFutureListener() &#123;//注册一个ChannelFutureListener，在操作完成时获得通知</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;//检查操作的状态</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());</span><br><span class="line">            ChannelFuture wf = future.channel().writeAndFlush(buffer);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="事件和ChannelHandler"><a href="#事件和ChannelHandler" class="headerlink" title="事件和ChannelHandler"></a>事件和ChannelHandler</h4><p>Netty使用不同的事件来通知状态的改变或者是操作的状态。能够基于已经发生的事件来触发适当的动作。这些动作可能是：</p><ul><li>记录日志；</li><li>数据流转换；</li><li>流控制；</li><li>应用程序逻辑。</li></ul><p>Netty的事件是按照它们与入站或者出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：</p><ul><li>连接已被激活或者连接失活；</li><li>数据读取；</li><li>用户事件；</li><li>错误事件。</li></ul><p>出站事件是未来将会触发的某个动作的操作结果，这些动作包括：</p><ul><li>打开或者关闭到远程节点的连接；</li><li>将数据写到或者冲刷到套接字。</li></ul><p>每个事件都可以被分发给ChannelHandler类中的某个用户实现的方法（将事件驱动范式直接转换为应用程序构件块）。</p><p> Netty的ChannelHandler为处理器提供了基本的抽象。每个ChannelHandler的实例都类似于一种为了响应特定事件而被执行的回调。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="Future、回调和ChannelHandler"><a href="#Future、回调和ChannelHandler" class="headerlink" title="Future、回调和ChannelHandler"></a>Future、回调和ChannelHandler</h4><p>Netty异步编程模型建立在Future和回调之上，将事件派发到ChannelHandler的方法发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，需要提供回调或者利用操作所返回的Future。</p><h4 id="选择器、事件和EventLoop"><a href="#选择器、事件和EventLoop" class="headerlink" title="选择器、事件和EventLoop"></a>选择器、事件和EventLoop</h4><p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了本来将需要手动编写的派发代码。在内部，会为每个Channel分配一个EventLoop，用以处理所有事件，包括：</p><ul><li>注册感兴趣的事件；</li><li>将事件派发给ChannelHandler；</li><li>安排进一步的动作。</li></ul><p>EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。此设计消除了可能有的在ChannelHandler实现中需要进行同步的任何顾虑，只需专注于提供正确的逻辑，用来在感兴趣的数据要处理的时候执行。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web服务</title>
      <link href="/2018/10/12/web%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/10/12/web%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h3><blockquote><p>一种与其他软件进行交互的软件程序，通过HTTP进行通信。是一个软件系统，为网络上进行的可互操作机器间交互提供支持。每个web服务都拥有一套自己的接口，由一种名为Web服务描述语言的机器可处理格式描述。其他系统需要根据Web服务的描述，适用SOAP消息与Web服务交互。SOAP消息常被序列化为XML并通过HTTP传输。</p></blockquote><p>存在着多种不同类型的Web服务，其中包括基于SOAP的、基于REST的以及基于XML-RPC的，基于REST的和基于SOAP的Web服务最为流行。企业级系统大多数都是基于SOAP的Web服务实现，公开可访问的Web服务更青睐基于REST的Web服务。</p><p>基于SOAP的Web服务由功能驱动，基于REST的Web服务由数据驱动。基于SOAP的Web服务往往是RPC风格；基于REST的Web服务关注的是资源，HTTP方法是对这些资源执行操作的动词。</p><h3 id="基于SOAP的Web服务"><a href="#基于SOAP的Web服务" class="headerlink" title="基于SOAP的Web服务"></a>基于SOAP的Web服务</h3><p>SOAP（Simple Object Access Protocol：简单对象访问协议）是一种协议，用于交换定义在XML里面的结构化数据。能够跨越不同的网络协议并在不同的编程模式中使用，其处理的并不是对象，已经不再代表Simple Object Access Protocol。</p><p>SOAP高度结构化，需要严格地进行定义，用于传输数据的XML可能会变的非常复杂。WSDL是客户端与服务器之间的契约，定义了服务提供的功能以及提供这些功能的方式，服务的每个操作以及输入/输出都需要由WSDL明确地定义。</p><p>SOAP将报文内容放入到信封里面，信封相当于一个运输容器，并且它还能够独立于实际的数据传输方式存在。</p><p>经过简化的SOAP请求报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /GetComment HTTP/1.1</span><br><span class="line">Host: www.chitchatcom</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.chitchat.com/forum&quot;&gt;</span><br><span class="line">&lt;m:GetCommentRequest&gt;</span><br><span class="line">&lt;m:CommentId&gt;123&lt;/m:CommentID&gt;</span><br><span class="line">&lt;/m:GetCommentRequest&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>简化后的SOAP响应报文示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3/org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">&lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">&lt;m:GetCommentResponse&gt;</span><br><span class="line">&lt;m:Text&gt;Hello World!&lt;/m:Text&gt;</span><br><span class="line">&lt;/m:GetCommentResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:envelope&gt;</span><br></pre></td></tr></table></figure><p>SOAP 1.2允许通过HTTP的Get方法发送SOAP报文，但大多数基于SOAP的Web服务都是通过HTTP的POST方法发送SOAP报文的。</p><p>一个基于SOAP的Web服务越复杂，对应的WSDL报文就越冗长。实际中SOAP请求报文通常会由WSDL生成的SOAP客户端负责生成，SOAP响应报文通常也是由WSDL生成的SOAP服务器负责生成。</p><h3 id="基于REST的Web服务"><a href="#基于REST的Web服务" class="headerlink" title="基于REST的Web服务"></a>基于REST的Web服务</h3><p>REST（Representational State transfer，具象状态传输）是一种设计理念，用于设计通过标准的几个动作来操纵资源，并以此来进行互相交流的程序（将操纵资源的动作称为“动词”，即verb）。</p><p>REST并不把函数暴露为可调用的服务，而是以资源（resource）的名义把模型暴露出来，允许通过少数几个称为动词的动作来操纵这些资源。</p><p>使用HTTP协议实现REST服务，URL将用于表示资源，HTTP方法则会用作操纵资源的动词。如表所示：</p><table><thead><tr><th style="text-align:left">HTTP方法</th><th style="text-align:left">作用</th><th style="text-align:left">使用实例</th></tr></thead><tbody><tr><td style="text-align:left">POST</td><td style="text-align:left">在一项资源尚未存在的情况下创建该资源</td><td style="text-align:left">POST /users</td></tr><tr><td style="text-align:left">GET</td><td style="text-align:left">获取一项资源</td><td style="text-align:left">GET /users/1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">重新给定URL上的资源</td><td style="text-align:left">PUT /users/1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除一项资源</td><td style="text-align:left">DELETE /users/1</td></tr></tbody></table><p>POST和PUT的区别在于，PUT需要准确地知道哪一项资源将会被替换，使用POST只会创建出一项新资源以及一个新的URL。POST用于创建一项全新的资源，PUT用于替换一项已经存在的资源。</p><p>REST不经只能通过这几个HTTP方法实现，如可以使用PATCH方法对一项资源进行部分更新。使用REST API的时候通常都是返回JSON，或者返回一些比SOAP报文要简单得多的XML，很少返回SOAP报文。</p><p>基于REST的Web服务也拥有相应的WADL（Web Applicaton Description Language，Web应用描述语言），可以对基于REST的Web服务进行描述，能够生成访问这些服务的客户端。</p><p>REST设计理念适用于只执行简单的CURD操作的应用，适用于更为复杂的服务可以通过如下两个方法对过程或者动作进行建模。</p><h4 id="将动作转化为资源"><a href="#将动作转化为资源" class="headerlink" title="将动作转化为资源"></a>将动作转化为资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /user/123/activation HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;data&quot;:&quot;2018-10-13T17:12:12Z&quot; &#125;</span><br></pre></td></tr></table></figure><p>将创建一个被激活的资源（activation resource），表示用户的激活状态，可以为激活的资源添加额外的属性。</p><h4 id="将动作转换为资源的属性"><a href="#将动作转换为资源的属性" class="headerlink" title="将动作转换为资源的属性"></a>将动作转换为资源的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATCH /user/123 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123; &quot;active&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>把用户的active属性设置为true</p>]]></content>
      
      
      <categories>
          
          <category> web杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web服务 </tag>
            
            <tag> SOAP </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jenkins初探</title>
      <link href="/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/10/08/jenkins%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>参考文档<a href="https://www.kancloud.cn/louis1986/jenkins/481896" target="_blank" rel="noopener">Jenkins学习文档</a>，<a href="https://blog.csdn.net/sms15732621690/article/details/71336224" target="_blank" rel="noopener">CentOS7Jenkins安装</a></p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget http://soft.51yuki.cn/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo vim /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_131/</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib.tools.jar</span><br><span class="line">PATH=$PATH:$&#123;JAVA_HOME&#125;/bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  sudo sh /etc/profile.d/jdk.sh</span><br><span class="line">[wuhua@VM_0_10_centos local]$ java -version</span><br><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>浏览器中输入<code>ip:8080</code></p><p>获取登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos src]$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>参考<a href="https://blog.csdn.net/jlminghui/article/details/54952148" target="_blank" rel="noopener">忘记Jenkins管理员密码的解决办法</a></p>]]></content>
      
      
      <categories>
          
          <category> web杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续集成 </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-整数集合</title>
      <link href="/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
      <url>/2018/09/13/redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>是集合键的底层实现之一，当一个集合只包含整数值元素，并且集合的元素数量不多时，redis使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>是redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>由intset.h/intset结构表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">unint32_t encoding;//编码方式</span><br><span class="line">unint32_t length;//集合包含的元素数量</span><br><span class="line">int8_t contents[];//保存元素的数组</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，数组中各项按值从小到大排列，且数组中不包含重复项。</p><p>length属性记录整数集合包含的元素数量，即contents数组的长度。</p><p>contents数组的真正类型取决于encoding属性的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * intset 的编码方式</span><br><span class="line"> */</span><br><span class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</span><br></pre></td></tr></table></figure><p>根据整数集合的升级规则，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>将新元素添加到整数集合里面且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后将新元素添加到整数集合里面。</p><p>升级过程：</p><ul><li>根据新元素的类型，拓展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置上，在放置的过程中维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组中。</li></ul><p>引发升级的新元素的长度总是比整数集合现在所有元素的长度都大，所以新元素的值要么大于所有现有元素，要么就小于所有现有元素。前者将新元素放置在底层数组的最开头（索引0），后者将新元素放置在底层数组的最末尾（索引length-1）。</p><blockquote><p>升级策略能提升整数集合的灵活性，尽可能地节约内存。</p></blockquote><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><p>整数集合操作API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">intsetNew</td><td style="text-align:left">创建一个新的压缩列表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetAdd</td><td style="text-align:left">将给定元素添加到整数集合里</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetRemove</td><td style="text-align:left">从整数集合中移除给定元素</td><td style="text-align:left">O(N)</td></tr><tr><td style="text-align:left">intsetFind</td><td style="text-align:left">检查给定值是否存在于集合</td><td style="text-align:left">O(logN)，二分查找法</td></tr><tr><td style="text-align:left">intsetRandom</td><td style="text-align:left">从整数集合中随机返回一个元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetGet</td><td style="text-align:left">取出底层数组在给定索引上的元素</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetLen</td><td style="text-align:left">返回整数集合包含的元素的个数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">intsetBlobLen</td><td style="text-align:left">返回整数集合占用的内存字节数</td><td style="text-align:left">O(1)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> intset </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-跳跃表</title>
      <link href="/2018/09/12/redis-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/2018/09/12/redis-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>跳跃表是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。支持平均O(logN)，最坏O(N)复杂度的节点查找。可以通过顺序性操作来批量处理节点。</p><p>redis使用跳跃表作为有序集合键的底层实现之一，若有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>redis只在实现有序集合键和在集群节点用作内部数据结构用到跳跃表。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，前者用于表示跳跃表节点，后者用于保存跳跃表节点的相关信息，例如节点的数量、指向表头节点和表尾节点的指针等。</p><p>zskiplist结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    // 表头节点和表尾节点,指向跳跃表的表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line"></span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>zskiplistNode结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    // 成员对象，指向一个字符串对象，保存着一个SDS值</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    // 分值，跳跃表中所有节点按分值从小到大排序</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    // 后退指针，用于从表尾向表头方向访问节点</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line"> //level数组可包含多个元素，每个元素包含一个指向其他节点的指针，通过层快速访问其他节点</span><br><span class="line">    //每创建一个节点根据幂次定律随机生成一个介于1和32之间的level作为数据的大小，大小为层的高度</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        // 前进指针，用于从表头向表尾方向访问节点</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        // 跨度，用于记录两个节点之间的距离，两个节点之间跨度越大，相聚越远，指向NULL跨度0</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>由redis.h/zskiplistNode结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">struct zskiplistLevel &#123;</span><br><span class="line">struct zskiplistNode *forward;//前进指针</span><br><span class="line">unsigned int span;//跨度</span><br><span class="line">&#125; level[];//层</span><br><span class="line">struct zskiplistNode *backward;//后退指针</span><br><span class="line">double score;//分值</span><br><span class="line">robj *obj;//成员对象</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ul><li>level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，可通过这些层加快访问其他节点的速度，一般层数量越多访问其他节点的速度越快。每创建一个新跳跃表节点的时候，程序根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小，即层的高度。</li><li>每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。</li><li>跨度用于记录两个节点之间的距离，跨度越大，节点间距离越远，指向NULL的所有前进指针的跨度都为0。实际上用来计算排位（rank），在查找某个节点的过程中，将沿途访问过的所有层的跨度累计，得到的结果就是目标节点在跳跃表中的排位。</li><li>后退指针用于从表尾向表头方向访问节点，每个节点中有一个后退节点，每次只能后退至前一个节点。</li><li>分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序，成员对象是一个指针，指向一个字符串对象，字符串对象则保存着一个SDS值。同一跳跃表中，各个节点保存的成员对象必须是唯一的，多个节点保存的分值可以相同：分值相同的节点按照成员对象在字典序中的大小进行排序，成员对象较小的节点排在前面。</li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>由redis.h/zskiplist结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">struct zskiplistNode *header, *tail;//表头节点和表尾节点</span><br><span class="line">unsigned long length;//表中节点的数量</span><br><span class="line">int level;//表中层数最大节点的层数</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h3 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h3><p>跳跃表的所有操作API:</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">zslCreate</td><td style="text-align:left">创建一个新的跳跃表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">zslFree</td><td style="text-align:left">释放给定跳跃表以及表中包含的所有节点</td><td style="text-align:left">O(N)，N为跳跃表的长度</td></tr><tr><td style="text-align:left">zslInsert</td><td style="text-align:left">将包含给定成员和分值的新节点添加到跳跃表中</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDelete</td><td style="text-align:left">删除跳跃表中包含给定成员和分值的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetRank</td><td style="text-align:left">返回包含给定成员和分值的节点在跳跃表中的排位</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslGetElementByRank</td><td style="text-align:left">返回跳跃表在给定排位上的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslIsInRange</td><td style="text-align:left">判断跳跃表中是否有节点的分值在给定分值范围内</td><td style="text-align:left">O(1）</td></tr><tr><td style="text-align:left">zslFirstInrange</td><td style="text-align:left">返回跳跃表中第一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslLastInrange</td><td style="text-align:left">返回跳跃表中最后一个分值在给定分值范围内的节点</td><td style="text-align:left">平均O(logN)，最坏O(N)，N为跳跃表长度</td></tr><tr><td style="text-align:left">zslDeleteRangeByScore</td><td style="text-align:left">删除跳跃表中所有在给定分值范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr><tr><td style="text-align:left">zslDeleteRangeByRank</td><td style="text-align:left">删除跳跃表中所有在给定排位范围内的节点</td><td style="text-align:left">O(N)，N为被删除节点的数量</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> skiplist </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-字典</title>
      <link href="/2018/09/10/redis-%E5%AD%97%E5%85%B8/"/>
      <url>/2018/09/10/redis-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>又称符号表、关联数组或映射，一种用于保存键值对的抽象数据结构。</p><p>一个键可以和一个值进行关联，字典中的每个键都是独一无二的，通过键查找与之关联的值、更新值或删除整个键值对。</p><p>redis构建了自己的字典实现，redis数据库使用字典作为底层实现，对数据库的增、删、改、查操作也是构建在对字典的操作之上。字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>redis字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>由dict.h/dictht结构定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;//哈希表数组</span><br><span class="line">unsigned long size;//哈希表大小</span><br><span class="line">unsigned long sizemask;//哈希表大小掩码，用于计算索引值，等于size-1</span><br><span class="line">unsigned long used;//该哈希表已有节点的数量</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。</p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">void *key;//键</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v; //值</span><br><span class="line">struct dictEntry *next;//指向下个哈希表节点，形成链表</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>next属性是一个指向哈希表节点的指针，可以将多个哈希表值相同的键值对链接在一起，以此来解决键冲突的问题。</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>由dict.h/dict结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">dictType *type;//类型特定函数</span><br><span class="line">void *privdata;//私有数据</span><br><span class="line">dictht ht[2];//哈希表</span><br><span class="line">int trehashidx;//rehash索引，当rehash不再进行时，值为-1  </span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">unsigned int (*hashFunction)(const void *key);//计算哈希值的函数</span><br><span class="line">void *(*keyDup)(void *privdata, const void *key);//复制键的函数</span><br><span class="line">void *(*valDup)(void *privdata, const void *key);//复制值的函数</span><br><span class="line">int (*keyCompare)(void *privdata, const void *key1, const void *key2);对比键的函数</span><br><span class="line">void (*keyDestructor)(void *privdata, void *key);//销毁键的函数</span><br><span class="line">void (*valDestructor)(void *privdata, void *obj);//销毁值的函数</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p><p>rehashidx属性记录rehash目前的进度，若没有在进行rehash，则值为-1。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>redis计算哈希值和索引值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">//使用哈希表的sizemask属性和哈希值，计算出索引值</span><br><span class="line">//ht[x]根据情况选择ht[0]和ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算哈希值。</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量键被分配到了哈希数组的同一个索引上面时，称这些键发生了冲突。</p><p>redis的哈希表使用链表链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以使用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单项链表连接起来，解决键冲突问题。速度考虑，程序总是将新节点添加到链表的表头位置，排在其他已有节点的前面。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>为让哈希表的负载因子维持在一个合理的范围之内，哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的拓展或者收缩，通过执行rehash（重新散列）操作来完成。步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间，哈希表的空间的大小取决于要执行的操作，以及ht[0]当前包含的键值对数量。<ol><li>若执行的是扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2^n;</li><li>若执行的是扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2^n;</li></ol></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash重新计算键的哈希值和索引，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]表变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash作准备。</li></ol><p><code>哈希表的拓展和收缩</code>：</p><blockquote><p>服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。<br>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。<br>哈希表的负载因子计算公式：<br> 负载因子 = 哈希表已保存节点数量 / ht[0].size<br> load_factor = ht[0].used / ht[0].size</p></blockquote><p>根据BGSAVE命令和BGREWRITEAOF命令是否正在执行，服务器执行拓展操作所需的负载因子并不相同。在执行BGSAVE命令或者BGREWRITEAOF命令的过程中，redis需要创建当前服务器进程的子进程，大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，在子进程存在期间，服务器会提高执行拓展操作所需的负载因子，尽可能地避免在子进程存在期间进行哈希表拓展操作，避免不必要的内存写入操作，节约内存。</p><p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，为避免数据量过大rehash对服务器性能造成影响，rehash动作是分多次、渐进式地完成的，当数据量过大时将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，避免了集中式rehash而带来的庞大计算量。</p><p>哈希表渐进式rehash的步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已经完成。</li></ol><p>在渐进式rehash执行期间，字典的删除、查找、更新等操作会在两个哈希表上进行，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何操作。</p><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><p>字典的主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">dictCreate</td><td style="text-align:left">创建一个新的字典</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictAdd</td><td style="text-align:left">将给定的键值对添加到字典里面</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictReplace</td><td style="text-align:left">将给定的键值对添加到字典里面，如果键已经存在于字典，用新值取代原有的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictFetchValue</td><td style="text-align:left">返回给定键的值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictGetRandomKey</td><td style="text-align:left">从字典中随机返回一个键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictDelete</td><td style="text-align:left">从字典中删除给定键所对应键值对</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">dictRelease</td><td style="text-align:left">释放给定字典，以及字典中包含的所有键值对</td><td style="text-align:left">O(N)，N为字典包含的键值对数量</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> dict </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-链表</title>
      <link href="/2018/09/09/redis-%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/09/09/redis-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>redis构建了自己的链表实现。</p><p>列表键的底层实现之一就是链表，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。</p><p>除列表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，redis服务器本身还使用链表来保存多个客户端的状态信息，使用链表来构建客户端输出缓冲区。</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>链表节点由adlist.h/listNode结构来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">struct listNode *prev;//前置节点</span><br><span class="line">struct listNode *next;//后置节点</span><br><span class="line">void *value;//节点的值</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p><p>使用多个listNode结构可组成链表，使用adlist.h/list来持有链表，操作起来更方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">listNode *head;//表头节点</span><br><span class="line">listNode *tail;//表尾节点</span><br><span class="line">unsigned long len;//链表所包含的节点的数量</span><br><span class="line">void *(*dup)(void *ptr);//节点值复制函数</span><br><span class="line">void *(*free)(void *ptr);//节点值释放函数</span><br><span class="line">int (*match)(void *ptr, void *key);//节点值对比函数</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>提供了表头指针head，表尾指针tail，链表长度计数器len，dup、free和match用于实现多态链表所需的类型特定函。</p><p>redis链表实现的特性：</p><ul><li>双端。</li><li>无环。</li><li>带表头指针和表尾指针。</li><li>带链表长度计数器。</li><li>多态：链表节点使用void*指针来保存节点值，可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，链表可用于保存各种不同类型的值。</li></ul><h3 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h3><p>链表和链表节点的API：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">listSetDupMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值复制函数</td><td style="text-align:left">O(1)，可通过链表的dup属性直接获得</td></tr><tr><td style="text-align:left">listGetDupMethod</td><td style="text-align:left">返回链表当前正在使用的节点值复制函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetFreeMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值释放函数</td><td style="text-align:left">O(1)，可通过链表的free属性直接获得</td></tr><tr><td style="text-align:left">listGetFree</td><td style="text-align:left">返回链表当前正在使用的节点值释放函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSetMatchMethod</td><td style="text-align:left">将给定的函数设置为链表的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listGetMatchMethod</td><td style="text-align:left">返回链表当前正在使用的节点值对比函数</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listLength</td><td style="text-align:left">返回链表的长度（包含了多少个节点）</td><td style="text-align:left">O(1)，链表的len属性</td></tr><tr><td style="text-align:left">listFirst</td><td style="text-align:left">返回链表的表头节点</td><td style="text-align:left">O(1)，链表的head属性</td></tr><tr><td style="text-align:left">listLast</td><td style="text-align:left">返回链表的表为节点</td><td style="text-align:left">O(1)，链表的tail属性</td></tr><tr><td style="text-align:left">listPrevNode</td><td style="text-align:left">返回给定节点的前置节点</td><td style="text-align:left">O(1)，节点的prev属性</td></tr><tr><td style="text-align:left">listNextNode</td><td style="text-align:left">返回给定节点的后置节点</td><td style="text-align:left">O(1)，节点的next属性</td></tr><tr><td style="text-align:left">listNodeValue</td><td style="text-align:left">返回给定节点目前正在保存的值</td><td style="text-align:left">O(1)，节点的value属性</td></tr><tr><td style="text-align:left">listCreate</td><td style="text-align:left">创建一个不包含任何节点的新链表</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeHead</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表头</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listAddNodeTail</td><td style="text-align:left">将一个包含给定值的新节点添加到给定链表的表尾</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listInsertNode</td><td style="text-align:left">将一个包含给定值的新节点添加到给定节点的之前或者之后</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listSearchKey</td><td style="text-align:left">查找并返回链表中包含给定值的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listIndex</td><td style="text-align:left">返回链表在给定索引上的节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listDelNode</td><td style="text-align:left">从链表中删除给定节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRotate</td><td style="text-align:left">将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，成为新的表头节点</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">listDup</td><td style="text-align:left">复制一个给定链表的副本</td><td style="text-align:left">O(N)，N为链表长度</td></tr><tr><td style="text-align:left">listRelease</td><td style="text-align:left">释放给定链表，以及链表中的所有节点</td><td style="text-align:left">O(N)，N为链表长度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-简单动态字符串</title>
      <link href="/2018/09/08/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/09/08/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush fruits &quot;banana&quot; &quot;apple&quot; &quot;cheery&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>redis在数据库中创建一个新的键值对，其中：</p><ul><li>键是一个字符串对象，对象底层的实现是一个保存了字符串“fruits”的SDS。</li><li>值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，分别保存着字符串“banana”、“apple”、“cheery”。  </li></ul><p>SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>sds.h/sdshdr:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">int len; //buf数组中已使用字节的数量、SDS所保存字符串的长度</span><br><span class="line">int free; //buf数组中未使用字节的数量</span><br><span class="line">char buf[]; //字节数组，用于保存字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，为其分配额外的一字节空间和添加空字符到字符串末尾等操作都由SDS函数自动完成。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><p>C语言使用长度为N+1的字符数组表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。但不能满足redis对字符串安全性、效率以及功能方面的要求。</p><h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>C字符串需遍历整个字符串对字符进行计数，复杂度为O(N)，redis直接返回SDS的len属性值，复杂度O(1)。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>C字符串不记录自身长度容易造成缓冲区溢出（buffer overflow），改写其后缓冲区的内容。</p><p>SDS的空间分配策略杜绝发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，若不满足，API会自动将SDS的空间拓展至执行修改所需的大小，然后才执行修改操作。</p><h4 id="减少修改字符串时带来的内存冲分配次数"><a href="#减少修改字符串时带来的内存冲分配次数" class="headerlink" title="减少修改字符串时带来的内存冲分配次数"></a>减少修改字符串时带来的内存冲分配次数</h4><p>每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>若程序执行的是增长字符串的操作，例如拼接操作（append），执行操作之前，程序需要先通过内存重分配来拓展底层数组的空间大小——忽略此步会产生缓冲区溢出。</li><li>若程序执行的是缩短字符串的操作，例如截断操作（tirm），在执行操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——忽略会产生内存泄漏。</li></ul><p>内存重分配涉及复杂的算法，可能需要执行系统调用，通常是比较耗时的操作：</p><ul><li>一般程序中，若修改字符串长度的情况不太常出现，每次修改都执行一次内存重分配是可接受的。</li><li>redis经常用于速度要求严苛、数据被频繁修改的场合，执行内存重分配会占去修改字符串所用时间的一大部分，频繁操作影响性能。</li></ul><p>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量加一，可以包含未使用字节。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必需要的空间，还会为SDS分配额外的未使用空间，可以使redis减少连续执行字符串增长操作所需的内存重分配次数。</p><p>分配未使用空间数量：</p><ul><li>若修改之后SDS的长度小于1M，程序分配和len属性同样大小的未使用空间，SDS的len属性值将和free属性的值相同，总长度=len+free+1byte（额外的一字节用于保存空字符）。</li><li>若修改之后SDS的长度大于等于1M，程序会分配1M的未使用空间，即free=1，总长度=len+1M+1byte。</li></ul><p>拓展SDS空间之前，SDS API会先检查未使用空间是否足够，若足够，API就会直接使用未分配空间，无需执行内存重分配。</p><h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><p>SDS提供了相关的API，可以在有需要的时候，真正地释放SDS的未使用空间，不必担心惰性空间释放策略会造成内存浪费。</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C字符串中的字符必须符合某种编码（ASCII），且除字符串末尾外，字符串里面不能包含空字符。限制C字符串只能保存文本数据，而不能保存图像、音频、视频、压缩文件这样的二进制数据。</p><p>为确保redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样子，被读取时就是什么样子。</p><p>redis不是使用buf字节数组保存字符，而是保存一系列二进制数据。SDS使用len属性的值而不是空字符来判断字符串是否结束。</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>SDS的API是二进制安全的，但一样遵循C字符串以空字符结尾的惯例：这些API会将SDS保存的数据的末尾设置为空字符，并且会在为buf数组分配空间时多分配一个字节来容纳这个空字符，为了让保存文本数据的SDS可以重用一部分\&lt;string.h>库定义的函数，避免了不必要的代码重复。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>C字符串和SDS之间的区别：</p><table><thead><tr><th style="text-align:left">C字符串</th><th style="text-align:left">SDS</th></tr></thead><tbody><tr><td style="text-align:left">获取字符串长度的复杂度为O(n)</td><td style="text-align:left">获取字符串长度的复杂度为O(1)</td></tr><tr><td style="text-align:left">API是不安全的，可能会造成缓冲区溢出</td><td style="text-align:left">API是安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:left">修改字符串长度N次必然需要执行N次内存重分配</td><td style="text-align:left">修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td style="text-align:left">只能保存文本数据</td><td style="text-align:left">可以保存文本或者二进制数据</td></tr><tr><td style="text-align:left">可以使用所有\&lt;string.h>库中的函数</td><td style="text-align:left">可以使用一部分\&lt;string.h>库中的函数</td></tr></tbody></table><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>SDS主要操作API</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">sdsnew</td><td style="text-align:left">创建一个包含给定C字符串的SDS</td><td style="text-align:left">O(N)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdsempty</td><td style="text-align:left">创建一个不包含任何内容的空SDS</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">sdsfree</td><td style="text-align:left">释放给定的SDS</td><td style="text-align:left">O(N)，N为被释放SDS的长度</td></tr><tr><td style="text-align:left">sdslen</td><td style="text-align:left">返回SDS的已使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的len属性</td></tr><tr><td style="text-align:left">sdsavail</td><td style="text-align:left">返回SDS的未使用空间字节数</td><td style="text-align:left">O(1)，读取SDS的free属性</td></tr><tr><td style="text-align:left">sdsdup</td><td style="text-align:left">创建一个给定SDS的副本（copy）</td><td style="text-align:left">O(N)，N为给定SDS的长度</td></tr><tr><td style="text-align:left">sdsclear</td><td style="text-align:left">清空SDS保存的字符串内容</td><td style="text-align:left">O(1)，惰性空间释放策略</td></tr><tr><td style="text-align:left">sdscat</td><td style="text-align:left">将给定字符串拼接到SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接的字符串的长度</td></tr><tr><td style="text-align:left">sdscatsds</td><td style="text-align:left">将给定SDS字符串拼接到另一个SDS字符串的末尾</td><td style="text-align:left">O(N)，N为被拼接SDS字符串的长度</td></tr><tr><td style="text-align:left">sdscpy</td><td style="text-align:left">将给定C字符串复制到SDS里面，覆盖SDS原有的字符串</td><td style="text-align:left">O(N)，N为被复制C字符串的长度</td></tr><tr><td style="text-align:left">sdsgrowzero</td><td style="text-align:left">用空字符串将SDS拓展至给定长度</td><td style="text-align:left">O(N)，N为拓展新增的字节数</td></tr><tr><td style="text-align:left">sdsrange</td><td style="text-align:left">保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除</td><td style="text-align:left">O(N)，N为被保留数据的字节数</td></tr><tr><td style="text-align:left">sdstrim</td><td style="text-align:left">接受一个SDS和C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符</td><td style="text-align:left">O(N^2)，N为给定C字符串的长度</td></tr><tr><td style="text-align:left">sdscmp</td><td style="text-align:left">对比两个SDS字符串是否相同</td><td style="text-align:left">O(N)，N为两个SDS中较短的那个SDS的长度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis设计与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> sds </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go模板引擎</title>
      <link href="/2018/08/24/Go%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2018/08/24/Go%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>Go标准库text/template、html/template。</p><hr><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>可以把模板引擎划分为两种理想的类型：</p><ul><li>无逻辑模板引擎（logic-less template engine）——将模板中指定的占位符替换成相应的动态数据。只进行字符串替换，不执行任何逻辑处理。目的是完全分离程序的表现和逻辑，并将所有计算方面的工作都交给处理器完成。</li><li>嵌入逻辑的模板引擎（embedded logic template engine）——将编程语言代码嵌入模板当中，并在模板引擎渲染时，由模板引擎执行这些代码并进行相应的字符串替换工作。</li></ul><p>无逻辑模板引擎的渲染速度往往会更快一些。</p><h3 id="Go的模板引擎"><a href="#Go的模板引擎" class="headerlink" title="Go的模板引擎"></a>Go的模板引擎</h3><p>Go语言的模板引擎介于无逻辑模板引擎和嵌入逻辑模板引擎之间，由处理器负责触发。</p><p>Go的通用模板引擎库text/template可以处理任意格式的文本，模板引擎库html/template专门处理HTML格式。模板中的动作默认使用两个大括号<code>{</code>和<code>}</code>包围，也可以通过模板引擎提供的方法自行指定其他定界符（delimiter）。</p><p>使用Go的Web模板引擎需要的步骤：</p><ul><li>对文本格式的模板源进行语法分析，创建一个经过语法分析的模板结构，模板源既可以是一个字符串，也可以是模板文件中包含的内容。</li><li>执行经过语法分析的模板，将ResponseWriter和模板所需的动态数据传递给模板引擎，被调用的模板引擎会把经过语法分析的模板和传入的数据结合起来，生成最终的HTML传递给ResponseWriter。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, &quot;Hello World!)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></li></ul><h4 id="对模板进行语法分析"><a href="#对模板进行语法分析" class="headerlink" title="对模板进行语法分析"></a>对模板进行语法分析</h4><p>ParseFiles是一个独立的函数，可以对模板文件进行语法分析，并创建出一个经过语法分析的模板结构以供Execute方法执行。</p><blockquote><p>调用ParseFiles函数的时候，Go会创建出一个新的模板，并将用户给定的模板文件的名字用作这个新模板的名字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := template.New(&quot;tmpl.html&quot;)</span><br><span class="line">t, _ := t.ParseFiles(&quot;tmpl.html&quot;)</span><br></pre></td></tr></table></figure><p>ParseFiles函数和Template结构的ParseFiles方法都可以接受一个或多个文件名作为参数，但只返回一个模板。返回用户传入的第一个文件的已分析模板，模板也会根据用户传入的第一个文件的名字进行命名，其他传入文件的已分析模板会被放置到一个映射里面，可以在之后执行模板时使用。</p><blockquote><p>即，向ParseFiles传入单个文件时，ParseFiles返回的是一个模板，向ParseFiles传入多个文件时，ParseFiles返回的是一个模板集合。</p></blockquote><p>使用ParseGlob函数对模板文件进行语法分析，会对匹配给定模式的所有文件进行语法分析。</p><p>实际上，所有对模板进行语法分析的手段最终都需要调用Parse方法来执行实际的语法分析操作。</p><p>专门用于处理分析模板时出现的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := template.Must(template.ParseFiles(&quot;tmpl.html&quot;))</span><br></pre></td></tr></table></figure><p>Must函数可以包裹起一个函数，被包裹的函数会返回一个指向模板的指针和一个错误，若错误不是nil，Must函数将产生一个panic。</p><h4 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h4><p>常用方法调用模板的Execute方法，并向它传递ResponseWriter以及模板所需的数据。若对模板集合调用Execute方法，只会执行模板集合中的第一个模板。使用ExecuteTemplate方法执行其他模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;)</span><br><span class="line"></span><br><span class="line">t.Execute(w, &quot;hello world!&quot;)</span><br><span class="line"></span><br><span class="line">t.ExecuteTemplate(w, &quot;t2.html&quot;, &quot;Hello World!&quot;)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作即嵌入在模板里面的命令，使用两个大括号{和}进行包围。</p><p>主要有动作：</p><ul><li>条件动作；</li><li>迭代动作；</li><li>设置动作；</li><li>包含动作。</li></ul><p>还有<code>定义动作</code>，（ . ）也是一个动作，代表的是传递给模板的数据，其他动作和函数基本上都会对这个动作进行处理，达到格式化和内容展示的目的。</p><h4 id="条件动作"><a href="#条件动作" class="headerlink" title="条件动作"></a>条件动作</h4><p>根据参数的值决定对多条语句中的哪一条语句进行求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line"></span><br><span class="line">some content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; if arg &#125;&#125;</span><br><span class="line">some content</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="迭代动作"><a href="#迭代动作" class="headerlink" title="迭代动作"></a>迭代动作</h4><p>迭代动作可以对数组、切片、映射或者通道进行迭代，在迭代循环的内部点(.)会被设置为当前被迭代的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range array &#125;&#125;</span><br><span class="line">Dot is set to the element &#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range . &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">other content to show</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="设置动作"><a href="#设置动作" class="headerlink" title="设置动作"></a>设置动作</h4><p>允许用户在指定的范围之内为点<code>(.)</code>设置值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;the dot is already set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;Dot is set to arg</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">Fallback if arg is empty</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h4 id="包含动作"><a href="#包含动作" class="headerlink" title="包含动作"></a>包含动作</h4><p>允需用户在一个模板里面包含另一个模板，从而构建出嵌套的模板。包含动作的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template &quot;name&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p>name参数为被包含模板的名字。</p><h3 id="参数、变量和管道"><a href="#参数、变量和管道" class="headerlink" title="参数、变量和管道"></a>参数、变量和管道</h3><p>参数即模板中的值，可以是布尔值、整数、字符串等字面量，也可以是结构、结构中的一个字段或者数组中的一个键。还可以是一个变量、一个方法（该方法必须只返回一个值、或只返回一个值和一个错误）或者一个函数。参数也可以是一个点(.)，用于表示处理器向模板引擎传递的数据。</p><p>除参数外，可在工作中设置以美元符号开头的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; range $key, $value := . &#125;&#125;</span><br><span class="line">The key is &#123;&#123; $key &#125;&#125; and the value is &#123;&#123; $value &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>又或者使用管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; 12.3456 | printf &quot;%.2f&quot; &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go的模板引擎函数都是受限制的：函数可以接受任意多个参数作为输入，但是只能返回一个值，或者返回一个值和一个错误。</p><p>创建自定义模板函数：</p><ul><li>创建一个名为FuncMap的映射，将映射的键设置为函数的名字，映射的值设置为实际定义的函数；</li><li>将FuncMap与模板进行绑定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func formatDate(t time.Time) string &#123;</span><br><span class="line">layout := &quot;2006-01-02&quot;</span><br><span class="line">return t.Format(layout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">funcMap := template.FuncMap&#123; &quot;fdate&quot;: formatDate &#125;</span><br><span class="line">t := template.New(&quot;tmpl.html&quot;).Funcs(funcMap)</span><br><span class="line">t, _ = t.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>模板中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;The Date/Time is &#123;&#123; . | fdate &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>又或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;the Date/Time is &#123;&#123; fdate . &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>使用管道将一个函数的输出传递给另一个函数作为输入，使代码更简单易读。</p><h3 id="上下文感知"><a href="#上下文感知" class="headerlink" title="上下文感知"></a>上下文感知</h3><p>Go的模板引擎可以根据内容所处的上下文改变其显示的内容。根据内容在模板中所处的位置，模板在显示这些内容的时候将对其进行相应的修改。可对被显示的内容实施正确的转义（escape）：模板现实的是HTML格式的内容，模板对其实施HTML转义；显示的是JavaScript格式的内容，对其实施JavaScript转义。还可以识别出内容中的URl或者CSS样式。</p><p>主要用于实现自动的防御编程，防止某些明显并且低级的编程错误。</p><h3 id="防御XSS攻击"><a href="#防御XSS攻击" class="headerlink" title="防御XSS攻击"></a>防御XSS攻击</h3><p>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致。</p><p>通过模板引擎在显示用户输入时将其转换为转义之后的HTML，避免可能会出现的问题。</p><h3 id="不对HTML进行转义"><a href="#不对HTML进行转义" class="headerlink" title="不对HTML进行转义"></a>不对HTML进行转义</h3><p>使用“不转义代码机制”允许用户输入HTML代码或者JavaScript代码，并在显示内容时执行这些代码。</p><p>将不想被转义的内容传给template.HTML函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;comment)))</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>程序通过类型转换（typecast）将表单中的评价值转换成template.HTML类型。</p><blockquote><p>可通过发送一个最初由微软公司为IE浏览器创建的特殊HTTP响应首部X-XSS-Protection让浏览器关闭内置的XSS防御功能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func process (w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">w.Header().Set(&quot;X-XSS-Protection&quot;, &quot;0&quot;)</span><br><span class="line">t, _ := template.ParseFiles(&quot;tmpl.html&quot;)</span><br><span class="line">t.Execute(w, template.HTML(r.FormValue(&quot;content)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套模版"><a href="#嵌套模版" class="headerlink" title="嵌套模版"></a>嵌套模版</h3><p>布局指Web设计中可以重复应用在多个页面上的固定模式。</p><p>通过包含动作，在一个模版里面包含另一个模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; template &quot;name&quot; . &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>动作参数name为被包含的模板名字，是一个字符串常量。每个页面都拥有它们各自的布局模版文件，程序最终无法拥有任何可共用的公共布局。</p><p>可通过定义动作（define action），在模板文件里面显示地定义模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>在一个模板文件里定义多个不同模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line"> ···</span><br><span class="line"> &#123;&#123; template &quot;content&quot; &#125;&#125;</span><br><span class="line"> ···</span><br><span class="line"> &lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">Hello World!</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>使用显示定义模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w, http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>可在不同的模板文件里面定义同名的模板（red_hello.html，blue_hello.html）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content&quot; &#125;&#125;</span><br><span class="line">&lt;h1 style= &quot;color: red;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;content &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt; hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用在不同模板文件中定义的同名模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *template.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red_hello.html&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layput.html&quot;, &quot;blue_hello.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.Execute(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>通过块动作定义默认模板<br>块动作（block action）允许用户定义一个模板并且立即使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block arg &#125;&#125;</span><br><span class="line">Dot is set to arg</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>改进上方逻辑，默认展示蓝色else只对layout.html进行语法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func process(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">var t *tempale.Template</span><br><span class="line">if rand.Intn(10) &gt; 5 &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;, &quot;red)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t, _ := template.ParseFiles(&quot;layout.html&quot;)</span><br><span class="line">&#125;</span><br><span class="line">t.ExecuteTemplate(w, &quot;layout&quot;, &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h3 id="通过块动作添加默认的content模版"><a href="#通过块动作添加默认的content模版" class="headerlink" title="通过块动作添加默认的content模版"></a>通过块动作添加默认的content模版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;&#123; define &quot;layout&quot; &#125;&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">···</span><br><span class="line">&#123;&#123; block &quot;content&quot; . &#125;&#125;</span><br><span class="line">&lt;h1 style=&quot;color: blue;&quot;&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>块动作定义的content模板，当layout模板被执行时，若模板引擎没找到可用的content模板，就会使用块动作中定义的content模板。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go模板库 </tag>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go与Cookie</title>
      <link href="/2018/08/23/Go%E4%B8%8ECookie/"/>
      <url>/2018/08/23/Go%E4%B8%8ECookie/</url>
      
        <content type="html"><![CDATA[<p>大多数cookie都可以被划分为会话cookie和持久cookie两种类型。</p><hr><h3 id="Go与cookie"><a href="#Go与cookie" class="headerlink" title="Go与cookie"></a>Go与cookie</h3><p>cookie在Go语言中用Cookie结构表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Cookie struct &#123;</span><br><span class="line">Namestring</span><br><span class="line">Valuestring</span><br><span class="line">Pathstring</span><br><span class="line">Domainstring</span><br><span class="line">Expirestime.Time</span><br><span class="line">RawExpiresstring</span><br><span class="line">MaxAgeint</span><br><span class="line">Securebool</span><br><span class="line">HttpOnlybool</span><br><span class="line">Rawstring</span><br><span class="line">Unparsed[]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有设置Expires字段的cookie通常称为会话cookie或者临时cookie，这种cookie在浏览器关闭的时候就会自动被移除。设置了Expires字段的cookie通常称为持久cookie，这种cookie会一直存在，直到指定的过期时间来临或者被手动删除为止。</p><p>Expires字段和MaxAge字段都可以设置cookie的过期时间，Expires字段用于明确地指定cookie应该在什么时候过期，MaxAge字段指明cookie在被浏览器创建出来之后能够存活多少秒。</p><p>为使cookie在所有浏览器上都能够正常运行，只使用Expires，或者同时使用Expires和MaxAge。</p><h3 id="将cookie发送至浏览器"><a href="#将cookie发送至浏览器" class="headerlink" title="将cookie发送至浏览器"></a>将cookie发送至浏览器</h3><p>Cookie结构的String方法可以返回一个经过序列化处理的cookie，其中Set-Cookie响应首部的值即为这些序列化之后的cookie组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">w.Header().Set(&quot;Set-Cookie&quot;, c1.String())</span><br><span class="line">w.Header().Add(&quot;Set-Cookie&quot;, c2.String())</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>除Set方法和Add方法外，还可使用net/http库中的SetCookie方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1 := http.Cookie&#123;</span><br><span class="line">Name:&quot;first_cookie&quot;,</span><br><span class="line">Value:&quot;Wuhua&quot;,</span><br><span class="line">HttpOnly:true,</span><br><span class="line">&#125;</span><br><span class="line">c2 := &#123;</span><br><span class="line">Name: &quot;second_cookie&quot;,</span><br><span class="line">Value:&quot;Love or hate&quot;,</span><br><span class="line">HttpOnly: true,</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c1)</span><br><span class="line">http.SetCookie(w, &amp;c2)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用SetCookie方法设置cookie，传递给方法的是指向Cookie的指针而不是Cookie结构本身。</p><h3 id="从浏览器获取cookie"><a href="#从浏览器获取cookie" class="headerlink" title="从浏览器获取cookie"></a>从浏览器获取cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">h := r.Header[&apos;Cookie&apos;]</span><br><span class="line">fmt.Fprintln(w, h)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>语句<code>r.Header[&quot;Cookie&quot;]</code>返回一个切片，切片包含一个字符串，字符串包含了客户端发送的任意多个cookie。取得单独的键值对格式的cookie，需要对r.Header[“Cookie”]返回的字符串进行语法分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func getCookie(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c1, err := r.Cookie(&quot;first_cookie&quot;);</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;Cannot get the first cookie&quot;)</span><br><span class="line">&#125;</span><br><span class="line">cs := r.Cookies()</span><br><span class="line">fmt.Fprintln(w, c1)</span><br><span class="line">fmt.Fprintln(w, cs)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>使用Request结构的Cookie方法获取指定名字的cookie，若指定的cookie不存在，则方法返回一个错误。使用Cookies方法获取多个cookie，返回一个包含了所有cookie的切片。</p><p>上方未设置cookie的过期时间，为会话cookie，完全退出浏览器并重启这些cookie会消失。</p><h3 id="使用cookie实现闪现消息"><a href="#使用cookie实现闪现消息" class="headerlink" title="使用cookie实现闪现消息"></a>使用cookie实现闪现消息</h3><p>实现闪现消息的常用方法是将这些消息存储在页面刷新时就会被移除的会话cookie里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func setMessage(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">msg := []byte(&quot;Hello World!)</span><br><span class="line">c := http.Cookie&#123;</span><br><span class="line">Name:&quot;flash&quot;,</span><br><span class="line">Value:base64.URLEncoding.EncodeToString(msg),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;c)</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>设置cookie时，如果cookie的值没有包含诸如空格或者百分号这样的特设字符，可不对它进行编码；由于消息本身通常包含此类字符，需要使用Base64URL编码，以此来满足响应首部对cookie值的URL编码要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">func showMessage(w http.ReponseWriter, r *http.Request) &#123;</span><br><span class="line">c, err := r.Cookie(&quot;flash&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if err == http.ErrNoCookie &#123;</span><br><span class="line">fmt.Fprintln(w, &quot;No message found)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rc := http.Cookie&#123;</span><br><span class="line">Name: &quot;flash&quot;,</span><br><span class="line">MaxAge:-1,</span><br><span class="line">Expires:time.Unix(1, 0),</span><br><span class="line">&#125;</span><br><span class="line">http.SetCookie(w, &amp;rc)</span><br><span class="line">val, _ := base64.URLEncoding.DecodeString(c.Value)</span><br><span class="line">fmt.Fprintln(w, string(val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>获取flash消息cookie，创建同名cookie并设置MacAge值为负数、Expires值为已经过去的时间，将同名cookie发送至客户端，相当于命令浏览器删除这个cookie。将flash消息解码，通过响应返回这条消息。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP简记</title>
      <link href="/2018/08/21/HTTP%E7%AE%80%E8%AE%B0/"/>
      <url>/2018/08/21/HTTP%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>请求行（request-line）；</li><li>零个或任意多个请求首部（header）；</li><li>一个空行；</li><li>可选的报文主体（body）。</li></ul><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP 1.1要求必须实现的只有GET方法和HEAD方法，其他方法（包括POST）方法是可选的。</p><ul><li>GET——命令服务器返回指定的资源。</li><li>HEAD——类似GET，不同于此方法不要求服务器返回报文的主体。用于在不获取报文主体的情况下取得相应的首部。</li><li>POST——命令服务器将报文主体中的数据传递给URI指定的资源。</li><li>PUT——命令服务器将报文主体中的数据设置为URI指定的资源，若URI指定的位置上已有数据存在，则使用报文主体中的数据去代替已有的数据，若资源未存在，则在URI指定的位置上新创建一个资源。</li><li>DELETE——命令服务器删除URI指定的资源。</li><li>TRACE——命令服务器返回请求本身，了解介于客户端和服务器之间的其他服务器是如何处理请求的。</li><li>OPTIONS——命令服务器返回它支持的HTTP方法列表。</li><li>CONNECT——命令服务器与客户端建立一个网络连接，用于设置SSL隧道以开启HTTPS功能。</li><li>PATCH——命令服务器使用报文主体中的数据对URI指定的资源进行修改。</li></ul><h4 id="常见的请求首部"><a href="#常见的请求首部" class="headerlink" title="常见的请求首部"></a>常见的请求首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">客户端在HTTP相应中能够接收的内容类型。如Accept: text/html</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">客户端要求服务器使用的字符集编码。如Accept-Charset: utf-8。</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">用于向服务器发送基本的身份验证证书</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">客户端在此首部中把服务器之前设置的所有cookie回传给服务器。如Cookie: my-first_cookie=hello; my_second_cookie=world</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">请求主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">请求包含主体的时候用于记录主体内容的类型。发送POST或GET请求时默认为x-www-form-urlen-coded，上传文件时应设置为multipart/form-data。</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">服务器的名字及端口号。无端口号表示使用80端口</td></tr><tr><td style="text-align:left">Referrer</td><td style="text-align:left">发起请求的页面所在的地址</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">对发起请求的客户端进行描述</td></tr></tbody></table><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>由一系列文本行组成，有顺序地进行排列：</p><ul><li>状态行；</li><li>零个或任意多个响应首部；</li><li>一个空行；</li><li>可选的报文主体。</li></ul><h4 id="5种类型的响应状态码"><a href="#5种类型的响应状态码" class="headerlink" title="5种类型的响应状态码"></a>5种类型的响应状态码</h4><table><thead><tr><th style="text-align:left">状态码类型</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">情报状态码。告知客户端已接收客户端发送的请求，并且已经对请求进行了处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">成功状态码。告知客户端已接收客户端发送的请求，并且已经成功地对请求进行了处理。标准响应为‘200 OK’</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">重定向状态码。告知客户端已接收客户端发送的请求，并且已经成功处理了请求，但为了完成请求指定的动作，客户端还需要再做一些其他的工作，大多用于实现URL重定向</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">客户端错误状态码。告知客户端发送的请求出现了某些问题。常见‘404 Not Found’表示服务器无法从请求指定的URL中找到客户端想要的资源</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">服务器错误状态码。当服务器因某些原因而无法正确地处理请求时，使用此类状态码告知客户端。</td></tr></tbody></table><h4 id="常见的响应首部"><a href="#常见的响应首部" class="headerlink" title="常见的响应首部"></a>常见的响应首部</h4><table><thead><tr><th style="text-align:left">首部字段</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">告知客户端，服务器支持哪些请求方法</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">响应主体的字节长度</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">若响应包含主体则为主体内容的类型</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">以格林尼治标准时间（GMT）格式记录的当前时间</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">仅在重定向时使用，告知客户端截下来应该向哪个URL发送请求。</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">返回响应的服务器的域名</td></tr><tr><td style="text-align:left">Set-Cookie</td><td style="text-align:left">在客户端里面设置一个Cookie，一个响应里面可以包含多个Set-Cookie首部</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">告知客户端在Authorization请求首部中应该提供哪种类型的身份验证信息。服务器常把此首部与“401 Unauthorized”状态行一同发送。此外还会向服务器许可的认证授权模式（schema）提供验证信息（challenge information） </td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> web杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试工具-siege</title>
      <link href="/2018/08/03/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-siege/"/>
      <url>/2018/08/03/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-siege/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>mac下使用brew直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install siege</span><br></pre></td></tr></table></figure><p><code>siege -C</code>查看相关的配置参数，可以自行修改，比如是否显示log，超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">localhost:~ wuhua$ siege -C</span><br><span class="line">CURRENT  SIEGE  CONFIGURATION</span><br><span class="line">Mozilla/5.0 (apple-x86_64-darwin17.0.0) Siege/4.0.4</span><br><span class="line">Edit the resource file to change the settings.</span><br><span class="line">----------------------------------------------</span><br><span class="line">version:                        4.0.4</span><br><span class="line">verbose:                        true</span><br><span class="line">color:                          true</span><br><span class="line">quiet:                          false</span><br><span class="line">debug:                          false</span><br><span class="line">protocol:                       HTTP/1.1</span><br><span class="line">HTML parser:                    enabled</span><br><span class="line">get method:                     HEAD</span><br><span class="line">connection:                     close</span><br><span class="line">concurrent users:               25</span><br><span class="line">time to run:                    n/a</span><br><span class="line">repetitions:                    n/a</span><br><span class="line">socket timeout:                 30</span><br><span class="line">cache enabled:                  false</span><br><span class="line">accept-encoding:                gzip, deflate</span><br><span class="line">delay:                          0.000 sec</span><br><span class="line">internet simulation:            false</span><br><span class="line">benchmark mode:                 false</span><br><span class="line">failures until abort:           1024</span><br><span class="line">named URL:                      none</span><br><span class="line">URLs file:                      /usr/local/Cellar/siege/4.0.4/etc/urls.txt</span><br><span class="line">thread limit:                   10000</span><br><span class="line">logging:                        false</span><br><span class="line">log file:                       /Users/wuhua/var/siege.log</span><br><span class="line">resource file:                  /Users/wuhua/.siege/siege.conf</span><br><span class="line">timestamped output:             false</span><br><span class="line">comma separated output:         false</span><br><span class="line">allow redirects:                true</span><br><span class="line">allow zero byte data:           true</span><br><span class="line">allow chunked encoding:         true</span><br><span class="line">upload unique files:            true</span><br><span class="line">no-follow:</span><br><span class="line"> - ad.doubleclick.net</span><br><span class="line"> - pagead2.googlesyndication.com</span><br><span class="line"> - ads.pubsqrd.com</span><br><span class="line"> - ib.adnxs.com</span><br></pre></td></tr></table></figure><p>项目：<a href="https://github.com/JoeDog/siege" target="_blank" rel="noopener">siege</a></p><p>参考：<a href="https://blog.csdn.net/shangmingtao/article/details/73850292#1siege%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">siege压力测试工具安装和介绍</a>，<a href="https://www.cnblogs.com/lawlietfans/p/6873306.html" target="_blank" rel="noopener">如何使用siege测试服务器性能</a></p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>可在命令行中输入siege –help获取。</p><table><thead><tr><th style="text-align:left">输入参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:left">-V,–version</td><td style="text-align:left">打印版本号</td></tr><tr><td style="text-align:left">-h,–help</td><td style="text-align:left">打印帮助信息（输出这些命令参数及详情）</td></tr><tr><td style="text-align:left">-C,–config</td><td style="text-align:left">显示当前配置信息</td></tr><tr><td style="text-align:left">-v,–verbose</td><td style="text-align:left">将通知信息输出到屏幕</td></tr><tr><td style="text-align:left">-q,–quiet</td><td style="text-align:left">停止verbose并抑制输出</td></tr><tr><td style="text-align:left">-g,–get</td><td style="text-align:left">显示请求URL的HTTP头和返回详情，适用于调试</td></tr><tr><td style="text-align:left">-p,–print</td><td style="text-align:left">打印，类似GET一样，打印整个页面（response html）</td></tr><tr><td style="text-align:left">-c,–concurrent=NUM</td><td style="text-align:left">设置并发用户数，默认为10</td></tr><tr><td style="text-align:left">-r,-–reps=NUM</td><td style="text-align:left">设置测试次数</td></tr><tr><td style="text-align:left">-t,–time=NUMm</td><td style="text-align:left">设置测试时间，m修饰秒（S）、分（M）、时（H），例如–time=1H</td></tr><tr><td style="text-align:left">-d,-–delay=NUM</td><td style="text-align:left">时间延迟，每次请求之前的延迟随机</td></tr><tr><td style="text-align:left">-b,–benchmark</td><td style="text-align:left">基准测试，请求之间没有延迟</td></tr><tr><td style="text-align:left">-i,–internet</td><td style="text-align:left">用户模拟、随机访问url</td></tr><tr><td style="text-align:left">-f,-–file=FILE</td><td style="text-align:left">选择特定的URLS文件（读取文件选取其中的url进行访问）</td></tr><tr><td style="text-align:left">-R,–rc=FILE</td><td style="text-align:left">指定一个siegerc文件</td></tr><tr><td style="text-align:left">-l,–log[=FILE]</td><td style="text-align:left">记录测试日志到文件，如果未指定FILE，则使用默认值：PREFIX/var/siege.log</td></tr><tr><td style="text-align:left">-m,-–mark=”text”</td><td style="text-align:left">标记，用字符串标记测试日志，介于.001和NUM之间。（未计入统计数据）</td></tr><tr><td style="text-align:left">-H,-–header=”text”</td><td style="text-align:left">添加测试的请求头header，可以为多个</td></tr><tr><td style="text-align:left">-A, –user-agent=”text”</td><td style="text-align:left">在请求中设置User-Agent</td></tr><tr><td style="text-align:left">-T, –content-type=”text”</td><td style="text-align:left">在请求中设置Content-Type</td></tr><tr><td style="text-align:left">–no-parser</td><td style="text-align:left">没有PARSER，关闭HTML页面解析器</td></tr><tr><td style="text-align:left">–no-follow</td><td style="text-align:left">不遵循，不要遵循HTTP重定向</td></tr></tbody></table><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><table><thead><tr><th style="text-align:center">输出参数名</th><th style="text-align:left">解释说明</th></tr></thead><tbody><tr><td style="text-align:center">Transactions</td><td style="text-align:left">总共测试次数</td></tr><tr><td style="text-align:center">Availability</td><td style="text-align:left">成功次数百分比</td></tr><tr><td style="text-align:center">Elapsed time</td><td style="text-align:left">总共耗时多少秒</td></tr><tr><td style="text-align:center">Data transferred</td><td style="text-align:left">总共数据传输</td></tr><tr><td style="text-align:center">Response time</td><td style="text-align:left">平均响应时间</td></tr><tr><td style="text-align:center">Transaction rate</td><td style="text-align:left">平均每秒处理请求数</td></tr><tr><td style="text-align:center">Throughput</td><td style="text-align:left">吞吐率</td></tr><tr><td style="text-align:center">Concurrency</td><td style="text-align:left">最高并发</td></tr><tr><td style="text-align:center">Successful transactions</td><td style="text-align:left">成功的请求数</td></tr><tr><td style="text-align:center">Failed transactions</td><td style="text-align:left">失败的请求数</td></tr><tr><td style="text-align:center">Longest transaction</td><td style="text-align:left">最长响应时间</td></tr><tr><td style="text-align:center">Shortest transaction</td><td style="text-align:left">最短响应时间</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>示例：</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">数据</th></tr></thead><tbody><tr><td style="text-align:left"> 请求登陆接口</td><td style="text-align:left"><a href="http://bighua.com/login" target="_blank" rel="noopener">http://bighua.com/login</a></td></tr><tr><td style="text-align:left"> 请求类型</td><td style="text-align:left">POST</td></tr><tr><td style="text-align:left"> 请求参数</td><td style="text-align:left">{“_token”: “qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5”,”email”: “228944883 @qq.com”,”password”: “hualin123”,”remember”: “on”}</td></tr><tr><td style="text-align:left"> 请求次数</td><td style="text-align:left">10次</td></tr><tr><td style="text-align:left"> 请求并发数量</td><td style="text-align:left">150</td></tr></tbody></table><p>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siege &quot;http://bighua.com/login POST &#123;&quot;_token&quot;:&quot;qeXesWXLPl6BnNhPWvc44NeaCyY75ahpqA42ErT5&quot;,&quot;email&quot;:&quot;228944883@qq.com&quot;,&quot;password&quot;:&quot;hualin123&quot;,&quot;remember&quot;:&quot;on&quot;&#125;&quot; -r 10 -c 150</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transactions:        1490 hits</span><br><span class="line">Availability:       99.33 %</span><br><span class="line">Elapsed time:       41.63 secs</span><br><span class="line">Data transferred:        2.16 MB</span><br><span class="line">Response time:        3.04 secs</span><br><span class="line">Transaction rate:       35.79 trans/sec</span><br><span class="line">Throughput:        0.05 MB/sec</span><br><span class="line">Concurrency:      108.82</span><br><span class="line">Successful transactions:           0</span><br><span class="line">Failed transactions:          10</span><br><span class="line">Longest transaction:       35.63</span><br><span class="line">Shortest transaction:        0.00</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>siege默认的线程数为255，与apache的默认值相对应，nginx的默认最大连接数为1024。不修改isege配置文件的话，-c的最大值只能为255。 只能测试并发量在255以下。</p><p>另外操作系统对打开文件的多少有限制，即限制socket打开的数量。可通过ulimit命令进行修改。参看博客：<a href="https://blog.csdn.net/z1134145881/article/details/52573441/" target="_blank" rel="noopener">Mac打开文件最大数限制修改</a>、<a href="https://blog.csdn.net/whereismatrix/article/details/50582919" target="_blank" rel="noopener">mac中修改系统限制量–ulimit和sysctl</a>。</p><p>对nginx设置参考<a href="https://blog.csdn.net/hjh15827475896/article/details/53442800" target="_blank" rel="noopener">单机 nginx 应对高并发处理</a>。</p>]]></content>
      
      
      <categories>
          
          <category> web杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> siege </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EXPLAIN[查询执行计划]</title>
      <link href="/2018/08/02/EXPLAIN-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2018/08/02/EXPLAIN-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>通过EXPLAIN命令获取关于查询执行计划的信息，是查看查询优化器如何决定执行查询的主要方法。</p><h3 id="调用EXPLAIN"><a href="#调用EXPLAIN" class="headerlink" title="调用EXPLAIN"></a>调用EXPLAIN</h3><p>在查询中的SELECT关键字之前增加EXPLAIN，MySQL会在查询上设置一个标记，执行查询时，标记会使其返回关于在执行计划中每一步的信息，而不是执行它。返回一行或多行信息，显示出执行计划中的每一部分和执行的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p>查询中每个表在输出中只有一行，若查询为两个表的联接，输出则有两行，别名表单算为一个表，因此把一个表与自己联接，输出也有两行。表：一个子查询，一个UNION结果等等。</p><p>EXPLAIN的两个主要变种：</p><ul><li>EXPLAIN EXTENED：使服务器“逆向编译”执行计划为一个SELECT语句。通过继续运行SHOW WARNINGS查看生成的语句。语句直接来自执行计划，不是原SQL语句，此时为一个数据结构。大部分场景下与原语句不同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[mysql&gt; explain extended select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;                                                                                                      +---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |</span><br><span class="line">+---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1681 | &apos;EXTENDED&apos; is deprecated and will be removed in a future release.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |</span><br><span class="line">| Note    | 1003 | /* select#1 */ select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`email` AS `email`,`login`.`users`.`password` AS `password`,`login`.`users`.`profile_status` AS `profile_status`,`login`.`users`.`remember_token` AS `remember_token`,`login`.`users`.`last_login_ip` AS `last_login_ip`,`login`.`users`.`created_at` AS `created_at`,`login`.`users`.`updated_at` AS `updated_at` from `login`.`users` where (`login`.`users`.`remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos;) |</span><br><span class="line">+---------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><ul><li>EXPLAIN PARTITIONS：若查询基于分区表，显示查询将访问的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysql&gt; explain partitions select * from `users` where `remember_token` = &apos;y$ihqfHMTKSbq671vFbQ0/nePPH8dAYolKmuXzTcW7nF1BmoNcqjI0S&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: remember_token</span><br><span class="line">          key: remember_token</span><br><span class="line">      key_len: 403</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>若查询的from子句中包括子查询，则mysql会执行子查询并将其结果放在一个临时表中，然后完成外层查询优化。必须在可以完成外层查询优化之前处理所有类似的子查询（V5.6中被取消），意味着若语句包含开销较大的子查询或使用临时表，实际会给服务器带来大量工作。</p><p>限制：</p><ul><li>不会显示触发器、存储过程或UDF会如何影响查询。</li><li>不支持存储过程、尽管可以可以手动抽取查询并单独地对其进行EXPLAIN操作。</li><li>不会显示MySQL在查询执行中所做的特定优化。</li><li>不会显示关于查询的执行计划的所有信息。</li><li>不区分具有相同名字的事务。</li><li>可能会误导。</li></ul><h3 id="重写非SELECT查询"><a href="#重写非SELECT查询" class="headerlink" title="重写非SELECT查询"></a>重写非SELECT查询</h3><p>EXPLAIN只能解释SELECT查询，不会对存储程序调用和INSERT、UPDATE、DELETE或其他语句做解释。通过将非SELECT语句转化为一个等价的访问所有相同列的SELECT，重写这些语句以利用EXPLAIN。</p><p>显示计划时，对于写查询没有“等价”的读查询。一个SELECT查询只需要找到数据的一份副本并返回，任何修改数据的查询必须在所有索引上查找并修改其所有副本，比等价的SELECT查询的消耗要高的多。</p><h3 id="EXPLAIN中的列"><a href="#EXPLAIN中的列" class="headerlink" title="EXPLAIN中的列"></a>EXPLAIN中的列</h3><h4 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h4><p>包含一个编号，标识SELECT所属的行。若语句中没有子查询或联合，只会有唯一的SELECT，显示1。否则，内层的SELECT语句一般会顺序编号，对应于其在原始语句中的位置。</p><p>MySQL将SELECT查询分为简单和复杂类型，复杂类型分为三大类：简单子查询、所谓的派生表（在FROM子句中的子查询）、以及UNION查询。</p><h4 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h4><p>显示对应行是简单还是复杂SELECT，SIMPLE意味着查询不包括子查询和UNION，若有复杂子部分，则最外层标记为PRIMARY，其他部分标记如下。</p><ul><li><p>SUBQUERY<br>在SELECT列表中的子查询中的SELECT（不再FROM子句中）</p></li><li><p>DERIVED<br>表示包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中</p></li><li><p>UNION<br>在UNION中的第二个和随后的SELECT被标记为UNION，若UNION被FROM子句中的子查询包含，第一个SELECT会被标记为DERIVED</p></li><li><p>UNION RESULT<br>UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT</p></li></ul><p>SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。DEPENDENT意味着SELECT依赖于外层查询中发现的数据；UNCACHEABLE意味着SELECT中的某些特性阻止结果被缓存于一个Item_cache中。（Item_cache未被文档记载；不是查询缓存，可被一些相同的构件否定，例如RAND()函数。）</p><h4 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h4><p>显示对应行正在访问哪个表，为表或表的别名（若SQL中定义）。</p><p>用于观察MySQL的关联优化器为查询选择的关联顺序。</p><blockquote><p>MySQL的查询执行计划总是左侧深度优先树。</p></blockquote><p>当FROM子句中有UNION时，table列会变得复杂。在FROM子句中有子查询时，table列是形式，N是子查询的id，指向EXPLAIN输出中的后面的一行。有UNION时，UNION RESULT的table列包含一个参入UNION的id列表。</p><h4 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h4><p>显示访问类型——MySQL决定如何查找表中的行。</p><p>访问方法，从最差到最优：</p><ul><li>ALL<br>全表扫描，扫描整张表去找需要的行。（若查询中使用了LIMIT或者Extra列中显示“Using distinct/not exists”则不是）</li><li>index<br>与全表扫描一样，区别于MySQL扫描表时按索引次序进行而不是行。避免了排序，但是需要承担按索引次序读取整个表的开销。意味着若按随机次序访问，开销会很大。若Extra列为“Using index”表示MySQL使用覆盖索引，只扫描索引的数据，不按索引次序的每一行，比按索引次序全表扫描的开销小很多。</li><li>range<br>范围扫描实际上是有限制的索引扫描，开始于索引里的某一点，返回匹配这个域的行，开销跟索引类型相当。是带有BETWEEN或在WHERE子句里带有&gt;的查询。<br>当MySQL使用索引去查找一系列值时，如In()和OR列表，也会显示为范围扫描。两者其实为不同的访问类型，性能上有重要的差异。</li><li>ref<br>索引访问（索引查找），返回所有匹配某个单个值的行。查找和扫描的混合体。只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。索引要跟某个参考值相比较，参考值或者是一个常数、或者是来自多表查询前一个表里的结果值。ref_or_null是ref之上的一个变体，意味着MySQL必须在初次查找的结果里进行第二次查找以找出NULL条目。</li><li>eq_ref<br>索引查找，MySQL最多只返回一条符合条件的记录。在MySQL使用主键或者唯一性索引查找时出现，将它们与某个参考值做比较。</li><li>const，system<br>MySQL对查询的某部分进行优化并将其转换成一个常量时出现。</li><li>NULL<br>意味着MySQL能在优化阶段分解查询语句，在执行阶段用不着再访问表或者索引。</li></ul><h4 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h4><p>显示查询可以使用哪些索引，基于查询访问的列和使用的比较操作符来判断。</p><h4 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h4><p>显示MySQL决定采用哪个索引来优化对该表的访问。若该索引未出现在possible_keys列中，则MySQL选用它是出于另外的原因——如即使没有where子句却选择覆盖索引。</p><p>possible_keys显示哪一个索引能有助于高效地进行查找，key显示优化采用哪一个索引可以最小化查询成本。</p><h4 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h4><p>显示MySQL在索引里使用的字节数。通过查找表的定义而被计算出，而不是表中的数据。</p><h4 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h4><p>显示之前的表在key列记录的索引中查找值所用的列或常量。</p><h4 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h4><p>MySQL估计为了找到所需的行而要读取的行数。内嵌循环关联计划里的循环数目，不是MySQL认为它最终要从表里读取出来的行数，而是MySQL为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。是MySQL认为它要检查的行数，而不是结果集合里的行数。</p><h4 id="filtered列"><a href="#filtered列" class="headerlink" title="filtered列"></a>filtered列</h4><p>使用EXPLAIN EXTENDED时出现，显示针对表里符合某个条件（WHERE子句或联接条件）的记录数的百分比所做的一个悲观估算。将rows列乘此值，为MySQL估算它将和查询计划里前一个表关联的行数。</p><h4 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h4><p>包含不适合在其他列显示的额外信息。</p><p>常见的最重要的值有；</p><ul><li>“Using index”<br>表示MySQL将使用覆盖索引，以避免访问表。</li><li>“Using where”<br>意味着MySQL服务器将在存储引擎检索行后再进行过滤。有时代表着查询可受益于不同的索引。</li><li>“Using temporary”<br>意味着MySQL在对查询结果排序时会使用一个临时表。</li><li>“Using filesort”<br>意味着MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。有两种文件排序算法，两种方式都可在内存或磁盘上完成，不会显示将会使用哪一种文件排序，也不会显示是在内存里还是磁盘上完成。</li><li>“Range checked for each record（index map：N）”<br>意味着没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_key列中索引的位图，并且是冗余的。</li></ul><h3 id="MySQL-5-6中的改进"><a href="#MySQL-5-6中的改进" class="headerlink" title="MySQL 5.6中的改进"></a>MySQL 5.6中的改进</h3><p>能对类似UPDATE、INSERT等查询进行解释。</p><p>对查询优化和执行引擎的改进，允许临时表尽可能晚地被具体化，而不总是在优化和执行使用到此临时表的部分查询时创建并填充它们。允许MySQL可以直接解释带子查询的查询语句，而不需要先实际地执行子查询。</p><p>通过在服务器中增加优化跟踪功能的方式改进优化器的相关部分。允许用户查看优化器做出选择，以及输入和抉择的原因。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> explain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git命令</title>
      <link href="/2018/08/01/git%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/01/git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一些不常用到或者易遗忘的git命令。</p><hr><p>参考：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Book</a></p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>参考：Book</p><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --short</span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>通过文件补丁的格式显示具体哪些行发生了改变:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h4 id="查看已暂存的将要添加到下次提交里的内容"><a href="#查看已暂存的将要添加到下次提交里的内容" class="headerlink" title="查看已暂存的将要添加到下次提交里的内容:"></a>查看已暂存的将要添加到下次提交里的内容:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &apos;description message&apos;</span><br></pre></td></tr></table></figure><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>从已跟踪文件清单中移除（确切地说，是从暂存区域移除，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br></pre></td></tr></table></figure><p>若删除之前修改过并且已经放到暂存区域，用强制删除选项 -f（译注：即 force 的首字母）,不能被 Git 恢复.</p><p>让文件保留在磁盘，不让 Git 继续跟踪:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>在 Git 中对文件改名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv filename new_filename</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv filename new_filename</span><br><span class="line">git rm filename</span><br><span class="line">git add new_filename</span><br></pre></td></tr></table></figure><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>回顾下提交历史:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>不用任何参数，按提交时间列出所有的更新，最近的更新排在最上面。加参数-p，用来显示每次提交的内容差异，加上-2来仅显示最近两次提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure><p>使用–stat参数查看每次提交的简略的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>参数–pretty指定使用不同于默认格式的方式展示提交历史，有一些内建的子选项供使用。如参数oneline将每个提交放在一行显示，参数format定制要显示的记录格式，还有short，full和fuller可用，展示的信息或多或少有些不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure><p>format<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rpretty_format" target="_blank" rel="noopener">常用的选项</a>。</p><p>oneline或format与log选项–graph结合使用,添加一些ASCII字符串来形象地展示分支、合并历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h %s&quot; --graph</span><br></pre></td></tr></table></figure><p>git log<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlog_options" target="_blank" rel="noopener">常用选项</a></p><p>–since和–until按照时间作限制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure><p>限制git log<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlimit_options" target="_blank" rel="noopener">输出的选项</a></p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>尝试重新提交，覆盖上一次的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>将文件还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>实际上是拷贝了另一个文件来覆盖。</p><blockquote><p>Git中任何已提交的东西几乎总是可以恢复的，任何未提交的东西丢失后很可能无法恢复。</p></blockquote><h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>运行<code>git remote</code>命令，列出指定的每一个远程服务器的简写。<br>指定选项 -v，显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个可以轻松引用的简写。</p><p>运行<code>git fetch shortname</code>拉取url所指仓库中有但自己没有的信息。</p><h4 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>若有一个分支设置为跟踪一个远程分支，使用<code>git pull</code>命令来自动的抓取然后合并远程分支到当前分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p><code>git push [remote-name] [branch-name]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p><code>git remote show [remote-name]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p><code>git remote rename</code>修改远程仓库的简写名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename oldshortname newshortname</span><br></pre></td></tr></table></figure><p>git remote rm移除一个远程仓库.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm shortname</span><br></pre></td></tr></table></figure><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>给历史中的某一个提交打上标签，以示重要。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p><code>git tag</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &apos;v1.8.5*&apos;</span><br></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>运行 tag 命令时指定 -a 选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a tagname -m &apos;description in tag&apos;</span><br></pre></td></tr></table></figure><p>-m 选项指定了一条将会存储在标签中的信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag tagname</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看提交日志</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">//使用显示的校验打标签</span><br><span class="line">git tag -a tagname  部分或完整校验和</span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行<code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin tagname</span><br></pre></td></tr></table></figure><p>一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>使用<code>git checkout -b [branchname] [tagname]</code>在特定的标签上创建一个新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newbranchshartname tagname.</span><br></pre></td></tr></table></figure><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>通过git config文件为命令设置别名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p><code>git branch</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch branchname</span><br></pre></td></tr></table></figure><p><code>git log --oneline --decorate</code>查看各个分支当前所指的对象</p><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p><code>git checkout</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout branchname</span><br></pre></td></tr></table></figure><p><code>git log --oneline --decorate --graph --all</code>查看分叉历史</p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>基于master的紧急分支的创建、合并、删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b iss53</span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br><span class="line">git branch -d hotfix</span><br><span class="line">git checkout iss53</span><br><span class="line">git checkout master</span><br><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>在两个分支中对同一个文件的同一个部分进行了不同的更改，Git没法干净的合并</p><p>使用<code>git status</code>命令查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p><p>可以打开这些包含冲突的文件然后手动解决冲突</p><p>包含特殊区段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行<code>git mergetool</code>，命令启动一个合适的可视化合并工具</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>不加任何参数运行，得到当前所有分支的一个列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch</span><br><span class="line">  iss21</span><br><span class="line">* master</span><br><span class="line">  test</span><br></pre></td></tr></table></figure><p>运行<code>git branch -v</code>查看每一个分支的最后一次提交:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch -v</span><br><span class="line">  iss21  49dba1c sort</span><br><span class="line">* master 49dba1c sort</span><br><span class="line">  test   49dba1c sort</span><br></pre></td></tr></table></figure><p>运行<code>git branch --merged</code>查看哪些分支已经合并到当前分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:algorithm wuhua$ git branch --merged</span><br><span class="line">  iss21</span><br><span class="line">* master</span><br><span class="line">  test</span><br></pre></td></tr></table></figure><p>运行<code>git branch --no-merged</code>查看所有包含未合并工作的分支:</p><p>使用<code>git branch -d</code>命令删除还未合并的分支会失败。</p><h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>只在master分支上保留完全稳定的代码，在名为develop或者next的平行分支上做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入master分支了。</p><h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>特性分支是一种短期分支，它被用来实现单一特性或其相关工作，在合并完成后即可被删除。例如bug的修改，功能的新增等。</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。</p><p>通过<code>git ls-remote (remote)</code>显式地获得远程引用的完整列表，通过<code>git remote show (remote)</code>获得远程分支的更多信息。 更常见利用远程跟踪分支。远程跟踪分支是远程分支状态的引用。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。以<code>(remote)/(branch)</code>形式命名。</p><blockquote><p>“origin” 并无特殊含义。远程仓库名字“origin”与分支名字“master”一样，在Git中并没有任何特别的含义一样。 同时“master”是运行<code>git init</code>时默认的起始分支名字，原因仅仅是它的广泛使用，“origin”是当运行<code>git clone</code>时默认的远程仓库名字。如果运行<code>git clone -o booyah</code>，则默认的远程分支名字将会是<code>booyah/master</code>。</p></blockquote><p>运行<code>git fetch origin</code>命令，查找 “origin” 是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动<code>origin/master</code>指针指向新的、更新后的位置。</p><p>运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目。</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>运行<code>git push (remote) (branch)</code>推送到分支。</p><p>抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝），即不会有一个新的brach分支 - 只有一个不可以修改的<code>origin/branch</code>指针。</p><p>运行<code>git merge origin/serverfix</code>将工作合并到当前所在的分支。</p><p>运行<code>git checkout -b branch origin/branch</code>将自己的分支建立在远程跟踪分支之上，及本地新建本地分支branch并且起点位于<code>origin/serverfix</code>。</p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>克隆一个仓库通常会自动地创建一个跟踪<code>origin/master</code>的master分支。运行<code>git checkout -b [branch] [remotename]/[branch]</code>设置其他的跟踪分支。可使用<code>--track</code>快捷方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track [remotename]/[branch]</span><br></pre></td></tr></table></figure><p>使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>显式地设置已有的本地分支跟踪一个刚刚拉取下来的远程分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u [remotename]/[branch]</span><br></pre></td></tr></table></figure><p>使用<code>git branch</code>的<code>-vv</code>选项查看设置的所有跟踪分支。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p><code>git fetch</code>命令从服务器上抓取本地没有的数据，不会修改工作目录中的内容，只获取数据然后自己合并。命令<code>git pull</code>在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。若有跟踪分支，不管它是显式地设置还是通过<code>clone</code>或<code>checkout</code>命令创建，<code>git pull</code>会查找当前分支所跟踪的服务器分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>通常单独显式地使用<code>fetch</code>与<code>merge</code>命令会更好一些。</p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>运行带有<code>--delete</code>选项的<code>git push</code>命令删除一个远程分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete branchname</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>使用<code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上。原理是首先找到这两个分支（即当前分支、变基操作的目标基底分支）的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底, 最后以此将之前另存为临时文件的修改依序应用。</p><p>目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。在这种情况下，首先在自己的分支里进行开发，当开发完成时需要先将自己的代码变基到<code>origin/master</code>上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><p>使用<code>git rebase</code>命令的<code>--onto</code>选项截取分支的分支变基到其他分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master branch sonbranch</span><br></pre></td></tr></table></figure><p>取sonbranch分支，找到处于分支branch和分支的分支sonbranch的共同祖先之后的修改，然后把它们在master分支上重放一遍。之后合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge sonbranch</span><br></pre></td></tr></table></figure><p>使用<code>git rebase [basebranch] [topicbranch]</code>命令直接将特性分支变基到目标分支上。省去先切换到topicbranch分支，再对其执行变基命令的多个步骤:</p><p>使用<code>git pull --rebase</code>命令而不是直接<code>git pull</code>，或者先<code>git fetch</code>，再<code>git rebase origin/master</code>。防变基已提交造成的混乱。</p><blockquote><p>不要对在仓库外有副本的分支执行变基。只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令。</p></blockquote><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>远程版本库就是硬盘内的另一个目录。若使用用共享文件系统，可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone /opt/git/project.git</span><br><span class="line"></span><br><span class="line">git clone file:///opt/git/project.git</span><br><span class="line"></span><br><span class="line">git remote add local_proj /opt/git/project.git</span><br></pre></td></tr></table></figure><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>新版本(V1.6.6+)的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。</p><h4 id="智能（Smart）-HTTP-协议"><a href="#智能（Smart）-HTTP-协议" class="headerlink" title="智能（Smart） HTTP 协议"></a>智能（Smart） HTTP 协议</h4><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">智能（Smart） HTTP 协议</a></p><h4 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">哑（Dumb） HTTP 协议</a></p><h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SSH 协议</a></p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">Git 协议</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis基本数据结构及命令</title>
      <link href="/2018/08/01/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/01/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h3><table><thead><tr><th style="text-align:left">结构类型</th><th style="text-align:left">结构存储的值</th><th style="text-align:left">结构的读写能力</th></tr></thead><tbody><tr><td style="text-align:left">STRING</td><td style="text-align:left">字符串、整数或者浮点数</td><td style="text-align:left">对整个字符串或者字符串中的一部分执行操作；整数或浮点数自增、自减操作</td></tr><tr><td style="text-align:left">LIST</td><td style="text-align:left">链表，链表上的每个节点都包含了一个字符</td><td style="text-align:left">链表两端推入或者弹出元素；根据偏移量对链表进行修剪；读取单个或多个元素；根据指查找或着移除元素</td></tr><tr><td style="text-align:left">SET</td><td style="text-align:left">字符串的无序收集器，被包含的每个字符串都是独一无二的、各不相同的</td><td style="text-align:left">添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td style="text-align:left">HASH</td><td style="text-align:left">包含键值对的无序散列表</td><td style="text-align:left">添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td style="text-align:left">ZSET(有序集合)</td><td style="text-align:left">字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td><td style="text-align:left">添加、获取、删除单个元素；根据分值范围或者成员来获取元素</td></tr></tbody></table><h4 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h4><p>与其他编程语言或者其他键值存储提供的字符串非常相似。</p><h4 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h4><p>一个列表结构可以有序地存储多个字符串。可执行的操作与很多编程语言中的列表操作非常相似。</p><h4 id="Redis中的集合"><a href="#Redis中的集合" class="headerlink" title="Redis中的集合"></a>Redis中的集合</h4><p>存储多个字符串，不同于列表，集合使用无序方式存储元素，使用散列表保证存储的每个字符串都是不同的。</p><h4 id="Redis中的散列"><a href="#Redis中的散列" class="headerlink" title="Redis中的散列"></a>Redis中的散列</h4><p>存储多个键值对之间的映射，散列存储的值既可以是字符串也可以是数字值。类似文档数据库中的文档，关系数据库中的行，允许用户同时访问或者修改一个或多个域。</p><h4 id="Redis中的有序集合"><a href="#Redis中的有序集合" class="headerlink" title="Redis中的有序集合"></a>Redis中的有序集合</h4><p>用于存储键值对，键被称为成员，每个成员各不相同，值被称为分值，分值必须为浮点数。唯一既可以根据成员访问元素，又可以根据分值及分值的排列顺序来访问元素的结构。</p><h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Redis中的自增命令和自减命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">LNCR</td><td style="text-align:left">INCR key-name——将键存储的值加上1</td></tr><tr><td style="text-align:left">DECR</td><td style="text-align:left">DECR key-name——将键存储的值减去1</td></tr><tr><td style="text-align:left">INCRBY</td><td style="text-align:left">INCRBY key-name amount——将键存储的值加上amount</td></tr><tr><td style="text-align:left">DECRBY</td><td style="text-align:left">DECRBY key-name amount——将键存储的值减去amount</td></tr><tr><td style="text-align:left">INCRBYFLOAT</td><td style="text-align:left">INCRBYFLOAT key-name amount——将键存储的值加上浮点数amount，redis v2.6+</td></tr></tbody></table><p>存储时，若值可被解释（interpret）为十进制整数或者浮点数，则允许用户对字符串执行各种INCR*和DECR*操作。对不存在的键或者保存了空串的键执行自增或者自减操作，Redis执行操作时将键的值当作0处理。对无法解释为整数或浮点数的字符串键执行自增或自减操作，将向用户返回一个错误。</p><p>处理子串和二进制位的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">APPEND</td><td style="text-align:left">APPEND key-name value——将值value追加到给定键key-name当前存储的值的末尾</td></tr><tr><td style="text-align:left">GETRANGE</td><td style="text-align:left">GETRANGE key-name start end——获取一个由偏移量start至偏移量end范围内所有字符组成的子串，包括start和end在内。</td></tr><tr><td style="text-align:left">SETRANGE</td><td style="text-align:left">SETRANGE key-name offset value——将start偏移量开始的子串设置为给定值</td></tr><tr><td style="text-align:left">GETBIT</td><td style="text-align:left">GETBIT key-name offset——将子节串看作是二进制位串，并将位串中偏移量为offset的二进制位的值设置为value</td></tr><tr><td style="text-align:left">BITCOUNT</td><td style="text-align:left">BITCOUNT key-name [start end]——统计二进制位串里面值为1的二进制位的数量，若给定偏移量start和end，则只对偏移量指定范围内的二进制位进行统计</td></tr><tr><td style="text-align:left">BITOP</td><td style="text-align:left">BITOP operation dest-key key-name [key-name …]——对一个或多个二进制位串执行包括并（AND）、或（OR）、异或（XOR）、非（NOT）在内的任意一种按位运算操作，并将计算结果保存在dest-key键里</td></tr></tbody></table><p>使用STRANGE或者SETBIT命令对字符串进行写入的时候，若字符串当前的长度不能满足写入的要求，Redis会自动地使用空字节（null）将字符串扩展至所需的长度，然后才执行写入或者更新操作。使用GETRANGE读取字符串，超出字符串末尾的数据会被视为是空串，使用GETBIT读取二进制位串，超出字符串末尾的二进制位会被视为0。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>常用的列表命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">RPUSH</td><td style="text-align:left">RPUSH key-name value [value …]——将一个或多个值推入列表的右端</td></tr><tr><td style="text-align:left">LPUSH</td><td style="text-align:left">LPUSH key-name value [value …]——将一个或多个值推入列表的左端</td></tr><tr><td style="text-align:left">RPOP</td><td style="text-align:left">RPOP key-name——移除并返回列表最右端的元素</td></tr><tr><td style="text-align:left">LPOP</td><td style="text-align:left">LPOP key-name——移除并返回列表最左端的元素</td></tr><tr><td style="text-align:left">LINDEX</td><td style="text-align:left">LINDEX key-name offset——返回列表中偏移量为offset的元素</td></tr><tr><td style="text-align:left">LRANGE</td><td style="text-align:left">LRANGE key-name start end——返回列表从start偏移量到end偏移量范围内的所有元素，偏移量start和end的元素也会包含在被返回的元素之内</td></tr><tr><td style="text-align:left">LTRIM</td><td style="text-align:left">LTRIM ley-name start end——对列表进行修剪，只保留从start偏移量到end偏移量范围内的元素，偏移量start和end的元素也会保留</td></tr></tbody></table><p>阻塞式的列表弹出民命令以及在列表之间移动元素的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">BLPOP</td><td style="text-align:left">BLPOP key-name [key-name …] timeout——从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left">BRPOP</td><td style="text-align:left">BRPOP key-name [key-name …] timeout——从第一个非空列表中掏出位于最右端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left">RPOPLPUSH</td><td style="text-align:left">RPOPLPUSH source-key dest-key——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素</td></tr><tr><td style="text-align:left">BRPOPLPUSH</td><td style="text-align:left">BRPOPLPUSH source-key dest-key timeout——从source-key列表中弹出位于最右端的元素，然后将这个元素推入dest-key列表的最左端，并向用户返回这个元素，若source-key为空，则在timeout秒之内阻塞并等待可弹出的元素出现</td></tr></tbody></table><p>应用于消息传递、任务队列。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>以无序的方式存储多个各不相同的元素。</p><p>常用集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SADD</td><td style="text-align:left">SADD key-name item [item …]——将一个或多个元素添加到集合中，并返回被添加元素当中原本并不存在于集合里面的元素数量</td></tr><tr><td style="text-align:left">SREM</td><td style="text-align:left">SREM key-name item [item …]——从集合里面移除一个或多个元素，并返回被移除元素的数量</td></tr><tr><td style="text-align:left">SISMEMBER</td><td style="text-align:left">SISMEMBER key-name item——检查元素item是否存在于集合key-name里</td></tr><tr><td style="text-align:left">SCARD</td><td style="text-align:left">SCARD key-name——返回集合包含的元素的数量</td></tr><tr><td style="text-align:left">SMEMBERS</td><td style="text-align:left">SMEMBERS key-name——返回集合包含的所有元素</td></tr><tr><td style="text-align:left">SRANDMEMBER</td><td style="text-align:left">SRANDMEMBER key-name [count]——从集合里面随机地返回一个或多个元素。当count为正数时，命令返回的随机元素不会重复；当count为负数时，命令返回的随机元素可能会出现重复</td></tr><tr><td style="text-align:left">SPOP</td><td style="text-align:left">SPOP key-name——随机地移除集合中的一个元素，并返回被移除的元素</td></tr><tr><td style="text-align:left">SMOVE</td><td style="text-align:left">SMOVE source-key dest-key item——若集合source-key包含元素item，从集合source-key里面移除元素item，并将元素item添加到集合dest-key中；若item被成功移除，命令返回1，否则返回0</td></tr></tbody></table><p>组合和处理多个集合的redis命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SDIFF</td><td style="text-align:left">SDIFF key-name [key-name …]——返回那些存在于第一个集合、但不存在于其他集合中的元素（差集运算）</td></tr><tr><td style="text-align:left">SDIFFSTORE</td><td style="text-align:left">SDIFFSTORE dest-key key-name [key-name …]——将存在于第一个集合但并不存在于其他集合中的元素（差集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left">SINTER</td><td style="text-align:left">SINTER key-name [key-name …]——返回那些同时存在于所有集合中的元素（交集运算）</td></tr><tr><td style="text-align:left">SINTERSTORE</td><td style="text-align:left">SINTERSTORE dest-key key-name [key-name …]——将同时存在于所有集合中的元素（交集运算）存储到dest-key键里面</td></tr><tr><td style="text-align:left">SUNION</td><td style="text-align:left">SUNION key-name [key-name …]——返回至少存在于一个集合中的元素（并集运算）</td></tr><tr><td style="text-align:left">SUNIONSTORE</td><td style="text-align:left">SUNIONSTORE desk-key key-name [key-name …]——将至少存在于一个集合中的元素（并集运算）存储到dest-key键里面</td></tr></tbody></table><h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><p>适用于将一些相关的数据存储在一起。</p><p>添加和删除键值对的散列操作：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">HMGET</td><td style="text-align:left">HMGET key-name key [key …]——从散列里面获取一个或多个键的值</td></tr><tr><td style="text-align:left">HMSET</td><td style="text-align:left">HMSET key-name key value [key value …]——为散列里面的一个或多个键设置值</td></tr><tr><td style="text-align:left">HDEL</td><td style="text-align:left">HDEL key-name key [key …]——删除散列里面的一个或多个键值对，返回成功找到并删除的键值对的数量</td></tr><tr><td style="text-align:left">HLEN</td><td style="text-align:left">HLEN key-name——返回散列包含的键值对的数量</td></tr></tbody></table><p>散列的批量操作命令以及和字符串操作类似的散列命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">HEXISTS</td><td style="text-align:left">HEXISTS key-name key——检查给定键是否存在于散列中</td></tr><tr><td style="text-align:left">HKEYS</td><td style="text-align:left">HKEYS key-name——获取散列包含的所有键</td></tr><tr><td style="text-align:left">HVALS</td><td style="text-align:left">HVALS key-name——获取散列包含的所有值</td></tr><tr><td style="text-align:left">HGETALL</td><td style="text-align:left">HGETALL key-name——获取散列包含的所有键值对</td></tr><tr><td style="text-align:left">HINCRBY</td><td style="text-align:left">HINCRBY key-name key increment——将键key存储的值加上整数increment</td></tr><tr><td style="text-align:left">HINCRBYFLOAT</td><td style="text-align:left">HINCRBYFLOAT key-name key increment——将键key存储的值加上浮点数increment</td></tr></tbody></table><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>存储着成员与分值之间的映射，提供了分值处理命令，分值在Redis中以IEEE 175双精度浮点数的格式存储。</p><p>常用的有序集合命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">ZADD</td><td style="text-align:left">ZADD key-name score member [score member …]——将带有给定分值的成员添加到有序集合里面</td></tr><tr><td style="text-align:left">ZREM</td><td style="text-align:left">ZREM key-name member [member …]——从有序集合里面移除给定的成员，并返回被移除成员的数量</td></tr><tr><td style="text-align:left">ZCARD</td><td style="text-align:left">ZCARD key-name——返回有序集合包含的成员数量</td></tr><tr><td style="text-align:left">ZINCRBY</td><td style="text-align:left">ZINCRBY key-name increment member——将member成员的分值加上increment</td></tr><tr><td style="text-align:left">ZCOUNT</td><td style="text-align:left">ZCOUNT key-name min max——返回分值介于min和max之间的成员数量</td></tr><tr><td style="text-align:left">ZRANK</td><td style="text-align:left">ZRANK key-name member——返回成员member在有序集合中的排名</td></tr><tr><td style="text-align:left">ZSCORE</td><td style="text-align:left">ZSCORE key-name member——返回成员memebr的分值</td></tr><tr><td style="text-align:left">ZRANGE</td><td style="text-align:left">ZRANGE key-name start stop [WITHSCORES]——返回有序集合中排名介于start和stop之间的成员，若给定了可选的WITHSCORES选项，则命令会将成员的分值一并返回</td></tr></tbody></table><p>有序集合的范围型数据获取命令和范围型数据删除命令、并集命令、交集命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">ZREVRANK</td><td style="text-align:left">ZREVRANK key-name member——返回有序集合里成员member的排名，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left">ZREVRANGE</td><td style="text-align:left">ZREVRANGE key-name start stop [WITHSCORES]——返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td></tr><tr><td style="text-align:left">ZRANGEBYSCORE</td><td style="text-align:left">ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]——返回有序集合中，分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left">ZREVRANGEBYSCORE</td><td style="text-align:left">ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]——获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返回它们</td></tr><tr><td style="text-align:left">ZREMRANGEBYRANK</td><td style="text-align:left">ZREMRANGEBYRANK key-name start stop——移除有序集合中排名介于start和stop之间的所有所有成员</td></tr><tr><td style="text-align:left">ZREMRANGEBYSCORE</td><td style="text-align:left">ZREMRANGEBYSCORE key-name min max——移除有序集合中分值介于min和max之间的所有成员</td></tr><tr><td style="text-align:left">ZINTERSTORE</td><td style="text-align:left">ZINTERSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的交集运算</td></tr><tr><td style="text-align:left">ZUNIONSTORE</td><td style="text-align:left">ZUNIONSTORE dest-key key-count key [key …][WEIGHTS weight [weight …]][AGGREGATE SUM &#124; MIN &#124; MAX]——对给定的有序集合执行类似于集合的并集运算</td></tr></tbody></table><h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><p>发布与订阅（pub/sub）是订阅者（listener）负责订阅频道（channel），发送者（publisher）负责向频道发送二进制字符串消息。当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。</p><p>发布与订阅命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SUBSCRIBE</td><td style="text-align:left">SUBSCRIBE channel [channel …]——订阅给定的一个或多个频道</td></tr><tr><td style="text-align:left">UNSUBSCRIBE</td><td style="text-align:left">UNSUBSCRIBE [channel [channel …]]——退订给定的一个或多个频道，若执行时没给定频道，则退订所有频道</td></tr><tr><td style="text-align:left">PUBLISH</td><td style="text-align:left">PUBLISH channel message——向给定频道发送消息</td></tr><tr><td style="text-align:left">PSUBSCRIBE</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]——订阅与给定模式相匹配的所有频道</td></tr><tr><td style="text-align:left">PUNSUBSCRIBE</td><td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]——退订给定的模式，如果执行时没有给定任何模式，则退订所有模式</td></tr></tbody></table><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>同其他编程语言的排序操作，可以根据某种比较规则对一系列元素进行有序的排列。可根据字符串、列表、集合、有序集合、散列这5种键里面存储着的数据，对列表、集合以及有序集合进行排序，相当于SQL中的order by子句。</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left">SORT</td><td style="text-align:left">SORT source-key [BY pattern][LIMIT offset count][GET pattern [GET PATTERN …]][ASC &#124; DESC][ALPHA][STORE dest-key]——根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</td></tr></tbody></table><p>可实现的功能：根据降序而不是默认的升序来排序元素；将元素看作是数字来进行排序，或则将元素看作是数字来进行排序，或者将元素看作是二进制字符串来进行排序；使用被排序元素之外的其他值作为权重来进行排序，可从输入的列表、集合、有序集合以外的其他地方进行取值。</p><p>对集合进行排序返回一个列表形式的排序结果。</p><h5 id="基本的Redis事务"><a href="#基本的Redis事务" class="headerlink" title="基本的Redis事务"></a>基本的Redis事务</h5><p>让用户在不被打断的情况下对多个键执行操作：WATCH、MULTI、EXEC、UNWATCH和DISCARD。</p><p>基本事务（basic transaction）使用MULTI命令和EXEC命令，让一个客户端在不被其他客户端打断的情况下执行多个命令。被MULTI命令和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。事务执行后，Redis才会处理其他客户端的命令。</p><p>Redis接收到MULTI命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送EXEC命令为止，接着Redis在不被打断的情况下，一个接一个地执行存储在队列里面的命令。</p><p>使用WATCH命令对键进行监视之后，直到用户执行EXEC命令的这段时间里，如果有其他客户端抢先对键进行了替换、更新或删除等操作，当用户尝试执行EXEC命令时，事务将失败并返回一个错误。UNWATCH命令可以在WATCH命令执行以后、MULTI命令执行之前对连接进行重置；DISCARD命令在MULTI命令执行之后、EXEC命令执行之前对连接进行重置。即在用户使用WATCH监视一个或多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已入队命令。</p><h5 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h5><p>指Redis会在键的过期时间到达时自动删除该键。</p><p>为键设置过期时间的命令：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">示例和描述</th></tr></thead><tbody><tr><td style="text-align:left">PERSIST</td><td style="text-align:left">PERSIST key-name——移除键的过期时间</td></tr><tr><td style="text-align:left">TTL</td><td style="text-align:left">TTL key-name——查看给定键距离过期还有多少秒</td></tr><tr><td style="text-align:left">EXPIRE</td><td style="text-align:left">EXPIRE key-name seconds——让给定键在指定的秒数之后过期</td></tr><tr><td style="text-align:left">EXPIREAT</td><td style="text-align:left">EXPIREAT key-name timestamp——将给定键的过期时间设置为给定的UNIX时间戳</td></tr><tr><td style="text-align:left">PTTL</td><td style="text-align:left">PTTL key-name——查看给定键距离过期时间还有多少毫秒，Redis V2.6+</td></tr><tr><td style="text-align:left">PEXPIRE</td><td style="text-align:left">PEXPIRE key-name milliseconds——让给定键在指定的毫秒数之后过期，Redis V2.6+</td></tr><tr><td style="text-align:left">PEXPIREAT</td><td style="text-align:left">PEXPIREAT key-name timestamp-milliseconds——将一个毫秒级精度的UNIX时间戳设置为给定键的过期时间，Redis V2.6+</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引及优化</title>
      <link href="/2018/07/30/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/30/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>参考文档 ：《高性能MySQL》</p><p>其他：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程</a>. <a href="https://www.cnblogs.com/whgk/p/6179612.html" target="_blank" rel="noopener">MySQL中的索引详讲</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构。——《高性能MySql-创建高性能的索引》</p></blockquote><blockquote><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p></blockquote><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>创建索引时，需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>索引是在存储引擎层而不是服务器层实现的，没有统一的索引标准，多半为B-Tree索引。B-Tree索引适用于全键值、键值范围或键前缀查找，键前缀查找只适用于根据最左前缀的查找。索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p><p>三星策略：索引将相关的记录放在一起为一星，索引中的数据顺序与查找中的排列顺序一致为二星，索引中的列包含了查询中需要的全部列为三星。</p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><p>修改表结构(添加索引):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>删除索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><p>创建索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure><p>修改表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">*ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</span><br><span class="line">*ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。</span><br><span class="line">*ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure><p>待阅读了解：<a href="https://www.cnblogs.com/yank/p/4193820.html" target="_blank" rel="noopener"><code>触发器</code></a>。</p><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>参考博文：<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>、<a href="https://www.cnblogs.com/mysql-dba/p/6689597.html" target="_blank" rel="noopener">深入浅出分析MySQL索引设计背后的数据结构</a></p><p>上方博文主要讲解了mysql使用b+tree作为索引结构，但innoDB和MyISAM的具体实现方式也是不同的。</p><p>在mysql中还有以基于哈希表实现的哈希索引，只有Memory引擎显示支持哈希索引。</p><p>InnoDB引擎有个特殊功能“自适应哈希索引”，当InnoDB注意到某些索引值被使用得非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引。是完全自动的，内部的行为。</p><p>InnoDB中必须包含AUTO_INCREMENT类型字段的索引（建议做主键），MyISAM不需要。</p><h4 id="索引利用"><a href="#索引利用" class="headerlink" title="索引利用"></a>索引利用</h4><p>参考博文：<a href="https://www.cnblogs.com/gossip/p/5707528.html" target="_blank" rel="noopener">索引的特点及使用</a></p><p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。包含多个列，列的顺序也十分重要，MySql只能高效的使用索引的最左前缀列。</p><p>MyISAM表支持空间索引，用作地理空间数据存储。无须前缀查询，会从所有维度来索引数据。详细省略。</p><p>在相同的列上创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p><p>索引优点：</p><ul><li>减少了服务器需要扫描的数据量。</li><li>帮助服务器避免排序和临时表（ORDER BY和GROUP BY操作）。</li><li>将随机IO变为顺序IO。</li></ul><blockquote><p>非常小的表，简单的全表扫描更高效。索引适用中到大型的表，特大型的表，建立和使用索引的代价随之增长（使用分区技术）。</p></blockquote><blockquote><p>创建自定义哈希索引：适用于类似存储大量url的场景，因url本身很长，使用B-Tree进行查找存储的内容会很大，在数据表中新增被索引url_crc列，存储url的哈希结果（使用CRC32做哈希），在where子句中手动指定哈希函数进行查找。不建议使用SHA1()和MD5()作为哈希函数，因哈希值过长浪费空间，比较时慢。</p></blockquote><h4 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h4><ul><li>独立的列：索引列不能是表达式的一部分，也不能是函数的参数。始终将索引列单独放在比较符号的一侧。</li><li>前缀索引和索引选择性：除模拟哈希索引，可以索引开始的部分字符，节约索引空间，提高索引效率。索引选择性指不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高。<code>mysql无法使用前缀索引做ORDER BY和GROUP BY，无法使用前缀索引做覆盖扫描。</code>可考虑字符串反转后建立前缀索引实现后缀索引，通过触发器维护这种索引。</li><li>多列索引：若没建多列索引有单列索引，5.0以上版本会将查询条件中的每列单独索引进行扫描，并将结果进行合并，这种策略会导致消耗更多的CPU和内存资源。可以通过参数optimizer_switch关闭索引合并功能，使用IGNORE INDEX提示让优化器忽略掉某些索引。</li><li>选择合适的索引列排序：索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。正确的顺序依赖于使用该索引的查询，索引可以按照升序或者降序进行扫描，已满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询需求。将选择性最高的列放到索引最前列利于where条件的查找，注意特殊情况的对待。</li><li>聚簇索引：InnoDB通过主键聚簇数据，没定义主键将选择一个唯一的非空索引替代，若无，会隐式定义一个主键来作为聚簇索引。聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。一般使用自增列作为聚簇索引，避免随机聚簇索引，特别是对于I/O密集型应用。对于高并发场景，自增列会造成明显的争用，主键的上届会成为“热点”，导致间隙锁竞争。</li><li>覆盖索引：包含所有需要查询的字段的值，索引的叶子结点中已经包含要查询的数据，查询只需扫描索引无需回表。覆盖索引必须要存储索引列的值，使用B-Tree索引做覆盖索引。</li><li>使用索引扫描来做排序：使用同一个索引既满足排序又用于查找行，只有当索引的列顺序和ORDER BY字句顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySql才能够使用索引来对结果做排序。若查询需要关联多张表，只有当ORDER BY字句引用的字段全部为第一个表时，才能使用索引做排序。</li><li>压缩（前缀压缩）索引：MyISAM使用前缀压缩减少索引的大小，让更多的内存可以放入到内存中。默认只压缩字符串，通过参数设置也可以对整数做压缩。MyISAM查找时无法在索引快使用二分查找只能从头开始扫描。对于CPU密集型应用，压缩索引使得MyISAM在索引查找上要慢好几倍。压缩索引需要在CPU内存资源与磁盘之间做权衡。</li><li>冗余和重复索引：指在相同的列上，按照相同的顺序创建的相同类型的索引。MySql需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个进行考虑，影响性能。应避免创建重复索引。冗余索引不同于重复索引，若创建了索引（A,B）再创建索引（A）就属于冗余索引，索引（A,B）可以被当做索引(A)来使用。冗余索引通常发生在为表添加新索引的时候，应尽量拓展已有的索引而不是创建新索引。有时处于性能的考虑需要冗余索引，因拓展已有的索引导致其变得太大，从而影响其他使用该索引的查询的性能。</li><li>未使用的索引：若对数据约束及查询无意义，应该删除。</li><li>索引和锁：InnoDB访问行加锁，当其在存储引擎层能够过滤掉所有不需要的行时，索引减少InnoDB访问行的次数，减少锁的数量，5.1+V在服务器端过滤掉行后就释放锁。InnoDB在二级索引上使用共享（读）锁，访问主键索引需要排他（写）锁。</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><h5 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h5><p>count()可统计某列值的数量（不统计NULL），也可以统计行数（通配符*忽略所有的列而直接统计所有的行数）。</p><p>使用MyISAM在COUNT(*)非常快的特性优化查询，替代SUM()等。</p><h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul><li>确保ON或者USING子句中的列上有索引，创建索引时考虑关联的顺序，一般只需在关联顺序中的第二个表的相应列上创建索引。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，使MySQL有可能使用索引来优化这个过程。</li><li>升级MySQL时注意关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul><h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><p>旧版本仅可能使用关联查询代替。若使用MySQL V5.6+或MariaDB，不必在意。</p><h5 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h5><p>MySQL很多场景下使用同样的的方法优化这两种查询，在内部处理时会互相转化这两类查询，使用索引优化。</p><p>当无法使用索引时，GROUP BY使用两种策略：使用临时表或者文件排序来做分组。</p><p>使用GROUP BY WITH ROLLUP对返回的分组结果再做一次超级聚合，通过EXPLAIN观察其执行计划，注意分组是否通过文件排序或者临时表实现，然后去掉WITH ROLLUP子句查看执行计划是否相同。最好的办法是尽可能的将WITH ROLLUP功能转移到应用程序中处理。</p><h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><p>针对分页查询LIMIT(1000, 20)，在页面中限制分页的数量，或优化大便宜量的性能。</p><p>尽可能地使用索引覆盖扫描，而不是查询所有的列。<br>将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得结果。<br>使用书签记录上次取数据的位置，下次从书签记录的位置开始扫描，避免使用offset。</p><h5 id="优化SQL-CALC-FOUND-ROWS"><a href="#优化SQL-CALC-FOUND-ROWS" class="headerlink" title="优化SQL_CALC_FOUND_ROWS"></a>优化SQL_CALC_FOUND_ROWS</h5><p>在分页的LIMIT语句中加上此参量提示，可以获取去掉LIMIT以后满足条件的行数，作为分页的总数。代价大。</p><h5 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h5><p>MySQL总是通过创建并填充临时表的方式来执行UNION查询，使得优化策略在UNION查询中无法得到很好的使用。需要手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用条件进行优化。</p><p>除非需要服务器消除重复的行，否则要使用UNION ALL，若无ALL关键字，MySQL会给临时表加上DISTINCT选型，导致对整个临时表的数据做唯一性检查。有ALL关键字，MySQL仍会使用临时表存储结果。</p><blockquote><p>事实上，MySQL总会将结果放入临时表，然后再读出，再返回给客户端。</p></blockquote><h5 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h5><p>Percona Toolkit中的pt-query-advisor。</p><h5 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h5><p>用户自定义变量是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用SET和SELECT语句来定义它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @id := 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = @id;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不能使用自定义变量场景：</p><ul><li>使用自定义变量的查询无法使用查询缓存。</li><li>不能在使用常量或标识符的地方使用自定义常量，如表名、列名和LIMIT子句中。</li><li>不能用做连接间的通信，其生命周期仅在一个连接中。</li><li>在连接池或者持久化连接中，自定义变量可能使代码间发生交互。</li><li>在不同版本间的兼容问题。</li><li>不能显示的声明自定义变量的类型。</li><li>优化器在某些场景下会将这些变量优化掉。</li><li>赋值的顺序和时间点不固定。</li><li>赋值符号:=的优先级非常低，赋值表达式应该使用明确的括号。</li><li>使用未定义的变量不会产生任何语法错误。</li></ul><p>使用：</p><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大量数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变为0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。</li></ul><h4 id="MySQL查询优化器能够处理的优化类型"><a href="#MySQL查询优化器能够处理的优化类型" class="headerlink" title="MySQL查询优化器能够处理的优化类型"></a>MySQL查询优化器能够处理的优化类型</h4><ul><li>重新定义关联表的顺序</li><li>将外链接转化为内链接</li><li>使用等价变换规则</li><li>优化COUNT()、MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul><h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h4><p>大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。</p><h5 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h5><p>查询请求超过实际需要，然后被丢弃，会给MySQL服务器带来额外的负担，增加网络开销，消耗服务器的CPU和内存资源。</p><p>示例：</p><ul><li>查询不需要的记录。</li><li>多表关联时返回全部列。</li><li>总是取出全部列。</li><li>重复查询相同的数据。</li></ul><h5 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h5><p>衡量查询开销的指标：</p><ul><li>响应时间。</li><li>扫描的行数。</li><li>返回的行数。  </li></ul><p>响应时间：服务时间与排队时间的和。</p><p>扫描行数和返回的行数：理想情况下扫描的行数和返回的行数应该是相同的，通常扫/返在1:1到10:1之间，也可能非常大。</p><p>扫描的行数和访问类型：EXPLAIN语句中的type列反应了访问类型，全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度由慢到快，扫描行数由小到大，对应着扫描表、扫描索引、范围访问和单直访问。没办法找到合适的访问类型，增加合适的索引能以最高效、扫描行数最少的方式找到需要的记录。</p><p>MySQL应用where条件的三种方式，由好到坏为：</p><ul><li>索引中使用where条件过滤不匹配的记录。存储引擎层完成。</li><li>使用索引覆盖扫描（Extra列出现Using Index）返回记录。直接从索引中过滤不需要的记录并返回命中结果，在MySQL服务器层完成，无需回表查询。</li><li>从数据表中返回记录，过滤不满足条件的记录（Extra列出现Using Where）。Mysql服务器层完成，MySQL从数据表中读出记录然后过滤。</li></ul><p>优化方式：</p><ul><li>使用索引覆盖扫描，把所有需要用到的列都放到索引中。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul><h4 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h4><h5 id="复杂查询和多个简单查询的选取"><a href="#复杂查询和多个简单查询的选取" class="headerlink" title="复杂查询和多个简单查询的选取"></a>复杂查询和多个简单查询的选取</h5><p>需要根据具体的情景考虑选取。</p><p>切分查询：将大查询切分为小查询，每个查询功能完全一样，只完成一小部分。</p><p>分解关联查询：对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。可以让缓存的效率更高、减少锁的竞争、利于高性能和可拓展、提升查询本身效率、减少冗余记录的查询等。</p><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>文件系统中，MySql将每个数据库（schema）保存为数据目录下的一个子目录，创建表时，MySql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义，大小写敏感和具体平台相关，windows下不敏感，类Unix中敏感。不同的存储引擎保存数据和索引的方式时不同的，表的定义在MySql服务层统一处理。</p><p>使用<code>show table status [like &#39;tablename&#39;]\G</code>显示表的相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: migrations</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 3</span><br><span class="line"> Avg_row_length: 5461</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 52</span><br><span class="line">    Create_time: 2018-07-19 17:15:56</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_unicode_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: </span><br><span class="line">No query specified</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>InnoDB是MySql的默认事务型引擎，被设计用来处理大量的短期（short-lived），大部分能正常提交，很少会被回滚。除有非常特别的原因需要使用其他存储引擎，应该优先考虑InnoDB引擎。</p><p>InnoDB的数据存储在表空间（tablespace）中，是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。采用MVCC支持高并发，默认REPEATABLE READ（可重复读）隔离级别，通过间隙锁（next-key locking）策略防止幻读。</p><p>基于聚簇索引建立，索引结构不同于其他存储引擎，聚簇索引对主键查询有很高的性能。聚簇索引的二级索引（secondary index，非主键索引）中必须包含主列键，若表上索引较多，应保证主键尽可能的小，防止二级索引变得很大。</p><p>InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。</p><p>其内部做了很多优化，如从磁盘读取数据时采用可预测性预读，自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index）；加速插入操作的插入缓冲区。</p><p>InnoDB通过一些机制和工具支持真正的热备份，如Oracle提供的MySQL Enterprise Backup、Percona提供的开源的XtraBackup。MySQL其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，在读写混合场景中，停止写入可能也意味着停止读取。<br>其他博客：<a href="http://www.cnblogs.com/Aiapple/p/5689634.html" target="_blank" rel="noopener">innodb存储引擎</a></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组原子性的SQL查询，或者说一个独立的工作单元。——《高性能MySQL》</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>A:atomicity，原子性，一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中的一部分操作。</li><li>C:consistency，一致性，数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li><li>I:isolation，隔离性，通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。</li><li>D:durability，持久性，一旦事务提交，其所做的修改就会永久保存到数据库中。</li></ul><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><ul><li>READ UNCOMMITED（未提交读）：事务可以读取未提交的数据，产生脏读。</li><li>READ COMMITED（提交读）：事务开始到提交，所做的修改对其他事务不可见。不可重复读，两次执行同样的查询，可能会得到不一样的结果。</li><li>REPEATABLE READ（可重复读）：mysql的默认事务隔离级别，解决脏读问题，InnoDB通过多版本并发控制解决幻读问题，保证在同一个事务中多次读取同样记录的结果是一致的。</li><li>SERIALIZABLE（可串行化）：最高级别隔离，强制事务串行执行，避免幻读。会在读取的每一行数据上加锁，导致大量的超时和锁争用问题。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个事务在同一资源上互相占用，请求锁定对方占用的资源，导致恶性循环。InnoDB将持有最少行级排他锁的事务进行回滚。</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>提高事务效率，修改表的数据时只需修改其内存拷贝，再把该修改行为持久在硬盘上的事务日志中，不用每次都将修改的数据本身持久到硬盘。事务日志持久后，内存中被修改的数据可以慢慢地刷回到磁盘。事务日志采用追加的方式，写日志的操作是磁盘上一小块区域内的顺序I/O。被称为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p><blockquote><p>存储引擎可在重启时，根据事务日志自动恢复上次没能写回磁盘被修改的数据。</p></blockquote><h4 id="MySql中的事务"><a href="#MySql中的事务" class="headerlink" title="MySql中的事务"></a>MySql中的事务</h4><p>提供了两种事务型的存储引擎：InnoDB和NDB Cluster。</p><p>自动提交（AUTOCOMMIT）：若不是显示的开始一个事务，每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>1或者ON表示已启用，0或OFF表示禁用。</p><p>修改AUTOCOMMIT对非事务型的表，如MyISAM和内存表，无任何影响，其无COMMIT和ROLLBACK的概念。</p><p>可以通过<code>SET TRANSACTION ISOLATION LEVEL</code>命令设置隔离级别。新的隔离级别在下一个事务开始时生效。<br>在事务中混合使用存储引擎:</p><blockquote><p>MySql服务器层不管理事务，事务由下层的存储引擎实现，在同一个事务中，使用多种存储引擎是不可靠的。<br>若事务中混合使用了事务型和非事务型的表，在事务回滚时，非事务型的表上的变更无法撤销，导致数据库处于不一致的状态，很难修复。<br>在非事务型的表上执行事务相关操作的时候，MySql通常不会发出提醒，也不会报错，只有回滚的时候才会发出一个警告，大多数情况下，不会有提示。</p></blockquote><p>隐式和显示锁定：</p><blockquote><p>InnoDB采用两阶段锁定协议（two-phase locking protocol），在事务执行过程中，随时都可以锁定，只有在COIMMIT或者ROLLBACK的时候才会释放，所有的锁在同一时刻被释放。这些锁为隐式锁，InnoDB根据隔离级别在需要的时候自动加锁。<br>InnoDB支持通过特定的语句进行显示加锁，这些语句不属于SQL规范。<br>MySql支持LOCK TABLES和UNLOCK TABLES语句，在服务器层实现，与存储引擎无关，不能替代事务。使用事务需要选择事务型存储引擎。<br><code>除事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要执行LOCK TABLES</code>，不管使用什么存储引擎。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> innodb </tag>
            
            <tag> 索引 </tag>
            
            <tag> 事务 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>laravel日志</title>
      <link href="/2018/07/27/laravel%E6%97%A5%E5%BF%97/"/>
      <url>/2018/07/27/laravel%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/logging/1374" target="_blank" rel="noopener">日志</a>。</p><p>理解</p><blockquote><p>laravel框架使用monolog记录日志，在配置文件的channels中，可自定义通道，默认选用stack通道。通道即记录日志时选择记录的方式，通道有八种可选驱动，驱动决定了日志记录的位置、信息格式等，可参考配置文件中的其他通道配置自己业务所需的通道进行日志记录。  </p></blockquote><blockquote><p>提供了八种在<a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC 5424 specification</a>中定义的日志等级。在记录时，根据调用方法对应的等级对比选用通道中规定的最低等级，使用最低等级不高于调用方法对应等级的通道记录信息。</p></blockquote><h3 id="中间件记录sql"><a href="#中间件记录sql" class="headerlink" title="中间件记录sql"></a>中间件记录sql</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/database/1397#97d96c" target="_blank" rel="noopener">监听查询事件</a>。</p><blockquote><p>在上方的文档中，larvel5.6提供的监听查询事件与之前版本的监听查询事件匿名函数的参数有不同，是个坑点。v5.6为一个参数带有sql、bindings、time属性，之前版本将这三个属性作为参数。</p></blockquote><p>sql查询事件可能发生在任何请求中，应将其作为全局中间件进行注册。事件监听应在用户请求开始就启动，使用前置中间件。</p><p>在log配置文件中定义sql通道，选用daily驱动将日志按日期进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;sql&apos; =&gt; [</span><br><span class="line">    &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">    &apos;path&apos; =&gt; storage_path(&apos;logs/sql/sql.log&apos;),</span><br><span class="line">    &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">    &apos;days&apos; =&gt; 7,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>中间件中逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    // 记录sql</span><br><span class="line">    DB::listen(function($query) &#123;</span><br><span class="line">        $sql = $query-&gt;sql;</span><br><span class="line">        $bindings = $query-&gt;bindings;</span><br><span class="line">        foreach ($bindings as $replace) &#123;</span><br><span class="line">            $value = is_numeric($replace) ? $replace : &quot;&apos;&quot; . $replace . &quot;&apos;&quot;;</span><br><span class="line">            $sql = preg_replace(&apos;/\?/&apos;, $value, $sql, 1);</span><br><span class="line">            Log::channel(&apos;sql&apos;)-&gt;info(&apos;SQL语句执行：&apos;.$sql.&apos;,耗时：&apos;.$query-&gt;time.&apos;ms&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件记录IO"><a href="#中间件记录IO" class="headerlink" title="中间件记录IO"></a>中间件记录IO</h3><p>实际记录请求和响应。</p><p>request和response所包含的API文档：<a href="https://laravel.com/api/5.6/index.html" target="_blank" rel="noopener">Laravel API</a>。</p><p>对于请求考虑记录请求url、客户端ip、请求方法、请求参数，对于响应记录响应状态码、返回字节数。</p><p>新建通道io:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;io&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">            &apos;path&apos; =&gt; storage_path(&apos;logs/io/io.log&apos;),</span><br><span class="line">            &apos;level&apos; =&gt; &apos;info&apos;,</span><br><span class="line">            &apos;days&apos; =&gt; 7,</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>中间件中调用Log记录，注意请求响记录的时期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    $data[&apos;request&apos;][&apos;url&apos;] = $request-&gt;fullUrl();</span><br><span class="line">    $data[&apos;request&apos;][&apos;ip&apos;] = $request-&gt;getClientIp();</span><br><span class="line">    $data[&apos;request&apos;][&apos;method&apos;] = $request-&gt;method();</span><br><span class="line">    $data[&apos;request&apos;][&apos;data&apos;] = $request-&gt;all();</span><br><span class="line">    $response = $next($request);</span><br><span class="line">    $data[&apos;response&apos;][&apos;status&apos;] = $response-&gt;status();</span><br><span class="line">    $data[&apos;response&apos;][&apos;contentLen&apos;] = strlen($response-&gt;content());</span><br><span class="line">    Log::channel(&apos;io&apos;)-&gt;info(serialize($data));</span><br><span class="line">    return $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录异常"><a href="#记录异常" class="headerlink" title="记录异常"></a>记录异常</h3><p>在App\Exceptions\Handler的report 方法中记录异常到日志。可在render方法中将异常消息作为response响应返回。</p><p>report function example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public function report(Exception $exception)</span><br><span class="line">   &#123;</span><br><span class="line">       $data =  $exception-&gt;getMessage().PHP_EOL;</span><br><span class="line">       $data .= &apos;file:&apos;.$exception-&gt;getFile();</span><br><span class="line">       $data .= &apos;(line&apos;.$exception-&gt;getLine().&apos;)&apos;.PHP_EOL;</span><br><span class="line">       $data .= $exception-&gt;getTraceAsString();</span><br><span class="line">       Log::channel(&apos;myLog&apos;)-&gt;error($data);</span><br><span class="line">       parent::report($exception);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>render function example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public function render($request, Exception $e)</span><br><span class="line">  &#123;</span><br><span class="line">      if ($e instanceof ModelNotFoundException) &#123;</span><br><span class="line">          $e = new NotFoundHttpException($e-&gt;getMessage(), $e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ($e instanceof ExceptionBiz) &#123;</span><br><span class="line">          $result = [</span><br><span class="line">              &apos;errcode&apos;   =&gt; $e-&gt;getCode(),</span><br><span class="line">              &apos;errmsg&apos;    =&gt; $e-&gt;getMessage(),</span><br><span class="line">              &apos;data&apos;      =&gt; [],</span><br><span class="line">          ];</span><br><span class="line">          if (!empty($e-&gt;getExtInfo())) &#123;</span><br><span class="line">              $result[&apos;data&apos;] = $e-&gt;getExtInfo();</span><br><span class="line">          &#125;</span><br><span class="line">          return response()-&gt;json($result);</span><br><span class="line">      &#125;</span><br><span class="line">      return parent::render($request, $e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>laravel定时任务</title>
      <link href="/2018/07/26/laravel%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/07/26/laravel%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="mac下laravel定时任务"><a href="#mac下laravel定时任务" class="headerlink" title="mac下laravel定时任务"></a>mac下laravel定时任务</h3><h4 id="添加Cron条目到mac（服务器）"><a href="#添加Cron条目到mac（服务器）" class="headerlink" title="添加Cron条目到mac（服务器）"></a>添加Cron条目到mac（服务器）</h4><p>文档：<a href="http://www.runoob.com/linux/linux-comm-crontab.html" target="_blank" rel="noopener">crontab</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab服务的重启关闭，开启</span><br><span class="line">sudo /usr/sbin/cron start</span><br><span class="line">sudo /usr/sbin/cron restart</span><br><span class="line">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure><p>将php artisan schedule:run 添加到crontab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>* * * * *</code>分别代表每小时中第几分钟、每天中第几小时、每月中第几日、每年中第几月、每周中第几天。<code>/usr/bin/php</code>为php执行路径（cli）。<code>/Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run</code>为项目<code>artisan</code>路径，要执行的命令。<code>&gt;&gt; /dev/null</code>表示将标准输出重定向到<code>/dev/null</code>（空设备文件）中（丢弃标准输出），<code>2&gt;&amp;1</code>将错误输出和标准输出绑定在一起，使用同一个文件描述符。</p><p>查看设置的定时任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">* * * * * /usr/bin/php /Users/wuhua/Desktop/TAL-practice/login/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h4 id="任务调度书写"><a href="#任务调度书写" class="headerlink" title="任务调度书写"></a>任务调度书写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected function schedule(Schedule $schedule)</span><br><span class="line">&#123;</span><br><span class="line">$schedule-&gt;call(function () &#123;</span><br><span class="line">            $addUserInfoIntoredis = new UserInfoController();</span><br><span class="line">           $addUserInfoIntoredis-&gt;addUsersInfo();</span><br><span class="line">        &#125;)-&gt;everyMinute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserInfoController的addUsersInfo方法中取数据库今日注册新用户添加到redis中。其中的逻辑省略。</p><h3 id="调用钉钉接口发送新用户注册通知"><a href="#调用钉钉接口发送新用户注册通知" class="headerlink" title="调用钉钉接口发送新用户注册通知"></a>调用钉钉接口发送新用户注册通知</h3><p>Guzzle文档：<a href="http://guzzle-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Guzzle中文文档</a>。</p><p>自定义钉钉机器人：<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.vcNk2y&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">自定义机器人</a>。</p><p>坑点：文档中对各种请求方式的参数未做详细说明，钉钉机器人需要以post请求发送json格式的数据，Guzzle发送请求中的第三项参数（数组）为要发送的数据，键名代表着要发送的数据的格式，键值（真正发送的数据）为发送的数据。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$client = new Client([</span><br><span class="line">            &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">        ]);</span><br><span class="line">$data = [</span><br><span class="line">       &apos;json&apos; =&gt; [</span><br><span class="line">       &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">       &apos;text&apos; =&gt; [</span><br><span class="line">              &apos;content&apos; =&gt; &apos;新注册用户：&apos;.$req-&gt;get(&apos;name&apos;).&apos;；邮箱：&apos;.$req-&gt;get(&apos;email&apos;).&apos;。&apos;,</span><br><span class="line">                ]</span><br><span class="line">       ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure><p>数据的json代表着以json格式发送数据。</p><h3 id="对发消息进行解偶"><a href="#对发消息进行解偶" class="headerlink" title="对发消息进行解偶"></a>对发消息进行解偶</h3><p>消息发送机制应该做成独立的模块，考虑使用事件和队列。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/events/1389" target="_blank" rel="noopener">事件系统</a>。</p><p>于EventServiceProvider的listen数组中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;App\Events\RegisterMsg&apos; =&gt;[</span><br><span class="line">     &apos;App\Listeners\SendRegisterMsgToRobot&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>生成事件和监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan event:generate</span><br></pre></td></tr></table></figure><p>于事件的构造函数中接收事件的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> * @var </span><br><span class="line"> */</span><br><span class="line">public $info;</span><br><span class="line">/**</span><br><span class="line"> * Create a new event instance.</span><br><span class="line"> *</span><br><span class="line"> * @return void</span><br><span class="line"> */</span><br><span class="line">public function __construct($info)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;info = $info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于监听器SendRegisterMsgToRobot的handle函数中书写业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$info = $event-&gt;info;</span><br><span class="line">$client = new Client([</span><br><span class="line">      &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">]);</span><br><span class="line">$data = [</span><br><span class="line">     &apos;json&apos; =&gt; [</span><br><span class="line">        &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">        &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from EventListener。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">               ]</span><br><span class="line">         ]</span><br><span class="line">];</span><br><span class="line">$client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br></pre></td></tr></table></figure><p>使用enent函数触发事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event(new RegisterMsg($info));</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>事件的处理过程可能会引起用户等待。加入队列中进行处理更适合场景。</p><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/queues/1395#260f10" target="_blank" rel="noopener">队列</a>。</p><p>生成任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:job SendRegisterMsg</span><br></pre></td></tr></table></figure><p>于SendRegisterMsg的handle函数中书写业务逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public function handle()</span><br><span class="line">&#123;</span><br><span class="line">    $info = $this-&gt;info;</span><br><span class="line">    $client = new Client([</span><br><span class="line">        &apos;base_uri&apos; =&gt; &apos;https://oapi.dingtalk.com/robot/send?access_token=62cad18354083b35ebf8ebcdc9dd164bb25cf9f0a96e9737f191e8a69c637924&apos;</span><br><span class="line">    ]);</span><br><span class="line">    $data = [</span><br><span class="line">        &apos;json&apos; =&gt; [</span><br><span class="line">            &apos;msgtype&apos; =&gt; &apos;text&apos;,</span><br><span class="line">            &apos;text&apos; =&gt; [</span><br><span class="line">                &apos;content&apos; =&gt; &apos;Message from job。新注册用户：&apos;.$info[&apos;name&apos;].&apos;；邮箱：&apos;.$info[&apos;email&apos;].&apos;。&apos;,</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">    $client-&gt;request(&apos;POST&apos;,&apos;&apos;,$data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendRegisterMsg::dispatch($info)</span><br></pre></td></tr></table></figure><h4 id="代码组织及结构调整"><a href="#代码组织及结构调整" class="headerlink" title="代码组织及结构调整"></a>代码组织及结构调整</h4><p>一个大型项目往往是慢慢集成的，添加的每一个模块应该在一个独立的子目录中，与原项目间互不影响。将所有代码文件添加父目录Login。</p><p>反思此消息发送，功能太单一，仅为text消息发送，而钉钉接口支持多种消息类型。若需要发送markdown、link、ActionCard、FeedCard等类型消息，这样写的复用率很低，因考虑进行功能的封装。其次，应该将配置相关的文件单独存放，便于管理配置。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>laravel标准框架</title>
      <link href="/2018/07/25/laravel%E6%A0%87%E5%87%86%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/07/25/laravel%E6%A0%87%E5%87%86%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="laravel标准框架的理解"><a href="#laravel标准框架的理解" class="headerlink" title="laravel标准框架的理解"></a>laravel标准框架的理解</h3><p>详情：路由、中间件、异常处理、MVC、定时任务、配置信息，课堂实际项目开发接口和风格了解，目录结构，日志分析。</p><hr><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>M：Model，模型，数据库操作具体对象。<br>V：View，视图，渲染返回的页面。<br>C：Controller，处理业务逻辑。  </p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/scheduling/1396" target="_blank" rel="noopener">任务调度</a>。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>于app/Console/Kernel.php 文件的schedule方法中定义所有调度任务。</p><p>通过<code>$schedule-&gt;call()</code>设置，传递匿名函数，匿名函数中执行调度任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;call(function () &#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;)-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通过<code>$schedule-&gt;command()</code>设置，传递命令名称或者类名称调度一个<code>Artisan</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;command(&apos;emails:send --force&apos;)-&gt;timefunction();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(EmailsCommand::class, [&apos;--force&apos;])-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通过<code>$schedule-&gt;job()</code>调度队列任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;job(new Heartbeat)-&gt;timefunction();</span><br></pre></td></tr></table></figure><p>通<code>$schedule-&gt;exec()</code>向操作系统发出命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$schedule-&gt;exec(&apos;node /home/forge/script.js&apos;)-&gt;timefunction();</span><br></pre></td></tr></table></figure><blockquote><p><code>timefunction()</code>指代调度频率的函数，包含较广，在文档上有详细的介绍。</p></blockquote><p>使用<code>withoutOverlapping</code>方法避免任务重复。</p><p>使用<code>onOneServer</code>方法让计划任务只在一台服务器上运行(必须使用<code>memcached</code>或<code>redis</code>作为你应用程序的默认缓存驱动程序，所有服务器都必须与同一个中央缓存服务器进行通信。 原理是获取到该任务的第一台服务器将对该任务加上原子锁，以防止其他服务器同时运行相同的任务。</p><p>使用<code>evenInMaintenanceMode</code>方法强制某个任务在维护模式下运行。</p><blockquote><p>使用<code>runInBackground</code>方法可使当前计划任务进入后台运行，从而不阻塞其他任务的执行。</p></blockquote><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>使用<code>sendOutputTo</code>方法将输出发送到单个文件上以便后续检查，参数为文件名。</p><p>使用<code>appendOutputTo</code>方法将输出附加到指定的文件上。</p><p>使用<code>emailOutputTo</code>方法通过电子邮件将输出发送到指定的邮箱上，参数为指定邮箱地址。</p><h4 id="任务勾子"><a href="#任务勾子" class="headerlink" title="任务勾子"></a>任务勾子</h4><p>通过<code>before</code>与<code>after</code>方法，指定要在调度任务完成之前和之后执行的代码，参数为匿名函数，于匿名函数中书写逻辑。</p><h4 id="Ping-网址"><a href="#Ping-网址" class="headerlink" title="Ping 网址"></a>Ping 网址</h4><p>使用<code>pingBefore</code>与<code>thenPing</code>方法使调度器在任务完成之前或之后自动ping给定的URL，参数为给定URL。  </p><p>需要Guzzle HTTP函数库的支持。</p><p><code>composer require guzzlehttp/guzzle</code></p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/logging/1374" target="_blank" rel="noopener">日志</a>。</p><p>使用Log facade 记录信息到日志。日志处理程序提供了八种在<a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC 5424 specification</a>里定义的日志等级：emergency、 alert、critical、 error、 warning、 notice、 info 和 debug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Log::emergency($message);</span><br><span class="line">Log::alert($message);</span><br><span class="line">Log::critical($message);</span><br><span class="line">Log::error($message);</span><br><span class="line">Log::warning($message);</span><br><span class="line">Log::notice($message);</span><br><span class="line">Log::info($message);</span><br><span class="line">Log::debug($message);</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>文档： <a href="https://laravel-china.org/docs/laravel/5.6/configuration/1353" target="_blank" rel="noopener">配置信息</a>。</p><h4 id="检索环境配置："><a href="#检索环境配置：" class="headerlink" title="检索环境配置："></a>检索环境配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;debug&apos; =&gt; env(&apos;APP_DEBUG&apos;, false),</span><br></pre></td></tr></table></figure><h4 id="确定-检查当前环境"><a href="#确定-检查当前环境" class="headerlink" title="确定/检查当前环境:"></a>确定/检查当前环境:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$environment = App::environment();</span><br><span class="line"></span><br><span class="line">if (App::environment(&apos;local&apos;)) &#123;</span><br><span class="line">    // The environment is local</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (App::environment([&apos;local&apos;, &apos;staging&apos;])) &#123;</span><br><span class="line">    // The environment is either local OR staging...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-设置配置值："><a href="#访问-设置配置值：" class="headerlink" title="访问/设置配置值："></a>访问/设置配置值：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$value = config(&apos;app.timezone&apos;);</span><br><span class="line">config([&apos;app.timezone&apos; =&gt; &apos;America/Chicago&apos;]);</span><br></pre></td></tr></table></figure><h4 id="配置缓存："><a href="#配置缓存：" class="headerlink" title="配置缓存："></a>配置缓存：</h4><blockquote><p>为提升速度，应该使用<code>Artisan</code>命令<code>config:cache</code>将所有的配置文件缓存到单个文件中。这会把你的应用程序中所有的配置选项合并成一个单一的文件，然后框架会快速加载这个文件。应该把运行<code>php artisan config:cache</code>命令作为生产环境部署常规工作的一部分。这个命令不应在本地开发环境下运行，因为配置选项在应用程序开发过程中是经常需要被更改的。</p></blockquote><h4 id="维护模式"><a href="#维护模式" class="headerlink" title="维护模式:"></a>维护模式:</h4><p>执行<code>Artisan</code>命令<code>down</code>启用维护模式。<br>当应用程序处于维护模式时，所有对应用程序的请求都显示为一个自定义视图。在更新或执行维护时「关闭」应用程序。 维护模式检查包含在应用程序的默认中间件栈中。如果应用程序处于维护模式，则将抛出一个状态码为 503 的 MaintenanceModeException 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan down</span><br></pre></td></tr></table></figure><p>向<code>down</code>命令提供<code>message</code>和<code>retry</code>选项。其中<code>message</code>选项的值可用于显示或记录自定义消息，而<code>retry</code>值可用于设置<code>HTTP</code>请求头中<code>Retry-After</code>的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan down --message=&quot;Upgrading Database&quot; --retry=60</span><br></pre></td></tr></table></figure><h4 id="关闭维护模式："><a href="#关闭维护模式：" class="headerlink" title="关闭维护模式："></a>关闭维护模式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan up</span><br></pre></td></tr></table></figure><blockquote><p>可以通过修改 resources/views/errors/503.blade.php 模板文件来自定义默认维护模式模板。<br>当应用程序处于维护模式时，不会处理 队列任务。而这些任务会在应用程序退出维护模式后再继续处理。</p></blockquote><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/middleware/1364" target="_blank" rel="noopener">中间件</a>。</p><p>用于过滤进入应用的 HTTP 请求。</p><p>可分为前置中间件、后置中间件，在请求之前或之后运行取决于中间件本身。</p><p>在 app/Http/Kernel.php 中的<code>$middleware</code>属性中列出的中间件为全局中间件。</p><p>使用 Http kernel 的<code>$middlewareGroups</code>属性，使用一个 key 把多个中间件打包成一个组，方便将他们应用到路由中。</p><p>在中间件中定义一个 terminate 方法，则会在响应发送到浏览器后自动调用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>文档：<a href="https://laravel-china.org/docs/laravel/5.6/errors/1373" target="_blank" rel="noopener">错误处理</a>。</p><p>App\Exceptions\Handler 类负责记录应用程序触发的所有异常并呈现给用户。</p><p>config/app.php 配置文件中的 debug 选项决定了对于一个错误实际上将显示多少信息给用户。默认情况下，该选项的设置将遵照存储在 .env 文件中的 APP_DEBUG 环境变量的值。</p><blockquote><p>对于本地开发，你应该将 APP_DEBUG 环境变量的值设置为 true。在生产环境中，该值应始终为 false。如果在生产中将该值设置为 true，则可能会将敏感配置值暴露给应用程序的最终用户。</p></blockquote><h4 id="report方法"><a href="#report方法" class="headerlink" title="report方法"></a>report方法</h4><p>report 方法用于记录异常或将它们发送给如 Bugsnag 或 Sentry 等外部服务。默认情况下，report 方法将异常传递给记录异常的基类。</p><p>report 辅助函数允许你使用异常处理器的 report 方法在不显示错误页面的情况下快速报告异常。</p><p>异常处理器的<code>$dontReport</code>属性包含一组不会被记录的异常类型。例如，由 404 错误导致的异常以及其他几种类型的错误不会写入日志文件。</p><h4 id="Render方法"><a href="#Render方法" class="headerlink" title="Render方法"></a>Render方法</h4><p>Render 方法负责将给定的异常转换为将被发送回浏览器的 HTTP 响应。默认情况下，异常将传递给为你生成响应的基类。可以按自己意愿检查异常类型或返回自己的自定义响应。</p><h4 id="Reportable-amp-Renderable-异常"><a href="#Reportable-amp-Renderable-异常" class="headerlink" title="Reportable &amp; Renderable 异常"></a>Reportable &amp; Renderable 异常</h4><p>除了在异常处理器的<code>report</code>和<code>render</code>方法中检查异常类型，还可以直接在自定义异常上定义<code>report</code>和<code>render</code>方法。当定义了这些方法时，它们会被框架自动调用。</p><h4 id="HTTP异常"><a href="#HTTP异常" class="headerlink" title="HTTP异常"></a>HTTP异常</h4><p>使用<code>abort</code>辅助函数从应用程序的任何地方生成这样的响应。</p><h5 id="自定义-HTTP-错误页面"><a href="#自定义-HTTP-错误页面" class="headerlink" title="自定义 HTTP 错误页面"></a>自定义 HTTP 错误页面</h5><p>创建一个 resources/views/errors/404.blade.php 视图文件。该文件将被用于你的应用程序产生的所有 404 错误。此目录中的视图文件的命名应匹配它们对应的 HTTP 状态码。由<code>abort</code>函数引发的<code>HttpException</code>实例将作为<code>$exception</code>变量传递给视图。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>对应文档：<a href="https://laravel-china.org/docs/laravel/5.6/routing/1363" target="_blank" rel="noopener">路由</a>。<br>文档比较详细，虽然复制粘贴，感觉对记住其主要用法还是有些作用的。</p><h4 id="基本路由："><a href="#基本路由：" class="headerlink" title="基本路由："></a>基本路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;foo&apos;, function () &#123;</span><br><span class="line">    return &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/user&apos;, &apos;UserController@index&apos;);</span><br><span class="line"></span><br><span class="line">Route::get($uri, $callback);</span><br><span class="line">Route::post($uri, $callback);</span><br><span class="line">Route::put($uri, $callback);</span><br><span class="line">Route::patch($uri, $callback);</span><br><span class="line">Route::delete($uri, $callback);</span><br><span class="line">Route::options($uri, $callback);</span><br></pre></td></tr></table></figure><h4 id="响应多个HTTP的路由或者响应所有HTTP路由："><a href="#响应多个HTTP的路由或者响应所有HTTP路由：" class="headerlink" title="响应多个HTTP的路由或者响应所有HTTP路由："></a>响应多个HTTP的路由或者响应所有HTTP路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::match([&apos;get&apos;, &apos;post&apos;], &apos;/&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::any(&apos;foo&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="重定向路由："><a href="#重定向路由：" class="headerlink" title="重定向路由："></a>重定向路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::redirect(&apos;/here&apos;, &apos;/there&apos;, 301);</span><br></pre></td></tr></table></figure><h4 id="视图路由-可带参数-："><a href="#视图路由-可带参数-：" class="headerlink" title="视图路由(可带参数)："></a>视图路由(可带参数)：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::view(&apos;/welcome&apos;, &apos;welcome&apos;);</span><br><span class="line"></span><br><span class="line">Route::view(&apos;/welcome&apos;, &apos;welcome&apos;, [&apos;name&apos; =&gt; &apos;Taylor&apos;]);</span><br></pre></td></tr></table></figure><h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><h5 id="必填参数"><a href="#必填参数" class="headerlink" title="必填参数"></a>必填参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;id&#125;&apos;, function ($id) &#123;</span><br><span class="line">    return &apos;User &apos;.$id;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;posts/&#123;post&#125;/comments/&#123;comment&#125;&apos;, function ($postId, $commentId) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="可选参数-要确保路由的相应变量有默认值"><a href="#可选参数-要确保路由的相应变量有默认值" class="headerlink" title="可选参数(要确保路由的相应变量有默认值)"></a>可选参数(要确保路由的相应变量有默认值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;name?&#125;&apos;, function ($name = null) &#123;</span><br><span class="line">    return $name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;name?&#125;&apos;, function ($name = &apos;John&apos;) &#123;</span><br><span class="line">    return $name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="正则表达式约束"><a href="#正则表达式约束" class="headerlink" title="正则表达式约束"></a>正则表达式约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/&#123;name&#125;&apos;, function ($name) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where(&apos;name&apos;, &apos;[A-Za-z]+&apos;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;&apos;, function ($id) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where(&apos;id&apos;, &apos;[0-9]+&apos;);</span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;/&#123;name&#125;&apos;, function ($id, $name) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;where([&apos;id&apos; =&gt; &apos;[0-9]+&apos;, &apos;name&apos; =&gt; &apos;[a-z]+&apos;]);</span><br></pre></td></tr></table></figure><h5 id="全局约束"><a href="#全局约束" class="headerlink" title="全局约束"></a>全局约束</h5><p>使用 pattern 方法在 RouteServiceProvider 的 boot 方法中定义这些模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    Route::pattern(&apos;id&apos;, &apos;[0-9]+&apos;);</span><br><span class="line"></span><br><span class="line">    parent::boot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由命名"><a href="#路由命名" class="headerlink" title="路由命名"></a>路由命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;user/profile&apos;, function () &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;name(&apos;profile&apos;);</span><br><span class="line">Route::get(&apos;user/profile&apos;, &apos;UserController@showProfile&apos;)-&gt;name(&apos;profile&apos;);</span><br></pre></td></tr></table></figure><h5 id="生成指定路由的-URL"><a href="#生成指定路由的-URL" class="headerlink" title="生成指定路由的 URL"></a>生成指定路由的 URL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 生成 URL...</span><br><span class="line">$url = route(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line">// 生成重定向...</span><br><span class="line">return redirect()-&gt;route(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Route::get(&apos;user/&#123;id&#125;/profile&apos;, function ($id) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;)-&gt;name(&apos;profile&apos;);</span><br><span class="line"></span><br><span class="line">$url = route(&apos;profile&apos;, [&apos;id&apos; =&gt; 1]);</span><br></pre></td></tr></table></figure><h4 id="检查当前路由"><a href="#检查当前路由" class="headerlink" title="检查当前路由"></a>检查当前路由</h4><p>调用路由实例上的 named 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">&#123;</span><br><span class="line">    if ($request-&gt;route()-&gt;named(&apos;profile&apos;)) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h4><p>使大量路由间共享路由属性：中间件、命名空间。共享属性应该以数组的形式传入<code>Route::group</code>方法的第一个参数中。    </p><h5 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h5><p>给路由组中所有的路由分配中间件，在group之前调用middleware方法，中间件会依照它们在数组中列出的顺序来运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware([&apos;first&apos;, &apos;second&apos;])-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/&apos;, function () &#123;</span><br><span class="line">        // 使用 first 和 second 中间件</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Route::get(&apos;user/profile&apos;, function () &#123;</span><br><span class="line">        // 使用 first 和 second 中间件</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>使用 namespace 方法将相同的 PHP 命名空间分配给路由组的中所有的控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::namespace(&apos;Admin&apos;)-&gt;group(function () &#123;</span><br><span class="line">    // 在 &quot;App\Http\Controllers\Admin&quot; 命名空间下的控制器</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>默认情况下，<code>RouteServiceProvider</code>会在命名空间组中引入路由文件，不用指定完整的 <code>App\Http\Controllers</code>命名空间前缀就能注册控制器路由。因此，只需要指定命名空间<code>App\Http\Controllers</code>之后的部分。</p><h5 id="子域名路由"><a href="#子域名路由" class="headerlink" title="子域名路由"></a>子域名路由</h5><p>路由组也可以用来处理子域名。子域名可以像路由<code>URI</code>一样被分配路由参数，允许你获取一部分子域名作为参数给路由或控制器使用。可以在<code>group</code>之前调用<code>domain</code>方法来指定子域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::domain(&apos;&#123;account&#125;.myapp.com&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;user/&#123;id&#125;&apos;, function ($account, $id) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h5><p>用<code>prefix</code>方法为路由组中给定的URL增加前缀.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::prefix(&apos;admin&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;users&apos;, function () &#123;</span><br><span class="line">        // 匹配包含 &quot;/admin/users&quot; 的 URL</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="路由名称前缀"><a href="#路由名称前缀" class="headerlink" title="路由名称前缀"></a>路由名称前缀</h5><p>name 方法可以用来给路由组中的每个路由名称添加一个给定的字符串。 例如，您可能希望以 「admin」为所有分组路由的名称加前缀。 给定的字符串与指定的路由名称前缀完全相同，因此我们将确保在前缀中提供尾部的<code>.</code>字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::name(&apos;admin.&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;users&apos;, function () &#123;</span><br><span class="line">        // 路由分配名称“admin.users”...</span><br><span class="line">    &#125;)-&gt;name(&apos;users&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="路由模型绑定"><a href="#路由模型绑定" class="headerlink" title="路由模型绑定"></a>路由模型绑定</h5><p>当向路由或控制器行为注入模型 ID 时，就需要查询这个 ID 对应的模型。Laravel 为路由模型绑定提供了一个直接自动将模型实例注入到路由中的方法。例如，你可以注入与给定 ID 匹配的整个 User 模型实例，而不是注入用户的 ID。</p><h4 id="路由模型绑定-1"><a href="#路由模型绑定-1" class="headerlink" title="路由模型绑定"></a>路由模型绑定</h4><p>当向路由或控制器行为注入模型 ID 时，就需要查询这个 ID 对应的模型。Laravel 为路由模型绑定提供了一个直接自动将模型实例注入到路由中的方法。例如，你可以注入与给定 ID 匹配的整个 User 模型实例，而不是注入用户的 ID。</p><h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>Laravel 会自动解析定义在路由或控制器行为中与类型提示的变量名匹配的路由段名称的 Eloquent 模型。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;api/users/&#123;user&#125;&apos;, function (App\User $user) &#123;</span><br><span class="line">    return $user-&gt;email;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>自定义键名.<br>如果你想要模型绑定在检索给定的模型类时使用除 id 之外的数据库字段，你可以在 Eloquent 模型上重写 getRouteKeyName 方法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> * 为路由模型获取键名。</span><br><span class="line"> *</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">public function getRouteKeyName()</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;slug&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h5><p>要注册显式绑定，使用路由器的 model 方法来为给定参数指定类。在 RouteServiceProvider 类中的 boot 方法内定义这些显式模型绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    parent::boot();</span><br><span class="line"></span><br><span class="line">    Route::model(&apos;user&apos;, App\User::class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，定义一个包含 {user} 参数的路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;profile/&#123;user&#125;&apos;, function (App\User $user) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>自定义逻辑解析.<br>使用<code>Route::bind</code>方法自定义的解析逻辑。传递到<code>bind</code>方法的闭包会接受<code>URI</code>中大括号对应的值，并且返回想要在该路由中注入的类的实例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    parent::boot();</span><br><span class="line"></span><br><span class="line">    Route::bind(&apos;user&apos;, function ($value) &#123;</span><br><span class="line">        return App\User::where(&apos;name&apos;, $value)-&gt;first() ?? abort(404);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>Laravel 包含了一个 中间件 用于控制应用程序对路由的访问。如果想要使用，请将 throttle 中间件分配给一个路由或一个路由组。throttle 中间件会接收两个参数，这两个参数决定了在给定的分钟数内可以进行的最大请求数。 例如，让我们指定一个经过身份验证并且用户每分钟访问频率不超过 60 次的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware(&apos;auth:api&apos;, &apos;throttle:60,1&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/user&apos;, function () &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="动态访问控制"><a href="#动态访问控制" class="headerlink" title="动态访问控制"></a>动态访问控制</h5><p>根据已验证的 User 模型的属性指定动态请求的最大值。 例如，如果您的 User 模型包含rate_limit属性，则可以将属性名称传递给 throttle 中间件，以便它用于计算最大请求计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::middleware(&apos;auth:api&apos;, &apos;throttle:rate_limit,1&apos;)-&gt;group(function () &#123;</span><br><span class="line">    Route::get(&apos;/user&apos;, function () &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="表单方法伪造"><a href="#表单方法伪造" class="headerlink" title="表单方法伪造"></a>表单方法伪造</h4><p>HTML表单不支持PUT、PATCH或DELETE行为。所以当你要从HTML表单中调用定义了PUT、PATCH或DELETE路由时，你将需要在表单中增加隐藏的_method 输入标签。使用_method字段的值作为HTTP的请求方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    @method(&apos;PUT&apos;)</span><br><span class="line">    @csrf</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="访问当前路由"><a href="#访问当前路由" class="headerlink" title="访问当前路由"></a>访问当前路由</h4><p>可以使用<code>Route Facade</code>上的<code>current</code>、<code>currentRouteName</code>和<code>currentRouteAction</code>方法来访问处理传入请求的路由的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$route = Route::current();</span><br><span class="line"></span><br><span class="line">$name = Route::currentRouteName();</span><br><span class="line"></span><br><span class="line">$action = Route::currentRouteAction();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2018/07/24/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/24/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="linux基础命令tail-cat-top-mkdir-vi-chmod等"><a href="#linux基础命令tail-cat-top-mkdir-vi-chmod等" class="headerlink" title="linux基础命令tail/cat/top/mkdir/vi/chmod等"></a>linux基础命令tail/cat/top/mkdir/vi/chmod等</h3><p>linux命令使用的详细参数可以通过man command进行查询，一般比较容易忘记命令的具体作用，下面仅对这些命令的具体功能及作用进行记录，并给出相应的命令使用。</p><p>参考：<a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全</a></p><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>作用：查看文件的尾部内容，不带参数则默认显示后十条。</p><p>查看正在改变的nginx日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f  com.access_log</span><br></pre></td></tr></table></figure><p>查看第5条开始往后信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail +5 com.access_log</span><br></pre></td></tr></table></figure><p>查看最后十个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c 10 com.access_log</span><br></pre></td></tr></table></figure><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>作用：连接文件并打印到标准输出设备上。</p><p>将nginx日志文件显示行号输入到备份文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n com.access_log backup_log</span><br></pre></td></tr></table></figure><p>将nginx日志文件cn.access_log和com.access_log加上行号（空白行不加）附加到备份文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b com.access_log cn.access_log &gt;&gt; backup_log</span><br></pre></td></tr></table></figure><p>清空日志com.access_log内容（遇到权限问题，需要sudo su到root）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; com.access_log</span><br></pre></td></tr></table></figure><p>制作镜像文件（假设软盘放好后）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure><p>把镜像写入软盘（假设软盘放好后）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat IMG_FILE &gt; /dev/fd0</span><br></pre></td></tr></table></figure><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>作用：实时显示进程状态。</p><p>mac和linux（服务器为centos7）下top的参数是有些不一致的。</p><p><a href="http://www.runoob.com/linux/linux-comm-top.html" target="_blank" rel="noopener">参考文档</a>上是linux下的使用。</p><h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>作用：创建目录。</p><p>于TEST目录下创建test子目录，若TEST目录不存在则创建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir TEST/test</span><br></pre></td></tr></table></figure><h3 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h3><p>作用：文本编辑器。</p><p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html" target="_blank" rel="noopener">Vim快捷键键位图</a><br><a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">vi/vim 的使用</a></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>作用：修改文件权限。</p><p><a href="https://www.cnblogs.com/123-/p/4189072.html" target="_blank" rel="noopener">linux文件的权限表示</a>。</p><p><a href="http://www.runoob.com/linux/linux-comm-chmod.html" target="_blank" rel="noopener">实例</a>。</p><h3 id="ssh及scp"><a href="#ssh及scp" class="headerlink" title="ssh及scp"></a>ssh及scp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@ip</span><br></pre></td></tr></table></figure><p>mac上传文件/目录到服务器：</p><p>上传目录到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r dir root@ip:/root/</span><br></pre></td></tr></table></figure><p>上传文件到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r file.txt root@ip:/root/</span><br></pre></td></tr></table></figure><p>拷贝服务器文件到本地则调换后两个参数顺序。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx多站点配置及日志分析</title>
      <link href="/2018/07/23/nginx%E5%A4%9A%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/23/nginx%E5%A4%9A%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>nginx配置多个站点、nginx日志配置和查看，根据日志统计访问次数、响应时间</p><hr><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li><a href="https://www.kancloud.cn/wizardforcel/nginx-doc/92350" target="_blank" rel="noopener">Nginx 中文官方文档</a></li></ol><h4 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h4><p>由于使用的brew安装的nginx，配置文件目录<code>/usr/local/etc/nginx</code>。</p><p>方法一：新建server，由于我们在本地操作，ip都是127.0.0.1对应localhost，所以为区分站点可只修改listen、root及php脚本fastcgi_param。需要指定路径下有站点目录。此时重启nginx，通过localhost:端口即可访问不同的站点。</p><p>方法二：在/etc/hosts文件中新增两个域名解析到127.0.0.1，我新增的是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 bighua.com</span><br><span class="line">127.0.0.1 bighua.cn</span><br></pre></td></tr></table></figure><p>然后修改两个server的server_name、root及php脚本fastcgi_param。在指定路径下要有站点目录。此时重启nginx，通过两个域名即可正确访问两个不同的站点。</p><h4 id="nginx日志配置和查看"><a href="#nginx日志配置和查看" class="headerlink" title="nginx日志配置和查看"></a>nginx日志配置和查看</h4><p>使用brew安装的nginx默认的日志文件在目录<code>/usr/local/var/log/nginx</code>下，但是根据nginx文档可以自己在每个server中单独配置访问日志。<br>在第一个server中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/com.access_log;</span><br></pre></td></tr></table></figure><p>在第二个server中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/cn.access_log;</span><br></pre></td></tr></table></figure><p>在http外或server外新增（即全局）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log    /Users/wuhua/Desktop/nginxlog/myerror_log;</span><br></pre></td></tr></table></figure><p>errlog_log只会以第一个为准，即在两个server中定义不同的error_log只会生成第一个server中的error_log文件。<br>之后重启nginx，在桌面上的nginxlog目录下会生成三个文件分别为：com.access_log、cn.access_log、cn.error_log。访问上面配置的两个域名，将会在两个访问日志中记录访问信息，出错信息记录到myerror_log。</p><h4 id="根据日志统计访问次数、响应时间"><a href="#根据日志统计访问次数、响应时间" class="headerlink" title="根据日志统计访问次数、响应时间"></a>根据日志统计访问次数、响应时间</h4><p>可以规定记录到日志中信息的格式，并为格式命名，然后在日志尾部通过命名应用格式。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                   &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"> </span><br><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/com.access_log main;</span><br></pre></td></tr></table></figure><p>格式中的信息表示如下表：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">含义</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">$remote_addr</td><td style="text-align:left">客户端地址</td><td style="text-align:left">127.0.0.1</td></tr><tr><td style="text-align:left">$remote_user</td><td style="text-align:left">客户端用户名称</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">$time_local</td><td style="text-align:left">访问时间和时区</td><td style="text-align:left">23/Jul/2018:17:23:15 +0800</td></tr><tr><td style="text-align:left">$request</td><td style="text-align:left">请求的url和http协议</td><td style="text-align:left">GET /login HTTP/1.1</td></tr><tr><td style="text-align:left">$status</td><td style="text-align:left">HTTP请求状态</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">$upstream_status</td><td style="text-align:left">upstream状态</td><td style="text-align:left">200</td></tr><tr><td style="text-align:left">$body_bytes_sent</td><td style="text-align:left">发送给客户端文件内容大小</td><td style="text-align:left">4618</td></tr><tr><td style="text-align:left">$http_referer</td><td style="text-align:left">url跳转来源</td><td style="text-align:left"><a href="http://bighua.cn/register" target="_blank" rel="noopener">http://bighua.cn/register</a></td></tr><tr><td style="text-align:left">$http_user_agent</td><td style="text-align:left">用户终端浏览器等信息</td><td style="text-align:left">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</td></tr><tr><td style="text-align:left">$http_x_forwarded_for</td><td style="text-align:left">客户端的真实ip</td><td style="text-align:left">127.0.0.1(通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加 x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端请求的服务器地址.)</td></tr><tr><td style="text-align:left">$ssl_protocol</td><td style="text-align:left">SSL协议版本</td><td style="text-align:left">TLSv1（https请求）</td></tr><tr><td style="text-align:left">$ssl_cipher</td><td style="text-align:left">交换数据中的算法</td><td style="text-align:left">RC4-SHA(https请求)</td></tr><tr><td style="text-align:left">$upstream_addr</td><td style="text-align:left">后台upstream的地址，即真正提供服务的主机地址</td><td style="text-align:left">127.0.0.1:80</td></tr><tr><td style="text-align:left">$request_time</td><td style="text-align:left">整个请求的总时间</td><td style="text-align:left">0.205</td></tr><tr><td style="text-align:left">$upstream_response_time</td><td style="text-align:left">请求过程中，upstream响应时间</td><td style="text-align:left">0.002</td></tr></tbody></table><p>未经设置默认eccess_log中的一条日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:17:23:15 +0800] &quot;GET /login HTTP/1.1&quot; 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;</span><br></pre></td></tr></table></figure><p>统计访问次数和响应时间，我们根据客户端真实IP($http_x_forwarded_for)/客户端地址($remote_addr)确定用户统计次数，然后在格式中添加$upstream_response_time和$request_time记录每一次请求的服务器响应时间和整个请求的时间。</p><p>设置log_format如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">   &apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br></pre></td></tr></table></figure><p>重启nginx再次访问页面查看最新一条日志记录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:19:49:17 +0800] &quot;GET /login HTTP/1.1&quot; 0.045 0.045 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>第一项<code>127.0.0.1</code>为用户地址，第八项和第九项0.045为整个请求的时间和服务器响应时间，统计访问次数则是统计第一项每个地址的出现次数。</p><p>配置详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">user  wuhua admin;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">error_log    /Users/wuhua/Desktop/nginxlog/myerror_log;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    </span><br><span class="line">    log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">&apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name bighua.com;</span><br><span class="line">   root /Users/wuhua/Desktop/TAL-practice/login/public;</span><br><span class="line">access_log   /Users/wuhua/Desktop/nginxlog/com.access_log myfmt;</span><br><span class="line"></span><br><span class="line">    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">    add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">   add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">   charset utf-8;</span><br><span class="line">   location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">    location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">        fastcgi_index   index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/login/public$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /\.(?!well-known).* &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name bighua.cn;</span><br><span class="line">        root /Users/wuhua/Desktop/TAL-practice/loginold/public;</span><br><span class="line">        access_log   /Users/wuhua/Desktop/nginxlog/cn.access_log myfmt;</span><br><span class="line"></span><br><span class="line">        add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">        add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">        add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">        location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">                fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">                fastcgi_index   index.php;</span><br><span class="line">                fastcgi_param   SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/loginold/public$fastcgi_script_name;</span><br><span class="line">                include         fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ /\.(?!well-known).* &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    include servers/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客<a href="https://www.cnblogs.com/handongyu/p/6513185.html" target="_blank" rel="noopener">Nginx 日志分析及性能排查</a>使用awk命令对日志进行处理。</p><p>另外自己的想法也可以通过php进行读文件处理，或则将awk命令处理过的日志存储数据库等等。</p><h5 id="使用awk进行日志分析"><a href="#使用awk进行日志分析" class="headerlink" title="使用awk进行日志分析"></a>使用awk进行日志分析</h5><p>根据日志格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  myfmt   &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">   &apos;$request_time $upstream_response_time &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                   &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;;</span><br></pre></td></tr></table></figure><p>第一次处理需要提取的信息有第一项、第五项、第六项，但是不加分隔符awk默认使用‘ ’空隔作为分隔符，按上方格式获取的一条日志记录如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [23/Jul/2018:19:49:17 +0800] &quot;GET /login HTTP/1.1&quot; 0.045 0.045 200 4618 &quot;http://bighua.cn/register&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>使用awk对应提取第一列、第九列、第十列。</p><p>提取数据command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **._access_log | awk &apos;&#123;print $1,$9,$10&#125;&apos;</span><br></pre></td></tr></table></figure><p>因为有两个日志文件，命令也比较长，整理成shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat $1 | awk &apos;&#123;print( $1,$9,$10)&#125;&apos; &gt; $1.data.csv</span><br></pre></td></tr></table></figure><p>调用脚本，以日志为参数，保存结果为csv文件。</p><p>统计访问次数则根据访问ip使用uniq进行处理，command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **._access_log | awk &apos;&#123;print $1&#125;&apos; | uniq -c</span><br></pre></td></tr></table></figure><p>根据参考博客可以导出为csv文件，command：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat **.access_log | awk &apos;&#123;print $1&#125;&apos; | uniq -c | awk &apos;&#123;print $1,$2&#125;&apos; &gt; **.countip.csv</span><br></pre></td></tr></table></figure><p>整理成shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat $1 | awk &apos;&#123;print $1&#125;&apos; | uniq -c | awk &apos;&#123;print $1,$2&#125;&apos; &gt; $1.countip.csv</span><br></pre></td></tr></table></figure><p>调用脚本，以日志为参数，保存处理结果为csv文件。</p><h5 id="使用ngxtop统计实时数据"><a href="#使用ngxtop统计实时数据" class="headerlink" title="使用ngxtop统计实时数据"></a>使用ngxtop统计实时数据</h5><p>项目地址：<a href="https://github.com/lebinh/ngxtop" target="_blank" rel="noopener">nginxtop</a></p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">sudo easy_install ngxtop</span><br></pre></td></tr></table></figure><p>使用文档：<a href="https://github.com/lebinh/ngxtop#usage" target="_blank" rel="noopener">Usage</a><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngxtop -c PATH/nginx.conf -t 1</span><br></pre></td></tr></table></figure><h5 id="使用php进行日志分析"><a href="#使用php进行日志分析" class="headerlink" title="使用php进行日志分析"></a>使用php进行日志分析</h5><p>这里就不在详叙了，想法就是读取文件，按行读取，按空格分割，从分隔结果的数据中取需要的数据。</p><h4 id="业务分析感悟"><a href="#业务分析感悟" class="headerlink" title="业务分析感悟"></a>业务分析感悟</h4><blockquote><p>通常我们根据日期为每天访问建立日志，同时对日志的分析，可以通过crontab设置定时任务，每天进行自动分析，可以考虑将分析结果存储到数据库等，便与查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
            <tag> laravel </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>laravel初探[登陆注册]</title>
      <link href="/2018/07/17/laravel%E5%88%9D%E6%8E%A2%5B%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%5D/"/>
      <url>/2018/07/17/laravel%E5%88%9D%E6%8E%A2%5B%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%5D/</url>
      
        <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>详情：搭建nginx/php/mysql/redis/laravel环境。<br>遇到的问题及收获见<a href="/2018/07/05/Mac搭建开发环境初体验/" title="Mac搭建开发环境初体验">Mac搭建开发环境初体验</a>。</p><hr><h3 id="登陆注册的基本功能"><a href="#登陆注册的基本功能" class="headerlink" title="登陆注册的基本功能"></a>登陆注册的基本功能</h3><p>详情：小作业，登录注册完成基本功能（注册用户信息格式验证，用户名唯一性，修改密码，用户资料，邮箱验证，手机号码验证，密码加密规则，session存储，cookie填写，前端保存密码，查询用户信息）。</p><h4 id="实践中主要参考资料"><a href="#实践中主要参考资料" class="headerlink" title="实践中主要参考资料"></a>实践中主要参考资料</h4><ol><li><a href="https://laravel-china.org/docs/laravel/5.6" target="_blank" rel="noopener">Laravel 5.6 中文文档</a>。</li><li><a href="https://github.com/kevinyan815/Learning_Laravel_Kernel" target="_blank" rel="noopener">Learning_Laravel_Kernel</a>，前人的laravel框架学习笔记。</li><li><a href="https://www.insp.top/learn-laravel-container" target="_blank" rel="noopener">laravel 学习笔记 —— 神奇的服务容器</a>，前人的学习博客。</li><li><a href="https://blog.csdn.net/tanmx219/article/details/78922770" target="_blank" rel="noopener">Laravel5.5源码详解 – Auth中间件</a>，前人总结的关于Auth中间件的博客。</li><li><a href="https://segmentfault.com/blog/lx1036" target="_blank" rel="noopener">Laravel/Angular 技术分享</a>，前人关于框架探秘博客。</li></ol><h4 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h4><p>基本完成任务进度表中这周的任务，包括：  </p><ol><li>注册登陆。</li><li>记住我。</li><li>用户资料填写、展示。</li><li>通过邮箱重置密码。</li><li>自己编写简单验证、使用框架自带认证器认证字段。</li></ol><hr><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><h4 id="关于重置密码的考虑"><a href="#关于重置密码的考虑" class="headerlink" title="关于重置密码的考虑"></a>关于重置密码的考虑</h4><p>之前自己也实现过这部分的功能，当时的做法是生成一个字段并存储到session中，将这个字段作为url参数发送到重置邮箱，通过这个url附带的参数和session中的参数进行比对然后设置一个临时登陆状态，跳转到重置密码页面，重置成功后销毁session字段跳转到登陆页。今天的做法类似，不过加了邮箱字段存session替换上方逻辑中的临时登陆态。<br>但框架自带的重置密码是通过字段、邮箱存数据库，之后取库进行比对操作的，个人感觉这种方式在某些场景下会增大DB的IO，但是可以记录用户的密码变更记录，需要结合具体场景进行考虑和应用。</p><h4 id="cookie和session的重新认识"><a href="#cookie和session的重新认识" class="headerlink" title="cookie和session的重新认识"></a>cookie和session的重新认识</h4><p>之前有学习过相关知识，但在使用中通常直接使用框架封装好的接口，实现业务时有些细节未做关注，例如：服务器如何识别浏览器用户标识，框架对用于标识用户凭证的相关cookie的设置等等。<br>通过阅读laravel自带的登陆源码、相关文档、数据库表字段等，总结其使用session和cookie实现的业务逻辑流程大概如下。</p><blockquote><p>浏览器第一次发起请求，laravel接受请求后生成_token、_previous、_flash存储于session。_token用于防csrf，也会经过加密后存储于cookie中，之后用户的每一次经web路由的请求都需要带上这个凭证。_flash用于记录闪存数据，在下一次请求后失效。_previous用于记录请求的url。在cookie中还会存储一项APP_NAME_session，用于标识session_id。 存储于cookie的XSRF_TOKEN和APP_NAME_session存储时间为一天。 在登陆后会在session中加入一个用于标识登陆状态的字段，若提交的记住我字段为true，则在cookie中新增记录login_web_***，存储时间为5年，并将此字段值记录于对应用户表的remember_token字段中。<br>登陆逻辑先判断是否session中是否有记录登陆状态的标识和请求带的cookie是否有记住我表示，若都没有则跳到登陆页，有记住我则根据记住我值在数据库中查找对应的用户信息，设置session登陆字段。</p></blockquote><h4 id="关于laravel框架的一点收获"><a href="#关于laravel框架的一点收获" class="headerlink" title="关于laravel框架的一点收获"></a>关于laravel框架的一点收获</h4><p>在本周任务中，有个字段验证功能，要求自己书写。但是我只在注册页面使用到ajax配合自己的字段验证，在其他页面使用到框架自带的validate验证器。通过阅读相关源码和文档发现，验证的错误消息返回其实是通过路由重定向带上错误消息和表单消息，这样的逻辑功能就很好理解了。回顾自己注册页面的验证逻辑，也可以通过这样实现，重写验证，完全不使用ajax。回想这部分处理的失败，主要是由于对laravel的使用缺乏经验，把事情想复杂了。<br>之前比较熟悉tp框架(v3.2.3)，tp框架没有laravel框架这么多的设计理念，例如容器、中间件等。现在理解中间件的作用相当于tp中基类的构造函数业务逻辑，都是在请求执行前进行的一些相关处理，laravel。laravel将路由模块独立出来，对路由的使用更加灵活，可以根据请求方式设置请求的具体执行路径，命名更方便等等。<br>记得之前在面试的过程中被问到laravel和tp的区别，之后搜了一下相关的问题，有人说到laravel更适合大型项目。跟过之前的使用经验和这周导师为我们展示的线上业务系统，目前的理解是laravel更适合模块的组织，可以将各个业务模块划分的更清晰，便于维护管理。<br>回看这周实现的几百行代码，实践中写下了很多逻辑bug，反复修改。编码也很不优雅，其中把一个处理逻辑放在了构造函数中，感觉这种方式很不符合laravel的规范，在代码组织上也有点糟，需要待改进。<br>本周的任务只使用到了laravel中很少的一部分功能，根据之前的接触了解，laravel还自带有队列、定时任务等特性，本次都没有使用到。如今的主要任务是熟悉框架，适应框架，能够使用框架顺利的完成工作，但作为研发，在完成任务之后，希望自己能够抽出时间了解其底层的实现机制。</p><h4 id="关于php一些语法知识的收获"><a href="#关于php一些语法知识的收获" class="headerlink" title="关于php一些语法知识的收获"></a>关于php一些语法知识的收获</h4><p>在之前也有了解过trait复用特性，但没写过大型的业务，基本没考虑过这个特性的使用，在阅读larvel框架源码的过程中，看到了很多地方使用到trait。<br>php的匿名函数也有了解过，在中间件中看到Closure类的使用，才第一次接触到这个类，之前对匿名函数的使用多在返回结果的处理和传参的处理上。看他人博客的介绍，在中间件中此处的作用是请求的转发，继续执行原请求的业务逻辑，待细看这部分的源码自己进行理解。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac搭建开发环境初体验</title>
      <link href="/2018/07/05/Mac%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/07/05/Mac%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>周一入职，已经是第4天了，这两天在配置开发环境上走了不少坑，记录下来以备后续查阅。</p><p>公司配的mac周二下午才到，全新的13.3寸256/8G的MacBookPro，希望自己的技术能力能配得上使用的工具。周一leader让在自带的电脑上配置nginx+mysql+redis+php开发环境，由于之前已经配置过很多次，所以主要是查看配置的合理性以及安装redis及相应的php拓展。redis在其官网上有相应的安装教程，phpredis找包然后下载解压缩，使用phpize生成configure文件，make &amp; make install，在php.ini中添加拓展。在检查lnmp的过程中，发现nginx是用的默认包管理工具安装的，想将这些都安装在一个地方便与使用和管理，于是卸载之自己编译安装，安装过程根据自己之前记录的一篇博客来的。最后在配置nginx时，又遇到了权限问题，昨天在Mac上搭建时也遇到了这个问题，解决办法简洁点就是将user设置为当前用户组用户，将指定的web目录从根文件开始赋予能够访问的权限。</p><p>初次使用Mac，这几天的环境搭建过程中踩坑收获如下：</p><ul><li>安装brew,mac下的包管理工具，感觉比centos的yum/rpm更好使，比自己动手编译安装的缺点是经常需要通过brew info得知安装软件的配置文件和执行文件位置，不便于管理。</li><li>自带php7.1.16，以php-fpm模式运行需要自己配置相关文件，在/etc目录下。   </li><li>在/etc/paths.d中以文件的方式添加环境变量更加方便管理，source后在另开的终端中才会生效。</li><li>编译安装nginx和使用brew安装nginx，配置web目录遇到的权限问题同上方式解决。</li><li>有mac下的mysql安装包，直接下载点点点，别忘了记下弹出的初始密码，也可使用brew安装。</li><li>使用brew安装redis，下载编译phpredis，phpize、./configure、make这三步没有问题，make install遇到<code>Operation not permitted</code>报错，查询得知Mac下的SIP机制导致的，需要在重启Mac过程中按<code>command</code>+<code>R</code>过程进入恢复模式，打开终端输入<code>csrutil disable</code>关闭SIP，再次重启电脑执行make install成功，在php.ini中添加拓展。</li></ul><p>周三晚上终于把环境搞定了，然后配置git配置node把此博客进行了迁移。书到用时方恨少，今天开始，好好学习好好工作！</p><p>在<a href="https://laravel-china.org/docs/laravel/5.6/deployment/1357#nginx" target="_blank" rel="noopener">Laravel 的部署</a>，附份nginx配置文件以备后续参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    root /Users/wuhua/Desktop/TAL-practice/login/public;</span><br><span class="line"></span><br><span class="line">    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">    add_header X-XSS-Protection &quot;1; mode=block&quot;;</span><br><span class="line">    add_header X-Content-Type-Options &quot;nosniff&quot;;</span><br><span class="line"></span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">    location = /robots.txt  &#123; access_log off; log_not_found off; &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /index.php;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">        fastcgi_index   index.php;</span><br><span class="line">        fastcgi_param   SCRIPT_FILENAME /Users/wuhua/Desktop/TAL-practice/login/public$fastcgi_script_name;</span><br><span class="line">        include         fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /\.(?!well-known).* &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> redis </tag>
            
            <tag> nginx </tag>
            
            <tag> phpredis </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo多台电脑间迁移解决方案</title>
      <link href="/2018/07/05/hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E9%97%B4%E8%BF%81%E7%A7%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/07/05/hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E9%97%B4%E8%BF%81%E7%A7%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>由于工作配发了mac，之前在自己的thinkpad上搭建的博客如何迁移到mac上，并且保持博客的完整性和统一性就成了问题。</p><p>在网上搜了一下，前人已经给出了巧妙的解决方案，通过在自己的hexo项目上开一个分支，分支中保留hexo所有重要文件，在其他电脑上直接下载此分支，然后使用npm下载所有依赖包，这样其实就可以得到自己的hexo完整项目。通过这个克隆的分支可以写博客上传到master，也可以自更新上传到分支，保证每次使用后的完整性。</p><p>具体参考的前人博客<a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">Hexo博客从一台电脑迁移到其他电脑</a>,介绍了总体的解决思路和步骤，具体细节要根据自己的情况而定。</p><p>具体到本博客的迁移过程：</p><ul><li><p>克隆自己的hexo项目到本地，其实主要目的是获取git配置文件，作为分支的git配置文件，若本地已有git项目，可省略此步，后面直接获取git配置文件即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cocowh/cocowh.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>备份本地的hexo项目，删除依赖库和不必要的文件（多余的主题目录，生成的页面等等，根据自己配置决定），<code>修改主题中git的配置文件名，否则主题目录被当作单独的git项目无法被跟踪，无法上传</code>，有个风险是主题配置文件中的信息被暴露出来，如果不上传，在另一台电脑上克隆后又要重新下载配置主题文件，显得繁琐。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -R hexo blogbackup</span><br><span class="line">cp -R cocowh.github.io/.git blogbackup/.git</span><br><span class="line">cp cocowh.github.io/.gitignore  blogbackup</span><br><span class="line">cd blogbackup</span><br><span class="line">rm -rf public node_modules //其实在.gitignore中已经包含这些文件和目录</span><br></pre></td></tr></table></figure></li><li><p>创建一个叫blogbackup的分支并push到分支。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b blogbacku</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;备份分支&quot;</span><br><span class="line">git push --set-upstream origin blogbackup</span><br></pre></td></tr></table></figure></li><li><p>在另一台已经部署好git、node 、hexo等必须环境的电脑上克隆blogbackup分支到本地，克隆master到本地(没用hexo自带提交指令，自己编写的本地提交脚本，根据情况灵活决定)。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone -b blogbackup https://github.com/cocowh/cocowh.github.io.git</span><br><span class="line">cd coocwh.github.io</span><br><span class="line">npm update</span><br><span class="line">mkdir .deploy</span><br><span class="line">cd .deploy</span><br><span class="line">git clone https://github.com/cocowh/coocwh.github.io.git</span><br><span class="line">cd ../..</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>到这里已经基本搞定，写博客运行脚本提交到master。再次迁移到另一台电脑上，直接提交到blogbackup分支就好，更新主题要将git文件名修改回来。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>天涯未远，江湖再见</title>
      <link href="/2018/06/16/%E5%A4%A9%E6%B6%AF%E6%9C%AA%E8%BF%9C%EF%BC%8C%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81/"/>
      <url>/2018/06/16/%E5%A4%A9%E6%B6%AF%E6%9C%AA%E8%BF%9C%EF%BC%8C%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客了，距离上一篇博客过去快两个月了。五月中寻毕设做的差不多了，堕落了一下，五月下旬回家陪可爱的外甥女玩了10天，六月上旬忙着写论文准备答辩，答辩后班级毕业照聚餐，然后提前回家陪家人过端午节，20号送二姐和外甥女上高铁。这篇本来打算在16号退宿走的那天记录的，想着趁年轻还想说还想写记录下。然而那天仅仅创建了文章，宿舍收拾打包东西，内心繁杂，也没太多心情想写。现在是24号凌晨4点，一直睡不着，就爬起来打开电脑，续写这篇记录。</p><h3 id="世人都晓勤奋好，贪玩懒惰忘不了"><a href="#世人都晓勤奋好，贪玩懒惰忘不了" class="headerlink" title="世人都晓勤奋好，贪玩懒惰忘不了"></a>世人都晓勤奋好，贪玩懒惰忘不了</h3><p>在今年生日的时候，已经写了篇博客，大致记录了大学四年的生活。总结这四年，应了那句话：间歇性踌躇满志，持续性混吃等死。</p><p>大学仿佛就是高中的一次循环。高一包夜上网玩游戏，夜晚被窝玩手机，成绩慢慢掉队。大一上课睡觉，课下浪玩游戏抄作业，大一下学期挂科。高二醒悟想考好点的大学开始慢慢认真学习，却发现掉队有些严重了，感谢学霸同桌带，成绩慢慢稳住，貌似那时候也是和一些同学有些矛盾，也可能是高三，直到现在在处理人际关系以及交往上还是不擅长。同样的也是在大二才开始意识到学习的重要性，有几个同班同学因为挂科严重被留级了，自己也开始上课认真听讲，慢慢的改上课睡觉的习惯，可是一学期的努力虽然成绩有所提高，但是跟那些学霸还是有些距离。摆在眼前的两条路：考研和工作，自己选择了后者，上学期末和同学一起加入了计协的web组，开始带我们的是一个大三的学姐，在下学期她就去腾讯实习了，受学姐的模范鼓励，以及一些情绪的影响，大二下学期一直默默的激励的自己去学习新的东西，虽然那些东西在现在看来真的是皮毛，学的太少太少了。大二这一年过的不太好，心情波动很大，和一些同学闹僵了。</p><p>对我来说的大学，在大二结束时就已经结束了。后面的两年都是以工作为主要目的，没任何值的纪念的生活细节。有时候总是觉得自己是不是有些心理问题，又或者说一些不成熟、幼稚的心理和想法，而自己从没有过正面的面对去解决它，就像这样将其归结为成长。直到现在仍然是复杂的思绪，我想或许有一天我会将所有的一切都找到合理的解决范本，然后再也不会像现在这样吐槽生活、记录心情。</p><p>今天是24号，到现在还没睡意，白天估计是废了，下个月2号入职，在家也呆不了几天了，总想骑车去一次老城十字街，去一次白马寺，去那些还没去过的地方，可是没有人一起的活动，显得一切都索然无味。就像大学的后两年，仅仅以找工作、不挂科以及忘记一些事情和逃避一些事情为主要内容的生活，没有任何意义，面对必须面对的所有人都保持应有的客套，还要忍受一些恶心的事情。</p><h3 id="狮山有情君有意，栀花香里话别离"><a href="#狮山有情君有意，栀花香里话别离" class="headerlink" title="狮山有情君有意，栀花香里话别离"></a>狮山有情君有意，栀花香里话别离</h3><p>就像一颗由远及近的流星，从远处慢慢飞过来，越来越快，到达最近时再以最快的速度离去，慢慢的，慢慢的消失。有些比较久远的事情，还是让他变模糊的好。我不知道现在正处在哪个阶段，或许是流星飞来的阶段。时间总觉得是越来越快了，父母老了，在过个几年就要退休了，今后的时间将大部分被工作带走，或许不觉间这几年就过去了。</p><p>大学这四年也是，总觉的不该这么快的，仿佛离别时都没意识到这就是离别，说是再见，或许是再也不见。离别可能也慢慢变成常态，慢慢的或许也没有现在的这些挢揉造作了。</p><p>无论四年如何，都是自己的人生轨迹。对学校的抱怨也好、留恋也罢，与同学的交好也好、积怨也罢，对某老师的厌恶也好、赞美也罢，所有这一切，形成了独一无二的轨迹。这几年，没仔细想过最后应有的模样，没规划过合理的路径，走一步看一步。开始准备读研，现在走上了工作的路径。开始想学吉他，现在拿起来爬格子还是很费力。总的来说，可能是不如意的。</p><p>今天是24号，昨天上午毕业典礼，下午发放毕业证和学位证，还在学校的同学，估计很多也在今天离开。天下没有不散的宴席，祝同学们前程似锦！</p><h3 id="前方不需太重的行囊，和过去和解吧"><a href="#前方不需太重的行囊，和过去和解吧" class="headerlink" title="前方不需太重的行囊，和过去和解吧"></a>前方不需太重的行囊，和过去和解吧</h3><p>一段经历，已成过去。进入社会，又是一个新的旅程！</p><p>忘记过去，规划以后的摸样，前方不需太重的行囊，和过去和解吧！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器lnmp环境搭建配置</title>
      <link href="/2018/05/09/%E6%9C%8D%E5%8A%A1%E5%99%A8lnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/05/09/%E6%9C%8D%E5%8A%A1%E5%99%A8lnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>搭建本博客之初的原因之一，就是在搭建lnmp和其他系列环境时遇到了很多问题，今天将服务器重置了，先配置好了go环境，在<a href="/2018/04/10/Golang笔记-基础篇-一/" title="Golang笔记-基础篇(一)">Golang笔记-基础篇(一)</a>的初始部分进行了相关步骤的补充。下面记录下lnmp环境的搭建配置。</p><h2 id="服务器用户设置"><a href="#服务器用户设置" class="headerlink" title="服务器用户设置"></a>服务器用户设置</h2><p>全新的腾讯云服务器，CentOS 7.5。</p><h3 id="ssh登陆"><a href="#ssh登陆" class="headerlink" title="ssh登陆"></a>ssh登陆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wuhua:~ wuhua$ ssh -p 22 root@188.131.143.137</span><br><span class="line">root@188.131.143.137&apos;s password: </span><br><span class="line">Last login: Sun Sep 30 11:27:15 2018 from 119.29.96.147</span><br></pre></td></tr></table></figure><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos ~]# adduser wuhua</span><br><span class="line">[root@VM_0_10_centos ~]# passwd wuhua</span><br><span class="line">更改用户 wuhua 的密码 。</span><br><span class="line">新的 密码：</span><br><span class="line">无效的密码： 密码未通过字典检查 - 它基于字典单词</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>创建的用户只有其home下的完整权限，若不需要超级权限此步骤可取消。</p><p>修改sudoers权限为可读可写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos ~]# whereis sudoers</span><br><span class="line">sudoers: /etc/sudoers /etc/sudoers.d /usr/share/man/man5/sudoers.5.gz</span><br><span class="line">[root@VM_0_10_centos ~]# ls -l /etc/sudoers</span><br><span class="line">-r--r----- 1 root root 3938 6月  27 02:07 /etc/sudoers</span><br><span class="line">[root@VM_0_10_centos ~]# chmod -v u+w /etc/sudoers</span><br><span class="line">mode of &quot;/etc/sudoers&quot; changed from 0440 (r--r-----) to 0640 (rw-r-----)</span><br><span class="line">[root@VM_0_10_centos ~]# vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere </span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">wuhua   ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>取消sudoers可写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos ~]# chmod -v u-w /etc/sudoers</span><br><span class="line">mode of &quot;/etc/sudoers&quot; changed from 0640 (rw-r-----) to 0440 (r--r-----)</span><br></pre></td></tr></table></figure><h3 id="新用户登陆"><a href="#新用户登陆" class="headerlink" title="新用户登陆"></a>新用户登陆</h3><p>若无上一步，无法以root权限操作，无法使用sudo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_10_centos ~]# exit</span><br><span class="line">登出</span><br><span class="line">Connection to 188.131.143.137 closed.</span><br><span class="line">wuhua:~ wuhua$ ssh -p 22 wuhua@188.131.143.137</span><br><span class="line">wuhua@188.131.143.137&apos;s password: </span><br><span class="line">[wuhua@VM_0_10_centos ~]$ pwd</span><br><span class="line">/home/wuhua</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ sudo su</span><br><span class="line"></span><br><span class="line">我们信任您已经从系统管理员那里了解了日常注意事项。</span><br><span class="line">总结起来无外乎这三点：</span><br><span class="line"></span><br><span class="line">    #1) 尊重别人的隐私。</span><br><span class="line">    #2) 输入前要先考虑(后果和风险)。</span><br><span class="line">    #3) 权力越大，责任越大。</span><br><span class="line"></span><br><span class="line">[sudo] wuhua 的密码：</span><br><span class="line">[root@VM_0_10_centos wuhua]#</span><br></pre></td></tr></table></figure><h2 id="nginx编译安装"><a href="#nginx编译安装" class="headerlink" title="nginx编译安装"></a>nginx编译安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>可通过<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a>选择版本，然后服务器端下载到/usr/local，此处选择最新稳定版1.14.0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos ~]$ wget -c https://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ tar -zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>全新服务器无编译器</p><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos nginx-1.14.0]$ sudo yum -y install gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure><h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><p>缺少pcre库，安装库<code>pcre-devel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos nginx-1.14.0]$ sudo yum -y install pcre-devel</span><br></pre></td></tr></table></figure><p>缺少zlib库，安装库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos nginx-1.14.0]$ sudo yum install -y zlib-devel</span><br></pre></td></tr></table></figure><h4 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h4><p>可选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module \  </span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf \</span><br><span class="line">--pid-path=/usr/local/nginx/conf/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure><p>自定义，安装到用户目录local文件夹nginx下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos nginx-1.14.0]$ ./configure --user=wuhua --group=wuhua --prefix=/home/wuhua/local/nginx --conf-path=/home/wuhua/local/nginx/conf/nginx.conf --pid-path=/home/wuhua/local/nginx/conf/nginx.pid --lock-path=/home/wuhua/local/nginx/nginx.lock --error-log-path=/home/wuhua/local/nginx/logs/error.log --http-log-path=/home/wuhua/local/nginx/logs/access.log --http-client-body-temp-path=/home/wuhua/local/nginx/client --http-proxy-temp-path=/home/wuhua/local/nginx/proxy --http-fastcgi-temp-path=/home/wuhua/local/nginx/fastcgi --http-uwsgi-temp-path=/home/wuhua/local/nginx/uwsgi --http-scgi-temp-path=/home/wuhua/local/nginx/scgi</span><br></pre></td></tr></table></figure><p>将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录，另外前两两项需要先创建好用户和用户组。</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos nginx-1.14.0]$ make &amp; make install</span><br></pre></td></tr></table></figure><p>若使用yum命令直接安装可使用<code>whereis nginx</code>查看安装的路径。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>主要修改<code>user</code>,<code>pid</code>,<code>error_log</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos conf]$ pwd</span><br><span class="line">/home/wuhua/local/nginx/conf</span><br><span class="line">[wuhua@VM_0_10_centos conf]$ cat nginx.conf</span><br><span class="line"></span><br><span class="line">user  wuhua;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line">pid   conf/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>worker_processes</code>根据文档提示一般设置为CPU核心数，或者<code>auto</code>启动时自动根据核心数设置worker进程数，nginx作为http服务器<code>worker_connenctions</code>*<code>worker_processes</code>/2 &lt;= max_client，nginx作为反向代理服务器<code>worker_connenctions</code>*<code>worker_processes</code>/4 &lt;= max_client。</p><p>参考<a href="https://www.kancloud.cn/wizardforcel/nginx-doc/92360" target="_blank" rel="noopener">Nginx 中文官方文档</a>,<a href="http://blog.51cto.com/liuqunying/1420556" target="_blank" rel="noopener">nginx 并发数问题思考</a></p><h3 id="为nginx的启动、重启、重载配置添加脚本"><a href="#为nginx的启动、重启、重载配置添加脚本" class="headerlink" title="为nginx的启动、重启、重载配置添加脚本"></a>为nginx的启动、重启、重载配置添加脚本</h3><h4 id="直接启动方法"><a href="#直接启动方法" class="headerlink" title="直接启动方法"></a>直接启动方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos sbin]$ pwd</span><br><span class="line">/home/wuhua/local/nginx/sbin</span><br><span class="line">[wuhua@VM_0_10_centos sbin]$ sudo ./nginx</span><br></pre></td></tr></table></figure><p>初次启动后可以查看conf目录下是否新增nginx.pid文件，里面保存有nginx的主进程号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos ~]$ pwd</span><br><span class="line">/home/wuhua</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ ps aux | grep nginx</span><br><span class="line">wuhua    15922  0.0  0.0 112720   984 pts/0    R+   15:32   0:00 grep --color=auto nginx</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ ls local/nginx/conf/</span><br><span class="line">fastcgi.conf          fastcgi_params.default  mime.types          nginx.conf.default   uwsgi_params</span><br><span class="line">fastcgi.conf.default  koi-utf                 mime.types.default  scgi_params          uwsgi_params.default</span><br><span class="line">fastcgi_params        koi-win                 nginx.conf          scgi_params.default  win-utf</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ sudo local/nginx/sbin/nginx </span><br><span class="line">[wuhua@VM_0_10_centos ~]$ ps aux | grep nginx</span><br><span class="line">root     15934  0.0  0.0  20548   608 ?        Ss   15:32   0:00 nginx: master process local/nginx/sbin/nginx</span><br><span class="line">wuhua    15935  0.0  0.0  23076  1380 ?        S    15:32   0:00 nginx: worker process</span><br><span class="line">wuhua    15938  0.0  0.0 112720   984 pts/0    R+   15:32   0:00 grep --color=auto nginx</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ ls local/nginx/conf/</span><br><span class="line">fastcgi.conf          fastcgi_params.default  mime.types          nginx.conf.default  scgi_params.default   win-utf</span><br><span class="line">fastcgi.conf.default  koi-utf                 mime.types.default  nginx.pid           uwsgi_params</span><br><span class="line">fastcgi_params        koi-win                 nginx.conf          scgi_params         uwsgi_params.default</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ cat local/nginx/conf/nginx.pid </span><br><span class="line">15934</span><br></pre></td></tr></table></figure><h4 id="添加脚本控制"><a href="#添加脚本控制" class="headerlink" title="添加脚本控制"></a>添加脚本控制</h4><blockquote><p>新建文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos sbin]$ sudo vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><blockquote><p>添加内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/home/wuhua/local/nginx/conf/nginx.pid</span><br><span class="line">ExecStartPre=/home/wuhua/local/nginx/sbin/nginx -t -c /home/wuhua/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/home/wuhua/local/nginx/sbin/nginx -c /home/wuhua/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/home/wuhua/local/nginx/sbin/nginx -s reload </span><br><span class="line">ExecStop=/home/wuhua/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/home/wuhua/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>systemctl的一些使用方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled servicename.service #查询服务是否开机启动</span><br><span class="line">systemctl enable xxx.service #开机运行服务</span><br><span class="line">systemctl disable xxx.service #取消开机运行</span><br><span class="line">systemctl start xxx.service #启动服务</span><br><span class="line">systemctl stop xxx.service #停止服务</span><br><span class="line">systemctl restart xxx.service #重启服务</span><br><span class="line">systemctl reload xxx.service #重新加载服务配置文件</span><br><span class="line">systemctl status xxx.service #查询服务运行状态</span><br><span class="line">systemctl --failed #显示启动失败的服务</span><br></pre></td></tr></table></figure><p>在使用前先刷新配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos ~]$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>关闭直接使用sbin/nginx打开的进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos ~]$ ps aux | grep nginx</span><br><span class="line">root     15934  0.0  0.0  20548   608 ?        Ss   15:32   0:00 nginx: master process local/nginx/sbin/nginx</span><br><span class="line">wuhua    15935  0.0  0.0  23076  1380 ?        S    15:32   0:00 nginx: worker process</span><br><span class="line">wuhua    16307  0.0  0.0 112720   984 pts/0    R+   15:38   0:00 grep --color=auto nginx</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ sudo kill 15934</span><br><span class="line">[sudo] wuhua 的密码：</span><br><span class="line">[wuhua@VM_0_10_centos ~]$ ps aux | grep nginx</span><br><span class="line">wuhua    16317  0.0  0.0 112720   984 pts/0    R+   15:38   0:00 grep --color=auto nginx</span><br><span class="line">[wuhua@VM_0_10_centos ~]$</span><br></pre></td></tr></table></figure><p>疑惑：</p><blockquote><p>此次配置过程中若未提前杀死使用nginx/sbin/nginx启动的nginx主进程，使用systemctl stop或者reload等操作无效。待探究。</p></blockquote><blockquote><p>添加脚本后centos7 中操作nginx的方法有</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled nginx.service #查询nginx是否开机启动</span><br><span class="line">systemctl enable nginx.service #开机运行nginx</span><br><span class="line">systemctl disable nginx.service #取消开机运行nginx</span><br><span class="line">systemctl start nginx.service #启动nginx</span><br><span class="line">systemctl stop nginx.service #停止nginx</span><br><span class="line">systemctl restart nginx.service #重启nginx</span><br><span class="line">systemctl reload nginx.service #重新加载nginx配置文件</span><br><span class="line">systemctl status nginx.service #查询nginx运行状态</span><br><span class="line">systemctl --failed #显示启动失败的服务</span><br></pre></td></tr></table></figure><blockquote><p>添加到开机自动启动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos ~]$ sudo systemctl enable nginx.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure><p>至此以安装成功，通过IP可访问显示nginx页面。</p><hr><h2 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h2><h3 id="安装（centos7默认mariadb）"><a href="#安装（centos7默认mariadb）" class="headerlink" title="安装（centos7默认mariadb）"></a>安装（centos7默认mariadb）</h3><p>单机不考虑分离，直接安装（作本地开发快速安装）,一般有单独的数据库服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ yum -y install mariadb mariadb-server</span><br></pre></td></tr></table></figure><h3 id="启动MariaDB并加入开机启动"><a href="#启动MariaDB并加入开机启动" class="headerlink" title="启动MariaDB并加入开机启动"></a>启动MariaDB并加入开机启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ sudo systemctl start mariadb</span><br><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ sudo systemctl enable mariadb</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.</span><br></pre></td></tr></table></figure><p>其他命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb #启动服务</span><br><span class="line">systemctl enable mariadb #设置开机启动</span><br><span class="line">systemctl restart mariadb #重新启动</span><br><span class="line">systemctl stop mariadb.service #停止MariaDB</span><br></pre></td></tr></table></figure><h3 id="初次登陆设置密码等"><a href="#初次登陆设置密码等" class="headerlink" title="初次登陆设置密码等"></a>初次登陆设置密码等</h3><p>登陆到数据库，初次登陆密码为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ mysql -uroot</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 2</span><br><span class="line">Server version: 5.5.60-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure><p>配置root密码，第一步密码为空，初次设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ sudo mysql_secure_installation</span><br><span class="line">[sudo] wuhua 的密码：</span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to log into MariaDB to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user.  If you&apos;ve just installed MariaDB, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line"></span><br><span class="line">Enter current password for root (enter for none): </span><br><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can log into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] y</span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">By default, a MariaDB installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MariaDB without having to have a user account created for</span><br><span class="line">them.  This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother.  You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;.  This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">By default, MariaDB comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access.  This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] y</span><br><span class="line"> - Dropping test database...</span><br><span class="line"> ... Success!</span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line"></span><br><span class="line">All done!  If you&apos;ve completed all of the above steps, your MariaDB</span><br><span class="line">installation should now be secure.</span><br><span class="line"></span><br><span class="line">Thanks for using MariaDB!</span><br></pre></td></tr></table></figure><h3 id="创建用户及设置权限"><a href="#创建用户及设置权限" class="headerlink" title="创建用户及设置权限"></a>创建用户及设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 13</span><br><span class="line">Server version: 5.5.60-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create user &apos;huagege&apos;@&apos;%&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; create user &apos;huagege&apos;@&apos;localhost&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to &apos;huagege&apos;@&apos;localhost&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to &apos;huagege&apos;@&apos;%&apos; identified by &apos;123456789&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; exit</span><br><span class="line">Bye</span><br><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$ mysql -uhuagege -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 14</span><br><span class="line">Server version: 5.5.60-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases</span><br><span class="line">    -&gt; ;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; exit</span><br><span class="line">Bye</span><br><span class="line">[wuhua@VM_0_10_centos multi-user.target.wants]$</span><br></pre></td></tr></table></figure><h3 id="配置Mariadb数据库字符"><a href="#配置Mariadb数据库字符" class="headerlink" title="配置Mariadb数据库字符"></a>配置Mariadb数据库字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在/etc/my.cnf中的mysqld标签下,新增字符设置:</span><br><span class="line">init_connect=&apos;SET collation_connection = utf8_unicode_ci&apos; </span><br><span class="line">init_connect=&apos;SET NAMES utf8&apos; character-set-server=utf8</span><br><span class="line"></span><br><span class="line">// 在/etc/my.cnf.d/client.cnf中的client标签下,新增字符设:</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">//在/etc/my.cnf.d/mysql-clients.cnf下的[mysql]标签下,新增字符设置:</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p>登陆mysql输入命令:</p><blockquote><p><code>show variables like &quot;%character%&quot;;show variables like &quot;%collation%&quot;;</code></p></blockquote><hr><h2 id="PHP编译安装"><a href="#PHP编译安装" class="headerlink" title="PHP编译安装"></a>PHP编译安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>可以通过<a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a>查看现有的版本，然后直接在服务器端下载源码包，此处选择最新版7.2.10，此源下载很慢，建议选择其他源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ wget -c http://cn2.php.net/distributions/php-7.2.10.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ tar -xvzf php-7.2.10.tar.gz</span><br><span class="line">[wuhua@VM_0_10_centos local]$ cd php-7.2.10</span><br></pre></td></tr></table></figure></p><h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><h4 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h4><p>根据之前的编译安装，centos7缺少的libmcrypt、mhash、mcrypt这三个库需要添加源才能下载到（源忘记了），使用的阿里云虚拟机可以直接下载安装。后续编译过程中根据所缺再增加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ yum -y install libmcrypt mhash mcrypt</span><br></pre></td></tr></table></figure></p><p>也可先运行直接全部安装所需库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ yum -y install wget vim pcre pcre-devel openssl openssl-devel libicu-devel gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses ncurses-devel curl curl-devel krb5-devel libidn libidn-devel openldap openldap-devel nss_ldap jemalloc-devel cmake boost-devel bison automake libevent libevent-devel gd gd-devel libtool* libmcrypt libmcrypt-devel mcrypt mhash libxslt libxslt-devel readline readline-devel gmp gmp-devel libcurl libcurl-devel openjpeg-devel bzip2-devel</span><br></pre></td></tr></table></figure></p><p>有些没有的话可以尝试更新源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo yum install epel-release</span><br><span class="line">[wuhua@VM_0_10_centos local]$ sudo yum update</span><br></pre></td></tr></table></figure></p><p>若源找不到对应库，也可直接将yum源更换为阿里云源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$ sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">[wuhua@VM_0_10_centos local]$ sudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">[wuhua@VM_0_10_centos local]$ sudo yum makecache</span><br></pre></td></tr></table></figure></p><h4 id="编译配置-1"><a href="#编译配置-1" class="headerlink" title="编译配置"></a>编译配置</h4><p>可用<code>./configure --help</code>查看配置项和说明，可查阅官网<a href="http://php.net/manual/zh/install.php" target="_blank" rel="noopener">http://php.net/manual/zh/install.php</a>和<a href="http://php.net/manual/zh/configure.about.php" target="_blank" rel="noopener">http://php.net/manual/zh/configure.about.php</a>以及源码包中的INSTALL文档。参考配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/php7 \</span><br><span class="line">--with-config-file-path=/usr/local/php7/etc \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--with-fpm-user=www \</span><br><span class="line">--with-fpm-group=www \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--enable-mysqlnd-compression-support \</span><br><span class="line">--with-iconv-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--enable-xml \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--with-curl \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-intl \</span><br><span class="line">--with-mcrypt \</span><br><span class="line">--with-libmbfl \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--with-gd \</span><br><span class="line">--enable-gd-jis-conv \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--enable-zip \</span><br><span class="line">--enable-soap \</span><br><span class="line">--with-gettext \</span><br><span class="line">--disable-fileinfo \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--with-pear \</span><br><span class="line">--enable-maintainer-zts \</span><br><span class="line">--with-ldap=shared \</span><br><span class="line">--without-gdbm</span><br></pre></td></tr></table></figure></p><p>将nginx、php-fpm运行在正在登录的wuhua用户，不选择相应配置项默认即为nobody。</p><p>最终配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos php-7.2.10]$  ./configure -prefix=/home/wuhua/local/php7 -with-config-file-path=/home/wuhua/local/php7/etc -with-config-file-scan-dir=/home/wuhua/local/php7/etc/conf.d -enable-fpm -enable-soap -with-openssl -with-openssl-dir -with-pcre-regex -with-zlib -with-iconv -with-bz2 -enable-calendar -with-curl -with-cdb -enable-dom -enable-exif -with-pcre-dir -enable-ftp -with-gd -with-jpeg-dir -with-png-dir -with-freetype-dir -with-gettext -with-gmp -with-mhash -enable-mbstring -with-libmbfl -with-onig -enable-pdo -with-pdo-mysql -with-zlib-dir -with-readline -enable-session -enable-shmop -enable-simplexml -enable-sockets -enable-sysvmsg -enable-sysvsem -enable-sysvshm -enable-wddx -with-libxml-dir -with-xsl -enable-zip -enable-mysqlnd -with-mysqli -enable-embedded-mysqli -enable-bcmath -enable-inline-optimization -enable-mbregex -enable-pcntl  -with-xmlrpc -enable-opcache</span><br></pre></td></tr></table></figure></p><p>注意：php7.2版本不支持–with-mcrypt, –enable-gd-native-ttf。在phh7.1时，官方就开始建议用openssl_*系列函数代替mcrypt_*系列的函数。7.2版本加上这两项配置无法通过的。</p><h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos php-7.2.10]$ make</span><br><span class="line">[wuhua@VM_0_10_centos php-7.2.10]$ make install</span><br><span class="line">[wuhua@VM_0_10_centos php-7.2.10]$ make test</span><br></pre></td></tr></table></figure><p>在阿里云低配服务器中编译安装报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual memory exhausted: 无法分配内存</span><br><span class="line">make: *** [ext/fileinfo/libmagic/apprentice.lo] 错误 1</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/kccdzz/p/8005944.html" target="_blank" rel="noopener">阿里云 virtual memory exhausted: 无法分配内存</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]$  free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         147         726           0         118         710</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[wuhua@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]$ sudo  dd if=/dev/zero of=/swap bs=1024 count=1M </span><br><span class="line">[sudo] wuhua 的密码：</span><br><span class="line">记录了1048576+0 的读入</span><br><span class="line">记录了1048576+0 的写出</span><br><span class="line">1073741824字节(1.1 GB)已复制，8.44555 秒，127 MB/秒</span><br><span class="line">[wuhua@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]$ sudo  mkswap /swap</span><br><span class="line">正在设置交换空间版本 1，大小 = 1048572 KiB</span><br><span class="line">无标签，UUID=2c71ba39-626b-4a40-92e0-531f102125fb</span><br><span class="line">[wuhua@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]$ sudo su</span><br><span class="line">[root@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]# swapon /swap </span><br><span class="line">swapon: /swap：不安全的权限 0644，建议使用 0600。</span><br><span class="line">swapon: /swap：swapon 失败: 设备或资源忙</span><br><span class="line">[root@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]#  echo &quot;/swap swap swap sw 0 0&quot; &gt;&gt; /etc/fstab</span><br><span class="line">[root@iZ2zeam0ijtd4z6q0e4y8eZ php-7.2.10]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            992         150          69           0         772         686</span><br><span class="line">Swap:          1023           0        1023</span><br></pre></td></tr></table></figure><h3 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h3><p>安装完成后直接运行<code>/usr/local/php7/sbin/php-fpm</code>会报错缺少配置的，需要进行相关的文件配置。<br>可以用编译后的配置文件复制到PHP7的配置目录（/usr/local/php7/etc/）。</p><h4 id="方法一：直接使用编译后未经优化处理的配置"><a href="#方法一：直接使用编译后未经优化处理的配置" class="headerlink" title="方法一：直接使用编译后未经优化处理的配置"></a>方法一：直接使用编译后未经优化处理的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos local]$  cp php-7.2.10/php.ini-production php7/etc/php.ini</span><br><span class="line">[wuhua@VM_0_10_centos local]$ sudo cp php-7.2.10/sapi/fpm/init.d.php-fpm /etc/php-fpm</span><br><span class="line">[wuhua@VM_0_10_centos etc]$ cp php-fpm.conf.default php-fpm.conf</span><br><span class="line">[wuhua@VM_0_10_centos php-fpm.d]$  cp www.conf.default www.conf</span><br></pre></td></tr></table></figure><h4 id="方法二：使用https-github-com-lizer2014-mylnmp-tree-master-PHP文中的配置"><a href="#方法二：使用https-github-com-lizer2014-mylnmp-tree-master-PHP文中的配置" class="headerlink" title="方法二：使用https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置"></a>方法二：使用<a href="https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置" target="_blank" rel="noopener">https://github.com/lizer2014/mylnmp/tree/master/PHP文中的配置</a></h4><p>参考博客<a href="https://typecodes.com/web/php7configure.html" target="_blank" rel="noopener">PHP7中php.ini、php-fpm和www.conf的配置</a></p><h4 id="修改php-ini参数"><a href="#修改php-ini参数" class="headerlink" title="修改php.ini参数"></a>修改php.ini参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos etc]$ vi php.ini</span><br></pre></td></tr></table></figure><p>extension_dir改为自己的，设置时区，开启OPcache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/extension_dir  //vi查找extension_dir配置</span><br><span class="line">extension_dir = &quot;/home/wuhua/local/php7/lib/php/extensions/no-debug-non-zts-20170718/&quot;</span><br><span class="line">/timezone       //vi查找timezone配置</span><br><span class="line">date.timezone =  PRC</span><br><span class="line"></span><br><span class="line">opcache.enable=1;</span><br></pre></td></tr></table></figure></p><h4 id="添加php的环境变量"><a href="#添加php的环境变量" class="headerlink" title="添加php的环境变量"></a>添加php的环境变量</h4><p>创建php.sh添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/wuhua/local/php7/bin/:/home/wuhua/local/php7/sbin/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos profile.d]$ sudo vim /etc/profile.d/php.sh</span><br><span class="line">[wuhua@VM_0_10_centos profile.d]$ source /etc/profile.d/php.sh</span><br><span class="line">[wuhua@VM_0_10_centos profile.d]$ php -v</span><br><span class="line">PHP 7.2.10 (cli) (built: Oct  8 2018 17:39:07) ( NTS )</span><br><span class="line">Copyright (c) 1997-2018 The PHP Group</span><br><span class="line">Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies</span><br></pre></td></tr></table></figure><h3 id="添加到centos7开机自动启动"><a href="#添加到centos7开机自动启动" class="headerlink" title="添加到centos7开机自动启动"></a>添加到centos7开机自动启动</h3><p>在系统服务目录里创建php-fpm.service文件</p><p>添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos profile.d]$ sudo vi /lib/systemd/system/php-fpm.service</span><br><span class="line">[sudo] wuhua 的密码：</span><br><span class="line">[wuhua@VM_0_10_centos profile.d]$ cat  /lib/systemd/system/php-fpm.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=php-fpm</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/home/wuhua/local/php7/sbin/php-fpm</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[wuhua@VM_0_10_centos profile.d]$</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wuhua@VM_0_10_centos profile.d]$ sudo systemctl enable php-fpm.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/php-fpm.service to /usr/lib/systemd/system/php-fpm.service.</span><br><span class="line">[wuhua@VM_0_10_centos profile.d]$</span><br></pre></td></tr></table></figure><p>当php-fpm启动时使用<code>systemctl start php-fpm.service</code>启动会报错，需要先<code>pa aux | grep php</code>查找对应的pid，杀死进程后再启动。</p><hr><h2 id="nginx配置fast-cgi并测试lnmp"><a href="#nginx配置fast-cgi并测试lnmp" class="headerlink" title="nginx配置fast-cgi并测试lnmp"></a>nginx配置fast-cgi并测试lnmp</h2><p><code>mkdir /var/www</code>新建www目录，<code>cp /usr/local/nginx/html/* /var/www</code>将nginx自带web目录内文件复制到www中，即将/var/www作为web目录。新建index.php，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//echo phpinfo();</span><br><span class="line">$servername = &quot;127.0.0.1&quot;;</span><br><span class="line">$username = &quot;huagege&quot;;</span><br><span class="line">$password = &quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    $conn = new PDO(&quot;mysql:host=$servername;dbname=huagege&quot;, $username, $password);</span><br><span class="line">    echo &quot;连接成功&quot;;</span><br><span class="line">&#125;</span><br><span class="line">catch(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>vi /usr/local/nginx/conf/nginx.conf</code>打开配置文件将root指令一一改为”/var/www”，注意php后缀解析的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /var/www;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">    root   /var/www;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /var/www;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /var/www$fastcgi_script_name;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试浏览器输入IP/index.php，显示成功连接数据库。由于之前将各项服务都加入到了开机启动，重启后再次访问仍然正常。至此，lnmp搭建完成。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> nginx </tag>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
            <tag> php7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-同步</title>
      <link href="/2018/05/05/Golang%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/05/05/Golang%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>传统并发程序对共享资源进行访问控制的主要手段，由标准库代码包sync中的Mutex结构体类型表示。其有两个公开的指针方法——Lock和Unlock，前者用于锁定当前的互斥量，后者用于对当前的互斥量进行解锁。</p><p>sync.Mutex类型的零值表示未锁定的互斥量。声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br></pre></td></tr></table></figure></p><p>一般在锁定互斥量后，紧接着使用defer语句保证该互斥锁的及时解锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br><span class="line"></span><br><span class="line">func write () &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    defer mutex.Unlock()</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁定操作和解锁操作应该成对出现，锁定了一个已锁定的互斥锁，进行重复锁定操作的goroutine将被阻塞，直到该互斥锁回到解锁状态。</p><p>code example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var mutex sync.Mutex</span><br><span class="line">fmt.Println(&quot;Lock the lock. (main)&quot;)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(&quot;The lock is locked. (main)&quot;)</span><br><span class="line">for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Lock the lock. (g%d)\n&quot;, i)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Printf(&quot;The lock is locked. (g%d)\n&quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(&quot;Unlock the lock. (main)&quot;)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">fmt.Println(&quot;The lock is unlocked. (main)&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lock]# go run repeatedlylock.go</span><br><span class="line">Lock the lock. (main)</span><br><span class="line">The lock is locked. (main)</span><br><span class="line">Lock the lock. (g1)</span><br><span class="line">Lock the lock. (g2)</span><br><span class="line">Lock the lock. (g3)</span><br><span class="line">Unlock the lock. (main)</span><br><span class="line">The lock is unlocked. (main)</span><br><span class="line">The lock is locked. (g1)</span><br></pre></td></tr></table></figure></p><p>对一个未锁定的互斥锁进行解锁操作，会引发一个运行时恐慌，Go 1.8之前可使用defer语句避免，Go 1.8开始此类恐慌变成不可恢复。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁即针对读写操作的互斥锁，可以针对读操作和写操作进行锁定和解锁操作。读写锁控制下的多个写操作都是互斥的，并且写操作与读操作之间也是互斥的，多个读操作之间不存在互斥关系。</p><p>读写锁由结构体sync.RWMutex表示，类型的零值已是可用的读写锁实例。包含两对方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (*RWMutex) Lock()</span><br><span class="line">func (*RWMutex) Unlock()</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (*RWMutex) RLock()</span><br><span class="line">func (*RWMutex) RUnlock()</span><br></pre></td></tr></table></figure></p><p>前一对方法的名称和签名与互斥锁的两个方法完全一致，分别代表对写操作的锁定（写锁定）和解锁（写解锁）。后一对方法表示了对读操作的锁定（读锁定）和解锁（读解锁）。</p><p>写解锁会试图唤醒所有因欲进行读操作而被阻塞的goroutine，读解锁只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写操作而被阻塞的goroutine。<code>对一个未被写锁定的读写锁进行写解锁，或者对一个未被读锁定的读写锁进行读解锁，都会引发一个不可恢复的运行时恐慌。</code></p><p>对于一个读写锁来说，施加于其上的读锁定可以有多个，只有对互斥锁进行等量的读解锁，才能够让某一个写锁定获得进行的机会，否则会使欲进行写锁定的gouroutine一直处于阻塞状态。</p><p>code example：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var rwm sync.RWMutex</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Try to lock for reading... [%d]\n&quot;, i)</span><br><span class="line">rwm.RLock()</span><br><span class="line">fmt.Printf(&quot;Locked for reading. [%d]\n&quot;, i)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">fmt.Printf(&quot;Try to unlock for reading... [%d]\n&quot;, i)</span><br><span class="line">rwm.RUnlock()</span><br><span class="line">fmt.Printf(&quot;Unlocked for reading. [%d]\n&quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * 100)</span><br><span class="line">fmt.Println(&quot;Try to lock for writing...&quot;)</span><br><span class="line">rwm.Lock()</span><br><span class="line">fmt.Println(&quot;Locked for writing.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost rlock]# go run rlock.go</span><br><span class="line">Try to lock for reading... [0]</span><br><span class="line">Try to lock for reading... [2]</span><br><span class="line">Locked for reading. [2]</span><br><span class="line">Try to lock for reading... [1]</span><br><span class="line">Locked for reading. [1]</span><br><span class="line">Locked for reading. [0]</span><br><span class="line">Try to lock for writing...</span><br><span class="line">Try to unlock for reading... [0]</span><br><span class="line">Unlocked for reading. [0]</span><br><span class="line">Try to unlock for reading... [2]</span><br><span class="line">Unlocked for reading. [2]</span><br><span class="line">Try to unlock for reading... [1]</span><br><span class="line">Unlocked for reading. [1]</span><br><span class="line">Locked for writing.</span><br></pre></td></tr></table></figure></p><p>sync.RWMutex类型还拥有一个指针方法——RLocker，该方法会返回一个实现了sync.Locker接口类型的值。该接口包含两个方法：Lock和Unlock，*sync.Mutex类型和*sync.RWMutex类型都是该接口类型的实现类型。调用读写锁的RLocker方法，得到的结果值是读写锁本身，结果值的Lock方法和Unlock方法分别对应了针对读写锁的读锁定操作和读解锁操作。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>标准库sync.Cond类型代表了条件变量，不同于互斥锁和读写锁，简单的声明无法创建一个可用的条件变量，需用sync.NewCond函数。函数声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func NewCond(l Locker) *Cond</span><br><span class="line">``` </span><br><span class="line">条件变量要与互斥量组合使用，sync.NewCond函数的唯一参数是sync.Locker类型，具体的参数值既可以是一个互斥锁也可以是一个读写锁。返回一个\*sync.Cond类型的结果值，该类型有3个方法，即：Wait、Signal和Broadcast，分别代表了等待通知、单发通知和广播通知的操作。</span><br><span class="line"></span><br><span class="line">Wait方法自动对与该条件变量关联的锁进行解锁，并使它所在的goroutine阻塞，一旦接收到通知该方法所在的goroutine就会被唤醒，该方法会立即尝试锁定该锁。方法Signal和BroadCast的作用都是发送通知，以唤醒正在为此阻塞的goroutine，前者目标只有一个，后者目标是所有。</span><br><span class="line"></span><br><span class="line">在只需对一个或多个临界区进行保护的时候，使用锁往往会使程序的性能损耗更小。</span><br><span class="line"></span><br><span class="line">## 原子操作</span><br><span class="line">原子操作即执行过程不能被中断的操作，针对某个值的原子操作执行过程当中，CPU绝不会再去执行其他针对该值的操作，无论这些操作是否为原子操作。</span><br><span class="line"></span><br><span class="line">Go提供的原子操作都是非侵入式的，由标准库代码包sync/atomic中的众多函数代表，可以通过调用这些函数对几种简单类型的值执行原子操作。类型包括int32、int64、uint32、uint64、uintptr和unsafe.Pointer。这些函数提供的原子操作共有5种：增或减、比较并交换、载入、存储和交换。分别提供了不同的功能，且适用的场景也有所区别。</span><br><span class="line">### 增或减</span><br><span class="line">用于增或减的原子操作（原子增/减操作）的函数名都以 “Add”为前缀，后跟针对具体类型的名称。原子增/减操作可实现被操作值的增大或减小。被操作值的类型只能是数值类型(int32、int64、uint32、uint64和uintptr)。例如对int32类型的变量i32的值增大3：</span><br><span class="line">```code</span><br><span class="line">mewi32 := atomic.AddInt32(&amp;i32, 3)</span><br></pre></td></tr></table></figure></p><p>对于不能被取址的数值无法进行原子操作，函数第二个参数的类型与被操作值的类型总是相同的。类似函数有atomic.AddInt64、atomic.AddUint32、atomic.AddUint64和atomic.AddUintptr。因atomic.AddUint32、atomic.AddUint64的第二个参数类型分别是uint32和uint64，无法传入通过传入一个负的数值来减小被操作值。可利用二进制补码的特性解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic.AddUint32(&amp;uint32, ^uint32(-NN-1))</span><br><span class="line">atomic.AddUint64(&amp;uint64, ^uint64(-NN-1))</span><br><span class="line">//NN代表一个负整数</span><br></pre></td></tr></table></figure></p><p>负整数的补码可通过对它按位（除符号位）求反码并加一得到，一个负整数可由对它的绝对值减一并求补码后得到的数值的二进制形式表示。</p><blockquote><p>uint32(int32(NN)) = ^uint32(-NN-1)</p></blockquote><p>不存在名为atomic.AddPointer的函数，unsafe.Pointer类型的值无法被加减。</p><h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><p>Compare And Swap简称CAS，在sync/atomic包中，此类原子操作名称以“CompareAndSwap”为前缀的若干函数代表。<br>针对int32类型值的函数声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</span><br><span class="line">```  </span><br><span class="line">接受3个参数，参数一的值指向被操作值的指针值，类型为*int32。后两个参数分别代表操作的旧值和新值，类型为int32。函数被调用之后，会先判断参数addr指向的被操作值与参数old的值是否相等，判断结果为true，函数会用参数new代表的新值替换旧值，否则替换操作被忽略。函数结果swapped表示是否进行了值的替换操作。</span><br><span class="line"></span><br><span class="line">CAS操作总是假设被操作值未曾改变（即与旧值相等），并一旦确认假设的真实性就立即进行值替换。不同于锁更加谨慎的做法，总是假设会有并发的操作修改被操作值，使用锁将相关操作放入临界区中加以保护。使用锁趋于悲观，CAS趋于乐观。</span><br><span class="line"></span><br><span class="line">CAS可以在不创建互斥量和不形成临界区的情况下，完成并发安全的值替换操作。可以减少同步对程序性能的损耗。但在被操作的值频繁变更的情况下，CAS操作并不容易成功。有时需要使用for循环进行多次尝试。CAS操作不会让goroutine阻塞，但是仍可能使流程的执行暂时停滞，停滞大都极为短暂。若想并发安全的更新一些类型的值，总是优先选择CAS操作。</span><br><span class="line"></span><br><span class="line">### 载入</span><br><span class="line">sync/atomic代码包提供一系列函数可以原子地读取某个值，以“Load”为前缀。以int32类型为例：</span><br><span class="line">```code</span><br><span class="line">func addValue(delta int32) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        v := atomic.LoadInt32(&amp;value)</span><br><span class="line">        if atomic.CompareAndSwapInt32(&amp;value, v, (v + delta))&#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>atomic.LoadInt32接受一个*int32类型的指针值，返回该指针值指向的那个值。此示例原子地读取变量value的值并把它赋给变量v。在读取value时，当前计算机中的任何CPU都不会进行其他针对此值的读写操作。赋值语句和其后的if语句并不会原子地执行，在它们执行期间，CPU仍然可能进行其他针对value的读写操作，即value的值仍然能会被改变。所以if语句仍然需要CAS操作。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>对应读取操作的写入操作，sync/atomic包提供了对应的存储函数，函数名称以“Store”为前缀。</p><p>在原子地存储某个值的过程中，任何CPU都不会进行针对同一个值的读写操作。若把所有针对此值的写操作都改为原子操作，可避免出现针对此值的读操作因被并发地进行，而读到修改了一半的值的情况。</p><p>原子的值存储操作总会成功，不关心存储的值的旧值是什么。例atomic.StoreInt32接受两个参数，参数一的类型是*int32，指向被操作数的指针值，参数二是int32类型，值是欲存储的新值。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>sync/atomic代码包存在一类函数与前文的CAS操作和原子载入操作相似，称为“原子交换操作”，名称以“Swap”为前缀。</p><p>不同于CAS，原子交换操作不关心被操作值的旧值，直接设置新值，比原子存储操作多了一步：返回被操作值的旧值，比CAS操作的约束更少，比原子载入操作的功能更强。</p><p>例atomic.SwapInt32函数，接受两个参数，参数一代表被操作值的内存地址的*int32类型值，参数二表示新值。函数结果值表示该新值替换掉的旧值。该函数调用后，会把参数二的值置于参数一所表示的内存地址上，并将之前在该地址上的那个值作为结果返回。</p><p>若想以并发安全的方式操作特定的简单类型值，应首先考虑使用这些函数实现。</p><h3 id="原子值"><a href="#原子值" class="headerlink" title="原子值"></a>原子值</h3><p>sync/atomic.Value是一个结构体类型，暂且称为“原子值类型”。用于存储需要原子读写的值。不同于sync/atomic包中的其他函数，sync/atomic.Value可接受的被操作值的类型不限。简单声明即可得到一个可用的原子值实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var atomicVal atomic.Value</span><br></pre></td></tr></table></figure></p><p>该类型包含两个指针方法——Load和Store。前者用于原子地读取原子值实例中存储的值，返回一个interface{}类型的结果且不接受任何参数。后者用于原子地在原子值实例中存储一个值，接受一个interface{}类型的参数而没有返回结果。在未曾通过Store方法向原子值实例存储值之前，它的Load方法总会返回nil。</p><p>原子值实例的Store方法参数值不能为nil，参数传入该方法的值与之前传入的值（若有）的类型相同。即一旦原子值实例存储了某一个类型的值，它之后存储的值就必须是该类型的。违反上述条件会引发一个运行时恐慌。</p><p>sync/atomic.Value类型的变量一旦被声明，其值就不应该复制到它处。<code>作为源值赋给变量、作为参数值传入函数、作为结果值从函数中返回、作为元素值通过通道传递等都会造成值的复制</code>，这些变量之上不应该施加这些操作。不会造成编译错误，但标准工具go  vet会报告此类不正确（具有安全隐患）的用法。sync/atomic.Value类型的指针类型的变量不存在此问题。因结构体值的复制不但会生成该值的副本，还会生成其中字段的副本，使施加于此的并发安全保护失效。向副本存储值的操作与原值无关。</p><p>对于sync包中的Mutex、RWMutex和Cond类型，go vet命令同样检查此类复制问题，解决方案是避免使用它们而是使用它们的指针值。</p><p>原子值的读写操作必是原子的，不受操作值类型的限制，比原子函数的适用场景大，某些时候可以完美替换。</p><p><code>检测程序是否存在竞态条件，可在运行或者测试程序的时候追加-race标记。监测结果会被打印到输出中。</code></p><h2 id="只会执行一次"><a href="#只会执行一次" class="headerlink" title="只会执行一次"></a>只会执行一次</h2><p>sync提供了具有特色的结构体类型sync.Once和它的Do方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var once sync.Once</span><br><span class="line">once.Do(func()&#123;fmt.Println(&quot;Once!&quot;)&#125;)</span><br></pre></td></tr></table></figure></p><p>Do接受一个无参数、无结果的函数值作为其参数，方法一旦被调用，就会去调用作为参数的那个函数。</p><p>对同一个sync.Once类型值的Do方法的有效调用次数永远会是1。无论调用这个方法多少次，无论在多次调用时传递给它的参数值是否相同，都仅有第一次调用是有效的，值有第一次调用该方法传递给它的那个函数会执行。</p><p>典型应用场景是执行仅需执行一次的任务，这样的任务并不适合在init函数中执行。例如数据库连接池的建立、全局变量的延迟初始化等。</p><p><code>sync.Once类型提供的功能由互斥锁和原子操作实现。使用的技巧包括卫述语句、双重检查锁定，以及对共享标记的原子读写操作。</code></p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>sync.WaitGroup类型的值是并发安全的，声明后即可使用，有3个指针方法：Add、Done和Wait。</p><p>sync.WaitGroup是一个结构体类型，有一个代表计数的字节数组类型的字段，该字段用4字节表示给定的计数，另用4字节表示等待计数。当一个sync.WaitGroup类型的变量被声明之后，这两个计数都会是0。通过该值的Add方法增大或减少给定计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(3)</span><br><span class="line">wg.Add(-3)</span><br></pre></td></tr></table></figure></p><p>不能让给定计数变为负数，会引发一个运行时恐慌，意味着对sync.WaitGroup类型值的错误使用。</p><p>也可通过该值的Done方法使其中的给定计数值减一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wg.Done()</span><br><span class="line">wg.Done()</span><br><span class="line">wg.Done()</span><br></pre></td></tr></table></figure></p><p>同Add方法不能使给定计数变为负数。</p><p>当调用sync.WaitGroup类型值的Wait方法时，它会去检查给定计数，若该计数为0，该方法会立即返回，且不会对程序的运行产生任何影响。若计数大于0，该方法调用所在的goroutine会阻塞，同时等待计数会加1。直到该值的Add方法或Done方法被调用时发现给定计数变为0，该值才去区唤醒因此而阻塞的所有goroutine，同时清零等待计数。不论时Add方法还是Done方法，唤醒的goroutine是在从给定计数最近一次从0变为正整数到此时（给定计数重新变为0时）的时间段内，执行当前值的Wait方法的goroutine。</p><p><code>sync.WaitGroup类型值一般用于协调多个goroutine的运行。</code></p><p>使用规则：  </p><ul><li>对同一sync.WaitGroup类型值的Add方法的第一次调用，发生在调用该值的Done方法和Wait方法之前。</li><li>在一个sync.WaitGroup类型值的生命周期内，其中的给定计数总是由起初的0变为某个正整数（或先后变为某几个正整数），然后再归为0。把完成这样一个变化所用的时间称为一个计数周期。</li><li>给定计数的每次变化都是由对Add方法或Done方法的调用引起的。</li><li>sync.WaitGroup类型值可以复用。此类型的生命周期可以包含任意个计数周期。一个sync.WaitGroup类型值在其每个计数周期中的状态和作用都是独立的。</li></ul><p><code>对于sync.WaitGroup类型的值，也时不应该复制的，在必要时使用go vet命令检查使用此类型值的方式是否正确。</code></p><h2 id="临时对象池"><a href="#临时对象池" class="headerlink" title="临时对象池"></a>临时对象池</h2><p>可将sync.Pool类型值看作存放临时值的容器。此类容器是自动伸缩的、高效的、并发安全的。为描述方便将sync.Pool类型的值称为“临时对象池”，存于其中的值称为“对象值”。</p><p>使用符合字面量初始化一个临时对象池的时候，可以为它唯一的公开字段New赋值。该字段类型是func () interface {}，即一个函数类型。赋给该字段的值会被临时对象池用来创建对象值。该函数一般仅在池中无可用对象值的时候才被调用。把这个函数称为“对象值生成函数”。</p><p>sync.Pool类型有两个公开的指针方法——Get和Put。前者从池中获取一个interface {}类型的值，后者则是把一个interface {}类型的值放置于池中。</p><p>通过Get方法获取到的值是任意的。若一个临时对象池的Put方法未被调用过,且它的New字段也未曾被赋予一个非nil的函数值，那么它的Get方法返回的结果就一定是nil。Get方法回返的不一定就是存在于池中的值，若结果值是池中的，那么在该方法返回它之前，就一定会把它从池中删除。功能上类似一个通用的缓冲池。</p><p>临时对象池的第一个特征，临时对象池可以把其中的对象值产生的存储压力进行分摊。它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，一般会先尝试从与本地P对应的本地私有池和本地共享池中或取一个对象值。若获取失败，会尝试从其他P的本地共享池中偷取一个对象值并直接返回给调用方。若仍未获取，只能希望寄托于当前临时对象池的对象值生成函数。对象值生成函数产生的对象值永远不会被放置到池中，而是被直接返回给调用方。临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。即它们随时会被偷走。</p><p>临时对象池的第二个特征是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。即使我们永远不会显示地从临时对象池取走某个对象值,该对象也不会永远待在临时对象池中，它的声明周期取决于垃圾回收任务下一次的执行时间。</p><p>不用该对从临时对象池中获取的值有任何假设，因其可能是池中的任何一个值，也可能是对象值生成函数产生的值。</p><p><code>临时对象池的实例也不应该被复制，否则go vet命令将报告此问题。</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
            <tag> 原子操作 </tag>
            
            <tag> 条件变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-channel</title>
      <link href="/2018/05/02/Golang%E7%AC%94%E8%AE%B0-channel/"/>
      <url>/2018/05/02/Golang%E7%AC%94%E8%AE%B0-channel/</url>
      
        <content type="html"><![CDATA[<p>channel——提倡“以通信作为手段来共享内存”最直接和最重要的体现。<br>Go使用通道类型值在不同的goroutine之间传递值。channel类似一个类型安全的通用型管道。</p><p>channel提供了一种机制，既可以同步两个并发执行的函数，又可以让这两个函数通过相互传递特定类型的值来通信。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>channel既值通道类型，指代可以传递某种类型的值的通道。通道即某一个通道类型的值，是该类型的一个实例。</p><h3 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1.类型表示法"></a>1.类型表示法</h3><p>属于引用类型。泛化的通道类型的声明：</p><blockquote><p><code>chan T</code></p></blockquote><p>声明别名类型：</p><blockquote><p><code>chan IntChan chan int</code></p></blockquote><p>声明一个chan int类型的变量：</p><blockquote><p><code>var intChan chan int</code></p></blockquote><p>通道类型是双向的，既可以向此类通道发送元素值，也可以从那里接收元素值。使用<code>&lt;-</code>接收操作符声明单向的通道类型，下面会i只能用于发送值的通道类型的泛化表示：</p><blockquote><p><code>chan &lt;- T</code>    //发送通道类型</p></blockquote><p>声明只能从其中接收元素值的通道类型：</p><blockquote><p><code>&lt;-chan T</code>     //接收通道类型</p></blockquote><h3 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2.值表示法"></a>2.值表示法</h3><p>通道类型的变量在被初始化前，值为nil。通道类型的变量是用来传递值的而不是存储值的。通道类型并没有对应的值表示法。其值具有即时性，无法准确用字面量来表达。</p><h3 id="3-操作的特性"><a href="#3-操作的特性" class="headerlink" title="3.操作的特性"></a>3.操作的特性</h3><p>通道是在多个goroutine之间传递数据和同步的重要手段，对通道操作的本身也是同步的。在同一时刻，仅有一个goroutine能向一个通道发送元素值，同时也仅有一个goroutine能从它那里接收元素值。通道中，各个元素值都是严格按照发送到此的先后顺序排列的，最早发送至通道的元素值会最先被接收。通道相当于一个FIFO的消息队列。通道中的元素具有原子性，是不可被分割的。通道中的每一个元素值都只可能被某一个goroutine接收，已被接受的值会立刻从通道中删除。</p><h3 id="4-初始化通道"><a href="#4-初始化通道" class="headerlink" title="4.初始化通道"></a>4.初始化通道</h3><p>引用类型的值都需要内建函数make来初始化。</p><blockquote><p><code>make(chan int, 10)</code></p></blockquote><p>初始化一个在同一时刻最多可以缓冲10个元素值且元素类型为int的通道类型。</p><blockquote><p><code>make(chan int)</code></p></blockquote><p>一个通道值的缓冲容量总是固定不变的，省略参数二意味着初始化的这个通道永远无法缓冲任何元素值。发送给它的元素值应该被立刻取走，否则发送方的goroutine就会暂停（阻塞），直到有接收方接收这个元素值。</p><p>将第二个参数值大于0的通道称为缓冲通道，未给定第二个参数值或给定值为0的通道称为非缓冲通道。</p><h3 id="5-接收元素值"><a href="#5-接收元素值" class="headerlink" title="5.接收元素值"></a>5.接收元素值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strChan := make(chan string, 3) //声明一个双向通道类型strChan</span><br><span class="line"></span><br><span class="line">elsm, ok := &lt;- strChan</span><br><span class="line">elem := &lt;- strChan //从该通道中接收元素值，无值时goroutine被阻塞直到有值时被唤醒</span><br></pre></td></tr></table></figure><p>从未初始化的通道中接收值会造成当前goroutine永久阻塞。</p><h3 id="6-Happens-before"><a href="#6-Happens-before" class="headerlink" title="6.Happens before"></a>6.Happens before</h3><p>对于一个缓冲通道有：  </p><ul><li>发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，则阻塞正在进行发送操作的goroutine。复制的目的地址有两种。当通道已空且有接收方在等待元素值时，它会是最早等待的那个接收方持有的内存地址，否则会是通道持有的缓冲中的内存地址。</li><li>接收操作会使通道给出一个已发送它的元素值的副本，若因通道的缓冲空间已空而无法立即给出，则阻塞正在进行接收操作的goroutine。一般情况下，接收方会从通道持有的缓冲中得到元素值。</li><li>对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道中接收它的操作完成之前完成。在通道完全复制一个元素值之前，任何goroutine都不可能从它那里接收到这个元素值的副本。</li></ul><h3 id="7-发送元素值"><a href="#7-发送元素值" class="headerlink" title="7.发送元素值"></a>7.发送元素值</h3><p>对接收操作符&lt;-两边的表达式的求值会先于发送操作执行，在对两个表达式求值完成之前，发送操作被阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var strChan = make(chan string, 3)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">syncChan1 := make(chan struct&#123;&#125;, 1)</span><br><span class="line">syncChan2 := make(chan struct&#123;&#125;, 2)</span><br><span class="line">go func() &#123; // 用于演示接收操作。</span><br><span class="line">&lt;-syncChan1</span><br><span class="line">fmt.Println(&quot;Received a sync signal and wait a second... [receiver]&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">for &#123;</span><br><span class="line">if elem, ok := &lt;-strChan; ok &#123;</span><br><span class="line">fmt.Println(&quot;Received:&quot;, elem, &quot;[receiver]&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Stopped. [receiver]&quot;)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123; // 用于演示发送操作。</span><br><span class="line">for _, elem := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; &#123;</span><br><span class="line">strChan &lt;- elem</span><br><span class="line">fmt.Println(&quot;Sent:&quot;, elem, &quot;[sender]&quot;)</span><br><span class="line">if elem == &quot;c&quot; &#123;</span><br><span class="line">syncChan1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(&quot;Sent a sync signal. [sender]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Wait 2 seconds... [sender]&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">close(strChan)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sent: a [sender]</span><br><span class="line">Sent: b [sender]</span><br><span class="line">Sent: c [sender]</span><br><span class="line">Sent a sync signal. [sender]</span><br><span class="line">Received a sync signal and wait a second... [receiver]</span><br><span class="line">Received: a [receiver]</span><br><span class="line">Received: b [receiver]</span><br><span class="line">Received: c [receiver]</span><br><span class="line">Received: d [receiver]</span><br><span class="line">Sent: d [sender]</span><br><span class="line">Wait 2 seconds... [sender]</span><br><span class="line">Stopped. [receiver]</span><br></pre></td></tr></table></figure></p><p>由于运行时系统的调度，每次运行的输出语句顺序可能不同。</p><p>syncChan通道是为了不让主goroutine过早地结束运行。一旦goroutine过早的结束运行，Go程序的运行也就结束了。main函数最后试图从syncChan接收值两次，接收完成之前主goroutine阻塞于此。两个goroutine都像syncChan发送值后，主goroutine恢复运行，随后结束运行。</p><p>syncChan1和syncChan2的元素类型都是struct{}。代表的是不包含任何字段的结构体类型，也称空结构体类型。空结构体的变量不占内存空间，并且所有该类型的变量都拥有相同的内存地址。建议用于传递“信号”的通道都用struct{}作为元素类型，除非需要传递更多的信息。</p><p>向一个值为nil的通道类型的变量发送元素值时，当前goroutine也会被永久的阻塞。若试图从一个已关闭的通道中发送元素值，会立即引发一个运行时恐慌，即使发送通道正在因通道已满而被阻塞。为避免此类流程中段可以在select代码块中执行发送操作。</p><p>若由多个goroutine向同一个已满的通道发送元素值而被阻塞，那么当该通道中有多余空间的时候，最早被阻塞的goroutine会最先被唤醒。对接收操作也是如此。运行时系统每次只会唤醒一个goroutine。</p><p>发送方向通道发送的值会被复制，接收方接收的总是该值的副本，而不是该值本身。通道的缓冲队列属于环形队列。当接收方从通道接收到一个类型的值时，对该值的修改不会影响发送方持有的源值。</p><h3 id="8-关闭通道"><a href="#8-关闭通道" class="headerlink" title="8.关闭通道"></a>8.关闭通道</h3><p>通过调用内建函数close关闭通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(strChan)</span><br></pre></td></tr></table></figure></p><blockquote><p><code>不应该在接收端关闭通道</code>，因无法判断发送端是否还会向该通道发送元素值。在发送端调用close以关闭通道不会对接收端接收该通道中已有的元素值产生任何影响。</p></blockquote><p>调用close函数的作用是告诉运行时系统不应该再允许任何针对被关闭的通道的发送操作，该通道即将被关闭。调用close函数只是让相应的通道进入关闭状态而不是立即阻止对它的一切操作。</p><blockquote><p>对同一个通道仅允许关闭一次，对通道的重复关闭会引起运行时恐慌。调用close函数时的参数值是一个值为nil的通道类型的变量也会引发运行时恐慌。</p></blockquote><h3 id="长度与容量"><a href="#长度与容量" class="headerlink" title="长度与容量"></a>长度与容量</h3><p>内建函数len和cap可作用于通道之上，分别获取当前通道中的元素值数量（长度）和通道可容纳元素值的最大数量（容量）。通道的容量再初始化时已经确定，并且之后不能改变，通道的长度会随实际情况改变。</p><p>容量为0的通道为非缓冲通道，否则为缓冲通道。</p><h2 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h2><p>单向通道可分为发送通道和接收通道，无论哪一种都不应该出现在变量的声明中。单向通道应由双向通道变换而来，可以用这种变换来约束程序对通道的使用方式。例如os/isgnal.Notify函数的声明：</p><blockquote><p><code>func Notify(c chan &lt;- os.Signal, sig ...os.Signal)</code></p></blockquote><p>第一个参数的类型是发送通道类型，调用时应该传入一个双向通道，自动把它转换为单向通道。Notify函数中的代码只能向通道c发送元素值，而不能从其中接收元素值。从该通道c中接收元素值会造成编译错误。函数之外不受此约束。但Notify函数对c进行发送操作，函数外的代码应该对其进行接收操作，函数外的发送操作会造成干扰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var strChan = make(chan string, 3)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">syncChan1 := make(chan struct&#123;&#125;, 1)</span><br><span class="line">syncChan2 := make(chan struct&#123;&#125;, 2)</span><br><span class="line">go receive(strChan, syncChan1, syncChan2) // 用于演示接收操作。</span><br><span class="line">go send(strChan, syncChan1, syncChan2)    // 用于演示发送操作。</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func receive(strChan &lt;-chan string,</span><br><span class="line">syncChan1 &lt;-chan struct&#123;&#125;,</span><br><span class="line">syncChan2 chan&lt;- struct&#123;&#125;) &#123;</span><br><span class="line">&lt;-syncChan1</span><br><span class="line">fmt.Println(&quot;Received a sync signal and wait a second... [receiver]&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">for &#123;</span><br><span class="line">if elem, ok := &lt;-strChan; ok &#123;</span><br><span class="line">fmt.Println(&quot;Received:&quot;, elem, &quot;[receiver]&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Stopped. [receiver]&quot;)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func send(strChan chan&lt;- string,</span><br><span class="line">syncChan1 chan&lt;- struct&#123;&#125;,</span><br><span class="line">syncChan2 chan&lt;- struct&#123;&#125;) &#123;</span><br><span class="line">for _, elem := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; &#123;</span><br><span class="line">strChan &lt;- elem</span><br><span class="line">fmt.Println(&quot;Sent:&quot;, elem, &quot;[sender]&quot;)</span><br><span class="line">if elem == &quot;c&quot; &#123;</span><br><span class="line">syncChan1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(&quot;Sent a sync signal. [sender]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Wait 2 seconds... [sender]&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">close(strChan)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用单向通道改进发送元素值demo，此代码对接收和发送进行了参数约束，规定了参数中通道的方向。</p><blockquote><p>通道允许的数据传递方向是其类型的一部分，对于两个通道类型而言，数据传递方向的不同，意味着它们类型的不同。利用函数声明将双向通道转换为单向通道的做法，只是一个语法糖，不能利用函数声明将一个单向通道转换成双向通道，这样做会得到一个编译错误。</p></blockquote><h2 id="for语句与channel"><a href="#for语句与channel" class="headerlink" title="for语句与channel"></a>for语句与channel</h2><p>使用for语句的range子句持续地从一个通道接收元素值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int</span><br><span class="line">//todo</span><br><span class="line">for e := range ch &#123;</span><br><span class="line">fmt.Printf(&quot;Element:%v\n&quot;, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>range子句的迭代目标不能是一个发送通道，同从发送通道中接收元素值会造成一个编译错误。</p><p>从还未初始化的通道中接收元素值会导致当前goroutine的永久阻塞，使用for语句会阻塞在range子句处。</p><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select语句是一种仅能用于通道发送和接收操作的专用语句。一条select语句执行时，会选择其中的某一个分支并执行。类似switch语句但选择分支的方法完全不同。</p><h3 id="组成和编写方法"><a href="#组成和编写方法" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h3><p>每个分支以case开始，跟在每个case后面的只能是针对某个通道的发送语句或接收语句，在select关键字后没有像switch语句那样的表达式，直接跟花括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var intChan = make(chan int, 10)</span><br><span class="line">var strChan = make(chan string, 10)</span><br><span class="line">select &#123;</span><br><span class="line">case e1 := &lt;-intChan:</span><br><span class="line">fmt.Printf(&quot;The first case was selected.e1=%v.\n&quot;, e1)</span><br><span class="line">case e2 := &lt;-strChan:</span><br><span class="line">fmt.Printf(&quot;The second case was selected.e2=%v.\n&quot;, e2)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Default!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>select语句中所有普通case都不满足选择条件，default case会被选中。</p><h3 id="分支选择规则"><a href="#分支选择规则" class="headerlink" title="分支选择规则"></a>分支选择规则</h3><p>在开始执行select语句时，所有根在case关键字后的发送语句或接收语句中的通道表达式和元素表达式都会先求值（求之顺序从左到右、自上而下），无论它们所在的case是否有可能被选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var intChan1 chan int</span><br><span class="line">var intChan2 chan int</span><br><span class="line">var channels = []chan int&#123;intChan1, intChan2&#125;</span><br><span class="line"></span><br><span class="line">var numbers = []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case getChan(0) &lt;- getNumber(0):</span><br><span class="line">fmt.Println(&quot;The 1th case is selected.&quot;)</span><br><span class="line">case getChan(1) &lt;- getNumber(1):</span><br><span class="line">fmt.Println(&quot;The 2nd case is selected.&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Default!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getNumber(i int) int &#123;</span><br><span class="line">fmt.Printf(&quot;numbers[%d]\n&quot;, i)</span><br><span class="line">return numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getChan(i int) chan int &#123;</span><br><span class="line">fmt.Printf(&quot;channels[%d]\n&quot;, i)</span><br><span class="line">return channels[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channels[0]</span><br><span class="line">numbers[0]</span><br><span class="line">channels[1]</span><br><span class="line">numbers[1]</span><br><span class="line">Default!</span><br></pre></td></tr></table></figure></p><p>因为intChan1和intChan2未被初始化，向它们发送的元素值会永久阻塞，即两个case语句被阻塞，select语句执行default case，才会有最后一行输出。</p><p>执行select语句时，运行时系统会自上而下地判断每个case中的发送或接收操作是否可以立即执行（当前goroutine不会因此操作而被阻塞    ）。需要依据通道的具体特性（缓冲或非缓冲）以及那一刻的具体情况来进行。只要发现有一个case上的判断是肯定的该case就会被选中。</p><blockquote><p>当有一个case被选中时，运行时系统就会执行该case及其包含的语句，而其他case会被忽略。若同时有多个case满足条件，那么运行时系统会通过一个伪随机数算法选中一个case。若所有case都不满足选择条件并且没有default case，那么当前goroutine就会一直被阻塞于此，直到至少有一个case中的发送或接收操作可以立即进行为止。</p></blockquote><p>一条select语句只能包含一个default case，可以放置在该语句的任何位置上。</p><h3 id="与for语句的连用"><a href="#与for语句的连用" class="headerlink" title="与for语句的连用"></a>与for语句的连用</h3><p>实际场景中常常把select语句放到一个单独的goroutine中执行，即使select语句被阻塞，也不会造成死锁。常与for语句连用以便持续操作其中的通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intChan := make(chan int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">intChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(intChan)</span><br><span class="line">syncChan := make(chan struct&#123;&#125;, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">Loop:</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case e, ok := &lt;-intChan:</span><br><span class="line">if !ok &#123;</span><br><span class="line">fmt.Println(&quot;End.&quot;)</span><br><span class="line">break Loop</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Received: %v\n&quot;, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">syncChan &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-syncChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Received: 0</span><br><span class="line">Received: 1</span><br><span class="line">Received: 2</span><br><span class="line">Received: 3</span><br><span class="line">Received: 4</span><br><span class="line">Received: 5</span><br><span class="line">Received: 6</span><br><span class="line">Received: 7</span><br><span class="line">Received: 8</span><br><span class="line">Received: 9</span><br><span class="line">End.</span><br></pre></td></tr></table></figure></p><h2 id="非缓冲的channel"><a href="#非缓冲的channel" class="headerlink" title="非缓冲的channel"></a>非缓冲的channel</h2><p>初始化通道时将其容量设置为0或直接忽略对容量的设置，会使该通道成为一个非缓冲通道。不同于<code>以异步的方式传递元素值的缓冲通道</code>，非缓冲通道只能<code>同步地传递元素值</code>。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens    before"></a>happens    before</h3><p>特别之处：  </p><ul><li>向此类通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接收操作进行为止。接收操作先得到元素值的副本，在唤醒发送方的goroutine之后返回。即此时接收操作会在对应的发送操作完成之前完成。</li><li>从此类通道接收元素值的操作会被阻塞，直到至少有一个针对该通道的发送操作进行为止。发送操作直接把元素值复制给接收方，然后在唤醒接收方所在的goroutine之后返回。即此时的发送操作会在对应的接收操作完成之前完成。</li></ul><p>只有在针对非缓冲通道的发送方和接收方“握手”之后，元素值的传递才会进行，然后双方的操作才能进行。如果发送方或/和接收方有多个，需要排队握手。</p><h3 id="同步的特征"><a href="#同步的特征" class="headerlink" title="同步的特征"></a>同步的特征</h3><p>由于非缓冲通道会以同步的方式传递元素值，在其上收发元素值的速度总是与慢的一方持平。可以通过调用内建函数cap判断一个通道是否带有缓冲。若想异步地执行发送操作，但通道确实非缓冲的，需另行异步化，例如：启用额外的goroutine执行此操作。在执行接收操作时通常无需关心通道是否带有缓冲，可以依据通道的容量实施不同的接收策略。</p><h2 id="time包与channel"><a href="#time包与channel" class="headerlink" title="time包与channel"></a>time包与channel</h2><p>标准库代码包time中的一些API是用通道辅助实现的，这些API可以帮助我们对通道的收发操作进行更有效的控制。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>time包中的Timer结构体类型会被作为定时器使用，可用time.NewTimer函数和time.AfterFunc函数构建time.Timer类型的值。</p><p>传递给time.NewTimer一个time.Duration类型的值，表示从定时器被初始化的那一刻起，距到期时间需要多少纳秒（ns）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(3*time.Hour + 36*time.Minute)</span><br></pre></td></tr></table></figure></p><p>此timer是*time.Timer类型而非time.Timer类型。前者的方法集合包含了两个方法：Reset和Stop。Reset方法用于重置定时器（定时器可复用），返回一个bool类型的值。Stop方法用于停止定时器，返回bool类型值作为结果。为false说明该定时器已经过期或已经被停止，否则说明该定时器由于方法调用而被停止。Reset方法的返回值与当此重置操作是否成功无关，无论结果如何，一旦Reset方法调用完成，该定时器就已被重置。</p><p>在time.Timer类型中，对外通知定时器到期的途径是通道，由字段C代表。C代表一个chan time.Timer类型的带缓冲的接收通道，在值赋给C时由双向通道自动转换为接收通道。定时器内部仍然持有该通道，且并未被唤醒，可以向其发送元素值。一旦触及到期时间，定时器就会向它的通知通道发送一个元素值，代表该定时器的绝对到期时间。传入的time.Duration类型值是该定时器的相对到期时间。</p><p>可以通过<code>time.NewTimer(time.Duration).C</code>获取<code>绝对到期时间</code>，可用<code>time.After(time)</code>替换之，与前者等价。time.After函数会新建一个定时器，并把它的字段C作为结果返回，为超时的设定提供了一种快捷方式。</p><p>从一个被调用Stop方法停止的未到期定时器的C字段中接收元素不会有任何结果且会使当前goroutine永久阻塞。在重置定时器前不要再次对它的C字段执行接收操作。<code>若定时器到期了，未及时从其C字段接收元素值，该字段就一直缓冲着那个元素值，即使在该定时器重置之后也是如此，由于C（通知通道的容量）为1，会影响重置后的定时器再次发送到期通知。虽不造成阻塞，但后续通知会被直接丢掉。若想复用定时器，应该确保旧的通知已被接收。</code></p><p>传入的代表相对时间的值应该为一个整数，否则定时器在被初始化或重置之时就会立即到期。</p><p><code>tme.AfterFunc</code>函数是另一种新建定时器的方法，接收两个参数，第一个参数代表相对到期时间,第二个参数指定到期时间需要执行的函数。同样返回新建的定时器，在定时器到期时，并不会向它的通知通道发送元素值，取而代之的是新启用一个goroutine执行调用方传入的函数。无论它是否被重置以及被重置多少次都会是这样。</p><h3 id="断续器"><a href="#断续器" class="headerlink" title="断续器"></a>断续器</h3><p>time包的结构体类型time.Ticker表示了断续器的静态结构。包含的字段与time.Timer一致，行为不同。定时器在重置之前只会到期一次，断续器则会在到期后立即进入下一个周期并等待再次到期，周而复始直到停止。</p><p>断续器传达到期通知的默认途径也是字段C，每隔一个相对到期时间，断续器就会向此通道发送一个代表了当次的绝对到期时间的元素值。字段C的容量仍然是1。若断续器在向其通知通道发送新的元素值的时候发现旧值还未被接收，就会取消当此的发送操作。与定时器一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ticker  *time.Ticker = time.NewTicker(time.Second)</span><br></pre></td></tr></table></figure></p><p>*time.Ticker类型的方法集合中只有一个方法stop，功能是停止断续器。与定时器的stop方法功能相同。一旦断续器被停止，就不会再向其通知通道发送任何元素值了，若此时字段C中已经有了一个元素值，那么该元素值就会一直在那里，直至被接收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">go func() &#123;</span><br><span class="line">for _ = range ticker.C &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case intChan &lt;- 1:</span><br><span class="line">case intChan &lt;- 2:</span><br><span class="line">case intChan &lt;- 3:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;End. [sender]&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">var sum int</span><br><span class="line">for e := range intChan &#123;</span><br><span class="line">fmt.Printf(&quot;Received: %v\n&quot;, e)</span><br><span class="line">sum += e</span><br><span class="line">if sum &gt; 10 &#123;</span><br><span class="line">fmt.Printf(&quot;Got: %v\n&quot;, sum)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;End. [receiver]&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>某次运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Received: 3</span><br><span class="line">Received: 3</span><br><span class="line">Received: 1</span><br><span class="line">Received: 3</span><br><span class="line">Received: 3</span><br><span class="line">Got: 13</span><br><span class="line">End. [receiver]</span><br></pre></td></tr></table></figure></p><p>当累计接收的值大于10时，停止接收通道，主goroutine运行后面语句打印<code>End. [receiver]</code>然后结束主goroutine，主goroutine启动的运行匿名函数的goroutine会因主goroutine的结束而结束，不会打印出<code>End. [sender]</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chan </tag>
            
            <tag> 通道 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-goroutine</title>
      <link href="/2018/05/02/Golang%E7%AC%94%E8%AE%B0-goroutine/"/>
      <url>/2018/05/02/Golang%E7%AC%94%E8%AE%B0-goroutine/</url>
      
        <content type="html"><![CDATA[<p>go语句是启用goroutine的唯一途径。</p><h2 id="go语句与Goroutine"><a href="#go语句与Goroutine" class="headerlink" title="go语句与Goroutine"></a>go语句与Goroutine</h2><p>一条go语句意味着一个函数或方法的并发执行，由go关键字和表达式组成。针对如下函数的调用表达式不能称为表达式语句：append、cap、complex、imag、len、make、new、real、unsafe.Alignof、unsafe.Offsetof和unsafe.Sizeof。前8个函数是Go语言的内建函数，后3个函数是标准库代码包unsafe中的函数。</p><blockquote><p>code example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">---</span><br><span class="line">go func()&#123;</span><br><span class="line">    println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p></blockquote><p>Go语言的运行时系统对go语句中的函数或方法（go函数）的执行是并发的，当go语言被执行的时候，其中的go函数会被单独地放入到一个goroutine中，该go函数的执行会独立于当前goroutine的运行。go函数并发执行，但执行的先后顺序不确定。</p><p>当go函数被执行完毕的时候，相应的goroutine会进入到死亡状态（Ghead）。标志着该goroutine的一次运行的完成。作为go函数的函数或方法可以有结果声明，但是返回的结果值会在它们被执行完成时被丢弃。需要用channel将go函数的结果传递给其他程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于执行的先后顺序不确定，go语句后无其他语句，main函数所在的G可能先于go函数所在的G执行结束，意味着可能go函数所在的G未来得及执行。</p><p>使用time包中的Sleep函数干预多个G的执行顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>time.Sleep函数让调用它的goroutine暂停（进入Gwaiting状态）一段时间。此种情况最好的方法时调用runtime.Gosched()函数，暂停当前的G，让其他的G有运行的机会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    names := []string&#123;&quot;Eric&quot;, &quot;Harry&quot;, &quot;Robert&quot;, &quot;Jim&quot;, &quot;Mark&quot;&#125;</span><br><span class="line">    for _, name := range names &#123;</span><br><span class="line">        go func (who string) &#123;</span><br><span class="line">            fmt.Printf(&quot;Hello, %s!\n &quot;, who)</span><br><span class="line">        &#125;(name) </span><br><span class="line">    &#125;</span><br><span class="line">    runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主goroutine的运作"><a href="#主goroutine的运作" class="headerlink" title="主goroutine的运作"></a>主goroutine的运作</h2><p>封装main函数的goroutine是Go语言运行时系统创建的第一个goroutine(主goroutine)，主Goroutine在runtime.m0上被运行。runtime.m0在运行完runtime.g0中的引导程序之后，会接着运行主goroutine。</p><p>主goroutine不仅执行main函数。它首先：设定每一个goroutine所能申请的栈空间的最大尺寸。在32位的计算机系统中此最大尺寸为250MB，在64位的计算机系统中此尺寸为1GB。若有某个goroutine的栈空间尺寸大于这个限制，运行时系统就会发出一个栈溢出（stack overflow）的运行时恐慌。随即，Go程序的运行也会被终止。</p><p>设定好goroutine的最大栈尺寸后，主goroutine会在当前M的g0上执行系统监测任务。系统监测任务的作用是调度器查缺补漏。</p><p>此后，主goroutine会进行一系列的初始化工作，涉及的工作内容大致有。  </p><ul><li>检查当前M是否为runtime.m0。若不是，说明之前的程序出现了某种问题，主goroutine会立即抛出异常，意味着Go程序的启动失败。</li><li>创建一个特殊的defer语句，用于在主goroutine退出时做必要的善后处理。因为主goroutine可能非正常的结束。</li><li>启用专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识。</li><li>执行main包中的init函数。</li></ul><p>在上述初始化工作完成之后，主goroutine就会去执行main函数。在执行main函数之后，会检查主goroutine是否引发了运行时恐慌，并进行必要的处理。最后，主goroutine会结束自己以及当前进程的运行。</p><p>main函数执行期间，运行时系统会根据Go程序中的go语句，复用或新建goroutine来封装go函数。这些goroutine都会放入相应P的可运行G队列中，然后等待调度器的调度。</p><h2 id="runtime包与goroutine"><a href="#runtime包与goroutine" class="headerlink" title="runtime包与goroutine"></a>runtime包与goroutine</h2><p>Go的标准库代码包runtime中的程序实体，提供了各种可以使用户程序与Go运行时系统交互的功能。</p><h3 id="1-runtime-GOMAXPROCS函数"><a href="#1-runtime-GOMAXPROCS函数" class="headerlink" title="1.runtime.GOMAXPROCS函数"></a>1.runtime.GOMAXPROCS函数</h3><p>用户程序在运行期间，设置常规运行时系统中的P的最大数量。调用会引起“Stop the world”，应在应用程序尽量早的调用，更好的方式是设置环境变量GOMAXPROCS。P的最大数量范围在1～256。</p><h3 id="2-runtime-Goexit函数"><a href="#2-runtime-Goexit函数" class="headerlink" title="2.runtime.Goexit函数"></a>2.runtime.Goexit函数</h3><p>立即使当前goroutine的运行终止，而其他goroutine并不会受此影响。runtime.Goexit函数在终止当前goroutine之前，会先执行该goroutine中所有还未执行的defer语句。</p><p>该函数将被终止的goroutine置于Gdead状态，并将其放入本地P的自由G列表，然后触发调度器的一轮调度流程。</p><blockquote><p>不应在主goroutine中调用此函数，否则引发运行时恐慌。</p></blockquote><h3 id="3-runtime-Gosched函数"><a href="#3-runtime-Gosched函数" class="headerlink" title="3.runtime.Gosched函数"></a>3.runtime.Gosched函数</h3><p>该函数暂停当前goroutine的运行，并将其置为Grunnable状态，放入调度器的可运行G队列。经过调度器的调度，该goroutine马上会再次运行。</p><h3 id="4-runtime-RunGoroutine函数"><a href="#4-runtime-RunGoroutine函数" class="headerlink" title="4.runtime.RunGoroutine函数"></a>4.runtime.RunGoroutine函数</h3><p>返回当前运行时系统中处于非Gdead状态的用户G的数量。这些goroutine被视为“活跃的”或者“可调度的”。返回值总会大于一（废话）。</p><h3 id="5-runtime-LockOSThread函数和runtime-UnLockOSThread函数"><a href="#5-runtime-LockOSThread函数和runtime-UnLockOSThread函数" class="headerlink" title="5.runtime.LockOSThread函数和runtime.UnLockOSThread函数"></a>5.runtime.LockOSThread函数和runtime.UnLockOSThread函数</h3><p>前者的调用使当前goroutine与当前M锁定在一起，后者的调用则会解除这样的锁定。多次调用前者不会造成问题但只有最后一次生效。没有调用前者时调用后者也不会产生任何副作用。</p><h3 id="6-runtime-debug-SetMaxStack函数"><a href="#6-runtime-debug-SetMaxStack函数" class="headerlink" title="6.runtime/debug.SetMaxStack函数"></a>6.runtime/debug.SetMaxStack函数</h3><p>约束单个goroutine所能申请栈空间的最大尺寸。主goroutine会对此值进行默认设置。</p><p>函数接收一个int类型的参数，参数为欲设定的栈空间的最大字节数。执行完毕后会把之前的设定值作为结果返回。</p><p>若运行时系统在为某个goroutine增加栈空间的时候，若其实际尺寸超过设定值，就会发起一个运行时恐慌并终止程序的运行。</p><p>此函数不会像runtime.GOMAXPROCS函数对传入的参数值进行检查和纠正。</p><h3 id="7-runtime-debug-SetMaxThreads函数"><a href="#7-runtime-debug-SetMaxThreads函数" class="headerlink" title="7.runtime/debug.SetMaxThreads函数"></a>7.runtime/debug.SetMaxThreads函数</h3><p>对Go运行时系统所时用的内核线程的数量（也为M的数量，其与内核线程一一对应）进行设置。引导程序中，该数量被设置为10000。</p><p>接收一个int类型的值，返回一个int类型的值。前者代表欲设定的新值，后者代表之前的旧值。若设定的数量小与当前正在使用的M的数量，则会引发一个运行时恐慌。函数调用后，新建M会检查当前所持M的数量，若大于M的数量的设定，运行时系统引发一个运行时恐慌。</p><h3 id="8-与垃圾回收有关的一些函数"><a href="#8-与垃圾回收有关的一些函数" class="headerlink" title="8.与垃圾回收有关的一些函数"></a>8.与垃圾回收有关的一些函数</h3><p>runtime/debug.SetGCPercent、runtime.GC和runtime/debug.FreeOSMemory。前者用于设定触发GC的条件，后两者用于手动触发GC。在后两个函数的执行期间，调度是停止的（阻塞）。runtime/debug.FreeOSMemory函数比runtime.GC多做一件事，在GC之后清扫一次堆内存。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> go语句 </tag>
            
            <tag> goroutine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-Go并发底层</title>
      <link href="/2018/04/27/Golang%E7%AC%94%E8%AE%B0-Go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82/"/>
      <url>/2018/04/27/Golang%E7%AC%94%E8%AE%B0-Go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>Go在操作系统提供的内核线程之上搭建了一个特有两级线程模型，称为Goroutine。其代表的含义为：</p><blockquote><p>不要用共享内存的方式来通信，作为替代，应该以通信作为手段来共享内存。</p></blockquote><p>Go不推荐以共享内存区的方式传递数据，作为替代，优先使用Channel。被用来在多个Goroutine之间传递数据，并且会保证其过程的同步。提供了一些传统的并发访问控制方式（互斥量、条件变量等）。</p><h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>Go语言的线程实现模型，有3个核心元素支撑线程实现模型的主框架：   </p><ul><li>M：Machine的缩写。一个M代表一个内核线程。</li><li>P：Processor的缩写。一个P代表了M所需的上下文环境。</li><li>G：Goroutine的缩写。一个G代表了对一段需要被并发执行的Go语言代码的封装。</li></ul><p>一个G的执行需要M和P的支持。一个M在与一个P关联之后就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列。该队列中的G会被依次传给与本P关联的M并获得运行时机。</p><p>M与KSE（内核调度实体）之间是一对一关系，一个M仅能代表一个内核线程。Go语言的运行时系统（runtime system）用其代表一个内核调度实体，在一个M的生命周期内，其仅会与一个KSE产生关联。M与P以及P与G之间的关系会在实际调度的过程中被改变。M与P之间也总是一对一的，P与G之间是一对多的。一个G最终由一个M来负责运行。</p><h3 id="1-M"><a href="#1-M" class="headerlink" title="1.M"></a>1.M</h3><p>一个M代表了一个内核线程。大多数情况下，创建一个M的原因是由于没有足够的M来关联P并运行其中的可运行的G。在运行时系统执行系统监控或垃圾回收等任务时也会导致新的M的创建。</p><p>M结构中字段众多。  </p><ul><li>curg：存放当前M正在运行的G的指针。</li><li>p：指向与当前M相关联的P。</li><li>msraerfm：M的起始函数。</li><li>nextp：暂存与当前M有潜在关联关系的P。把调度器将某个P赋给某个M的nextp字段的操作称为对M和P的预联。有时运行时系统会把被重新启用的M和已与它预联的P关联在一起。</li></ul><p>M在被创建之初会被加入到全局的M列表（runtimr.allm）中。然后它的起始函数和准备关联的P（大多数情况下是导致此M创建操作的P）会被设置。最后运行时系统会为它专门创建一个新的内核线程并与之相关联。此时新的M就为执行G做好了准备。起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。全局M列表无特殊意义，运行时系统会通过它获取到所有M的信息。可以防止M被当作垃圾回收掉。</p><p>新的M被创建完成后会先进行一些初始化工作，包括对自身所持的栈空间以及信号处理方面的初始化。初始化完成后M的起始函数会被执行（若存在）。若起始函数代表的是系统监控任务，则M会一直在那里执行而不会继续后面的流程。否则在初始化函数执行完毕后，当前M会与准备与它关联的P完成关联。此时一个并发执行环境才形成。</p><p>运行时系统管辖的M有时会被停止，例如运行时系统开始执行垃圾回收任务的时候。运行时系统停止M时，在对其属性进行必要的重置之后，把它放入调度器的空闲M列表（runtime.sched.midle）。在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。</p><p>M本身是无状态的，M是否空闲仅以它是否存在于调度器的空闲M列表中为依据。</p><p>单个Go程序所使用的M的最大数量可以被设置。<code>使用命令运行Go程序时，一个引导程序先会被启动。引导程序为Go程序的运行建立必要的环境</code>。引导程序会对M的最大数量进行初始设置，为10000，即一个Go程序最多可以使用10000个M。意味着最理想情况下，同时可以有10000个内核线程被同时运行。操作系统内核对进程的虚拟内存的布局的控制以及大小的限制，此数量级线程可能很难共存，Go语言本身对于线程数量的限制几乎可以被忽略。除此之外可以在Go程序中对该限制进行限制。调用标准库代码包runtime/debug中的SetMaxThreads函数并提供新的M最大数量。执行后会把旧的M最大数量作为结果值返回。若传入的值比当时M的实际数量小，运行时系统会发起一个运行时恐慌。若需要设置M的最大数量，越早调用此函数越好。</p><h3 id="2-P"><a href="#2-P" class="headerlink" title="2.P"></a>2.P</h3><p>P是使G能够在M中运行的关键。运行时系统会适时地让P与不同的M建立或断开关联，以使P中的可运行的G能够在需要的时候及时获得运行时机。类似操作系统内核在CPU之上实时切换不同的进程或线程。</p><p>调用runtime.GOMAXPROCS函数，可以改变单个Go程序可以间接拥有的P的最大数量。此外，可以在运行Go程序之前设置环境变量GOMAXPROCS的值来对Go程序可以拥有的P的最大数量做出预先设定。P的最大数量相当于是对可以被并发运行的用户级别的G的数量做出限制。每个P都需要关联一个M才能使其中的可运行的G得到执行，不意味着环境变量GOMAXPROCS的值会限制住M的总数量。当M因系统调用的进行而被阻塞（运行的G进入了系统调用）时，运行时系统会将M和与之关联的P分离出来。此时，这个P的可运行G队列中还有未被运行的G，则运行时系统会找到一个空闲M或创建出一个新的M，并与该P关联以满足这些G的运行需要。若Go程序中创建的大部分Goroutine中都包含了很多需要间接地进行各种系统调用的代码时，即使环境变量GOMAXPROCS的值被设定为1，也可能会有多个M被创建出来。实际的M总数量很可能会比环境变量GOMAXPROCS所指代的数量多。真正使用的内核线程的数量不会因此而环境变量受到限制。</p><p>Go程序开始被运行时，引导程序也会对P的最大数量进行设置。默认值为1。默认情况下，无论我们在程序中用go语句启用出多少Goroutine，它们都只会被塞入同一个P的可运行G的队列中。P最大数量值绝不会比引导程序中的硬性上限值大，超过时会被硬性上限值取代。</p><p>runtime.GOMAXPROCS函数的执行会暂时使所有的P都相继进入停止状态并试图阻止任何用户级别的G的运行。只有在新的P最大数量被设定完成之后，运行时系统才会开始陆续恢复它们。对程序性能损耗大。即只在Go程序的main函数的开始处调用runtime.GOMAXPROCS函数较好，最好不对其进行调用而只预先设置GOMAXPROCS。</p><p>确定P最大数量后，运行时系统会根据这个数值初始化全局P列表（runtime.allp）。包含了当前运行时系统创建的所有P。然后运行时系统把调度器的可运行G队列中的所有G均匀的放入到全局P列表中的各个P的可运行G队列中。此时，运行时系统需要用到的所有P都以就绪。</p><p>同空闲M列表，在运行时系统中存在着调度器的空闲P列表（runtime.sched.pidle）。当一个P不再与任何M关联的时候，运行时系统会把它放入到该列表，当运行时系统需要一个空闲的P关联某个M时，会从此列表中取出一个。即使P进入到空闲P列表，它的可运行G列表也不一定是空的。</p><p>P本身是有状体的：  </p><ul><li>Pidle：表明当前P未与任何M存在关联。</li><li>Prunning：表明当前P正在与某个M关联。</li><li>Psyscall：表明当前P中的被运行的那个G正在被系统调用。</li><li>Pgcstop：表明运行时系统正在进行垃圾回收。在运行时系统进行垃圾回收时，会试图把全局P列表中的都置于此状态。</li><li>Pdead：表明当前P已经不会再被使用。当在Go程序运行的过程中通过调用runtime.GOMAXPROCS函数减少P最大数量时，多余的P会被运行时系统置于此状态。</li></ul><p>P的初始状态时Pgcstop，虽然运行时系统并不会在这时进行垃圾回收。初始化和填充P中的可运行G队列之后，运行时系统会将状态设置为Pidle并放入到调度器的空闲P列表中。空闲P列表中的所有P都会由调度器根据实际情况进行取用。除了Pdead之外的其他状态的P都会在运行时系统进行垃圾回收的时候被置于Pgcstop状态，等到垃圾回收结束之后并不会恢复至原有状态，而会被统一地换为Pidle状态。意味着它们会被重新调度。除了Pgcstop状态，处于其他状态的P都有可能由于全局P列表的缩小而被认为是多余的并置于Pdead状态。P被转换为Pdead状态之前，其可运行G队列中的G都会被转移至调度器的可运行G队列中，其自由G列表中的G都会被转移到调度器的自由G列表中。</p><p>每个P中都有一个可运行G列表，还包含一个自由G列表（gfree）。自由G列表中包含一些已经被运行完成的G。随着被运行完成的G的增多，该自由列表可能会很长。若增长到一定程度，运行时系统会把其中的部分G转移到调度器的自由G列表（runtime.sched.gfree）中。当使用go语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G来封装我们提供的函数，仅当获取不到这样的一个G时才有可能区创建一个新的G。若相应P的自由G列表为空而获取不到自由G时，运行时系统若在这个过程中发现其中的自由G太少，则会先尝试从调度器的自由G列表中转移过来一些G。只有在调度器的自由G列表也为空时才会有新的G被创建。很大程度上提高了G的复用率。当一个P被运行时系统认为不会再被使用（被置于Pdead状态）的时候，其中的自由G列表中的所有G都会转移至调度器的自由G列表中。</p><p>P的结构中，可运行G队列和自由G列表是最重要的两个成员，间接的体现运行时系统对相应的G的调度情况。</p><h3 id="3-G"><a href="#3-G" class="headerlink" title="3.G"></a>3.G</h3><p>一个G就相当于一个Goroutine(或者称Go程)，对应使用go语句欲并发执行的一个匿名或命名的函数。</p><p>Go语言的编译器会把我们编写的go语句（go关键字和其后的函数的统称）变成对一个运行时系统中的函数调用，并把go语句中的函数（go函数）即其参数都作为参数传递给这个运行时系统中的函数。go语句代表了我们向运行时系统递交的一个并发任务。</p><p>运行时系统在接到这样一个调用之后，先检查go函数即其参数的合法性，然后会试图从本地P的自由G列表和调度器的自由G列表获取可用的G。没有获取到则会新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（runtime.allg）。新建的G会在第一时间被加入到该列表中。该列表的主要作用是集中存放当前运行时系统中的所有G的指针。无论将会封装当前的go函数的G是否是新的，运行时系统都会对它进行一次初始化。包括关联go函数以及设置G的状态的ID等步骤。初始化完成后，这个G被放入到本地P的可运行G队列中。时机成熟，调度会立即进行以使这个G尽快被运行。</p><p>每个G都会由运行时系统根据其实际状况设置不同的状态：  </p><ul><li>Gidle：当前G被创建但还完全未被初始化的时候。</li><li>Grunnable：表示当前G是可运行的并且正在等待被运行。</li><li>Grunning：表示当前G正在被运行。</li><li>Gsyscall：表示当前G正在进行系统调用。</li><li>Gwaiting：表示当前G正在因某个原因而等待。</li><li>Gdead：表示当前G已被运行完成。</li></ul><p>运行时系统用一个G封装我们通过go语句递交的go函数的时候，先对这个G进行初始化。其中的一步就是初始化这个G的状态为Grunnable，即一个G真正被使用是在其状态被设置为Gorunnable之后。</p><p>一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。</p><p>G在退出系统调用时，运行时系统先会尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为Grunnable状态并放入到调度器的自由G列表中。</p><p>进入死亡状态（Gdead）的G可以被重新初始化并使用。相比之下，P在进入死亡状态（Pdead）之后则只能面临被销毁的结局。Gdead与Pdead状态所表达的含义完全不同。处于Gdead状态的G会被放入本地P或调度器的自由G列表，为重用提供了条件。</p><h3 id="4-核心元素的容器"><a href="#4-核心元素的容器" class="headerlink" title="4.核心元素的容器"></a>4.核心元素的容器</h3><p>M，P和G的容器：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">源码</th><th style="text-align:center">作用域</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">全局P列表</td><td style="text-align:center">runtime.allm</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有M的列表</td></tr><tr><td style="text-align:center">全局P列表</td><td style="text-align:center">runtime.allp</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有P的列表</td></tr><tr><td style="text-align:center">全局G列表</td><td style="text-align:center">runtime.allg</td><td style="text-align:center">运行时系统</td><td style="text-align:left">用于存放所有G的列表</td></tr><tr><td style="text-align:center">调度器的空闲M列表</td><td style="text-align:center">runtime.sched.midle</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放空闲M的列表</td></tr><tr><td style="text-align:center">调度器的空闲P列表</td><td style="text-align:center">runtime.sched.pidle</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放空闲P的列表</td></tr><tr><td style="text-align:center">调度器的可运行G队列</td><td style="text-align:center">runtime.sched.runq</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放可运行G的队列</td></tr><tr><td style="text-align:center">调度器的自由G列表</td><td style="text-align:center">runtime.sched.gfree</td><td style="text-align:center">调度器</td><td style="text-align:left">用于存放自由G的列表</td></tr><tr><td style="text-align:center">P的可运行G队列</td><td style="text-align:center">runq</td><td style="text-align:center">本地P</td><td style="text-align:left">用于存放当前P中的可运行G的队列</td></tr><tr><td style="text-align:center">P的自由G列表</td><td style="text-align:center">gfree</td><td style="text-align:center">本地P</td><td style="text-align:left">用于存放当前P中的自由G的列表</td></tr></tbody></table><p>全局的3个列表存在的主要目的是为了统计运行时系统中的所有M、P或G。运行时系统创建出的任何G都会存在于全局G列表中，其于的4个与G有关的列表只会存放在当前作用域内的具有特定状态的G。调度器的可运行G队列和P的可运行G队列都拥有几乎平等的运行机会。运行时系统调度的过程中会先后对它们进行检查，并会运行第一个被发现的可运行的G。从Gsysycall状态和Ggcstop状态转出的G，会被放入调度器的可运行G队列，被运行时系统初始化的G，会被放入本地P的可运行G队列。从Gwaiting状态转出的G，除因网络I/O陷于等待的G，都会被放入到本地P的可运行G队列。调用runtime.GOMAXPROCS函数，可能会导致运行时系统清空调度器的可运行G队列。其中所有G都会被均匀地放入到全局P列表中的各个P的可运行G队列当中。在G转入Gdead状态后，先会被放入本地P的自由G列表，在运行时系统需要用自由G封装go函数时，先尝试从本地P的自由G列表中获取。调度器的自由G列表只起到一个暂存自由G的作用。</p><p>与M和P相关的非全局容器被用于存放暂时不被使用的元素的实例。在运行时系统有需要时，会从中获取相应元素的实例并重新启用它。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>两级线程模型中的一部分调度任务会由操作系统内核之外的程序承担，Go语言中，其运行时系统中的调度器会负责这一部分调度任务。调度的主要对象是M、P和G的实例，调度的辅助设施是各种容器。每个M（每个内核线程）在运行过程中都会按需执行一些调度任务。</p><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1.基本结构"></a>1.基本结构</h3><p>调度器有它自己的数据结构，这一数据结构的主要目的是为了更加方便地管理和调度各个核心元素的实例。调度器的部分字段：</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">数据类型</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center"> gcwaiting</td><td style="text-align:center">uint32</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> stopwait</td><td style="text-align:center">int32</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> stopnote</td><td style="text-align:center">Note</td><td style="text-align:left">垃圾回收任务被执行期间的辅助标记、停止计数和通知机制</td></tr><tr><td style="text-align:center"> sysmonwait</td><td style="text-align:center">unit32</td><td style="text-align:left">作为系统检测任务被执行期间的停止和通知机制</td></tr><tr><td style="text-align:center"> sysmonnote</td><td style="text-align:center">Note</td><td style="text-align:left">作为系统检测任务被执行期间的停止和通知机制</td></tr></tbody></table><p>通过调度器gcwaiting的值，可知垃圾回收器是否已经开始准备或正在进行垃圾回收。stopwait字段是为了对还未被停止调度的P进行计数。当计数器为0时，说明调度工作已被完全停止，垃圾回收器会立即开始执行垃圾回收任务。stopnode字段被用来向垃圾回收器告知调度工作已经完全被停止的通知机制的重要部分。</p><p>辅助协调手段存在的意义在于保证所有的P在垃圾回收期间都处于Pgcstop状态。<code>Go语言的垃圾回收器先停止一切调度工作（包括对M和P的调度），然后进行垃圾回收，最后待垃圾回收完成之后再重启调度工作。</code>即Go语言的垃圾回收任务是在“stop the world”执行垃圾回收任务）的环境下被执行的。“Stop the world”即指运行时系统要放下手头所有工作并专心(无其它并发任务）执行垃圾回收任务。</p><p>垃圾回收器在准备执行垃圾回收任务的时候，先把调度器的gcwaiting字段的值设置为1，告诉调度器，它已经开始准备执行垃圾回收任务。垃圾回收器会利用stopnode字段将自身阻塞，以等待调度器完全停止调度。调度器在发现gcwaiting字段的值被置为1之后，会积极响应，并陆续停止正在进行的调度工作。待所有的调度工作均已停止（计数器的stopwait字段的值为0）之后，调度器回利用stopnode字段向垃圾回收器发送通知。垃圾回收器在收到通知后才会真正开始垃圾回收，通知机制在底层由信号灯实现。</p><p>垃圾回收器进行垃圾回收的时候，被持续执行的系统检测任务也需要被暂停，sysmonwait和sysmonnode的作用就是及时地暂停和恢复监测任务的执行。sysmonwait字段表示系统监测任务是否已经被暂停的标记，sysmonnode字段则是被用来向执行系统监测任务的程序发送通知。</p><p>系统监测任务是被持续执行的，即被置于无尽的循环中。在每次迭代之初，相关程序（系统监测器）会先检查调度器的gcwaiting字段的值，若其值为1，则说明垃圾回收器已经开始准备或正在执行垃圾回收任务。系统监测器会先将调度器的sysmonwait字段的值设置为1以表示系统监测任务已被暂停。然后利用sysmonnode字段阻塞自身以等待垃圾回收的完成。在调度工作被重启之后，调度器若发现其sysmonwait字段值为1则会利用sysmonnode字段向系统检测器发送通知。系统监测器在收到该通知之后会立即执行当次迭代的后续流程并继续进行之后的迭代。</p><h3 id="2-一轮调度"><a href="#2-一轮调度" class="headerlink" title="2.一轮调度"></a>2.一轮调度</h3><p>引导程序为Go程序的运行建立必要的环境。在引导程序完成工作之后，Go程序的main函数才会被真正地执行。引导程序在最后让调度器进行一轮调度，才能让main函数所在的G马上有机会被运行（封装main函数的G总是Go语言运行时系统创建的第一个G）。</p><center><p><img src="https://git-blog.oss-cn-beijing.aliyuncs.com/gfayilundiaodu.png" alt="一轮调度"><br></p></center><br>调度器的一轮调度中，有5个子流程。由标准库代码包runtime中的schedule函数代表。调度器会先从一些比较容易找到可运行G的地方入手，即全局的可运行G队列和本地的可运行G队列。若找不到，调度程序进入强力查找模式（子流程“全力查找可运行的G”）。若仍未找到可运行的G，该子流程就会暂停，直到有可运行的G出现才会继续下去。<p></p><p>在一轮调度的开始，调度器会先判断当前M是否已被锁定。M和G可以成对地锁定在一起。调度器会按照一定的策略动态地关联M、P和G，并以此高效地执行并发程序。</p><p>锁定M和G的操作是为CGO准备的，CGO代表了Go中的一种机制，时Go程序和C程序之间的一种调用机制。</p><p>若调度器在一轮调度之初发现当前M已与某个G锁定，就会停止调度并停止当前M（让其暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前M意味着相关的内核线程并不能再去做其他事情。调度器也不会为当前M寻找可运行的G。若当前M找到一个可运行G，但G与某个M锁定，就会唤醒与之锁定的M以运行该G，并重新为当前M寻找可运行的G。</p><p>若调度器判断当前M未与任何G锁定，则一轮调度的主流程就会继续运行。调度器会检查是否有运行时串行任务正在等待执行。通过判断gcwaiting字段的值，若不为0则一轮调度流程走进另一个分支:停止并阻塞当前M以等待运行时串行任务执行完。一旦串行任务执行完成,该M就会被唤醒,一轮调度也会再次开始。</p><p>若调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的寻找G。一旦找到一个可运行的G，调度器在判断该G未与任何M绑定之后，立即让当前M运行它。</p><p>一轮调度是调度器中最核心的流程，运行时系统在调度过程中经常使用。例如，在用户程序启动时的一系列工作之后之后，一轮调度会首次启动并使封装main的G被调度运行。某个G的运行时阻塞、结束、退出系统调用、栈的增长都会使调度器进行一轮调度。用户程序对某些标准库函数的调用也会触发一轮调度流程。调用runtime.Gosched函数相当于手动让调度器进行了新一轮的调度，使其他Goroutine能够得到运行机会。调用runtime.Goexit函数会在终结调用它的那个Goroutine之后，立即开始进行新一轮调度以使其他等待运行的Goroutine获得机会。</p><h3 id="3-全力查找可运行的G"><a href="#3-全力查找可运行的G" class="headerlink" title="3.全力查找可运行的G"></a>3.全力查找可运行的G</h3><p>“全力查找可运行G”子流程会尝试从各处搜索可运行的G，甚至会从别的P（非本地P）偷取可运行的G。由runtime.findrunnable函数代表，该函数返回一个处于Grunnable状态的G。搜索流程大致分为2个阶段和10个步骤。  </p><ul><li>（1）获取执行终结器的G。一个终结器（或称终结函数）可以与一个对象关联，通过调用runtime.SetFinalizer函数产生这种关联。当一个对象变为不可达（未被其他任何对象引用）时，垃圾回收器在回收该对象之前，会执行与之关联的终结函数（若有）。所有终结函数的执行都会由一个专用的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态并放入本地P的可运行G队列。</li><li>（2）从本地P的可运行G队列获取G。</li><li>（3）从调度器的可运行G队列获取G。</li><li>（4）从网络I/O轮询器（netpoller）处获取G。若netpoller已被初始化且已有过网络I/O操作，那么调度器会试着从netpoller获取获取一个G列表，并把表头的G作为结果返回。同时把其余的G放入调度器的可运行G队列。若netpoller未初始化或还未有过网络I/O操作，这一步会跳过。这里的获取浅尝辄止，非阻塞。</li><li>（5）从其他P的可运行G队列获取G。条件允许情况下，调度器使用一种伪随机算法在全局P列表中选取P，然后试着从它们的可运行G队列中盗取（或者说转移）一半的G到本地P的可运行G队列。选取P和盗取G的过程会重复多次，成功则停止。成功会把盗取的一个G作为结果返回，否则搜索的第一阶段就结束。</li><li>（6）获取执行GC标记任务的G。搜索第二阶段，调度器会判断是否正处在GC的标记阶段，以及本地P是否可用于GC标记任务。若答案都是true，调度器会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回。</li><li>（7）从调度器的可运行G队列获取G。调度器再次尝试从该处获取一个G，并把它作为结果返回。若依然找不到可运行的G，会解除本地P与当前M的关联并把该P放入调度器的空闲P列表。</li><li>（8）从全局P列表中的每个P的可运行G队列中获取G。遍历全局P列表中的P，并检查他们的可运行G队列。只要发现某个P的可运行G队列不为空，取该iP，判定可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。若所有P可运行G队列都为空，继续后面的搜索。</li><li>（9）获取GC任务标记的G。判断是否正处于GC的标记阶段，以及GC标记任务相关的全局资源是否可用。若答案都是true，调度器就会从其空闲P列表拿出一个P。若该P持有一个GC专用标记G，关联该P与当前M，再次执行第二阶段（步骤（6）开始）。</li><li>（10）网络I/O轮询器（netpoller）获取G。若netpoller已被初始化，并且有过网络I/O操作，调度器再次试着从netpoller获取一个G列表。与步骤（4）基本相同，区别于此处是阻塞的，只有当netpoller有可用的G时阻塞才会解除。若netpoller未被初始化或者未有过网络I/O操作，跳过此步。</li></ul><p>若经过上述步骤仍未找到可运行的G，调度器就会停止当前的M。在之后的某个时刻，该M被唤醒之后，会重新进入“全力查找可运行的G”的子流程。</p><p>网络I/O轮询器（netpoller）是Go为了在操作系统提供的异步I/O基础组件之上，实现自己的阻塞式I/O而编写的一个子程序。当一个G试图在一个网络连接上进行读/写操作时，底层程序（包括基础组件）就会开始为此做准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就回返回相应的事件，让netpoller立即通知为此等待的G。从netpoller获取G意味着获取那些已经接收到通知的G。调度器让它们转入Grunnable状态并等待运行。</p><p>全力查找可运行G的子流程会想方设法去搜寻G，执行比较耗时费力，会调用多方资源来满足当前M运行G的需要。因始终未找到G而停止的M在被唤醒后，依然会执行该子流程，直到找到一个可运行的G，M才会结束它的执行。</p><h3 id="4-启用或停止M"><a href="#4-启用或停止M" class="headerlink" title="4.启用或停止M"></a>4.启用或停止M</h3><p>调度器有时会停止当前M，由如下函数负责M的启用或者停止。  </p><ul><li>stopm()。停止当前M的执行，直到因有新的G变得可运行而被唤醒。</li><li>gcstopm。为串行运行时任务的执行让路，停止当前M的执行，串行运行时任务执行完毕后会被唤醒。</li><li>stoplockedm()。停止已经与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒。</li><li>startlockedm(gp *g)。唤醒与gp绑定的那个M，并让该M去执行gp。</li><li>startm(_p_ *p, spinning bool)。唤醒或创建一个M去关联_p_并开始执行。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h3 id="5-系统监测任务"><a href="#5-系统监测任务" class="headerlink" title="5.系统监测任务"></a>5.系统监测任务</h3><p>由sysmon函数实现。监测任务主要做：  </p><ul><li>在需要时抢夺符合条件的G和P；</li><li>在需要时进行强制GC；</li><li>在需要时清扫堆；</li><li>在需要时打印调度器跟踪信息。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h3 id="6-变更P的最大数量"><a href="#6-变更P的最大数量" class="headerlink" title="6.变更P的最大数量"></a>6.变更P的最大数量</h3><p>P最大数量变更直接影响Go程序的并发性能。调用runtime.GOMAXPROC函数时，会先进行下面两项检查，确保变更合法和有效。  </p><ul><li>若传入的参数值（新值）比运行时系统为此设定的硬性上限值（256）大，前者会被后者替代。</li><li>新值不是正整数，或者与存储在运行时系统中的P最大数量值（旧值）相同，该函数或略此变更直接返回旧值。</li></ul><blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote><h2 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h2><h3 id="1-g0和m0"><a href="#1-g0和m0" class="headerlink" title="1.g0和m0"></a>1.g0和m0</h3><p>运行时系统中的每个M都拥有一个特殊的G，称为M的g0。M的g0管辖的内存称为M的调度栈，对应于操作系统为相应线程创建的栈。M的调度栈也成为OS线程栈或系统栈（参runtime.systemstack函数）。</p><p>M的g0由Go运行时系统在初始化M时创建并分配给M的，一般用于执行调度、垃圾回收、栈管理等方面的工作。M还有一个专用于处理信号的G，称为<code>gsignal</code>。它的栈称为信号栈。系统栈和信号栈不会自动增长，但一定会有足够的空间执行代码。</p><p>除g0，其他由M运行的G都可以视为用户级别G，称为用户G，g0和gsignal称为系统G。g0不会被阻塞，不包含在任何G队列或列表中。栈不会在垃圾回收中被扫描。</p><p>除每个M都有属于自己的g0外，还存在一个runtime.g0。runtime.g0用于执行引导程序，运行在Go程序拥有的<code>第一个内核线程</code>中，该内核线程称为runtime.m0。runtime.m0和runtime.g0都是静态分配的，引导程序无需为它们分配内存。</p><h3 id="2-调度器锁和原子操作"><a href="#2-调度器锁和原子操作" class="headerlink" title="2.调度器锁和原子操作"></a>2.调度器锁和原子操作</h3><p>并发调度时，调度器会在读写一些全局变量以及它的字段的时候动用调度器锁进行保护。</p><p>Go运行时系统在一些需要保证并发安全的变量的存取上使用原子操作。原子操作比锁操作可以有效的节约系统资源和提升系统性能。</p><h3 id="3-调整GC"><a href="#3-调整GC" class="headerlink" title="3.调整GC"></a>3.调整GC</h3><p>目前的GC基于CMS（Concurrent Mark-Sweep，并发标记-清扫）算法，时非分代的和非压缩的。</p><p>目前的GC有3种执行模式：  </p><ul><li>gcBackgroundMode，并发地执行垃圾收集和清扫；</li><li>gcFroceMode，串行地值执行垃圾收集（即执行时停止调度），但并发地执行清扫。</li><li>gcFroceBlockMode，串行地执行垃圾收集和清扫。</li></ul><p>调度器驱使的自动GC和系统监测任务中的强制GC，都会以gcBackgroundMode模式执行。前者会检查Go程序当前的内存使用量，仅当使用量过大时才真正执行GC，后者无视此条件。</p><p>可以通过GODEBUG控制自动GC的并发性，使其值包含gcstoptheworld=1或gcstoptheworld=2，让GC的执行模式由gcBackgroundMode变为gcForceMode或gcForceBlockMode。相当于让并发的GC进入调试模式。</p><p>GC会在为Go程序分配的内存翻倍增长时被触发。Go运行时系统会在分配新内存时检查Go程序的内存使用增量。可以通过调用runtime/debug.SetGCPercent函数改变这个增量的阀值，该函数接受一个int类型的参数：在新分配的内存是上次记录的已分配的内存的百分之几时触发GC。若为负数会导致自动GC的关闭；预设值是100。SetGCPercent函数在被调用后会返回旧的增量阀值。设置环境量变量GOGC亦可，含义规则与SetGCPercent一致。将其值设置为off会关闭自动GC。对GOGC的设置需要在Go程序启动之前进行，否则不生效。</p><p>关闭自动GC意味着需要在程序中手动GC，调用runtime.GC函数可以手动触发一次GC，该函数会阻塞调用方直到GC完成。这种情况下的GC会以gcForceBlockMode模式执行。调用runtime/debug包的FreeOSMemory函数也会手动触发一次完全串行的GC，并且在GC完成之后还会做一次清除堆的操作。两者在执行时都不会检查Go程序的内存使用增量。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git使用中发生的一些莫名错误</title>
      <link href="/2018/04/27/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E9%94%99%E8%AF%AF/"/>
      <url>/2018/04/27/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="git-push报错-Tags-index-master"><a href="#git-push报错-Tags-index-master" class="headerlink" title="git push报错 Tags:[index,master]"></a>git push报错 Tags:[index,master]</h3><p>背景：<code>git add</code>和<code>git commit</code>后未及时<code>git push</code>，第二天<code>git push</code>报错。<br>错误详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: index file smaller than expected</span><br><span class="line">fatal: index file smaller than expected</span><br><span class="line">error: unable to resolve reference refs/remotes/origin/master: ??</span><br><span class="line">error: Cannot lock the ref &apos;refs/remotes/origin/master&apos;.</span><br></pre></td></tr></table></figure></p><p>解决方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm .git/index</span><br><span class="line">rm .git/refs/remotes/origin/master</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>原因：查询stackoverflow得上方解决结果，直接删除相应的报错文件，然后再重新将改变的工作提交到仓库中，最后再推倒远程仓库。可能原因猜测index文件和master文件被污染，不知具体原因。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-多线程编程理论</title>
      <link href="/2018/04/25/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/25/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>Linux操作系统提供以POSIX（Portable Operating System Interface of Unix）标准中定义的线程为中心的各种系统调用，最贴近POSIX线程标准的线程实现称为NPTL（Native POSIX Threads Library），已成为Linux默认的线程实现。</p><p>Go语言的并发编程模型在底层是由操作系统所提供的线程库支撑的。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个线程可以被看作是在某个进程中的一个控制流。一个进程至少包含一个线程，进程的第一个线程随着进程的启动被创建，被称为该进程的主线程。一个进程的其他线程由当前进程中已存在的线程所执行相应的系统调用（pthread_create函数）创建，拥有多个线程的进程可以并发的执行多个任务，并且即使某个或某些任务被阻塞也不会影响到其他任务的正常执行。可以改善程序的响应时间和吞吐量。一个线程必属于某一个进程，生命周期不可逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己的线程栈，存储自己的私有数据。线程栈被包含在操作系统内核分配给其所属进程的虚拟内存地址中。一个进程中的很多资源会被其中的所有资源共享，共享资源包括在当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数，以及当前进程所持有的文件描述符等。</p><p>操作系统内核提供若干个系统调用以使应用程序能够管理当前进程中的所有线程，应用程序可以通过相应的系统功能协调这些线程的运行。系统功能由一些同步原语代表。</p><h3 id="1-线程的标识"><a href="#1-线程的标识" class="headerlink" title="1.线程的标识"></a>1.线程的标识</h3><p>同进程一样，每个线程也都有属于它自己的ID，称为线程ID或TID。线程ID在系统范围内可以不是唯一的，在其所属进程的范围内必须是唯一的。Linux操作系统的线程实现确保每个线程在系统范围内的唯一性。线程不复存在后，其线程ID可被其他线程复用。</p><p>线程的ID由操作系统内核分配。应用程序无需关注。在调试时，线程ID帮助区别不同的线程。</p><h3 id="2-线程间的控制"><a href="#2-线程间的控制" class="headerlink" title="2.线程间的控制"></a>2.线程间的控制</h3><p>同一个进程中的任意两个线程的关系都是平等的，不存在层级关系。任何线程都可以对其所属的进程中的其他线程进行有限的管理。主要有：  </p><ul><li>创建线程：主线程在其所属进程启动的时候被创建，此处针对其他线程的创建。任何线程都可以通过调用系统调用<code>pthread_create</code>来创建新的线程。创建线程时，调用线程需要给定新线程将要执行的函数以及传入该函数的参数值。代表该函数的参数被命名为start，通常称start函数。start函数可有返回值。在其他线程中通过与新线程的连接得到在该新线程中执行的start函数的返回值，若新线程创建成功，调用线程得到新线程的ID。</li><li>终止线程：线程可以通过多种方式终止其所属进程的其他线程。例如调用系统调用<code>pthread_cancel</code>。<code>pthread_cancel</code>函数取消给定的线程ID代表的线程。它会向目标线程发出一个请求，要求它立即终止执行。该函数只是发送请求并立即返回，不会等待目标线程对该请求做出响应。至于目标线程什么时候对此请求做出响应、做出怎样的响应，则取决于另外的因素（目标线程的取消状态即类型）。默认情况，目标线程总是会接收线程取消请求，等到时机成熟（执行到某个取消点）的时候目标线程才会去响应线程取消请求。</li><li>连接已终结的线程：由系统调用pthread_join代表。该函数会一直等待（阻塞）与给定的线程ID对应的线程的终止，并把该线程执行的start函数的返回值告知给调用线程。如果目标线程已经处于终止状态，该函数会立即返回。类似把调用线程放置在目标线程后面，当目标线程把流程控制权交出后，调用线程接过流程控制权并继续执行pthread_join函数调用之后的代码。如果一个线程是可被连接的，终止之时必须被连接，否则会变成一个僵尸线程。僵尸线程导致系统资源的浪费，使所属进程的可创建线程数量被无意义减少。</li><li>分离线程：将一个线程分离，意味着它不再是一个可被连接的线程。默认情况下，一个线程总是可以被其他线程连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自动进行清理和销毁工作。分离操作是不可逆的，无法使一个不可连接的线程变回到可被连接的状态。但是对于一个已处于分离状态的线程执行终止操作仍然会起作用。分离操作由系统调用pthread_detach代表，接受一个代表了线程ID的参数值。</li></ul><p>一个线程对自身也可以进行两种控制：终止和分离。线程终止自身的方式有很多种，在线程执行的start函数中执行return语句会使该i线程随着start函数的执行结束而终止。在主线程中执行了return语句，当前进程中的所有线程都会被终止。在任意线程中调用系统调用exit也会达到一样效果。另一种显示地调用系统调用pthread_exit。在主线程中调用pthread_exit函数，只有主线程自己会被终止，其他线程仍然会正常运行。线程分离自身与分离其他线程的方式一致，调用pthread_detach函数。区别在于调用线程传递给该函数的线程ID是自己的ID还是其他线程的ID。</p><h3 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3.线程的状态"></a>3.线程的状态</h3><p>线程只是进程的一个控制流，对进程的状态描述几乎都适用于线程。</p><p>线程在被创建出来之后会进入就绪状态，处于就绪状态的线程会等待被运行的时机。</p><p>一旦该线程被真正地运行，就会由就绪状态转换至运行状态。正在运行的线程可能会由于某些原因（等待未完成的I/O操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量）被阻塞，进而由运行状体转换至睡眠状态。当阻塞线程等待的事件或条件发生或满足时，线程被唤醒。从睡眠状态转出，先进入就绪状态等待运行时机。若CPU处于空闲状态则会立即运行。处于运行状态的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待下一个运行时机。操作系统内核的调度器会按照一定的算法和策略使线程在这三个状态之间状态之间转换。线程在其生命周期的大部分时间里都会处于就绪状态、运行状态或睡眠状态之中。</p><p>在当前线程自我终结或者其他线程向当前线程发出取消请求且取消时机已到之后，当前线程就会试图进入终止状态。若当前线程之前没有被分离，且此时没有其他线程与它连接，则当前线程进入僵尸状态而非终止状态。当且仅当有其他线程与之连接之后，当前进程才会从僵尸状态转换至终止状态。处于终止状态的线程才会被操作系统内核回收。在任意线程中调用exit函数以及在主线程中执行return语句，都不但会使其所属进程中的所有线程立即终止，还会结束该进程的运行，无论当前线程是否被分离。</p><h3 id="4-线程的调度"><a href="#4-线程的调度" class="headerlink" title="4.线程的调度"></a>4.线程的调度</h3><p>调度器的实时调度和切换，产生众多线程并行运行的现象。调度器把时间划分成极小的时间片并把这些时间片分配给不同的线程，以使众多线程都能有机会在CPU上运行。</p><p>线程的执行总是趋向于CPU受限或I/O受限。即线程要么需要花费一定的时间使用CPU进行计算，要么花费一些时间等待相对较慢的I/O操作的完成。一个线程的趋向性并不总是清晰的，调度器往往需要猜测它们，依据对线程的趋向性的猜测把它们进行分类，并让I/O受限的线程具有更高的动态优先级以优先使用CPU。因为I/O操作往往花费很长的时间，应让其尽早地开始执行</p><p>线程的动态优先级可以被调度器实时调整，线程的静态优先级只能由程序指定。若程序没有显示的指定一个线程的静态优先级，则将被设定为0。调度器不会改变线程的静态优先级。线程的动态优先级是调度器根据其静态优先级调整得出。线程的静态优先级决定线程单次能够在CPU上运行的最长时间，即调度器分配给它的时间片的大小。</p><p>所有等待CPU的线程会被按照动态优先级从高到低的顺序排入到与该CPU对应的运行队列中。下一个被运行的线程总是动态优先级最高的一个。每一个CPU的运行队列中都包含两个优先级阵列，其中的一个用于存放正在等待运行的线程（激活的优先级阵列），另一个用于存放已经运行过但还未完成的线程（过期的优先级阵列）。优先级阵列是一个由若干个链表组成的数组。一个链表只会包含具有相同优先级的线程，一个线程也只会被放到与它的优先级相对应的哪一个链表中。当一个线程被放入某个优先级阵列的时候，实际上是被放入与它的优先级相对应的那个链表的末尾处。</p><p>下一个被运行的线程总是会从激活的优先级阵列中选出。若调度器发现某个线程已经占用了CPU很长时间（小于或等于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器会让等待的线程在CPU上运行。被换下来线程被排入过期的优先级阵列。当激活的优先级阵列中没有待运行的线程的时候，调度器会把这两个优先级阵列的身份互换，即之前的激活的优先级阵列称为新的过期的优先级阵列，之前的过期的优先级阵列成为新的激活的优先级阵列。被放入过期的优先级阵列的线程就又有机会被运行了。</p><p>线程被阻塞进入睡眠状态会从运行队列中被移除，不能够被调度和运行。睡眠状态分为可中断的睡眠状态和不可中断的睡眠状态，同多进程篇释意。</p><p>线程因等待某个事件或条件的发生而被加入到对应的等待队列中，并随即进入睡眠状态。当事件或条件发生时，内核通知对应的等待队列中的所有线程，线程被唤醒从等待队列转移至适当的运行队列中。调度器会稍稍调高被唤醒的线程动态优先级，使这类线程能够更早地被运行。</p><p>若计算机上有多个CPU，平衡它们之间的负载也是调度器的工作。调度器尽量使一个线程在一个特定的CPU上运行。有利于维护高速缓存的高命中率以及高效使用就进的内存。内核会为每个CPU都建立一个运行队列，每个队列中都保存对应CPU的负载系数。调度器根据这一系数了解并调整各个CPU的负载（还有其他因素），把在较忙碌的CPU上运行的线程迁移至其他较空闲的CPU上运行。</p><p>操作系统内核的调度器使用若干策略对众多线程在CPU上的运行进行干涉，使得操作系统中的各个任务都能够有条不紊地进行，同时兼顾效率和公平性。通过协调各个线程的状态达到调度的目的。</p><h3 id="5-线程实现模型"><a href="#5-线程实现模型" class="headerlink" title="5.线程实现模型"></a>5.线程实现模型</h3><p>线程的实现模型主要有3个：用户级线程模型、内核级线程模型和两级线程模型。差异于线程与内核调度实体（Kernel Scheduling Entity,简称KSE）之间的对应关系上。内核调度实体是可以被内核的调度器调度的对象。也被称为内核级线程，是操作系统内核的最小调度单元。  </p><ul><li>用户级线程模型：由用户级别的线程库全权管理。线程库并不是内核的一部分，只被存储在进程的用户空间之中。进程中的线程的存在对于内核来说是无法感知的，不是内核调度器的调度对象。对线程的各种管理和协调是用户级程序的自主行为，与内核无关。应用程序在对线程进行创建、终止、切换或同步等操作的时候，并不需要让CPU从用户态切换到内核态。用户线程模型在线程操作的速度上存在优势，对线程的管理不需要内核参入，程序的移植性更强。在此模型下的多线程不能够被真正地并发运行。当线程在I/O操作过程中被阻塞，其所属进程也会被阻塞，由线程无法被内核调度造成。调度器将进程看作一个无法再被分割的调度单元，无论其中存在多少个线程。即使计算机上存在多个CPU进程中的多个CPU也无法被分配给不同的CPU运行。对于CPU的负载均衡来说，进程的粒度太粗，让不同的进程在不同的CPU上运行的意义微乎其微。线程的优先级页形同虚设。同一个进程中的所有线程的优先级只能由该进程的优先级来体现。线程库对线程的调度不受内核控制，与内核为进程设定的优先级是没有关系的。现代操作系统都不是使用这种模型来实现线程的。由于包含了多个用户级线程的进程只与一个KSE相对应，这种线程实现模式也被称为多对一（M：1）的线程实现。</li><li>内核级线程模型：该模型下的线程由内核负责管理。是内核的一部分，应用程序对线程的创建、终止和同步都必须通过内核提供的系统调用来完成，进程中的每一个线程都与一个KSE相对应。内核可以分别对每一个线程进行调度。内核级线程模型又被称为一对一（1：1）的线程实现。线程完全由内核管理和调度，可以真正实现线程的并发运行。这些线程完全由内核来管理和调度，内核在极短的时间快速切换和运行各个线程使得它们看起来像正在被同时运行。即使进程中的一个线程由于某种原因进入到了阻塞状态，其他线程也不会受到影响并可以正常的运行。使得内核在多个CPU上进行负载平衡变得容易和有效。如果一个线程与被阻塞的线程之间存在同步关系，则可能受到影响。这是一种应用级别的干预，不属于线程本身的特质。内核对线程的全权接管使操作系统在库级别几乎无需为线程管理做什么事情。与用户级别线程模型形成鲜明的对比。内核线程的管理成本比用户级别线程高出很多。线程的创建会使用到内核资源。创建线程、切换线程、同步线程等操作所花费的时间也会更多。如果一个进程包含了大量的线程，会给内核的调度器造成非常大的负担，会影响到操作系统的整体性能。<code>采用内核级线程模型的操作系统对一个进程中可以创建的线程的数量有直接或间接的限制</code>。很多现代操作系统都是以内核级线程模型实现线程的，包括Linux操作系统。</li><li>两级线程模型：两极线程模型的目标是取前两种模型的精华，去二者只糟粕。被称为多对多（M：N）的线程实现。在此模型下，一个进程可以与多个KSE相关联。这与内核级线程模型是相似的。不同的是，进程中的线程（应用程序线程）并不与KSE一一对应。应用程序线程可以被映射到同一个已关联的KSL上。已被加载到进程的虚拟内存中的实现两级线程模型的线程库会通过操作系统内核创建多个内核级线程。然后，通过这些内核级线程对应用程序线程进行调度。大多数此类线程库都可以为实际运行运行的应用程序线程动态地分配若干个内核级线程。使线程的管理工作更加复杂，需要内核和线程库的共同努力和协作才能正确、有效地进行。但是内核资源的消耗得以减少，使线程管理操作的效能提高。因实现的复杂性，往往不会被操作系统内核的开发者采纳。但可以很好地在编程语言层面上实现并发挥出其应有的作用。<code>Go的并发编程模型与两级线程模型在理念上相似</code>，具体实现方式更加高级优雅些。<code>Go的并发编程模型中</code>，不受操作系统内核管理的独立控制流并不被叫作应用程序线程或者线程，而被称为Goroutine(也可称为Go程)。</li></ul><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>同步，永远是多线程编程中最核心和重要的话题之一。为多个线程更好地协同工作或者维持共享数据的一致性，以后者为目的的同步比较常见。</p><h3 id="1-共享数据的一致性"><a href="#1-共享数据的一致性" class="headerlink" title="1.共享数据的一致性"></a>1.共享数据的一致性</h3><p>包含多个线程的程序（多线程程序）多以共享数据作为在线程之间传递数据的手段。一个进程所拥有的相当一部分虚拟内存地址都可以被该进程中的所有线程所共享，这些被共享的数据大多以内存空间作为载体。共享数据的一致性代表着某种约定，在该约定成立的前提下，多线程程序中的各个线程才能够使相应的流程被正确地执行。</p><p>临界区是只能被串行化地访问或执行的某个资源或某段代码。亦被称作串行区域。保证临界区有效的最佳方式是利用同步机制，针对多线程的同步机制有：原子操作、互斥量、条件变量。</p><h3 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h3><p>在同一时刻只允许一个线程处于临界区之内的约束被称为互斥。每一线程在进入临界区之前都必须先锁定某个对象。只有成功锁定对象的线程才会被允许进入到临界区之内，否则就会被阻塞。这个对象被称为互斥对象或互斥量。</p><p>互斥量有两种可能的状态，锁定状态和未锁定状态。每次只能被锁定一次，任何线程都不能对它进行二次加锁。成功锁定互斥量的线程成为该互斥量的所有者，只有互斥量所有者才能对该互斥量进行解锁。锁定即对互斥量的获取，解锁即对互斥量的释放。</p><p>为合理、安全使用共享数据，应把操作同一个共享数据的代码都置于一个或多个临界区之内，并使用一个互斥量对它们进行保护。互斥量必须能够被使用相应的共享资源的线程访问到，因此互斥量的变量或常量一般不是局部的。为尽量少的暴露程序的实现细节，应该在满足要求的前提下最小化互斥量的访问权限。初始化互斥量应该在任何线程真正使用它之前进行。若多个线程将要执行的代码中都包含了对同一个互斥量的初始化操作，必须保证该互斥量只会被初始化一次。互斥量对每个想要锁定它的线程都是平等的。</p><blockquote><p>对互斥量的初始化必须要保证唯一性，线程在离开临界区时候必须要及时解锁互斥量，以免造成不必要的性能损耗甚至死锁。</p></blockquote><p>在一般情况下，应该尽量少地使用互斥量。每个互斥量保护的临界区应该在合理范围内并尽量地大。若多个线程频繁地进入某个较大的临界区，并且之间经常存在访问冲突，应该把这个较大的临界区切分成若干个较小的临界区，并使用不同的互斥量加以保护。目的是让等待进入同一个临界区的线程数变少，降低线程被阻塞的几率，减少处于睡眠状态的时间。从一定程度上提高程序的整体性能。若切分后不同的互斥量保护的临界区中包含了对同一个共享资源的同一种操作，则临界区的切分是不成功的。尽量不要让不同的互斥量所保护的临界区重叠，会增加<code>死锁</code>发生的几率。</p><p>当进程中的所有线程发生死锁，进程会停滞，只能重新启动，会丢失运行时数据甚至造成各种不一致的状态。</p><p>使用操作系统提供的线程库的功能，<code>试锁定和回退</code>：在执行一个代码块的时候需要先后锁定两个互斥量，在锁定其中一个互斥量成功之后使用<code>试锁定</code>的方法锁定另一个互斥量，若<code>试锁定</code>第二个互斥量不成功，就把第一个互斥量解锁，并重新对这两个互斥量进行锁定和<code>试锁定</code>。若需要需定的互斥量有多个，则总是先锁定其中一个，再按照上述流程<code>试锁定</code>其他互斥量并在必要时进行回退。<code>试锁定</code>指操作系统的线程库提供的一个函数，会尝试对一个互斥量进行锁定，锁定失败函数直接返回一个错误码，而不是阻塞在那里。</p><p><code>固定顺序锁定</code>：需要先后对多个对个互斥量进行锁定的场景下，总以固定不变的顺序锁定它们。避免因多个线程先后对多个互斥量锁定顺序不一致，导致互相等待对方释放锁并占用对方所需而造成的死锁。</p><p>互斥量的实现会使用到机器语言级别的原子操作，并仅在锁定冲突时才会涉及系统调用的执行。互斥量比其他同步方法（例如信号灯）的速度快。</p><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><p>条件变量不保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据状态发生发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥量组合使用，互斥量为共享数据的访问提供互斥支持，条件变量可以就共享数据的状态的变化向相关线程发出通知。当线程成功锁定互斥量从而访问到共享数据的时候，共享数据的状态并不一定正好满足它的要求。</p><p>条件变量在使用之前必须创建和初始化，初始化必须要保证唯一性，在被真正使用前必须要与某个互斥量进行绑定。在一个条件变量之上进行的操作有3种：  </p><ul><li>等待通知（wait）：阻塞当前线程，直至收到该条件变量发来的通知。</li><li>单发通知（signal）：让该条件变量向至少一个正在等待它的通知的线程发送通知，以表示某个共享数据的状态已经被改变。</li><li>广播通知（broadcast）：让条件变量给正在等待它的通知的所有线程都发通知，以表示某个共享数据的状态已经改变。</li></ul><p>等待通知会先解锁与该条件变量绑定在一起的互斥量，然后再使当前线程阻塞。只有在当前的共享数据的状态不满足条件时，才执行等待通知操作，检查共享数据的状态需要受到互斥量的保护，即检查共享数据状态的操作和等待通知操作都需要再相应的临界区内进行。等待通知操作所包含的解锁互斥量的操作和阻塞当前线程的操作共同形成一个原子操作。</p><p>等待通知操作因收到条件变量发送的通知而唤醒当前线程之后，会首先重新锁定与该条件变量绑定在一起的互斥量，若互斥量已经被其他线程抢先锁定，则当前线程再次进入睡眠状态。</p><p>条件变量的通知具有即时性，通知只是负责向等待线程发送一个信号以告知共享数据的状态发生了某种变化，而不会存储相关信息。在通知被发送的时候，若没有任何线程正在等待此条件变量的通知，该通知就会被无视，不会被传到在它被发送之后才开始等待它的线程。在互斥量的保护下执行单发通知操作通常会更加安全。</p><p>广播通知的发送线程无法得知有哪些线程正在等待共享数据的当前状态，不会知道在执行单发通知操作之后哪一个线程会接收到该通知，发送线程只执行广播通知操作以向所有的等待线程告知共享数据的状态已发生变化，不会关心哪些等待线程会对这一状态变化进行应答。等待线程被唤醒后会重新检查共享数据的状态，并自行决定是对此作出响应还是等待下一个通知。</p><h3 id="4-线程的安全性"><a href="#4-线程的安全性" class="headerlink" title="4.线程的安全性"></a>4.线程的安全性</h3><p>若一个代码块可以被多个线程并发地执行，并总能够产生预期的结果，则该代码块就是线程安全的（thread-safe）。例如若代码块中包含了对共享数据的更新操作，则此代码块就是非线程安全的。若该代码块中的类似操作都处于临界区之中，则此代码块是线程安全的。</p><p>常被置于线程安全问题之中的代码块是函数。函数是最常用的代码块，其线程安全性有着更多的含义。使函数具有安全性的最有效的方式是使其可重入（reentrant）。若某个进程中的所有线程都可以并发地对一个函数进行调用，并且无论它们调用该函数的实际执行情况怎样，该函数都可以产生预期的结果，则该函数是可重入的。即若多个线程并发的调用该函数与它们以任意的顺序依次地调用它所产生的效果总是相同的，则该函数的可重入的。</p><p>若一个函数把共享数据的值作为其返回的结果或者包含于其返回的结果中，则该函数不是可重入函数。为使函数可重入，杜绝在函数的返回结果中含有任何共享数据，除非共享数据是完全不可被更新的。任何内含了对共享数据进行操作的代码的函数都可以被视为不可重入函数。</p><p>为实现线程安全的函数，可将代码置于临界区之中，但低效。应从函数体中找出操作共享数据的代码并用互斥量把它门保护起来。更好的方式是将这些代码从函数体中分离出来，有利于施加保护措施。</p><p>若代码块中仅包含共享数据的访问操作而不包含对他们的更新操作，则代码块内可以不使用互斥量。但线程需要自己维护一份其需要使用道德共享数据的副本，线程会在使用共享数据之前就把它们完全复制到当前线程的线程栈之中。对于函数，副本作为其局部变量存在。某个线程对某个函数的第一次调用会致使该i函数中的局部变量陆续被创建在该线程的线程栈中。在不同线程的线程栈中，因调用相同的函数而被创建的同名局部变量之间是完全独立的，并且不会相互干扰。一般这样的函数是可重入的，即线程安全的。</p><h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><p>多线程在系统资源的利用和程序性能的提高方面具有优势，在某些情况（信号的处理、同时运行多套不同的程序以及包含多个需要超大内存支持的任务等），多进程编程更加合适。</p><h2 id="多核时代的并发编程"><a href="#多核时代的并发编程" class="headerlink" title="多核时代的并发编程"></a>多核时代的并发编程</h2><p>并发运行是指多个任务被同时发起运行，但是在同一时刻这些任务不一定都处于运行状态，取决于CPU核心或者CPU的数量。并行运行指在同一时刻可以有多个任务真正地同时运行，并行运行的必要条件是多CPU核心或多CPU的计算环境。并行运行的一个必要条件就是并发运行，是并发运行的一个更高级的层次。</p><p>提高并行程序的性能：  </p><ul><li>控制临界区的纯度。</li><li>控制临界区的粒度。</li><li>减少临界区中代码的执行耗时。</li><li>避免长时间持有互斥量。</li><li>优先使用原子操作而不是互斥量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-多进程编程理论</title>
      <link href="/2018/04/24/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/24/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>进程间的通讯常被称为IPC（Interprocess Communication）。Linux操作系统中分为基于通讯的IPC方法、基于信号的IPC方法以及基于同步的IPC方法。  基于通讯的IPC方法又分为以数据传送为手段的IPC方法和以共享内存为手段的IPC方法。  </p><ul><li>数据传送：管道（用以被传送子节流），消息队列（用以被传送结构化的消息对象）。</li><li>共享内存：共享内存区，最快的一种IPC方法。</li><li>基于信号：信号（signal）机制。</li><li>基于同步：信号灯（semaphore）。</li></ul><p>Go语言支持的IPC方法：管道、信号和Socket。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>用于描述程序的执行过程，程序与进程形成一对相依的概念，分别描述一个程序的静态形式和动态特征。进程是操作系统进行资源分配的一个基本单位。</p><h4 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h4><p>一个进程可以使用系统调用fork创建若干个新的进程，前者被称为后者的父进程，后者被称为前者的子进程。</p><blockquote><p>子进程源自它的父进程的一个副本，获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。每一份副本都是独立的，子进程对属于它的副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。</p></blockquote><p>Linux的操作内核使用写时复制（Copy On  Write，简称COW）等技术提高进程创建的效率。被创建的子进程可以通过系统调用exec把一个新的程序加载到自己的内存中，替换掉原先在其内存中的数据段、堆、栈以及代码段，之后子进程执行被加载进来的程序。</p><p>内核启动进程作为进程树的根负责系统的初始化操作，是所有进程的祖先，其父进程是其自己。若一个进程先于它的子进程结束，那么这些子进程将会被内核启动进程“收养”，成为它的直接子进程。</p><h4 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h4><p>为了进程管理，内核必须对每个进程的属性和行为进行详细的记录，包括优先级、状态、虚拟地址范围以及各种访问权限等等，被记录在每个进程的进程描述符中。</p><p>进程描述符是一个复杂的数据结构，被保存在进程描述符中的进程ID（常被称为PID）是进程在操作系统中的唯一标识。进程ID为1的进程是内核启动进程。进程ID是一个非负整数且总是递增的编号，新创建的进程的ID是前一个被创建的进程的ID递增的结果。进程ID可以被重复使用。当进程ID达到最大限值，内核从头开始查找已被闲置的进程ID并使用最先找到的哪一个作为新进程的ID。进程描述符中还包含当前进程的父进程ID（常被称为PPID）。</p><p>Go中使用标准库代码包os提供的API来查看当前进程的PID和PPPID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid := os.Getpid()</span><br><span class="line">ppid := os.Getppid()</span><br></pre></td></tr></table></figure></p><p>PID不传达与进程有关的任何信息，仅是一个用来唯一标识进程的数字。进程属性信息只被包含在内核中的、与PID对应的进程描述符中。PPID也是，可用于查找守护进程的踪迹。</p><p>进程ID对内核以外的程序非常有用，可以高效地把进程ID转换成对应进程的描述符。可以用shell命令kill终止某个进程ID所对应的进程，可以通过进程ID找到对应的进程并向它发送信号。</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>可运行状态、可中断的睡眠状体、不可中断的睡眠状体、暂停状态或跟踪状态、僵尸状态和退出状态。   </p><ul><li>可运行状态：（TASK_RUNNING，简称R）：处在该状态的进程将要、立即或正在CPU上运行。运行时机不确定由进程调度器来决定。</li><li>可中断的睡眠状态（TASK_INTERRUPTIBLE，简称S）：当进程正在等待某个事件（网络连接或信号灯）的发生时会进入此状体。会被放入对应事件的等待队列中，事件发生时，一个或多个进程就会被唤醒。</li><li>不可中断睡眠状态（TASK_UNINTERRUPTIBLE，简称D）:与可中断的睡眠状态的唯一区别是不可被打断，意味着处在此种状态的进程不会对任何信号作出响应。发送给处于此状态中进程的信号直到该进程转出该状态才会被传递过去。处于此状体的进程通常是由于在等待一个特殊的事件。例如等待同步的I/O操作（磁盘I/O等）的完成。</li><li>暂停状态或跟踪状态（TASK_STOPPED或TASK_TRACED，简称T）：向进程发送SIGSTOP信号就会使该进程处于暂停状态，除非该进程正处于不可中断的睡眠状态。向处于暂停状态的进程发动SIGCONT信号会使进程转向可运形状体。处于被跟踪状态的进程会暂停并等待跟踪它的进程对它进行操作。跟踪状态与暂停状态非常相似，但是，向处于跟踪状态的进程发送SIGCONT信号并不能使它被恢复。只有当调试进程进行了相应的系统调用或退出之后，它才能够被恢复。</li><li>僵尸进程（TASK_DEAD-EXIT_ZOMBIE，简称Z）：处于此状态的进程即将要结束。该进程占用的绝大多数资源也都已经被回收。还有一些信息还未被删除，例如退出码以及一些统计信息。保留这些信息考虑到该进程的父进程可能需要它们。由于此时的进程主体已经被删除而只留下了一个空壳，故此状态常被称为僵尸状态。</li><li>退出状态（TASK_DAED-EXIT_DEAD，简称X）：在进程退出过程中，有可能连退出码和统计信息都不需要被保留。造成原因可能是显示地让该进程的父进程忽略掉SIGCHLD信号（当一个进程消亡的时候，内核会给其父进程发送一个SIGCHLD信号以告之），也可能是该进程已经被分离（让子进程和父进程分别独立的运行）。分离后的子进程将不会再使用和执行父进程共享的代码段中的指令，而是加载并运行一个全新的程序。在此情况下，改进程在退出的时候就不会转入僵尸状态，而会直接转入退出状态。处于退出状态的进程会被结束掉，所占用的系统资源会被操作系统自动回收。</li></ul><p>进程的状态只会在可运行状态和非可运行状态之间转换。</p><h4 id="进程的空间"><a href="#进程的空间" class="headerlink" title="进程的空间"></a>进程的空间</h4><p>一个用户进程（程序的执行实例）总会生存于用户空间中，这些进程可以做很多事，但是却不能与其所在的计算机的硬件进行交互。内核可以与硬件交互，但是却生存在内核空间中。用户进程无法直接访问内核空间。用户空间和内核空间体现了Linux操作系统对物理内存的划分。即这两个空间指的都是操作系统在内存上划分出的一个范围，共同瓜分操作系统能够支配的内存区域。</p><p>内存空间中的每一个单元都是有地址的，由指针来标识和定位。这里所指的地址并非物理内存中的真实地址，被称为虚拟地址。由虚拟地址来标识的内存区域又被称为虚拟地址空间，或虚拟内存。虚拟内存的最大容量与实际可用的物理内存的大小是无关的。内核和CPU会负责维护虚拟内存与物理内存之间的映射关系。</p><p>内核为每个用户进程分配的是虚拟内存而不是物理内存，每个用户进程被分配到的虚拟内存总是在用户空间中的，而内核空间被留给内核专用。每个用户进程都会认为分配给它的虚拟内存就是整个用户空间。一个用户进程不可能操纵另一个用户进程的虚拟内存，因为后者的虚拟内存对于前者来说是不可见的。即进程间的虚拟内存几乎是彼此独立、互不干扰的。由于它们基本被映射到了不同的物理内存之上。</p><p>内核把进程的虚拟内存划分为若干页（page）。物理内存单元的划分由CPU负责。一个物理内存单元被称为一个页框（page frame）。不同进程的大多数页都会与不同的页框相对应。</p><p>进程之间共享页框是被允许的，是作为IPC方法之一的共享内存区的基础。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>内核会暴露一些接口给用户进程，使用户进程能够使用操作系统更底层的功能，是用户进程能够使用内核功能（包括操纵计算机硬件）的唯一手段。用户进程使用这些接口的行为被称为系统调用，有时“系统调用”也指内核提供了这些接口。系统调用是向内核空间发出的一个明确的请求，而普通的函数只是定义了如何获取一个给定的服务。系统调用会导致内核空间中的数据的存取和指令的执行，而普通函数只能在用户空间中进行操作。系统调用是内核的一部分。</p><p>为保证操作系统的稳定性和安全，内核依据CPU提供的、可以让进程驻留的特权级别建立了两个特权状态。即内核态和用户态。大部分时间里CPU都处于用户态，这时CPU只能对用户空间进行访问，即CPU在用户态下运行的用户进程不能与内核接触。当用户进程发出一个系统调用时，内核会把CPU从用户态切换到内核态，而后会让CPU执行对应的内核函数。CPU在内核态下由权限访问内核空间。相当于使用户进程通过系统调用使用到了内核提供的功能。当内核函数被执行完毕，内核会把CPU从内核态切换回用户态，并把执行结果返回给用户进程。</p><blockquote><p>只有当CPU被切换至内核态之后才可以执行内核空间中的函数，而在内核函数执行完毕后，CPU状态也会被及时地切换回用户态。</p></blockquote><h4 id="进程的切换和调度"><a href="#进程的切换和调度" class="headerlink" title="进程的切换和调度"></a>进程的切换和调度</h4><p>Linux操作系统通过CPU，可以在多个进程间进行切换（也称为进程间的上下文切换），以产生多个进程在同时运行的假象。每个进程会认为自己独占CPU。在进程切换时，需要保存当前进程的运行时状态，若要执行的另一个进程不是第一次运行则需要将该进程恢复到之前被换下时的运行时状态。进程切换主要是由内核来完成，除了进程切换之外，为了使各个生存着的进程都有被u运行的机会、让它们共享CPU，内核还需考虑把哪一个进程应该作为下一个被运行的进程、应该在哪一时刻进行切换，以及切换下的进程需要在哪一时刻再被换上，等等。解决类似问题的反感和任务被统称为进程调度。</p><p>进程切换和进程调度是程序并发执行的基础。</p><h3 id="关于同步"><a href="#关于同步" class="headerlink" title="关于同步"></a>关于同步</h3><p>当几个进程同时对同一个资源进行访问的时候，可能造成互相的干扰，即竟态条件。造成竟态条件的根本原因在于进程在进行某些操作的时候被中断了。虽然进程再次运行的时候其状态会恢复如初，但是外界环境很可能已经在这极短的时间内改变了。</p><p>我们把执行过程中不能被中断的操作称为原子操作（atomic operation），把只能被串行化的访问或执行的某个资源或某段代码称为临界区（critical section）。原子操作是不能被中断的，临界区对是否可以被中断没有强制的规定。只要保证一个访问者在临界区中的时候其他访问者不被允许进入。所有的系统调用都属于原子操作，执行不会被中断。</p><p>原子操作必须由一个单一的汇编指令代表，并且需要得到芯片级别的支持。原子操作能够做到绝对的并发安全，并且比其他同步机制要快很多。原子操作只适合细粒度的简单操作。Go在CPU和各个操作系统的底层支撑之上提供了对原子操作的支持。由标准库代码包<code>sync/atomic</code>中的一些函数代表。</p><p>让要求被串行执行的若干代码形成临界区的做法更通用，保证只有一个进程或线程在临界区之内的做法是——互斥（mutual exclusion，简称mutex）。实现互斥的方法必须确保排他原则（exclusion principle），并且保证不能依赖于任何计算机硬件（包括CPU）。即互斥方法必须有效且通用。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道（pipe）是一种半双工（单向）通讯方式。只能用于父进程与子进程以及同祖先的子进程之间的通讯。例如shell:</p><blockquote><p><code>ps aux | grep go</code></p></blockquote><p>shell为每个命令都创建一个进程，然后把左边的命令的标准输出用管道与右边的命令的标准输入连接起来。优点简单，缺点只能单向通讯以及通讯双方关系上的严格限制。</p><p>使用标准库代码包os/exec中的API，可以执行操作系统命令并在此之上建立管道。</p><blockquote><p><code>cmd := exec.Command(&quot;echo&quot;,&quot;-n&quot;,&quot;command from golang.&quot;)</code></p></blockquote><p>cmd同操作系统命令</p><blockquote><p><code>echo -n &quot;command from golang&quot;</code></p></blockquote><p>对应。</p><p>可以使用exec.Cmd类型之上的Start方法启动一个操作系统命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := cmd.Start();err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not be startup:%s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用cmd的值的StdoutPipe方法创建一个能够获取此命令输出的管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stdout, err := cmd.StdoutPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdout pipe for command: %s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出管道stdout类型是io.ReadCloser，这是接口类型并扩展了接口类型io.Reader。启动命令之后可以调用stdout的值的Read方法获取命令的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">output := make([]byte,30)</span><br><span class="line">n, err := stdout.Read(output)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, output[:n])</span><br><span class="line">----</span><br><span class="line">var outputBuf bytes.Buffer  //标准库代码包bytes</span><br><span class="line">for &#123;</span><br><span class="line">    tempOutput := make([]byte, 5)</span><br><span class="line">    n, err := stdout.Read(tempOutput)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        if err == io.EOF &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;,err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if n &gt; 0 &#123;</span><br><span class="line">        outputBuf.Write(tempOutput[:n])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, outputBuf.String())</span><br></pre></td></tr></table></figure></p><p>Read方法把读出的输出数据存入调用方法传递给它的字节切片中并返回一个int类型值和一个error类型值。命令输出小于output的值的长度，n的值代表命令实际输出的字节的数量。否则我们并没有完全读出输出管道中的数据，n的值等于output的值的长度，需要再去读取一次或者多次。若输出管道中没有可读数据，Read方法返回的第二个结果值为变量io.EOF的值，可判断是否被读完。</p><p>使用带缓冲的读取器从输出管道中读取数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">putputBuf := bufio.NewReader(stdout)</span><br><span class="line">output, _, err := outputBuf.ReadLine()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;,string(output))</span><br></pre></td></tr></table></figure></p><p>stdout的值是io.Reader类型，作为bufio.NewReader函数的参数，返回一个bufio.Reader类型的值。即缓冲读取器。默认缓冲读取器携带一个长度4096的缓冲区，长度代表了一次可以读取的字节的最大数量。cmd代表的命令只有一行输出，使用outputBuf的ReadLine方法读取。第二个bool类型结果代表当前行是否还未被读完，若为false可以利用for语句读取剩余的数据。</p><p>使用Go实现<code>ps aux | grep go</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cmd1 := exec.Command(&quot;ps&quot;, &quot;aux&quot;)</span><br><span class="line">cmd2 := exec.Command(&quot;grep&quot;, &quot;go&quot;)</span><br><span class="line">stdout1, err := cmd1.StdoutPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdout pipe for command: %s&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if err := cmd1.Start(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not running: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">outputBuf1 := bufio.NewReader(stdout1)</span><br><span class="line">stdin2, err := cmd2.StdinPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdin pipe for command: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">outputBuf1.WriteTo(stdin2)</span><br><span class="line">var outputBuf2 bytes.Buffer</span><br><span class="line">cmd2.Stdout = &amp;outputBuf2</span><br><span class="line">if err := cmd2.Start(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not be startup: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">err = stdin2.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not close the stdio pipe: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if err := cmd2.Wait(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not wait for the command: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过StdinPipe方法在cmd2之上创建一个输入管道，然后把cmd1连接的输出管道中的数据全部写入到这个输入管道中。返回与该命令连接的输入管道，是io.WriteCloser接口类型类型的值，扩展了io.Writer接口类型，可被作为outputBuf1的WriteTo方法的参数。把所属值中缓冲的数据全部写入到参数值代表的写入器中。等于把第一个命令的输出内容通过管道传递给第二个命令。之后需启动cmd2并关闭与它连接的输入通道。调用cmd2的Wait方法阻塞其所属的命令直到完全运行结束为止，然后再读取outputBuf2的内容。</p><p>以上为<code>匿名管道</code>，对应的是<code>命名管道</code>，任何进程都可以通过命名管道交换数据，以文件的形式存在于文件系统中。linux中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost Test]$ mkfifo -m 644 myfifo</span><br><span class="line">[joker@localhost Test]$ tee dst.log &lt; myfifo &amp;</span><br><span class="line">[1] 13315</span><br><span class="line">[joker@localhost Test]$ cat src.log &gt;myfifo</span><br><span class="line">12345</span><br><span class="line">[1]+  完成                  tee dst.log &lt; myfifo</span><br></pre></td></tr></table></figure></p><p>创建命名管道myfifo，将src.log的内容写道dst.log。命名管道是阻塞式的，只有在对这个命令管道的读操作和写操作都已经准备就绪之后数据才会开始流转。相对于匿名管道，命名管道的通讯双方可以毫不相干，仍是单向的。可以使用它建立非线性的连接实现数据的多路复用，需要考虑多个进程同时向命名管道写数据的情况下的操作原子性问题。</p><p>Go标准库代码包os中包含了可以创建独立管道的API。</p><blockquote><p><code>reader, writer, err := os.Pipe()</code></p></blockquote><p><code>reader</code>代表了该管道输出端的*os.File类型值。  </p><p><code>writer</code>代表了该管道输入端的*os.File类型值。  </p><p>可以在其之上调用*os.File类型包含的所有方法。  </p><p>在Go底层使用系统函数来创建管道，并将两端封装成两的*os.File类型的值。</p><p>命名管道默认在其中一端还未就绪的时候阻塞另一端的进程。不能反过来使用reader或者writer，在reader上调用Write方法或在writer上调用Read方法获取的第二个结果值都将是一个非nil的error类型值。无论在哪一方调用Close方法都不会影响另一方的读取或写入数据的操作。</p><blockquote><p>在exec.Cmd类型值上调用StdinPipe或StdoutPipe方法后得到的输入管道或输出管道也是通过os.Pipe函数生成的。在两个方法内部对生成的管道做了附加处理。输入管道的输出端在所属命令启动后被立即关闭，输入端在所属命令运行结束后被关闭。输出管道的两端的自动关闭时机与输入管道相反。有些命令会等到输入管道被关闭之后才结束运行，需要在数据被读取之后尽早地手动关闭输入管道。</p></blockquote><p>由于通过os.Pipe函数生成的管道在底由系统级别的管道支持，所以在使用时，要注意操作系统对管道的限制。例如匿名管道会在管道缓冲被写满之后使用写数据的进程阻塞，命名管道会在其中一端未就绪前阻塞另一端的进程。</p><p>当有多个输入端同时写入数据时，需要考虑原子性问题。操作系统提供的管道不提供原子操作支持。Go在标准库代码包io中提供一个被存于内存中的、有原子性操作保证的管道（内存管道）。生成方法:  </p><blockquote><p><code>reader, writer := io.Pipe()</code></p></blockquote><p><code>reader</code>代表该管道输出端的*PipeReader类型值。  </p><p><code>writer</code>代表该管道输入端的*PipeWriter类型值。</p><p>*PipeReader类型和*PipeWriter类型分别对管道的输出端和输入端做了很好的限制。在*PipeReader类型的值上只能使用Read方法从管道中读取数据，在*PipeWriter类型的值上只能使用Write方法向管道写入数据，避免管道使用者对管道的反向使用。使用Close方法关闭管道的某一端之后，另一端在写入数据或者读取数据的时候会得到一个预定义的error类型值。可以通过调用CloseWithError来自定义另一端将会得到的error类型值。</p><p>于os.Pipe函数生成的管道相同的是，仍然需要并发的运行被用来在内存管道的两端进行操作的代码。在内存管道的内部通过充分使用sync代码包中提供的API从根本上保证操作的原子性。这种管道不是基于文件系统，没有作为中介的缓冲区，通过它传递的数据只会被复制一次，提高数据的传递效率。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>操作系统中的信号（Signal）是IPC中唯一一种异步的通讯方法。本质是用软件来模拟硬件的中断机制。被用于通知某个进程有某个事件发生。</p><p>每一个信号都有一个以“SIG”为前缀的名字，在操作系统内部，信号都由正整数代表，称为信号编号，Linux系统可使用<code>kill -l</code>命令查看所支持的信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure></p><p>支持62种信号（没有编号为32和33的信号），编号1-31的信号属于标准信号（不可靠信号），编号34-64的信号属于实时信号（可靠信号）。对于同一个进程，每种标准信号只会被记录并处理一次。若发送给某一进程的标准信号的种类有多个，被处理的顺序是完全不确定的。而多个实时信号都可以被记录，并且按照信号的发送顺序被处理。</p><p>信号的来源有键盘输入、硬件故障、系统函数调用和软件中的非法运算。进程响应信号的方式有3种：忽略、捕捉和执行默认操作。</p><p>Linux操作系统对每一个标准信号都有默认的操作方式，针对不同种类的标准信号，其默认的操作方式一定会是以下操作中的一个：终止进程、忽略该信号、终止进程并保存内存信息、停止进程、恢复停止的进程。对大多数标准信号可以自定义当进程接收到它们之后应该进行怎样的处理。自定义信号响应的唯一方法是：进程告知操作系统内核，当某种信号到来时，需要执行某种操作。在程序中，信号响应的自定义操作常由函数实现。</p><p>Go使用标准库代码包中<code>os/signal</code>中的处理信号的API对<code>标准信号</code>作出响应。指定了需要被处理的信号并用一种方式（使用到通道类型的变量）来监听信号的到来。</p><p>os.Signal接口类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal()//to distinguish from other Stringers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Signal</code>方法的声明无实际意义，作为os.Signal接口类型的一个标识。此接口的所有实现接口的Signal方法都是空方法。</p><p>所有此接口类型的实现类型的值都可以代表一个操作系统信号，每一个操作系统都需要由操作系统所支持。</p><p>标准库代码包syscall中，为不同的操作系统所支持的每一个<code>标准信号</code>都声明一个相应的同名常量(信号常量)，信号常量的类型都是syscall.Signal的，是os.Signal接口类型的一个实现，同时也是int类型的别名类型。意味着每一个信号常量都隐含着一个整数值，信号常量的整数值与其所代表的信号在所属操作系统中的编号一致。在syscall.Signal类型的String方法，有一个包级私有名为signal的数组类型的变量，每个索引值代表了一个<code>标准信号</code>的编号，对应的元素则是针对该信号的一个简短的描述。</p><p>代码包os/signal中的Notify函数用来把操作系统发送给当前进程的指定信号通知给该函数的调用方。</p><blockquote><p><code>func Notify(c chan &lt;- os.Signal, sig ...os.Signal)</code></p></blockquote><p>第一个参数是通道类型，该通道中只能传递os.Signal类型的值（信号值），在signal.Notify中，只能向该通道类型值放入信号值，不能从该值中取出信号值。此函数把当前进程收到的指定信号放入参数c代表的通道类型值（signal接收通道）中，调用方代码可以从signal接收通道中按顺序获取操作系统法送来的信号并进行相应的处理。</p><p>第二个参数是一个可变长参数，在调用signal.Notify函数时，可以在第一个参数值之后附加任意个os.Signal类型的值，sig代表的参数值包含我们希望自行处理的所有信号。接收到希望自行处理的信号之后，os/signal包中的处理程序（signal处理程序）会把它封装成syscall.Signal类型的值并放入到signal接收通道中。只为第一个参数绑定实际值被当作自行处理所有信号，并把接收到的几乎所有的信号都逐一进行封装并放入到signal接收通道中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigRecv := make(chan os.Signal, 1)</span><br><span class="line">sigs := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;</span><br><span class="line">signal.Notify(sigRecv, sigs..)</span><br><span class="line">for sig := range sigRecv &#123;</span><br><span class="line">    fmt.Printf(&quot;Received a signal :%s\n&quot;,sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建调用signal.Notify函数所需的两个参数的值。sigRecv是signal接收通道，sigs切片代表了希望自定义处理的SIGINT和SIGQUIT信号。只要sigRecv的值中存在元素值，for语句就会把它们按顺序地接收并赋给迭代变量sig。在sigRecv代表的通道类型值被关闭后，for语句会立即被退出执行，不用担心程序在这里死循环。</p><p>signal处理程序在向signl接收通道发送值的时候，不会因为通道已满而产生阻塞。signal.Notify函数的调用方必须保证signal接收通道会由足够的空间缓存并传递接收到的信号。应此可以创建一个足够长的接收通道，或者只创建一个长度为1的通道并时刻准备从该通道中接收信号。</p><p>当接收到不想自定义处理的信号，执行操作系统指定的默认操作。指定了想要自行处理的信号但没有在接收到信号时执行必要的处理动作，相当于使当前进程忽略了这些信号。</p><p>在类Unix操作系统下的SIGKILL和SIGSTOP信号既不能被自行处理也不会被忽略，对他们的操作只能是执行默认操作。因为它们向系统的超级用户提供了使进程终止或停止的可靠方法，系统不允许任何程序消除或改变与这两个信号所对应的处理动作。</p><p>对于其他信号，除了能够自行处理它们之外，还可以使用os/signal包中的Stop方法在之后的任意时刻恢复针对它们的系统默认操作。其声明为：</p><blockquote><p><code>func Stop(c chan &lt;- os.Signal)</code></p></blockquote><p>参数声明与signal.Notify函数的第一个参数声明完全一致。函数signal.Stop取消掉在之前调用signal.Notify函数的时候告知signal处理程序需要自行处理的若干信号的行为。把当初传递给signal.Notify函数的signal接收通道作为调用signal.Stop函数的参数。调用signal.Stop函数后，作为其参数的signal接收通道将不会再被发送任何信号。这会使之前被用于从signal接收通道接收信号值的for语句一直阻塞，需要再调用signal.Stop函数之后使用内建函数close关闭该signal接收通道。此是for语句会退出执行。</p><p>只取消部分自行处理信号的行为，可再次调用signal.Notify函数并重新设定于其参数sig绑定的、以os.Signal为元素类型的切片类型值（信号集合），第一个参数的signal接收通道要相同。若signal接收通道不同，signal处理程序会将两次调用视为毫不相干，分别看待这两次调用时所设定的信号集合。</p><p>signal处理程序内部存在一个包级私有字典（信号集合字典）用于存放signal接收通道为键、以信号集合的变体为元素的键值对。调用sianal.Notify函数时，signal处理程序就会在信号集合字典中查找相应的键值对，如果键值对不存在，就向信号集合字典添加这个新的键值对，否则就更新该键值对中信号集合的变体。前者相当于向signal处理程序注册一个信号接收保证的申请，后者相当于更新该申请，signal接收通道作为调用方接收信号的为一途经，成为申请的标识。调用signal.Stop函数时，signal处理程序会删除掉信号集合字典中以该函数的参数值（某个signal接收通道）为键的键值对。</p><p>当接收到一个发送当前进程且已被标识为应用程序想要自行处理的操作系统信号之后，signal处理程序会对它进行封装，然后遍历信号集合字典中的所有键值对，并查看它们的元素中是否包含了该信号。若包含，就会立即把它发送给作为键的signal接收通道。</p><!-- signal接收通道再Go提供的操作系统信号通知机制中起到了很重要的作用，能否合理地处理操作系统的信号，基本在于signal接收通道的初始化和使用的方式。 --><p>使用os.StartProcess函数启动一个进程,或者使用os.FindProcess函数查找一个进程,两个函数都返回一个*os.Process类型的值(进程值)和一个error类型的值。可以调用该进程值的Signal方法向该进程发送一个信号，其接受一个os.Signal类型的参数值并返回一个error类型值。</p><blockquote><p><code>ps aux | grep &quot;mysignal&quot; | grep -v &quot;grep&quot; | awk &#39;{print $2}&#39;</code></p></blockquote><p><code>go run</code>命令程序中执行一系列的操作，包括依赖查找、编译、打包、链接等步骤，完成之后会有一个与被运行的命令源码文件的主文件名同名的可执行文件被生成在相应的临时工作目录中。实际上与<code>go build</code>命令生成的可执行文件一致，但是运行执行可执行文件而产生的进程是一个全新的进程，与代表了<code>go run mysignal.go</code>命令的进程毫不相干。即两个进程互相独立，都拥有自己的进程ID。使用<code>go run</code>命令运行mysignal.go，命令会生成并执行可执行文件mysignal，然后该可执行文件所产生的输出会通过该命令程序打印到标准输出上。即该命令程序被挂起、停止或终止后，mysignal中程序所打印的内容也再不会出现在标准输出上。</p><blockquote><p><code>ps aux | grep &quot;mysignal&quot; | grep -v &quot;grep&quot; | grep -v &quot;go run&quot; | awk &#39;{print $2}&#39;</code></p></blockquote><p>加入<code>grep -v &quot;go run&quot;</code>过滤掉原先进程列表中的与<code>go run</code>命令对应的进程。</p><p>信号与管道都被称为基础的IPC方法。再基于数据传递的解决方案中，要保证数据的原子性，管道不提供这种原子性保证，Go标准库中提供的API也没有附加这种保证。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket，常被译为套接字，通过网络连接来使两个或更多的进程建立通讯并相互传递数据。使通讯端的位置透明化。</p><h4 id="1-Socket的基本特征"><a href="#1-Socket的基本特征" class="headerlink" title="1.Socket的基本特征"></a>1.Socket的基本特征</h4><p>在Linux操作系统中存在一个名为Socket的系统调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure></p><p>接收三个参数分别代表了这个Socket的通讯域、类型和所用协议。通讯域决定了该Socket的地址格式和通讯范围。</p><table><thead><tr><th style="text-align:center">通讯域</th><th style="text-align:center">含义</th><th style="text-align:left">地址形式</th><th style="text-align:left">通讯范围</th></tr></thead><tbody><tr><td style="text-align:center"> AF_INET</td><td style="text-align:center">IPv4域</td><td style="text-align:left">IPv4地址（4个字节），端口号（两个字节）</td><td style="text-align:left">在基于IPv4协议的网络中的任意两台计算机之上的两个应用程序</td></tr><tr><td style="text-align:center"> AF_INET6</td><td style="text-align:center">IPv6域</td><td style="text-align:left">IPv6地址（16个字节），端口号（两个字节）</td><td style="text-align:left">在基于IPv6协议的网络中的任意两台计算机之上的两个应用程序</td></tr><tr><td style="text-align:center"> AF_UNIX</td><td style="text-align:center">Unix域</td><td style="text-align:left">路径名称</td><td style="text-align:left">在同一台计算机上的两个应用程序</td></tr></tbody></table><p><code>AF</code>是“address family”的缩写。</p><p>Socket的类型有SOCK_STREAM、SOCK_DGRAM、面向更底层的SOCK_RAW、针对某个新兴数据传输技术的SOCK_SEQPACKET。</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">SOCK_DGRAM</th><th style="text-align:center">SOCK_RAW</th><th style="text-align:center">SOCK_SEQPACKET</th><th style="text-align:center">SOCK_STREAM</th></tr></thead><tbody><tr><td style="text-align:center">数据形式</td><td style="text-align:center">数据报</td><td style="text-align:center">数据报</td><td style="text-align:center">字节流</td><td style="text-align:center">字节流</td></tr><tr><td style="text-align:center">数据边界</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center">逻辑边界</td><td style="text-align:center">没有</td><td style="text-align:center">没有</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">数据有序性</td><td style="text-align:center">不能保证</td><td style="text-align:center">不能保证</td><td style="text-align:center">能够保证</td><td style="text-align:center">能够保证</td></tr><tr><td style="text-align:center">传输可靠性</td><td style="text-align:center">不具备</td><td style="text-align:center">不具备</td><td style="text-align:center">具备</td><td style="text-align:center">具备</td></tr></tbody></table><blockquote><p>以数据报为数据形式意味着数据接收方的Socket接口程序可以意识到数据的边界并会对他们进行切分。省去接收方的应用程序寻找数据边界和切分数据的工作量。</p></blockquote><blockquote><p>以字节流为数据形式的数据传输传输的是一个字节接着一个字节的串，类似很长的字节数组。一般情况字节流并不能出哪些字节属于哪个数据包。Socket接口程序无法从中分离出独立的数据包。这一工作由应用程序完成。SOCK_SEQPACKET类型的Socket的接口程序不同，数据发送方的Socket接口程序可以记录数据边界，即应用程序每次发送的字节流片段之间的分界点。数据边界信息随着字节流一同被发往数据接收方。数据接收方的Socket接口程序会根据数据边界把字节流切分成（或者说还原成）若干个字节流片段并按照需要依次传递给应用程序。</p></blockquote><p>面向有连接的Socket之间在进行数据传输之前必须要先建立逻辑连接，之后通讯双方可以互相传输数据。连接暗含双方地址，在传输数据时不必再指定目标地址。面向无链接的Socket再进行通讯时无需建立连接，传递的每一个数据包都是独立的，被直接发送到网络上，每个数据包都含有目标地址，数据流是单向的。不能用同一个面向无连接的Socket实例既发送数据又接收数据。</p><p>SOCK_RAW类型的Socket提供了一个可以直接通过底层（TCP/IP协议栈中的网络互联层）传递数据。应用程序必须具有操作系统的超级用户权限才能够使用这种方式，使用成本相对较高，应用程序一般需要自己构建数据传输格式（像TCP/IP协议栈中的TCP协议的数据段格式和UDP协议的数据报格式）。应用程序极少使用这种类型的Socket。</p><p>一般把0作为Socket的第三个参数值，含义是让操作系统内核根据第一个参数和第二个参数的值自行决定Socket所使用的协议。既Socket的通讯域和类型与所使用的协议之间存在对应关系。</p><table><thead><tr><th style="text-align:center">决定因素</th><th style="text-align:center">SOCK_DGRAM</th><th style="text-align:center">SOCK_RAW</th><th style="text-align:center">SOCK_SEQPACKET</th><th style="text-align:center">SOCK_STREAM</th></tr></thead><tbody><tr><td style="text-align:center">AF_INET</td><td style="text-align:center">UDP</td><td style="text-align:center">IPv4</td><td style="text-align:center">SCTP</td><td style="text-align:center">TC或SCTP</td></tr><tr><td style="text-align:center">AF_INET6</td><td style="text-align:center">UDP</td><td style="text-align:center">IPv6</td><td style="text-align:center">SCTP</td><td style="text-align:center">TCP或SCTP</td></tr><tr><td style="text-align:center">AF_UNIX</td><td style="text-align:center">有效</td><td style="text-align:center">无效</td><td style="text-align:center">有效</td><td style="text-align:center">有效</td></tr></tbody></table><p><code>有效</code>表示该通讯域和类型的组合会使内核选择某个内部的Socket协议。<br><code>无效</code>表示该通讯域和类型的组合是不合法的。</p><p>在没有发生任何错误的情况下，系统调用socket会返回一个int类型的值，该值是作为socket唯一标示符的文件描述符。得到该标示符后，可以调用其他系统调用来进行各种相关操作，例如绑定和监听端口、发送和接收数据以及关闭Socket实例等等。</p><p>通过系统调用来操作系统提供的Socket接口，Socket接口程序与TCP/IP协议栈的实现程序一样，是Linux操作系统内核的一部分。</p><h4 id="基于TCP-IP协议栈的Socket通讯"><a href="#基于TCP-IP协议栈的Socket通讯" class="headerlink" title="基于TCP/IP协议栈的Socket通讯"></a>基于TCP/IP协议栈的Socket通讯</h4><p>通过Socket接口可以建立和监听TCP连接和UDP连接，可以直接与网络互联层的IP协议实现程序进行通讯。</p><p>使用标准库代码包net中的API编写服务端和客户端程序。</p><blockquote><p><code>func Listen(net, laddr string)(Listener, error)</code></p></blockquote><p>函数net.Listen被用于获取一个监听器，接收两个string类型的参数，参数一表示以何种协议在给定的地址上监听，Go中用一些字符串字面量来表示。</p><table><thead><tr><th style="text-align:center">字面量</th><th style="text-align:center">Socket协议</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center"> “tcp”</td><td style="text-align:center">TCP</td><td style="text-align:left">无</td></tr><tr><td style="text-align:center"> “tcp4”</td><td style="text-align:center">TCP</td><td style="text-align:left">网络互联层协议仅支持IPv4</td></tr><tr><td style="text-align:center"> “tcp6”</td><td style="text-align:center">TCP</td><td style="text-align:left">网络互联层协议仅支持Ipv6</td></tr><tr><td style="text-align:center"> “udp”</td><td style="text-align:center">UDP</td><td style="text-align:left">无</td></tr><tr><td style="text-align:center"> “udp4”</td><td style="text-align:center">UDP</td><td style="text-align:left">网络互联层协议仅支持IPv4</td></tr><tr><td style="text-align:center"> “udp6”</td><td style="text-align:center">UDP</td><td style="text-align:left">网络互联层协议仅支持IPv6</td></tr><tr><td style="text-align:center"> “unix”</td><td style="text-align:center">有效</td><td style="text-align:left">在通讯域协议为AF_UNIX且类型为SOCK_STREAM的时候内核采用的默认协议</td></tr><tr><td style="text-align:center"> “unixgram”</td><td style="text-align:center">有效</td><td style="text-align:left">在通讯域协议为AF_UNIX且类型为SOCK_DGRAM的时候内核采用的默认协议</td></tr><tr><td style="text-align:center"> “unixpacket”</td><td style="text-align:center">有效</td><td style="text-align:left">在通讯域为AF_UNIX且类型为SOCK_SEQPACKET的时候内核采用的默认协议</td></tr></tbody></table><p>函数net.Listen的第一个参数的值所代表的协议必须是面向流的协议，TCP和SCTP都属于面向流的协议，TCP协议实现程序无法记录和意识到任何消息边界，无法从字节流分离出消息，SCTP协议可以做到，使得应用程序无需再在发送的字节流的中间加入额外的消息分隔符，也无需再去查找所谓的消息分隔符并据此对字节流进行切分。</p><blockquote><p>net.Listen函数的第一个参数的值必须是tcp、tcp4、tcp6、unix和unixpacket中的一个。代表的都是面向流的协议。tcp表示Socket所用的TCP协议会兼容基于IPv4协议的TCP协议和基于IPv6协议的TCP协议。unix和unixpacket代表两个通讯域为Unix域的内部的Socket协议，遵循它们的Socket实例即被用于在本地计算机上的不同应用程序之间的通讯。</p></blockquote><p>第二参数laddr的值代表当前程序在网络中的标识，是Local Address的简写，格式为“host:port”,”host”代表IP地址或主机名，”port”代表当前程序欲监听的端口号。”host”处的内容必须是与当前计算机对应的IP地址或主机名，若是主机名该API中的程序会先通过DNS找到与主机名对应的IP地址，若主机名没有在DNS中注册会造成一个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listener, err := net.Listen(&quot;TCP&quot;, &quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure></p><p>返回的第一个结果是net.Listener类型，是我们欲获取的监听器，第二个结果是一个error类型值，代表可能出现的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := listener.Accept()</span><br></pre></td></tr></table></figure></p><p>调用时流程会被阻塞，直到某台计算机上的某个应用程序与当前程序建立了一个TCP连接。返回的第一个结果值代表当前TCP连接的net.Conn类型值，第二个结果值是一个error类型值。</p><p>代码包net的Dial函数用于向网络中的某个地址发送数据。  </p><blockquote><p><code>func Dial(network, address string)(Conn, error)</code>   </p></blockquote><p>参数一与net.Listen函数的第一个参数含义类似，拥有更多可选值。发送数据前不一定建立连接，UDP协议和IP协议都是面向无连接型的协议，udp、udp4、udp6、ip、ip4和ip6都可以作为network的值。unixgram也是network参数的可选值之一，代表了一个基于Unix域的内部Socket协议，以数据报作为传输形式。</p><p>参数二与net.Listen函数的第二个参数laddr完全一致。名称可由raddr（Remote Address）代替。laddr与raddr相对，前者指当前程序所使用的地址（本地地址），后者指参与通讯的另一端所使用的地址（远程地址）。</p><p>客户端的地址不用给出，端口号可以由程序指定，也可由操作系统内核动态分配。使用net.Dial建立Socket连接的客户端程序，占用的端口号由操作系统内核动态分配。客户端程序的地址中的”host”是本地计算机的主机名或IP地址，由操作系统内核指定。也可以自己去指定当前程序的地址，由另外的函数建立连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure></p><p>结果值一是net.Conn类型值，结果值二是一个error类型值。<br>网络延时表现在此行代码会一直阻塞，超过等待时间后函数的执行就会结束并返回相应的error类型值。不同操作系统对基于不同协议的连接请求的超时时间有不同的设定。Go可使用net包的DialTimeout函数设置超时时间。</p><blockquote><p><code>func DialTimeout(network, address string, timeout time.Duration ) (Conn, error)</code></p></blockquote><p>参数三设置超时间，类型为time.Duration，单位是纳秒。可用常量来表示时间，time.Nanosecond代表1纳秒，值为1。常量time.Microsecond代表1微秒，值为1000*Nanosecond，即1000纳秒。time.Second代表1秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;, 2*time.Second)</span><br></pre></td></tr></table></figure></p><p>此超时时间不是值此函数执行耗时，还包括DNS解析等耗时。</p><p>使用操作系统内核提供的API创建Socket等操作被隐藏在Go提供的Socket API中。</p><blockquote><p>通过调用net.Listen函数得到一个net.Listener类型值之后，调用该值的Accept方法等待客户端连接请求的到来，收到客户端的连接请求后，服务端与客户端建立TCP连接（三次握手）。成功建立连接后，通过Accept方法得到一个代表了该TCP连接的net.Conn类型值。通讯两端可以分别利用各自获得的net.Conn类型值交换数据。</p></blockquote><p>Go的Socket编程API在底层获取的是一个非阻塞式的Socket实例，使用Socket接口在一个TCP连接上的数据读取操作是<code>非阻塞式</code>的。在应用程序试图通过系统调用read从Socket的接收缓冲区中读取数据时，即使接收缓冲区中没有任何数据，操作系统内核也不会使系统调用read进入阻塞状态，而是返回一个错误码为“<code>EAGAIN</code>”的错误，应用程序不会视其为真正的错误，稍等片刻后再去尝试读取。若有数据，系统调用read就会携带这些数据立即返回。即使当时接收缓冲区中只包含了一个字节的数据也会是这样，这一特性被称为<code>部分读</code>（partial read）。向发送缓冲区写入一段数据，即使发送缓冲区已经被填满系统调用write也不会被阻塞，而是直接返回错误码为“<code>EAGAIN</code>”的错误，应用程序忽略该错误并稍后再尝试写入数据。若发送缓冲区中有少许剩余空间但不足以放入这段数据，那么系统调用write会尽可能地写入一部分数据然后返回已写入的字节的数据梁，这一特性被称为<code>部分写</code>（partial write）。应用程序每次调用write之后都会区检查该结果值，并发现数据未被完全写入时继续写入剩下的数据。在非阻塞的Socket接口下，系统调用accept也会显示一致的非阻塞风格，不会被阻塞以等待新连接的到来，会直接返回错误码为“<code>EAGAIN</code>”的错误。</p><p>Go语言Socket编程API屏蔽了非阻塞式Socket接口的部分写特性，相关API直到把所有数据全部写入到Socket的发送缓冲之后才会返回，除非在写入的过程中发生了某种错误。保留了非阻塞式Socket接口的部分读特性。在TCP协议之上传输的数据是字节流形式的，数据接收方无法意识到数据的边界（消息边界），Socket编程API程序无从判断函数返回的时机。</p><p>net.Conn类型是一个接口类型，在它的方法集合中包含了8个方法。</p><h5 id="Read方法"><a href="#Read方法" class="headerlink" title="Read方法"></a>Read方法</h5><p>被用来从Socket的接收缓冲区读取数据。</p><blockquote><p><code>Read(b []byte)(n int, err error)</code></p></blockquote><p>接受一个[]byte类型的参数，参数值相当于一个被用来存放从连接上接收到的数据的“容器”。长度由应用程序决定，Read会最多从连接中读取数量等于该参数值的长度的若干字节，并把它们依次放置到该参数值中的相应元素位置上。传递给Read方法的参数值应该是一个不包含任何非零值元素的切片值。一般情况，Read方法只有在把参数值填满之后才会返回。当未填满参数值且参数值靠后部分存在遗留元素时，通过返回的第一个结果值进行真正数据的识别，结果值n代表了实际读取到的字节的个数，即Read方法向参数值中填充的字节的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := make([]byte, 10)</span><br><span class="line">n, err := conn.Read(b)</span><br><span class="line">content := string(b[:n])</span><br></pre></td></tr></table></figure></p><p>若Socket编程API程序在从Socket的接收缓冲区中去读取数据的时候发现TCP连接已经被另一端关闭，则会立即返回一个err处理or类型值，与<code>io.EOF</code>变量的值是相等的，象征着文件内容的完结，此处意味着在TCP连接上再无可被读取的数据，即TCP连接已经无用，可以被关闭。若第二个结果值与io.EOF变量的值相等，则应该中止后续的数据读取操作，并关闭该TCP连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var dataBuffer bytes.Buffer</span><br><span class="line">b := make([]byte, 10)</span><br><span class="line">for &#123;</span><br><span class="line">    n, err := conn.Read(b)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        if err == io.EOF &#123;</span><br><span class="line">            fmt.Println(&quot;The connection is closed.&quot;)</span><br><span class="line">            conn.Close()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Printf(&quot;Read Error : %s\n&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    dataBuffer.Write(b[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可利用标准库代码包<code>bufio</code>（Buffered I/O）中的API实现一些较复杂的数据切分操作，提供了与带缓存的I/O操作有关的支持。net.Conn类型实现了接口类型<code>io.Reader</code>中唯一的方法Read，使用<code>bufio.NewReader</code>函数（接收一个io.Reader类型的参数值）包装变量conn：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(conn)</span><br></pre></td></tr></table></figure></p><p>调用reader变量的值之上的ReadBytes方法依次获取经过切分之后的数据。该方法接受一个byte类型的参数值，该参数值是通讯两端协商一致的边界消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line, err := reader.ReadBytes(&apos;\n&apos;)</span><br></pre></td></tr></table></figure></p><p>每次调用之后会得到一段以该i边界消息为结尾的数据。消息边界的定位比较复杂，HTTP协议规定消息头部信息的末尾是连续的两个空行“\r\n\r\n”，获取消息的头部信息后，相关程序通过其中名为“Cotent-Length”的信息项的值得到HTTP消息的数据部分的长度。bufio代码包提供了高级的API如<code>bufio.NewScanner</code>、<code>bufio.Sacnner</code>等函数处理。</p><h5 id="Write方法"><a href="#Write方法" class="headerlink" title="Write方法"></a>Write方法</h5><p>被用来向Socket的发送缓冲区写入数据。</p><blockquote><p><code>Write(b []byte)(n int, err error)</code></p></blockquote><p>屏蔽了很多非阻塞式Socket接口的细节，可以简单地调用它不用做其他额外的处理，除非操作超时异常。使用bufio的<code>bufio.NewWriter</code>函数（接收接收一个io.Writer类型的参数值）包装变量conn。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer := bufio.NewWriter(conn)</span><br></pre></td></tr></table></figure></p><p>writer的值可被看作针对变量conn代表的TCP连接的缓冲写入器。可以调用其上的以“Write”为名称前缀的方法分批次地向其中的缓冲区写入数据，也可调用<code>ReadFrom</code>方法直接从其他<code>io.Reader</code>类型值中读出并写入数据，调用Reset方法以达到重置和复用它的目的。写入全部数据后，调用<code>Flush</code>方法，保证其中的所有数据都被真正地写入到它的代理对象中。调用<code>bufio.NewWriterSize</code>函数初始化一个缓冲写入器，类似<code>bufio.NewWriter</code>，自定义将要生成的缓冲写入器的缓冲区容量，解决缓冲写入器的缓冲区容量（默认4096字节）小于写入的数据的字节数量的问题。否则<code>Write</code>方法试图把这些数据的全部或一部分直接写入到它代理的对象中，而不会先在自己的缓冲写入器中缓存这些数据。</p><h5 id="Close方法"><a href="#Close方法" class="headerlink" title="Close方法"></a>Close方法</h5><p>关闭当前的连接。不接受任何参数并返回一个error类型值。调用后该连接值上的Read方法、Write方法或Close方法的任何调用都会立即返回一个error类型值。</p><p>当调用Close方法时，Read方法或Write方法正在被程序调用且还未执行结束，会立即结束执行并返回非nil的error类型值，即使它们正处于阻塞状态。</p><h5 id="LocalAddr和RemoteAddr方法"><a href="#LocalAddr和RemoteAddr方法" class="headerlink" title="LocalAddr和RemoteAddr方法"></a>LocalAddr和RemoteAddr方法</h5><p>不接受任何参数并返回一个met.Addr类型的结果。代表了参入当前通讯的某一端的应用程序在网络中的地址。LocalAddr返回代表本地地址的net.Addr类型值，RemoteAddr返回代表远程地址的net.Addr类型值。net.Addr类型是一个接口类型，方法集合中有两个方法——Network和String，前者返回当前连接所使用的协议的名称，后者返回相应的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.LocalAddr().Network()  //协议名称</span><br><span class="line">conn.RemoteAddr().String()  //于服务端获取另一端（客户端）应用程序的网络地址</span><br><span class="line">conn.LocalAddr().String()   //于客户端获取操作系统内核为该客户端程序分配的网络地址</span><br></pre></td></tr></table></figure></p><h5 id="SetDeadline、SetReadDeadline、SetWriteDeadline方法"><a href="#SetDeadline、SetReadDeadline、SetWriteDeadline方法" class="headerlink" title="SetDeadline、SetReadDeadline、SetWriteDeadline方法"></a>SetDeadline、SetReadDeadline、SetWriteDeadline方法</h5><p>接收一个time.Time类型值，返回一个error类型值。</p><p><code>SetDeadline</code>:设置在当前连接上的I/O（包括但不限于读和写）操作的超时时间。为绝对时间对之后的每个I/O操作都起作用，循环从一个连接上读取数据，设定超时时间需要在每次迭代中的读取数据操作之前都设定一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b := make([]byte, 10)</span><br><span class="line">for &#123;</span><br><span class="line">    conn.SetDeadline(time.Now().Add(2 * time.Second))</span><br><span class="line">    n, err := conn.Read(b)</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>conn.SetDeadline(time.Time{})</code>//传入time.Time类型的零值取消超时时间</p></blockquote><p><code>SetReadDeadline</code>:针对读操作，即连接值的Read方法的调用的超时时间。</p><p><code>SetWriteDeadline</code>:针对写操作，即连接值的Write方法的调用的超时时间。</p><p>SetDeadline方法相当于先后以同样的参数值对SetReadDeadline和SetWriteDeadline方法进行调用。</p><blockquote><p>在服务端程序中，为了快速，独立地处理已经建立的每一个连接，应该尽量让这些处理过程并发地执行。否则处理已建立的第一个连接的时候，后续连接只能排队等待。</p></blockquote><p>Go语言标准库中，一些实现了某种网络通讯功能的代码包都是以net代码包所提供的Socket编程API为基础，如net/http代码包。标准库代码包net/rpc中的API为我们提供了在两个Go语言程序之间建立通讯和交换数据的另一种方式——远程过程调用（Remote Procedure Call）。基于TCP/IP协议，使用net包以及net/http包提供的API。</p><p>阅读<code>gpoc/src/multiproc/socket/tcpsock.go</code>小demo加深socket编程理解。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-并发理论</title>
      <link href="/2018/04/23/Golang%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/23/Golang%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>并发编程含义并不单一，基于一个独立程序（多线程编程）、一台计算机（多进程编程）、一个网络（分布式计算）。此处指在单台计算机的环境下可以使计算机指令同时发生并相互协作的计算机语言级别的并发计算技术。</p><p>主要思想是使多个任务可以在同一时间执行以便能够更快地得到结果。</p><h3 id="串行程序与并发程序"><a href="#串行程序与并发程序" class="headerlink" title="串行程序与并发程序"></a>串行程序与并发程序</h3><blockquote><p>串行程序：一个只能被顺序执行的指令列表。</p></blockquote><blockquote><p>并发程序：被并发的执行的两个或两个以上的串行程序的统称。</p></blockquote><p>并发程序允许其中的串行程序运行在一个或多个可共享的CPU之上，同时也允许每个串行程序都运行在专为它服务的CPU上。前一种方法称为<code>多元程序</code>：由操作系统内核支持并提供多个串行程序复用多个CPU的方法。也被被称为<code>多元处理</code>：计算机中的多个CPU共用一个存储器（即内存），并且在同一时刻可能会有数个串行程序分别运行在不同的CPU之上。</p><h3 id="并发程序与并行程序"><a href="#并发程序与并行程序" class="headerlink" title="并发程序与并行程序"></a>并发程序与并行程序</h3><blockquote><p><code>并发程序</code>：可以被同时发起执行的程序。</p></blockquote><blockquote><p><code>并行程序</code>：被设计成可以在并行的硬件上执行的程序。</p></blockquote><p>并发程序代表了所有可以实现真正的或者可能的并发行为的程序，包含了并行程序。</p><h3 id="并发程序与并发系统"><a href="#并发程序与并发系统" class="headerlink" title="并发程序与并发系统"></a>并发程序与并发系统</h3><p>并发程序属于程序，也可以称之为一个内聚的软件单元。松耦合的程序与程序之间可以通过协商一致的协议进行通讯，它们可以被看作是一个系统而不是程序。并发系统可能是并行的，常常成为并行系统。</p><h3 id="并发程序的不确定性"><a href="#并发程序的不确定性" class="headerlink" title="并发程序的不确定性"></a>并发程序的不确定性</h3><p>串行程序所有活动的先后顺序是固定的，一个并发程序中的活动只是部分有序的，即其中一些活动的发生顺序并没有被明确地指定，被称为不确定性。导致并发程序的每次运行的活动执行路径都是不同的。</p><h3 id="并发程序的内部交互"><a href="#并发程序的内部交互" class="headerlink" title="并发程序的内部交互"></a>并发程序的内部交互</h3><p>同步：避免在并发访问共享数据时可能存在的冲突，确保在互相传递数据时能够顺利地接通。</p><blockquote><p>在同一时刻，某一资源只能被一个程序占用。</p></blockquote><p><code>传递数据</code>是并发程序内部的另一种交互方式，被称为并发程序内部的通讯。也可以使用异步的方式对通讯进行管理，使得数据可以不加延迟地发送给数据接受方。即使在数据接收方还没有立即为接收该数据做好准备的时候，也不会造成数据发送方的等待。数据被临时存放在一个被称为<code>通讯缓存</code>的数据结构中。<code>通讯缓存</code>是一种特殊的共享资源，可以同时被多个程序使用，数据接收方可以在准备就绪后按照数据被存入通讯缓存的顺序从通讯缓存中接收它们。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 并发理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-测试</title>
      <link href="/2018/04/21/Golang%E7%AC%94%E8%AE%B0-%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/04/21/Golang%E7%AC%94%E8%AE%B0-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p>可使用go test命令或者标准库提供的testing代码包。</p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>测试源码文件应该与被测试源码文件处于同一代码包内。testing中的API和go test命令协同使用，testing提供自动化测试支持，自动执行目标代码包中的任何测试函数。</p><h4 id="功能测试函数"><a href="#功能测试函数" class="headerlink" title="功能测试函数"></a>功能测试函数</h4><p>功能测试程序以函数为单位，被用于测试程序实体功能的函数的名称和签名形如:<br><code>func TestXxx (t *testing.T)</code></p><h4 id="常规记录"><a href="#常规记录" class="headerlink" title="常规记录"></a>常规记录</h4><p>参数t上的Log和Logf方法一般用于记录一些常规信息，以展示测试程序的运行过程以及被测试程序的实时状态。  </p><blockquote><p>t.Logf方法与fmt.Printf函数的使用方法类似。<br>t.Log方法于fmt.Println函数的使用方法类似。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Log(Test tcp listener &amp; sender(serverAddr= &quot;,&quot;127.0.0.1:8000&quot;,&quot;)...&quot;)</span><br><span class="line">t.Log(Test tcp listener &amp; sender(serverAddr= %s&quot;,&quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><p>Error,Errorf方法，当测试的程序实体的状态不正确的时候，及时对当前的错误状态进行记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actLen := Len(s)</span><br><span class="line">if acrLen != expLen &#123;</span><br><span class="line">    t.Errorf(&quot;Error:The length of slice should be %d but %d.\n&quot;, expLen, actLen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>t.Error方法相当于先后对t.Log和t.Fail方法进行调用。<br>t.Errof相当于先后t.Logf和t.Fail方法进行调用。</p></blockquote><h4 id="致命错误记录"><a href="#致命错误记录" class="headerlink" title="致命错误记录"></a>致命错误记录</h4><p>Fatal和Fatalf方法用于记录致命状体错误，即错误无法进行的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if listener == nil &#123;</span><br><span class="line">    t.Fatalf(&quot;Listener startup failing!(addr = %s)!n\&quot;, severAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>t.Fatal相当于先后调用t.Log和t.FailNow。<br>t.Fatalf相当于先后调用t.Logf和t.FailNow方法。</p></blockquote><h4 id="失败标记"><a href="#失败标记" class="headerlink" title="失败标记"></a>失败标记</h4><p>t.FailNow与t.Fail的不同:前者被调用时会立即终止当前测试函数的执行，使当前测试运行的程序转去执行其他的测试函数。</p><blockquote><p>只能在运行测试函数的Coroutine中调用t.FailNow方法，不能在测试代码创建的Goroutine中调用，但不会报错，因不产生任何结果。</p></blockquote><h4 id="失败判断"><a href="#失败判断" class="headerlink" title="失败判断"></a>失败判断</h4><p>调用t.Failed方法，返回bool结果，代表当前测试函数中的测试是否已被标记为失败。</p><h4 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h4><p>t.SkipNow:当前测试函数为已经被忽略的并且立即终止该函数的执行，测试运行程序转去执行其他测试函数。同t.FailNow，只能在运行测试函数的Goroutine中被调用。</p><blockquote><p>t,Skip方法相当于先后对t.Log和t.SkipNow进行调用。<br>t.Skipf方法相当于先后对t.Logf和t.SkipNow进行调用。</p></blockquote><p>t.Skipped方结果告知当前测试是否已被忽略。</p><h4 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h4><p>t.Parallel:标记当前测试函数为可并行运行的，使测试运行程序可以并发地执行它以及其他可并行运行的测试函数。</p><h4 id="功能测试的运行"><a href="#功能测试的运行" class="headerlink" title="功能测试的运行"></a>功能测试的运行</h4><p>go test命令。  </p><p><code>go test 代码包 代码包</code>:运行代码包中的测试。  </p><p><code>go test 测试源码文件 被测试源码文件</code>:部分测试，仅运行测试源码文件的测试。  </p><p><code>go test -run=Prime 代码包</code>:-run标记值为正则表达式，名称与正则表达时匹配的功能测试函数才会在当次的测试运行过程中被执行。</p><p>默认通过方法t.Log和t.Logf记录测试不会显示，使用标记<code>-v(冗长模式)</code>在测试运行结束后打印出所有在测试运行过程中被记录的日志。<br><code>go test -v 代码包 代码包</code></p><h4 id="测试运行时间"><a href="#测试运行时间" class="headerlink" title="测试运行时间"></a>测试运行时间</h4><p><code>go  test -timeout</code>:在达到其值所代表的时间上限时测试还未结束引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -timeout 100ms 代码包</span><br></pre></td></tr></table></figure></p><p><code>go test -short</code>:让测试尽快结束。<br>代码包testing中的Short函数表明是否在执行<code>go test</code>命令的时候加入了<code>-short</code>标记，返回bool值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if testing.Short() &#123;</span><br><span class="line">    multiSend(severAddr, &quot;SenderT&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    multiSend(severAddr, &quot;SenderT1&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">    multiSend(severAddr, &quot;SenderT2&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="测试的并发执行"><a href="#测试的并发执行" class="headerlink" title="测试的并发执行"></a>测试的并发执行</h4><p><code>go test -parallel</code>:设置允许并发执行的功能测试函数的最大数量。在多核CPU或者多CPU的计算机上，使用并发执行的方式执行测试。  </p><p>前提：功能测试函数的开始处加入<code>t.Parallel()</code>。调用<code>t.Parallel</code>方法时，执行功能测试函数的测试运行程序会阻塞，等待其他同样满足并发执行条件的测试函数被清点且阻塞后，命令根据<code>-parallel</code>标记的值全部或者部分地并发执行这些功能测试函数中的在语句<code>t.Parallel()</code>之后的那些代码。</p><p><code>-parallel</code>的默认值是通过标准库代码包runtime的函数GOMAXPROCS设置的值。即使给予<code>-parallel</code>标记的值，真正能够并发执行功能测试函数的数量也不会比默认值多。通常不需要在命令中加入<code>-parallel</code>标记。</p><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>Benchmark Test，通过一些科学手段实现对一类测试对象的某项性能指标进行可测量、可重复和可比对的测试。即性能测试。</p><h4 id="编写基准测试函数"><a href="#编写基准测试函数" class="headerlink" title="编写基准测试函数"></a>编写基准测试函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkXxxx(b *testing.B)</span><br></pre></td></tr></table></figure><p>有Log<em>、Error</em>、Fatal<em>、Fail</em>、Skip<em> 系列方法。 同</em>testing.T类型的同名方法相同。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p><code>b.StartTimer()</code>:开始对当前的测试函数的执行进行计时。总会在开始执行基准函数的时候被自动的调用，此函数用于计时器被停止后重新启动。  </p><p><code>b.StopTimer()</code>:使当前函数的计时器停止。</p><p><code>b.ResetTimer()</code>:重置当前基准测试函数，即将函数的执行时间重值为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package **</span><br><span class="line">import (</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func BenchMark(b *testing.B) &#123;</span><br><span class="line">    customTimerTag := false</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StopTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StartTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost bmt]# go test -bench=&quot;.&quot; -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark-2          11000200756 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  testing/bmt1.009s</span><br></pre></td></tr></table></figure><blockquote><p>testing包中限制：在基准测试函数单次执行时间超过指定值（默认1s，可由<code>-benchtime</code>标记自定义）的情况下，只执行该基准测试函数一次，即在不超过此执行时间上限的情况下尽可能多地执行一个基准测试函数。</p></blockquote><h4 id="内存分配统计"><a href="#内存分配统计" class="headerlink" title="内存分配统计"></a>内存分配统计</h4><p><code>b.ReportAllocs()</code>:判断在启动当前测试的<code>go test</code>命令的后面是否有<code>-benchmark</code>标记，返回bool值。  </p><p><code>b.SetBytes()</code>:接受一个int64类型的值，用于记录在单次操作中被处理的字节的数量。帮助统计被测试的程序实体的实际性能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func BenchMark(b *testing.B) &#123;</span><br><span class="line">    customTimerTag := false</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StopTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    b.SetBytes(12345678)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StartTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost bmt]# go test -bench=&quot;.&quot; -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark-2          11000449919 ns/op  12.34 MB/s</span><br><span class="line">PASS</span><br><span class="line">ok  testing/bmt1.047s</span><br></pre></td></tr></table></figure><p><code>12.34 MB/s</code>:每秒被处理的字节的数量（MB为单位）。等于测试运行程序在执行（可能是多次）Benchmark函数的过程中每秒调用b.SetBytes方法的次数乘以传入的整数值。</p><h4 id="基准测试的运行"><a href="#基准测试的运行" class="headerlink" title="基准测试的运行"></a>基准测试的运行</h4><p>go test命令运行基准测试的标记：</p><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:left">标记描述 </th></tr></thead><tbody><tr><td style="text-align:center"><code>-bench regexp</code></td><td style="text-align:left">默认情况下不会运行任何基准测试，使用该标记以执行匹配“regexp”处的正则表达式所代表的基准测试函数。若需要运行所有的基准测试函数，可以写为:<code>-bench .</code>或<code>-bench=.</code>。 </td></tr><tr><td style="text-align:center"><code>-benchmem</code></td><td style="text-align:left">在输出内容中包含基准测试的内存分配统计信息。 </td></tr><tr><td style="text-align:center"><code>-benchtime t</code></td><td style="text-align:left">间接地控制单个基准测试函数的操作次数。<code>t</code>指执行单个测试函数的累计耗时上限，默认<code>1s</code>。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# go test -bench=Prime cnet/ctcp</span><br><span class="line">BenchmarkPrimeFuncs-2          13006791258 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.023s</span><br></pre></td></tr></table></figure><blockquote><p>结构体类型testing.B的字段N可以用于设置对基准测试函数中的某一个代码块重复执行的次数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test -bench=Prime -benchtime 1s -v cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestPrimeFuncs</span><br><span class="line">--- PASS: TestPrimeFuncs (2.00s)</span><br><span class="line">tcp_test.go:27: Test tcp listener &amp; sender (serverAddr=127.0.0.1:8080)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=4]</span><br><span class="line">BenchmarkPrimeFuncs-2          13003077128 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.020s</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test -bench=Prime -benchmem  cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkPrimeFuncs-2          13002297558 ns/op   22184 B/op     108 allocs/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.048s</span><br></pre></td></tr></table></figure><p> <code>22184 B/op</code>:每次操作分配的字节的平均数为22184个。<br> <code>108 allocs/op</code>:没次操作分配内存的次数为108次。</p><p> <code>-cpu</code>标记:自定义测试运行次数并在测试运行期间多次改变Go语言最大并发处理数。  </p><ul><li>设置Go最大并发处理数，即调用runtime.GOMAXPROCS函数并把对应的整数作为参数传入。</li><li>运行目标代码包内的所有功能测试。</li></ul><blockquote><p>测试运行程序对<code>-cpu</code>标记的处理方式与<code>-parallel</code>标记正好相反。后者默认使用最大并发处理数，前者直接设置它。前者不会影响后者的默认值。</p></blockquote><blockquote><p><code>[root@localhost src]# go test -bench=Prime -cpu=1,2,4,8,12,16,20 cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkPrimeFuncs              13007500941 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=4]</span><br><span class="line">BenchmarkPrimeFuncs-2        10000    137119 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-4        10000    183526 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-4</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-8        10000    157748 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-8</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-12       10000    154919 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-12</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-16       10000    152336 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-16</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-20       10000    134758 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-20</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp26.474s</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:center">使用示例</th><th style="text-align:left">说明 </th></tr></thead><tbody><tr><td style="text-align:center"><code>-parallel</code></td><td style="text-align:center"><code>-parallel 4</code></td><td style="text-align:left">功能：设置并发执行的功能测试函数的最大数量。  默认值：调用runtime.GOMAXPROCS(0)的结果，即最大并发处理数量。先决条件：功能测试函数开始处调用结构体testing,T类型的参数值的Parallel方法。生肖的测试：功能测试。</td></tr><tr><td style="text-align:center"><code>-cpu</code></td><td style="text-align:center"><code>-cpu 1,2,4</code></td><td style="text-align:left">功能：根据标记的值，迭代设置Go语言并发处理最大书并执行全部功能测试或全部基准测试。默认值：“”，即空字符串。先决条件：无。生效的测试：功能测试和基准测试。</td></tr></tbody></table><blockquote><p>这两个标记的作用域都是代码包，只能用于控制某一个代码包内的测试的流程。多个代码包的功能测试是可并发执行，基准测试串行执行。</p></blockquote><h3 id="样本测试"><a href="#样本测试" class="headerlink" title="样本测试"></a>样本测试</h3><p>编写不需要testing代码包的API，使用<code>go test</code>命令解析和执行。</p><h4 id="编写样本测试函数"><a href="#编写样本测试函数" class="headerlink" title="编写样本测试函数"></a>编写样本测试函数</h4><p>名称以<code>Example</code>开始，函数体最后可有若干个注释行，用于比较该测试函数被执行期间，标准输出上出现的内容是否与预期相符。</p><p>注释被正确解析需满足:  </p><ul><li>必须出现在函数体的末尾，与结束符<code>}</code>之间没有代码。</li><li>在第一行注释中紧跟在注释前导符<code>//</code>之后的永远应该是<code>Output:</code>。</li><li>在<code>Output:</code>右边的内容以及后续注释中的内容都分别代表了标准输出中的一行内容。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package et</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func ExampleHello() &#123;</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">fmt.Println(&quot;Hello, Golang~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output: Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若测试函数被执行的过程中向标准输出打印的内容是<code>Output:</code>右边内容”Hello, Golang~”，则该测试函数中的测试就是通过的，否则就是失败的。</p><h4 id="样本测试的运行"><a href="#样本测试的运行" class="headerlink" title="样本测试的运行"></a>样本测试的运行</h4><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_tsest.go:18: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- PASS: ExampleHello (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok  testing/et0.006s</span><br></pre></td></tr></table></figure><p>修改<code>Output:</code>右边内容”Hello, Erlang”。</p><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_test.go:18: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- FAIL: ExampleHello (0.00s)</span><br><span class="line">got:</span><br><span class="line">Hello, Erlang~</span><br><span class="line">want:</span><br><span class="line">Hello, Golang~</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAILtesting/et0.026s</span><br></pre></td></tr></table></figure><p>修改<code>Output:</code>右边内容多行，对应多行输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func ExampleHello() &#123;</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">fmt.Println(&quot;Hello, Golang~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output: Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_test.go:19: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- PASS: ExampleHello (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok  testing/et0.007s</span><br></pre></td></tr></table></figure><h4 id="样本测试函数的命名"><a href="#样本测试函数的命名" class="headerlink" title="样本测试函数的命名"></a>样本测试函数的命名</h4><ul><li>被测试对像为整个代码包，名称<code>Example</code>。</li><li>被测试对象为一个函数，对于函数F，名称<code>ExampleF</code>。</li><li>被测试对象为一个类型，对于类型T，名称<code>ExampleT</code>。</li><li>被测试对象为某个类型中的一个方法，对于类型T中的方法M，名称<code>ExampleT_M</code>。</li><li>加入后缀需用下划线“_”隔开且后缀首字母小写。针对类型T的方法M加入后缀“basic”，名称<code>ExampleT_M_basic</code>。</li></ul><h3 id="测试运行记录"><a href="#测试运行记录" class="headerlink" title="测试运行记录"></a>测试运行记录</h3><p>在<code>go test</code>命令后跟标记的方式来启动和定制用于在测试运行时记录性能的方法。</p><h4 id="收集资源使用情况"><a href="#收集资源使用情况" class="headerlink" title="收集资源使用情况"></a>收集资源使用情况</h4><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:left">标记描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>-cpuprofile cpu.out</code></td><td style="text-align:left">记录CPU使用情况，并写到指定的文件中直到测试退出。<code>cpu.out</code>作为指定文件的文件名可以被其他任何名称代替。</td></tr><tr><td style="text-align:center"><code>-memprofile mem.out</code></td><td style="text-align:left">记录内存使用情况，并在测试通过后将内存使用概要写到指定文件<code>mem.out</code>中。</td></tr><tr><td style="text-align:center"><code>-memprofilerate n</code></td><td style="text-align:left">控制着记录内存分配操作的行为，记录i将会被写到内存使用概要文件中。<code>n</code>代表着分析器的取样间隔，单位为字节，即当有n个字节的内存被分配时，分析器就会取样一次。</td></tr></tbody></table><blockquote><p><code>[root@localhost et]# go test -cpuprofile cpu.out et_test.go</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  command-line-arguments0.043s</span><br></pre></td></tr></table></figure><p>在执行命令的当前目录中窜县一个用于运行测试的可执行文件<code>et.test</code>，可通过执行文件运行相应的测试。在目标代码包的所在目录中会出现一个名为<code>cpu.out</code>的文件，使用<code>go tool pprof</code>命令对来交互式的对这个概要文件进行查阅。</p><blockquote><p><code>go tool pprof ./**.test cpu.out</code></p></blockquote><p>标记<code>-cpuprofile</code>相当于一个开关，决定了在测试运行期间是否对CPU使用情况进行取样操作，取样操作的时间固定，每10毫秒进行一次取样，当<code>-cpuprofile</code>标记有效时，运行测试的程序会通过标准库代码包<code>runtime/pprof</code>中的API来控制该操作的启动和停止。<code>pprof.StartCPUProfile</code>用来启动CPU使用情况记录操作，<code>pprof.StopCPUProfile</code>同来停止CPU使用情况记录操作。</p><p><code>-memprofile</code>标记有效时，测试运行程序会在测试运行的同时记录他们对内存的使用情况，即程序运行期间堆内存的分配情况，单位是字节，值越小意味着取样间隔会更短效果越好。<code>-memprofilerate</code>标记的值会赋给runtime包中的int类型的变量MemProfileRate，默认值为512*1024，即512K字节。如果设置为0则代表停止取样。</p><blockquote><p><code>go test -memprofile mem.out -memprofilerate 10 测试代码包</code></p></blockquote><p>会生成两个文件，一个在执行该命令所在目录下的可执行文件<code>测试代码包.test</code>，每次运行会重新生成替换原文件。另一个在目标代码包所在目录下的概要文件<code>mem.out</code>，可用<code>go tool pprof</code>命令对概要文件进行查询和分析。</p><blockquote><p><code>go tool pprof ./测试代码包.test 代码包路径/mem.out</code></p></blockquote><p>要获得最好的取样效果，可以将<code>-memprofilerate</code>标记的值设置为1，当有一个字节被分配，分析器就会进行一次取样。消耗比较大，可将<code>GOGC</code>设置为”off”，使垃圾回收器处于不可用状态。但会让程序运行在一个没有垃圾回收器的环境中，可用的内存只会不断的减少，没有可用的内存时程序会崩溃。</p><h4 id="记录程序阻塞事件"><a href="#记录程序阻塞事件" class="headerlink" title="记录程序阻塞事件"></a>记录程序阻塞事件</h4><p>在<code>go test</code>命令添加<code>-blockprofile</code>和<code>-blockprofilerate</code>标记来达到记录线程阻塞事件。</p><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:left">标记描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>-blockprofile block.out</code></td><td style="text-align:left">记录Goroutine阻塞事件，并在所有测试通过后将概要信息写到指定的文件<code>block.out</code>中。</td></tr><tr><td style="text-align:center"><code>-blockprofilerate b</code></td><td style="text-align:left">用于控制记录Goroutine阻塞事件的时间间隔，单位为次，默认值为1</td></tr></tbody></table><blockquote><p><code>go test -blockprofile block.out -blockprofilerate 100 代码包</code></p></blockquote><blockquote><p><code>go tool pprof ./代码包.test 代码包路径/block.out</code></p></blockquote><p><code>-blockprofilerate</code>的值通过标准库代码包runtime中的API函数<code>SetBlockProfileRate</code>传递给Go运行时系统。传入参数0，意味着取消记录操作，传入参数1，每一个阻塞事件都将被记录。默认值1，可省略<code>-blockprofilerate</code>标记。</p><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>go test命令可接受的与测试覆盖率有关的标记。</p><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:center">使用示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-cover</code></td><td style="text-align:center"><code>-cover</code></td><td style="text-align:left">启用测试覆盖率分析</td></tr><tr><td style="text-align:center"><code>-covermode</code></td><td style="text-align:center"><code>-covermode=set</code></td><td style="text-align:left">自动添加<code>-cover</code>标记并设置不同的覆盖率统计模式。支持的模式有：set:只记录语句是否被执行过，count:记录语句被执行的次数，atomic:记录语句被执行次数并保证在并发时也能正确计数。模式不能同时使用，默认set。</td></tr><tr><td style="text-align:center"><code>-coverpkg</code></td><td style="text-align:center"><code>-coverpkg bufio,net</code></td><td style="text-align:left">自动添加<code>-cover</code>标记并对该标记后所罗列的代码包中的程序进行测试覆盖率统计。默认情况下，测试运行程序只会被直接测试的代码包中的程序进行统计。意味着在测试中被间接使用到的其他代码包中的程序也可以被统计。代码包由导入路径指定，多个代码包之间“,”分隔。</td></tr><tr><td style="text-align:center"><code>-coverprofile</code></td><td style="text-align:center"><code>-coverprofile cover.out</code></td><td style="text-align:left">自动添加<code>-cover</code>标记并将所有已经通过测试的覆盖率的概要写入指定文件中。</td></tr></tbody></table><blockquote><p><code>root@localhost src]# go test -cover cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.010scoverage: 68.6% of statements</span><br></pre></td></tr></table></figure><p>标记<code>-coverpkg</code>使我们可以获得间接被使用的代码包中的程序在测试期间的执行率。</p><blockquote><p><code>[root@localhost src]# go test cnet/ctcp -coverpkg=bufio,net</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.015scoverage: 14.8% of statements in bufio, net</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test cnet/ctcp -coverprofile=cover.out</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.018scoverage: 68.6% of statements</span><br></pre></td></tr></table></figure><p>使用cover工具查看概要文件中的内容。  </p><ul><li>根据指定的规则重写某一个源码文件中的代码，并输出到指定的目标上。</li><li>读取测试覆盖率的统计信息文件，并以指定的方式呈现。</li></ul><p>重写：计数器。</p><p>可通过<code>-mode</code>标记将统计模式直接传递给cover工具，与<code>-covermode</code>标记的用法和含义一致。实际上go test命令将<code>-covermode</code>标记的值原封不动地作为运行cover工具时提送给它的<code>-mode</code>标记的值，<code>-mode</code>标记没有默认值。</p><blockquote><p><code>go tool cover -mode=set -var=&quot;GoCover&quot; -o dst.go src.go</code></p></blockquote><p>查看覆盖率概要文件：</p><blockquote><p><code>go tool cover -func=cover.out</code></p></blockquote><p><code>-func</code>标记可以让cover工具把概要文件中包含的每个函数的测试覆盖率概要信息打印到标准输出上。</p><blockquote><p><code>go tool cover -html=cover.out</code></p></blockquote><p><code>-html</code>标记用更加图形化的信息来反应统计情况，该命令会立即返回并且在标准输出上也不会出现任何内容，默认浏览器会被启动并显示cover工具根据概要文件生成的html格式的页面文件。被测试语句以绿色显示，未被测试的语句以红色显示，未参加测试覆盖率计算的语句以灰色表示。不同统计模式下生成的概要文件不同，对应的html文件也不同。</p><p>cover工具可接受的标记。</p><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:center">使用示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-func</code></td><td style="text-align:center"><code>-func=cover.out</code></td><td style="text-align:left">根据根要文件中的内容输出每一个被测试函数的测试覆盖率概要信息。</td></tr><tr><td style="text-align:center"><code>-html</code></td><td style="text-align:center"><code>-html=cover.out</code></td><td style="text-align:left">把概要文件中的内容换成HTML格式的文件，并使用默认浏览器查看它。</td></tr><tr><td style="text-align:center"><code>-mode</code></td><td style="text-align:center"><code>-mode=count</code></td><td style="text-align:left">被用于设置测试概要文件的统计模式。</td></tr><tr><td style="text-align:center"><code>-o</code></td><td style="text-align:center"><code>-o=cover.out</code></td><td style="text-align:left">把重写后的源代码的输出到指定文件中，如果不添加此标记，那么重写后的源代码会输出到标准输出上。</td></tr><tr><td style="text-align:center"><code>-var</code></td><td style="text-align:center"><code>-var=GoCover</code></td><td style="text-align:left">设置被添加到原先的源代码中的额外变量的名称</td></tr></tbody></table><h2 id="程序文档"><a href="#程序文档" class="headerlink" title="程序文档"></a>程序文档</h2><p>使用<code>godoc</code>命令在本机启动一个可被用于查看本机所有工作区域中的所有代码包文档的web服务。</p><blockquote><p><code>godoc -http=:9090 -index</code></p></blockquote><h3 id="编写程序注释"><a href="#编写程序注释" class="headerlink" title="编写程序注释"></a>编写程序注释</h3><p>行注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//行注释</span><br></pre></td></tr></table></figure></p><p>块注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h3 id="代码包的注释"><a href="#代码包的注释" class="headerlink" title="代码包的注释"></a>代码包的注释</h3><p>对当前代码包的功能和用途进行总体性的介绍。被存放到当前代码包目录下的<code>doc.go</code>文件中。应有与包中其他源码文件相同的代码包声明语句，并在声明语句之上以块注释的方式插入代码包注释。</p><p>代码包注释总会出现在godoc命令生成的对应文档页面的首要位置上，即代码包注释会作为该代码包的文档的第一段说明出现。</p><h3 id="程序实体的注释"><a href="#程序实体的注释" class="headerlink" title="程序实体的注释"></a>程序实体的注释</h3><p>程序实体的文档即是它的声明代码以及紧挨着在上面的行注释。</p><h3 id="变量和变量的注释"><a href="#变量和变量的注释" class="headerlink" title="变量和变量的注释"></a>变量和变量的注释</h3><p>将注释描述统一放在常量或变量之上。</p><h3 id="文档中的示例"><a href="#文档中的示例" class="headerlink" title="文档中的示例"></a>文档中的示例</h3><p>代码包的文档页面中包含有针对性的示例代码。是godoc命令程序自动从代码中的测试源码文件中取得的。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些小技巧</title>
      <link href="/2018/04/20/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/04/20/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="灵活使用shell"><a href="#灵活使用shell" class="headerlink" title="灵活使用shell"></a>灵活使用shell</h2><p>在搭建此博客时参见某博客主的一个方案（没找到该博客，搭建时参考了很多），不使用hexo自带的hexo d，而是自己创建一个shell脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/cocowh.github.io</span><br><span class="line">cd .deploy/cocowh.github.io</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>执行编译后将编译好的public文件夹里的静态页面复制到自己的gitpage仓库，然后再切换到仓库目录执行git。</p><p>然后今天觉得hexo n也比较麻烦，执行后需要赋予权限，所以也利用shel直接将两个步骤进行了合并。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">hexo new $1</span><br><span class="line">chmod -R 777 source</span><br></pre></td></tr></table></figure></p><p>有时shell真的能给一些事情带来方便，根据场景多多使用。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程学习资料库</title>
      <link href="/2018/04/16/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%BA%93/"/>
      <url>/2018/04/16/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="编程资源收集"><a href="#编程资源收集" class="headerlink" title="编程资源收集"></a>编程资源收集</h2><ul><li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">EbookFoundation编程中文书籍索引</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">justjavac编程中文书籍索引</a></li></ul><h2 id="语言社区"><a href="#语言社区" class="headerlink" title="语言社区"></a>语言社区</h2><ul><li><a href="https://studygolang.com/" target="_blank" rel="noopener">go语言中文网</a></li><li><a href="https://laravel-china.org/" target="_blank" rel="noopener">laravel-china</a></li></ul><h2 id="安全社区"><a href="#安全社区" class="headerlink" title="安全社区"></a>安全社区</h2><ul><li><a href="https://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a></li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://github.com/changkun/modern-cpp-tutorial" target="_blank" rel="noopener">高速上手 C++11/14/17</a>（gitpage）</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2>]]></content>
      
      
      <categories>
          
          <category> 资料库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于golang的一些资料整理</title>
      <link href="/2018/04/16/%E5%85%B3%E4%BA%8EGolang%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/16/%E5%85%B3%E4%BA%8EGolang%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>大多数采集于<a href="https://github.com/justjavac/free-programming-books-zh_CN#go" target="_blank" rel="noopener">justjavac</a></p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://github.com/cocowh/books" target="_blank" rel="noopener">英文版系列书籍(go实战、web等pdf格式)</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md" target="_blank" rel="noopener">《Go入门指南》(gitpage)</a></li><li><a href="https://mikespook.com/learning-go/" target="_blank" rel="noopener">《学习Go语言》中文版(pdf+git)</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">《Go Web 编程》中文版(gitpage)</a></li><li><a href="https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/preface.md" target="_blank" rel="noopener">《go实战开发》(gitpage半成品)</a></li><li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="noopener">《Network programming with Go》中文版(gitpage)</a></li><li><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/" target="_blank" rel="noopener">《Go语言标准库》(git)</a></li><li><a href="https://github.com/hyper0x/go_command_tutorial" target="_blank" rel="noopener">《GO 命令教程》(gitpage)</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action" target="_blank" rel="noopener">《Go语言博客实践》(gitpage)</a></li><li><a href="https://www.ctolib.com/docs-magical-go-c-web-page-download.html" target="_blank" rel="noopener">《神奇的 Go 语言》(webpage)</a><!-- * [《深入解析Go》](https://github.com/tiancaiamao/go-internals) --></li></ul><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><ul><li><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></li><li><a href="http://gorevel.cn/docs/manual/index.html" target="_blank" rel="noopener">Revel 框架手册</a></li><li><a href="https://github.com/golang-china/golangdoc.translations" target="_blank" rel="noopener">Go 官方文档翻译</a></li></ul><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul><li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="noopener">《Go 编程基础》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 资料库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祝自己生日快乐</title>
      <link href="/2018/04/14/%E7%A5%9D%E8%87%AA%E5%B7%B1%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2018/04/14/%E7%A5%9D%E8%87%AA%E5%B7%B1%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h2 id="那些年阿"><a href="#那些年阿" class="headerlink" title="那些年阿"></a><center>那些年阿<center></center></center></h2><p> 四年就要混过去了，这是在大学过的第四个生日，回忆以前的每一年的这一天真是感慨万千！</p><h3 id="第一年、大一"><a href="#第一年、大一" class="headerlink" title="第一年、大一"></a>第一年、大一</h3><p> 大一的生活可以说是最不操心的。  </p><p> 初入大学，自己也没有目标，高三熬夜刷题养成了白天语文课睡觉的坏习惯，到了大学变本加厉。大一开始的日子，随波逐流，什么都想学，什么都想参加。面试学生会，加入吉他协会，打游戏，玩手游…没想过读研还是找工作，没想过大学该怎么走。</p><p>下学期生日，很巧的在这一个月里，班里差不多有四五名同学生日，每个人的生日都有所不同，慢慢的会发现，圈子在慢慢的形成。回想起那时，还是很幼稚青涩，脸皮薄，放不开，现在依旧如此。  </p><p>如果说上学期贪玩，下学期则是彻底的堕落。上学期有时上课还在前面认真听讲，下学期则是基本节节课睡觉。期末考试成绩烂的一塌糊涂，挂了一门主修课，替别人跑南湖，挂了体育。慢慢的开始思考自己的出路了，开始焦虑了。 </p><p>农村孩子，爸妈辛苦了这么多年，不容易，岁月催人老。  </p><p>可怜之人必有可恨之处，用在自己毫不过分。眼高手低，眼不着地。</p><h3 id="第二年、大二"><a href="#第二年、大二" class="headerlink" title="第二年、大二"></a>第二年、大二</h3><p>如过时间可以重来过的话，要学会对自己的每一句话负责。明晰自己的喜好，取自己所需，争自己想得。学会做人做事留有余地。  </p><p>这一年，班里变化很大，一个网瘾太大当兵退学了，几个挂科严重留级了。这学期开始自己也开始认真学习了，该掉了上课睡觉的毛病，因为想要读研，也因为她。   </p><p>她，感谢她的陪伴和前期的包容，对不起。 如果说恋爱是一门学问的话，我应该还在小学生级别，青涩不勇敢，使你承担了太多。在最美好的的时间里遇见不是很合适、也没有能够好好珍惜的人，如今看来，谈不上遗憾，只是一段经历了。有个疙瘩是跟班里的一个女同学因她闹僵了，唉～如今都找到工作了，祝我们都有美好的明天。  </p><p>上学期的考试成绩还不错，努力也有了收获，但是跟那些学霸级的还是没的比，期末考试那段时间也是挺纠结的。期末前和同学加入了计协web组，一个刚成立的组，感谢这个选择，大学总学了点什么。</p><p>下学期的时间基本都是在逸夫楼度过的。开始带我们的是一个很厉害的学姐，学期初她在忙着找实习，工作室还有另一个学长也在找实习，学姐找到了很好的实习，去了腾讯，然而学长学的不好，找实习都很难找。给我很大的压迫感，有种大学就要结束了，明天就要毕业了的感觉，而我大学什么都没学会，担心自己的以后。学期初的心情很是不好，上学期期末和寒假、开学丢手机、努力一学期成绩仅仅为中上、跟同学关系闹僵等等。此时将所有的情绪都放在了努力学习web开发上，不停的学习，有时为了弄好一个东西很晚才回宿舍。  </p><p>生日前不久跟一起加入工作室的同学关系也弄僵了，以前关系还可以，开学时的情绪一直持续了很久，那时也久久未平，闹僵的原因就不说了，很大原因自己小气吧。生日那天也在忙着学习，忙着配置搭建服务器，十点多舍友发消息问几点回宿舍才知道给准备了生日蛋糕，很是感动。很可惜后来跟他的关系也闹僵了。    </p><p>这一年宿舍的关系也不好，两个舍友闹僵了，大二上学期我还想着找机会聚一聚缓和以下这两位舍友的关系，可惜其中一位不愿意，很是遗憾。现在想想也无所谓了，本性都是自私自利的，性格也相差太大，不能够互相包容。</p><p>如果说大学最大的改变，就是在这学期形成的吧。不相信任何人，不相信任何事，不能够包容，自私自利。拿得起，放不下。但是也找到了自己的目标，找到了自己的方向，最大的收获，也在这年。</p><h3 id="第三年、大三"><a href="#第三年、大三" class="headerlink" title="第三年、大三"></a>第三年、大三</h3><p>业精于勤荒于嬉，行成于思毁于随。  </p><p>上学期开始就退出工作室了，对工作室产生了意见。环境太吵闹，没有学习和做技术的感觉，静不下心。开学初，和同学合作做了第二个小项目，很简单很low，九月下旬接了一个页面小项目。然后这学期比较堕落，微信公众号开发了解皮毛，前端学习也是混，没怎么精进，也没好好上课，回归了游戏的老本行。  这一学期，技术没什么长进，吃老本原地踏步。</p><p>可怜之人必有可恨之处阿，下学期开始准备春招找实习了，结果很遗憾，除了最开始的作业帮没有一个offer，然而自己开始拒了作业帮的offe想要找到更好的r。这一学期还是找不准自己的工作方向，前端弄一点，后端看一点，投的也很乱。技术上除了学了下vue，php基础巩固了以下，专业课基础知识回忆巩固了下，其他长进很少。找实习找的很焦虑，最后跟了学校实习。</p><p>这学期跟班里几个同学一期报名了学车，一边找实习一边学车，生日那天，请一起练车的同学 吃了顿饭，也算是为自己庆祝生日了。   </p><p>感谢大三暑假的勇敢，感谢新浪面试官的答疑解惑，坚持了php的路，没半路又转java，实习前接了个公众号开发的项目，跟校企合作的实习公司请假做自己的项目，事实证明是对的。</p><h3 id="第四年、大四"><a href="#第四年、大四" class="headerlink" title="第四年、大四"></a>第四年、大四</h3><p>行道水穷处，坐看云起时。</p><p>上学期主要就在准备秋招了，投了很多公司，感觉比春招找实习要难很多。基本的生活节奏就是投简历、笔试、面试，这时已经确定了自己的方向，做php。很遗憾的是好几个大公司在笔试就被刷掉了，还有些公司没注意到就已经招完了。班里的同学拿到好offer的也很少，可以说没几个，考研的在努力跑图书馆跑教室，保研的就很舒服了。十月国庆回家返校后开始怀疑自己的方向了，有放弃转java的念头，相关的岗位太少了。最后在十月底第二次跑校宣时收获了第一个较理想的offer，之前有武汉小公司的offer，看不上，没接受。之所以说较理想，是因为上市公司给的薪资高，超出自己预期很多，比肩一线互联网公司甚至超过，但是公司非互联网，技术上较BAT等互联网公司有很大差距，不知道以后发展会怎么样。或许面试真的看缘分的，还有校宣机会真的很重要，这仅仅是跑第二次校宣。感谢陪我跑校宣的同学，第一次一起去的武汉理工录取了他，第二次取得武大录取了我，如果他不去我可能也不会去了，就错失去了这个机会，祝我们都有美好的明天。  </p><p>拿到offer后就很堕落了，想做技术上的学习总是静不下心，天天睡到自然醒，吃喝玩乐。最后学期末选毕设，坑开始了，老师太认真，放假还留学校做了十天。</p><p>这学期也是大部分时间都耗在毕设上了，想去实习都没有足够的时间了，被hr挽拒。每周的生活是检查上周的任务，布置这周的任务，每天看代码，看相关的文档，翻译文档，写总结。越做越烦，毁不该没去跟同学一起去养猪公司混毕设的想法越来越明显。</p><p>前段时间正式的学习了golang的语法知识，golang的底层也是c和汇编，做的毕设正式c和汇编为主，而自己的主要是c部分，php的底层学习拓展也要用到c，希望自己能够坚持把毕设搞下去，将c语言再好好学习一遍，收获一定会很大。徐老师是个好老师，可以说是非常的尽职尽责了，毕设相关的软硬件平台，相关资料全部给我们找好了，有不懂的可以随时问他，只能说自己不争气阿，惰性十足。</p><p>这两周坚持了几天的夜跑，看来又是三天打鱼两天晒网了，明天继续跑吧。</p><p>今天的生日，又在逸夫楼看了一天的代码，唉～后天又要检查。感谢爸妈姐姐的祝福，祝福爸妈和两个姐姐身体健康、两个姐姐家庭幸福、外甥外女健康快乐成长！</p><p>23了，要毕业了，要工作了，愿能够顺利开心毕业，愿工作如意，愿所有是非烟消云散，愿我们都有美好的明天！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(四)</title>
      <link href="/2018/04/13/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%9B%9B/"/>
      <url>/2018/04/13/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="Go流程控制像C，也有很多方面与C不同："><a href="#Go流程控制像C，也有很多方面与C不同：" class="headerlink" title="Go流程控制像C，也有很多方面与C不同："></a>Go流程控制像C，也有很多方面与C不同：</h2><ul><li>没有do和while循环，只有更加广义的for。</li><li>switch更加灵活，可以被用于进行类型判断。</li><li>与for类似，if和switch语句都可以接受一个可选的初始化语句。</li><li>支持在break语句和continue语句之后跟一个可选的标记（Label）语句，表示需要终止或继续的代码块。</li><li>有类似多路转接器的select语句。</li><li>语句可以被用于地启用Coroutine。</li><li>使用defer语句可以更方便地执行异常捕获和资源回收任务。</li></ul><hr><h2 id="基本流程控制"><a href="#基本流程控制" class="headerlink" title="基本流程控制"></a>基本流程控制</h2><h3 id="代码块和作用域"><a href="#代码块和作用域" class="headerlink" title="代码块和作用域"></a>代码块和作用域</h3><p>由花括号“{”和“}”括起来的若干表达式和语句的序列。不包含任何内容为空代码块。<br>隐式代码块：  </p><ul><li>Go语言源码，全域代码块。</li><li>代码包，代码包代码块。</li><li>源码文件，源码文件代码块。</li><li>每个if语句、for语句、switch语句和select语句都是一个代码块。</li><li>每个switch或select语句中的字句都是一个代码块。</li></ul><p>每一个标识符都有它的作用域，使用代码块表示作用域范围：  </p><ul><li>预定义标识符作用域全局代码块。</li><li>代表常量、类型、变量或函数的、被声明在顶层的标识符的作用域时代码包代码块。</li><li>…</li></ul><p>可以重声明外层代码块声明过的标识符，将外层同名标识符屏蔽。</p><blockquote><p>Go通过标示符首字母的大小写控制对应程序实体的访问权限，标示符首字母大写则其对应的程序实体可被本代码包之外的代码访问到，即可导出的。小写则对应的程序实体就只能被本包内的代码访问。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><h4 id="组成和编写方法"><a href="#组成和编写方法" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>条件表达式可不用括号括起来，条件表达式之后和else关键字之后必须由花括号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if 100 &lt; number &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">if diff := 100 - number; 100 &lt; number &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else if 200 &lt; diff&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if语句接受一条初始化语句。</p><h4 id="惯用法"><a href="#惯用法" class="headerlink" title="惯用法"></a>惯用法</h4><p>作为卫述语句用来检查关键的先决条件的合法性并在检查未通过的情况下立即终止当前代码块的执行的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">标准库代码包os函数</span><br><span class="line">func Open(name string) (file *File, err error)</span><br><span class="line">/*</span><br><span class="line">f, err := os.Open(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func update(id int,deptment) bool&#123;</span><br><span class="line">    if id &lt;= 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">func update(id int,deptment) errorl&#123;</span><br><span class="line">    if id &lt;= 0 &#123;</span><br><span class="line">        return errors.New(&quot;The id is INVALID&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //todo</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="组成和编写方式"><a href="#组成和编写方式" class="headerlink" title="组成和编写方式"></a>组成和编写方式</h4><p>同其他（C/C++等）语言，判定条件无括号。</p><h4 id="表达式switch语言"><a href="#表达式switch语言" class="headerlink" title="表达式switch语言"></a>表达式switch语言</h4><p>选择case执行后直接忽略其他case，而不需要break打断，没有case选择执行则执行default case，default case非必须作为最后一个case出现。不同于其他语言，break的使用方法也有些不一样。条件表达式可不用括号括起来，可接受一条初始化语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch content := getContent(); content &#123;</span><br><span class="line">    default:</span><br><span class="line">        ftm.Println(&quot;Unknown language&quot;)</span><br><span class="line">    case &quot;PHP&quot;:</span><br><span class="line">        ftm.Println(&quot;Protect Hair Prefact&quot;)</span><br><span class="line">    case &quot;Java&quot;:</span><br><span class="line">        ftm.Println(&quot;shit language&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在除了最后一条case语句的每一条case语句中的语句列表的最后一条语句可以是fallthrough语句，会将流程控制权转移到下一条case语句上。可以把多个case值放在一个case上。break语句被执行，包含它的switch语句、for语句或selet语句的执行会被立即终止执行，流程控制权被转移到这些语句后面的语句上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch content := getContent(); content &#123;</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;wuhua is cool&quot;)</span><br><span class="line">    case &quot;smart&quot;:</span><br><span class="line">        fallthrough</span><br><span class="line">    case &quot;fool&quot;:</span><br><span class="line">        break</span><br><span class="line">        fmt.Println(&quot;Bye&quot;)</span><br><span class="line">    case &quot;cute&quot;, &quot;handsome&quot;, &quot;honest&quot;:</span><br><span class="line">        fmt.Println(&quot;yes, he is&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类型seitch语句"><a href="#类型seitch语句" class="headerlink" title="类型seitch语句"></a>类型seitch语句</h4><p>对类型进行判断而不是值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">switch v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;The string is &apos;%s&apos;.\n&quot;,v.(string))</span><br><span class="line">    case int, uint, int8, uint64:</span><br><span class="line">        fmt.Printf(&quot;The integer is %d.\n&quot;,v)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unsupported value.(type = %T).\n&quot;,v)</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">switch i := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;The string is &apos;%s&apos;.\n&quot;, i)</span><br><span class="line">    case int, uint, int8, uint64:</span><br><span class="line">        fmt.Printf(&quot;The integer is %d.\n&quot;, i)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unsupported value.(type = %T).\n&quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>fallthrough语句不允许出现在类型switch语句中的任何case语句的语句列表中。</p></blockquote><h4 id="惯用法-1"><a href="#惯用法-1" class="headerlink" title="惯用法"></a>惯用法</h4><p>替换串连if语句。在switch表达式缺失时，判定目标被时为布尔值true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch number := 1995; &#123;</span><br><span class="line">    case number &lt; 1990:</span><br><span class="line">        fmt.Println(&quot;90前&quot;)</span><br><span class="line">    case number &gt;= 2000:</span><br><span class="line">        fmt.Println(&quot;00后&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;90后&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><h4 id="组成和编写方法-1"><a href="#组成和编写方法-1" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>同其他语言。若无条件，则true将会作为缺省的条件。</p><h4 id="for子句"><a href="#for子句" class="headerlink" title="for子句"></a>for子句</h4><p>一条for语句可以携带一个for字句提供条件对迭代进行控制。由初始化字句、条件、后置字句组成，同其他语言。省略括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">var j uint = 1;</span><br><span class="line">for ;j % 5 != 0; j *= 3&#123;</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">for k := 1; k % 5 != 0; &#123;</span><br><span class="line">    k *= 3</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="range子句"><a href="#range子句" class="headerlink" title="range子句"></a>range子句</h4><p>for语句可携带一个range子句，迭代出一个数组或切片值中的每个元素、一个字符串中的每个字符或者一个字典之中的每个键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ints := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">for i,d := range ints &#123;</span><br><span class="line">    fmt.Printf(&quot;%d: %d\n&quot;, i, d)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">ints := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">length := len(ints)</span><br><span class="line">indexesMirror := make([]int, length)</span><br><span class="line">elementsMirror := make([]int, length)</span><br><span class="line">var i int</span><br><span class="line">for indexesMirror[length - i - 1],elementsMirror[length - i - 1] = range ints&#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随着range表达式的结果值的不同，range字句会有不同的表现：  </p><ul><li>数组、数组指针、切片，range循环的迭代产出值可以是一个也可以是两个。迭代顺序与索引递增顺序一致。第一个产出值为索引，第二个为索引对应元素值。</li><li>字符串，遍历其Unicode代码点。第一个产出值为索引，第二个为索引对应元素值，类型为rune。</li><li>字典，迭代顺序不固定，迭代过程中键值对被删除，相应的迭代值不会被产出，新增，相应的迭代值是否被产出不确定。第一个产出值为键值对中键的值，第二个为与键对应元素值。</li><li>通道类型，迭代效果类似于连续不断的从该通道中接收元素值，直到通道被关闭。若通道为nil，range表达式被永远阻塞。每次迭代，仅会产出一个通道类型值。</li></ul><h4 id="惯用法-2"><a href="#惯用法-2" class="headerlink" title="惯用法"></a>惯用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m := map[uint]string&#123;1:&quot;A&quot;, 6:&quot;C&quot;, 7:&quot;B&quot;&#125;</span><br><span class="line">var maxKey uint</span><br><span class="line">for k := range m &#123;</span><br><span class="line">    if k &gt; maxKey &#123;</span><br><span class="line">        maxKey = k</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">var values []string</span><br><span class="line">for _, v := range m &#123;</span><br><span class="line">    values = append(values, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用break终止for循环，可配合标记（Lable）语句一起使用。一条标记语句可以成为goto语句、break语句、continue语句的目标。标记语句中的标记只是一个标识符，可以放在任何语句的左边以作为这个语句的标签，标记和被标记的语句之间用冒号“:”来分隔。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">    for k, v := range namesCount&#123;</span><br><span class="line">        //todo</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在break语句后跟标记，意味着终止执行的对象就是标记代表的那条语句。continue只在for语句中使用，会是直接包含它的那个for循环直接进入下一次迭代。在continue后跟标记，意味着跳过后面的执行语句，开始执行标记代表的那条语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var namesCount map[string]int</span><br><span class="line">//为用户昵称及其重复次数，统计只包含中文的用户昵称的计数信息</span><br><span class="line">targetsCount := make(map[string]int)    </span><br><span class="line">for k,v := range namesCount &#123;</span><br><span class="line">    matched := true</span><br><span class="line">    for _,r := range k &#123;</span><br><span class="line">        if r &lt; &apos;\u4e00&apos; || r &gt; &apos;\u9fbf&apos; &#123;</span><br><span class="line">            matched = false</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if !matched &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    targetsCounts[v] = v</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">targetsCount := make(map[string]int)    </span><br><span class="line">L:</span><br><span class="line">    for k,v := range namesCount &#123;</span><br><span class="line">        for _,r := range k &#123;</span><br><span class="line">            if r &lt; &apos;\u4e00&apos; || r &gt; &apos;\u9fbf&apos; &#123;</span><br><span class="line">               continue L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        targetsCounts[v] = v</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用for循环反转一个切片类型值中的所有元素值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i, j := 0, len(numbers) - 1; i &lt; j; i ,j = i + 1, j -1&#123;</span><br><span class="line">    numbers[i], numbers[j] = numbers[j], numbers[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>把流程控制权限无条件转移到标记所代表的语句上。</p><h4 id="组成和编写方法-2"><a href="#组成和编写方法-2" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>只能与标记语句连用。需要注意goto语句跳过的某些声明语句，导致标签所代表的语句缺少应有的变量。标记语句的直属代码块应为goto语句的直属代码块的外层代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    if n % 3 != 0 &#123;</span><br><span class="line">        goto L</span><br><span class="line">    &#125;</span><br><span class="line">    switch &#123;</span><br><span class="line">        case n % 7 == 0:</span><br><span class="line">            n = 200</span><br><span class="line">            fmt.Printf(&quot;%v is a common multiple of 7 and 3.\n&quot;, n)</span><br><span class="line">        default:</span><br><span class="line">    &#125;</span><br><span class="line">L1:</span><br><span class="line">    fmt.Printf(&quot;%v isn&apos;t a multiple of 3.\n &quot;, n)</span><br></pre></td></tr></table></figure></p><h4 id="惯用法-3"><a href="#惯用法-3" class="headerlink" title="惯用法"></a>惯用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//查找name中的第一个非法字符并返回</span><br><span class="line">//如果返回的是空字符就是明name中不包含任何非法字符</span><br><span class="line">func findEvildoer(name string) string &#123;</span><br><span class="line">    var evildoer string</span><br><span class="line">    for _, r := range name &#123;</span><br><span class="line">            switch &#123;</span><br><span class="line">                case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">                case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">                case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">                default:</span><br><span class="line">                    evildoer = string(r)</span><br><span class="line">                    goto L1</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goto L2</span><br><span class="line">L1:</span><br><span class="line">    fmt.Printf(&quot;The first evildoer of name &apos;%s&apos; is &apos;%s&apos; !\n&quot;, name, evildoer)</span><br><span class="line">L2:</span><br><span class="line">    return evildoer</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func findEvildoer(name string) string &#123;</span><br><span class="line">    var evildoer string</span><br><span class="line">L1:</span><br><span class="line">    for _, r := range name &#123;</span><br><span class="line">            switch &#123;</span><br><span class="line">                case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">                case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">                case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">                default:</span><br><span class="line">                    evildoer = string(r)</span><br><span class="line">                    break L1</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if evildoer != &quot;&quot;&#123;</span><br><span class="line">        fmt.Printf(&quot;The first evildoer of name &apos;%s&apos; is &apos;%s&apos; !\n&quot;, name, evildoer)</span><br><span class="line">    &#125;</span><br><span class="line">    return evildoer</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func checkValidity(name string) error &#123;</span><br><span class="line">    var srrDetail string</span><br><span class="line">    for i, r := range name &#123;</span><br><span class="line">        switch &#123;</span><br><span class="line">            case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">            case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">            case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">            case r == &apos;_&apos; || r == &apos;-&apos; || r == &apos;.&apos;:</span><br><span class="line">            default:</span><br><span class="line">                    errDetail = &quot;The name contains some illagal characters.&quot;</span><br><span class="line">                    goto L</span><br><span class="line">        &#125;</span><br><span class="line">        if i == 0 &#123;</span><br><span class="line">            switch r &#123;</span><br><span class="line">                case &apos;_&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;_&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">                case &apos;-&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;-&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">                case &apos;.&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;.&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">L:</span><br><span class="line">    return errors.New(&quot;Validity check failure:&quot; + errDetail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它语言编程风格一样，为代码简洁清晰，有节制使用goto。</p><hr><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>特有的流程控制语句，被用于预定对一个函数的调用，称为延迟函数，只能出现在方法或者函数的内部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer fmt.Println(&quot;The finishing touches.&quot;)</span><br></pre></td></tr></table></figure></p><p>外围函数（调用defer的函数）执行的结束会由于defer语句的执行而被推迟，所有的defer语句执行完，外围函数才执行结束。  </p><p>使用defer语句执行释放资源或异常处理等收尾任务。</p><p>defer语句调用函数的参数会按普通从上到下的执行顺序初始化，但defer语句调用的函数仅在外围函数的执行将要结束时才会执行，可将defer语句置于函数或方法体内任何位置。多个defer语句的函数的顺序调用，按LIFO的执行顺序，但参数按FIFO的顺序初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">defer func()&#123;</span><br><span class="line">    fmt.Println(&quot;The finishing touches.&quot;)</span><br><span class="line">&#125;()//调用匿名函数</span><br><span class="line">---</span><br><span class="line">func start(tag string) string&#123;</span><br><span class="line">    fmt.Ptintf(&quot;start function %s.\n&quot;, tag)</span><br><span class="line">    return tag</span><br><span class="line">&#125;</span><br><span class="line">func finish(tag string) &#123;</span><br><span class="line">    fmt.Printf(&quot;finish function %s.\n&quot;, tag)</span><br><span class="line">&#125;</span><br><span class="line">func tag()&#123;</span><br><span class="line">    defer finish(start(&quot;sign&quot;))</span><br><span class="line">    fmt.println(&quot;record the tag  sign&quot;)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    start function sign</span><br><span class="line">    record the tag sign</span><br><span class="line">    finish function sign</span><br><span class="line">*/</span><br><span class="line">---</span><br><span class="line">func printNumbers() &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    4 3 2 1 0</span><br><span class="line">*/</span><br><span class="line">---</span><br><span class="line">func printNumbers() &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">       defer func() &#123;</span><br><span class="line">           fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    5 5 5 5 5</span><br><span class="line">*/</span><br><span class="line">//defer 在循环结束后执行，此时i = 5，未传参，引入的是外层变量i。</span><br><span class="line">---</span><br><span class="line">func modify(n int) (number int) &#123;</span><br><span class="line">    defer func(plus int) (result int) &#123;</span><br><span class="line">        result = n + plus   //result初始0，result = 2 + 3 = 5</span><br><span class="line">        number += result    //number = 1 + 5 = 6</span><br><span class="line">        return</span><br><span class="line">    &#125;(3)</span><br><span class="line">    number++    //指定结果初始零值0，number = 0 + 1 = 1</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    modify(2) = 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>使用error类型值表明非正常的状态。属于预定义标识符，代表Go语言内建的接口类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Error为方法调用提供当前错误的详细信息。任何数据类型只要实现这个可以返回string类型值的Error方法就可以成为一个error接口类型的实现。标准库代码包errors提供用于创建error类型值的函数New。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func New(text string) error &#123;</span><br><span class="line">    return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line">type errorString struct &#123;</span><br><span class="line">    s string</span><br><span class="line">&#125;</span><br><span class="line">func (e *errorString) Error () string &#123;</span><br><span class="line">    return e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递给errors.New函数的参数值是调用它的Error方法的时候返回的结果值，即传递给errors.New的参数值是其返回的error类型值的字符串表示形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(&quot;%s\n&quot;, &quot;A normal error.&quot;)</span><br></pre></td></tr></table></figure></p><p>fmt&gt;Errorf函数根据格式说明符和后续参数生成一个字符串类型值，用此字符串类型值初始化一个error类型值并作为结果值返回给调用方。fmt.Errorf函数内部，创建和初始化error类型值的操作通过调用errors.New函数完成。  </p><p>可根据需要定义自己的error类型。例如osPathError：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string   //&quot;Open&quot;, &quot;unlink&quot;,etc</span><br><span class="line">    Path string //The associated file</span><br><span class="line">    Err error   //Returned bu the system call</span><br><span class="line">&#125;</span><br><span class="line">func (e *PathError) string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对此例，通常为遵循面向接口编程的原则，函数或方法中的相关结果声明的类型应该是error类型，不该是某一个error类型的实现类型。需要先判定获取到的error类型值的动态类型，再依此来进行必要的类型转换和后续操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(&quot;/etc/profile&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    if pe, ok := err.(*os.PathError); ok&#123;</span><br><span class="line">        fmt.Printf(&quot;Path Error: %s (op = %s, path = %s)&quot;, pe,Err, pe.Op, pe.Path)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;Uknown Error: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h3><p>不应该通过调用painc函数来报告普通的错误，而应该把它作为报告致命错误的一种方式。</p><h4 id="painc"><a href="#painc" class="headerlink" title="painc"></a>painc</h4><p>用于报告程序运行期间的、不可恢复的错误状态，停止当前控制流程的执行并报告一个运行时的恐慌。接受任意类型的参数值，通常是string或者error类型。  </p><p>运行时恐慌会沿着调用栈方向进行传达，直至到达当前Goroutine(Go程，一个能够独占一个系统线程并在其中运行程序的独立环境)调用栈的顶层。此时当前Goroutine的调用栈的所有函数的执行都被停止，意味着程序崩溃。运行时恐慌也可以由Go语言的运行时系统来引发。</p><h4 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h4><p>运行时恐慌一旦被引发就会像调用方传递直至程序崩溃。recover函数可以“拦截”运行时恐慌，将当前程序从运行时恐慌的状态中恢复并重新获得流程控制权。<br>defer语句重的延迟函数总会执行，只有在defer语句的延迟函数中调用recover函数才能够起到“拦截”运行时恐慌的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">//import **</span><br><span class="line">func main() &#123;</span><br><span class="line">    fetchDemo()</span><br><span class="line">    fmt.Println(&quot;The main function is excuted.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func fetchDemo()&#123;</span><br><span class="line">    defer func()&#123;</span><br><span class="line">        if v := recover(); v!= nil &#123;</span><br><span class="line">            fmt.Printf(&quot;Recovered a painc.[index = %d]\n&quot;, v)</span><br><span class="line">        &#125;打印语句</span><br><span class="line">    &#125;()</span><br><span class="line">    ss := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</span><br><span class="line">    fmt.Printf(&quot;Fetch the elements in %v one by one...\n&quot;,ss)</span><br><span class="line">    fetchElement(ss, 0)</span><br><span class="line">    fmt.Println(&quot;The elements fetching is done.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func fetchElement(ss []string, index int) (element string) &#123;</span><br><span class="line">    if index &gt;= len(ss) &#123;</span><br><span class="line">        fmt.Printf(&quot;Occur a panic! [index = %d]\n&quot;, index)</span><br><span class="line">        panic(index)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt,Printf(&quot;Fetching the element...[index = %d]\n&quot;,index)</span><br><span class="line">    element = ss[index]</span><br><span class="line">    defer fmt.Printf(&quot;The element is \&quot;%s\&quot;.[index = %d]&quot;, element, index)打印语句</span><br><span class="line">    fetchElement(ss, index + 1)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1:  Fetch the elements in [A B C ] one by one...</span><br><span class="line">2:  Fetching the element...[index = 0]</span><br><span class="line">3:  Fetching the element...[index = 1]</span><br><span class="line">4:  Fetching the element...[index = 2]</span><br><span class="line">5:  Occur a panic! [index = 3]</span><br><span class="line">6:  The element is &quot;C&quot;.[index = 2]</span><br><span class="line">7:  The element is &quot;B&quot;.[index = 1]</span><br><span class="line">8:  The element is &quot;A&quot;.[index = 0]</span><br><span class="line">9:  Recovered a painc.[index = 3]</span><br><span class="line">10: The main function is excuted.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>索引超出主动引发运行时恐慌沿着调用栈逐一向上层传达，在向上层传达前只执行本代码块（fetchElement）的defer语句的函数。直到上层（fetchDemo）在传达恐慌前执行defer中recover函数“拦截”恐慌，此时意味着此层代码已经执行结束，打印语句<br>  fmt.Println(“The elements fetching is done.”)<br>没能够执行。调用fetchDemo的mian函数重获流程控制权限。<br>常用处理：</p><blockquote><p>程序实体内部发生运行时恐慌，会在被传递给调用方之前被“平息”并以error类型值的形式返回给调用方。<br>应该在遇到知名的、不可恢复的错误状态时才去引发一个运行时恐慌，否则可以利用函数或方法的结果值来向程序调用方传达错误状态。<br>应该仅在程序处理模块的边界位置上的函数或方法中对运行时恐慌进行“拦截”和“平息”。  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(三)</title>
      <link href="/2018/04/12/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/"/>
      <url>/2018/04/12/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的使用"><a href="#数据的使用" class="headerlink" title="数据的使用"></a>数据的使用</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>若值x可以被赋给类型为T的变量，则：</p><ul><li>值x的类型是T。</li><li>值x的类型是V，V和T具有相同的潜在类型，V和T至少有一个是未命名的类型。</li><li>类型T是一个接口类型，值x的类型实现了T。</li><li>值x是一个双向通道类型的值，T是一个通道类型。</li><li>值x是预定义标识符nil，可赋给切片、字典、函数、接口、指针、通道等类型的变量。</li><li>值x是一个由某个数据类型的值代表的无类型的常量，可以被赋给该数据类型的变量。</li><li>所有值都可以赋给空标识符“_”。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ints = []int&#123;1, 2, 3&#125;</span><br><span class="line">ints[1], ints[2] = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], _ = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], ints[2] = (ints[1] * (ints[0] + 1)), (ints[2] * (ints[0] + 2))</span><br><span class="line">i1 += 1 //i1 = i1 + 2</span><br><span class="line">i2 &amp;= 2 &lt;&lt; 3 //i2 = i2 &amp; (2&lt;&lt;3)</span><br></pre></td></tr></table></figure><p>“=”两边的表达式的数量不相等，左边可以有多个，对于右边的唯一表达式有：  </p><ul><li>表达式是一个调用会返回多个结果的函数或者方法的表达式。</li><li>表达式是一个应用于字典之上的索引表达式。v, ok := map[“k”]。</li><li>表达式是一个类型断言表达式。v, ok ：= x.(string)。</li><li>表达式是一个由接收操作符和通道类型值组成的表达式。v,ok := &lt;-ch。  </li></ul><p>除此之外赋值操作符两边的表达式数量必须一致，并都都是单值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">s := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</span><br><span class="line">i,s[i-1] = 2, &quot;Z&quot;</span><br></pre></td></tr></table></figure></p><p>s值是[]string{“Z”, “B”, “C”}而不是[]string{“A”, “Z”, “C”}，对表达式i-1的求值先于赋值，在赋值之前，第二个赋值对象被确定为s[0]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a             //交换变量值</span><br><span class="line">x := []int&#123;1, 2, 3&#125;     //切片初始化</span><br><span class="line">x[0], x[0] = 1, 2       //从做到有执行最终x[0=2</span><br><span class="line">x[2], x[3] = 4, 5       //索引超范围引发恐慌，但x[2]=4已被变更</span><br></pre></td></tr></table></figure></p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>某量保持不变称为常量，否则称为变量。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量在编译期间被创建，作为局部变量被定义在函数内部，由字面量或常量表达式赋值。  </p><p>分为布尔常量、rune常量（字符常量）、整数常量、浮点数常量、复数常量和字符串常量。  </p><p>常量可以是有类型的也可以是无类型，可以被显式地给定类型，也可以被隐含地给定类型。  </p><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><p>仅以常量作为操作数的表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 + 3.0         //无类型的浮点数常量5.0</span><br><span class="line">15 / 4.0        //无类型的浮点数常量3.75</span><br><span class="line">&apos;w&apos; + 1         //无类型的rune常量&apos;x&apos;</span><br><span class="line">---</span><br><span class="line">1 &lt;&lt; 3.0        //无类型整数常量8</span><br><span class="line">1.0 &lt;&lt;3         //无类型整数常量8</span><br><span class="line">1 &lt;&lt; 100        //无类型的整数常量1267650600228229401496703205376超出范围</span><br><span class="line">---</span><br><span class="line">&quot;A&quot; &gt; &quot;C&quot;       //无类型的布尔常量false</span><br></pre></td></tr></table></figure></p><h5 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h5><p>使用关键字const将字面常量或常量表达式与标识符绑定在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const untypedConstant = 10.0    //无类型常量</span><br><span class="line">const typedConstant int64 = 1024  //类型为int64的常量</span><br><span class="line"></span><br><span class="line">const tc1, tc2, tc3 int64 = 1024, -10, 88 //平行赋值</span><br></pre></td></tr></table></figure></p><p>左侧只允许插入一个类型字面量，规定作则标识符的类型，右侧的常量类型需与其一致，未给定类型，则右侧常量类型彼此独立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const utc1, utc2, utc3 = 6.3, false, &quot;C&quot;</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc  = 6.3</span><br><span class="line">    utc2 = false</span><br><span class="line">    utc3 = &quot;c&quot;</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;c&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>并不需要显式的对所有常量赋值，被省略赋值的常量，会被隐含地赋与其上面的、最近的且被显式赋值的那个常量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false恒等</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4</span><br><span class="line">    utc5 </span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4       = &quot;C&quot;</span><br><span class="line">    utc5       = &quot;C&quot;</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    utc1         =       6.3</span><br><span class="line">    utc2, ytc3   =   false, &quot;C&quot;</span><br><span class="line">    utc4, utc5</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line">对此有规则：  </span><br><span class="line">* 若有未被显式赋值的常量，同一行的常量的赋值都必须被省略。</span><br><span class="line">* 未显式赋值的那一行的常量声明中的常量标识符数量必须与在它上面的、最近的且显式赋值的那一行常量声明中的常量标识符的数量相等。</span><br><span class="line"></span><br><span class="line">iota代表了连续的、无类型的整数常量，第一次出现在一个以const开始的常量声明语句中的时候总会表示整数常量0。随着在同一条常量声明语句中包含iota的常量的递增，iota所表示的整数值也会递增。</span><br><span class="line">```code</span><br><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    c = 2</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; iota</span><br><span class="line">    v</span><br><span class="line">    w</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; 0</span><br><span class="line">    v = 1 &lt;&lt; 1</span><br><span class="line">    w = 1 &lt;&lt; 2恒等</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1</span><br><span class="line">    v = 2</span><br><span class="line">    w = 4</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    e, f = 0, 1</span><br><span class="line">    g, h = 1, 2</span><br><span class="line">    i, j = 2, 4 </span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    _, _</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">     e, f = 0, 1</span><br><span class="line">     g, h = 2, 4</span><br><span class="line">     i, j = 3, 8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>在同一条常量声明语句中，iota代表的整数常量的是否递增取决于是否又有一个常量声明包含了它，而不是它是否又在常量声明中出现了一次。可用空标识符“_”跳过iota表示的递增序列中的某个或某些值。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在声明之后可以被赋值任意次，值在程序运行期间才被计算。</p><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>以关键字var开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v int64 = 0 //声明变量的类型</span><br><span class="line">var x = 0       //省略变量的类型</span><br></pre></td></tr></table></figure></p><p>变量的类型未被显示指定将由变量值推导得出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    v1 = 0</span><br><span class="line">    v2 = -1</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">var v3, v4, v5 float64</span><br><span class="line">=</span><br><span class="line">var v3, v4, v5 float64 = 0.0, 0.0, 0.0</span><br></pre></td></tr></table></figure></p><p>隐式赋值在变量声明中不可用，未被显示赋值的变量值将会是与改变量的类型相对应的零值，此时变量的类型不可省略。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>变量声明可以作为源码文件中的顶级元素，也可以称为函数体内容的一部分，前者全局变量，后者局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">var v6 bool //全局变量</span><br><span class="line">func main()&#123;</span><br><span class="line">    var v6 bool = true  //局部变量</span><br><span class="line">    fmt.Printf(&quot;v6: %v\n&quot;, v6)恒等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在函数体内部，局部变量会遮蔽与其同名的全局变量。<br>函数体内部的短变量声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v6 := true</span><br><span class="line">v7, v8 := &quot;Go&quot;, 1.2</span><br><span class="line">v8, v9 := 2.0, false    //v8重声明</span><br></pre></td></tr></table></figure></p><p>重声明为对在当前上下文环境中的已存在变量的又一次赋值，赋的值与改变量的类型之间应满足赋值规则。  </p><p>重声明仅出现在短变量声明中，不能用普通的声明方式重新声明一个在当前上下文环境中已存在的变量，不论改变量是一个全局变量还是一个局部变量。<br>短变量声明条件：  </p><ul><li>仅能够在函数体内部声明变量的时候使用。     </li><li>:=的左边的标识符至少有一个代表在当前上下文环境中的新变量。</li></ul><p>空标识符“_”代表的不是新变量。短变量声明可以出现在if、for和switch等语句的初始化器中，并被用来声明仅存在于这些语句块中的局部临时变量。  </p><p>在当前上下文环境中声明了某个局部变量但没有使用它，会造成一个编译错误，对变量的赋值不算对其使用。  </p><h3 id="可比性与有序性"><a href="#可比性与有序性" class="headerlink" title="可比性与有序性"></a>可比性与有序性</h3><h4 id="类型的恒等"><a href="#类型的恒等" class="headerlink" title="类型的恒等"></a>类型的恒等</h4><p>对于两个命名类型来说，名称不同，肯定不恒等，名称相同且源于相同的类型声明，则是恒等的。别名类型与它的源类型是两个完全不同的类型，命名类型和匿名类型总是不相等的。  </p><p>恒等判断规则：  </p><ul><li>数组类型，长度一致且元素的数据类型一致。</li><li>切片类型，元素的数据类型一致。</li><li>结构体类型，字段声明的数量相同且对应位置上的字段具有相同的字段名称和恒等的数据类型。字段声明的标签实际上是一个字符串字面量，标签一致也为判断恒等的依据。</li><li>指针类型，基本类型（指向的那个类型）恒等。</li><li>函数，包含了相同数量的参数和结果声明，并且对应位置上的参数和类型都是恒等的。不关注参数和结果名称，只关注数量、顺序和类型。若为可变参函数则都为可变参函数。</li><li>接口类型，拥有相同的方法集合。</li><li>字典类型，具有恒等的元素类型和键类型。</li><li>通道类型，具有恒等的元素类型且方向相同。</li></ul><h4 id="数据的可比性和有序性"><a href="#数据的可比性和有序性" class="headerlink" title="数据的可比性和有序性"></a>数据的可比性和有序性</h4><p>可比性是可以判断相等与否，有序性是可以比较大小。  </p><ul><li>布尔值具有可比性。</li><li>整数类型值具有可比性和有序性。</li><li>浮点数类型值具有可比性和有序性。</li><li>复数类型值具有可比性。</li><li>字符串值具有可比性和有序性。</li><li>指针值具有可比性。指向同一个变量或者都为空值nil。</li><li>通道类型值具有可比性。元素类型和缓冲区大小都一致。</li><li>接口类型值具有可比性。拥有相等的动态类型和相同的动态值。若都为空值也相等。</li><li>非接口类型X的值可以与接口类型T的值t判断相等，当且仅当接口类型T具有可比性且类型性X式接口类型T的实现类型。</li><li>结构体类型中的所有字段都具有可比性，则结构体类型的值具有可比性。</li><li>数组类型值具有可比性。元素类型的值具有可比性。</li></ul><p>切片类型、字典类型和函数类型的值不具有可比性，这些值可以与空值nil进行判等。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>把一个类型的值转换为另一个类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T(x)</span><br><span class="line">---</span><br><span class="line">*string(v)</span><br><span class="line">---</span><br><span class="line">&lt;-chan int(v) = &lt;-(chan int(v))//将v转换为chan int类型的值，在从此通道中接收一个int类型的值</span><br><span class="line"></span><br><span class="line">(&lt;-chan int)(v) //将v转换成通道类&lt;-chan int的值</span><br><span class="line">---</span><br><span class="line">func()(v) //结果为v的无参数匿名函数</span><br><span class="line"></span><br><span class="line">(func())(v) //将v转换为函数类型的值</span><br><span class="line"></span><br><span class="line">func() int(v)  = (func() int)(v) //将v转换为函数结果为int类型的函数类型。</span><br></pre></td></tr></table></figure></p><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>…</p><h4 id="与string类型相关的转换"><a href="#与string类型相关的转换" class="headerlink" title="与string类型相关的转换"></a>与string类型相关的转换</h4><p>…</p><h4 id="别名类型值之间的转换"><a href="#别名类型值之间的转换" class="headerlink" title="别名类型值之间的转换"></a>别名类型值之间的转换</h4><p>…</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><p>只接受通道类型的值作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int,1)</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p><p>使作为参数的通道无法在接受任何元素值。若试图关闭一个仅能接受元素值的通道，则造成一个编译错误。通道关闭之后再向它发送元素值或者试图再次关闭它，都会引发一个运行时恐慌。试图关闭一个nil的通道值也会引发一个运行时恐慌。<br>关闭一个通道不会影响关闭之前已经发送的那些元素值，关闭之后所有的接收操作都会立即返回一个该通道的元素类型的零值。</p><h4 id="len函数和cap函数"><a href="#len函数和cap函数" class="headerlink" title="len函数和cap函数"></a>len函数和cap函数</h4><p>len的使用：</p><blockquote><p>参数类型为字符串类型，返回string类型值的字节长度；<br>参数类型为数组类型或数组指针类型，返回数组类型值的长度；<br>参数类型为切片类型，返回切片类型的长度；<br>参数类型为字典类型，返回字典类型值的长度，即其中已包含的键的数量；<br>参数类型为通道类型，返回通道类型值当前包含的元素的数量。</p></blockquote><p>cap的使用：</p><blockquote><p>参数类型为数组类型或数组类型指针，返回数组类型的长度；<br>参数类型为切片类型，返回切片类型值的容量；<br>参数类型为通道类型，返回通道类型值的容量。</p></blockquote><h4 id="new函数和make函数"><a href="#new函数和make函数" class="headerlink" title="new函数和make函数"></a>new函数和make函数</h4><p>参见<a href="/2018/04/11/Golang笔记-基础篇-二/" title="Golang笔记-基础篇(二)">Golang笔记-基础篇(二)</a>数据初始化部分。</p><h4 id="append函数和copy函数"><a href="#append函数和copy函数" class="headerlink" title="append函数和copy函数"></a>append函数和copy函数</h4><p>参见<a href="/2018/04/11/Golang笔记-基础篇-二/" title="Golang笔记-基础篇(二)">Golang笔记-基础篇(二)</a>切片部分。</p><h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><p>专用于删除一个字典类型之中的某个键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, k)//m为字典类型值，k为要删除键值对的键</span><br></pre></td></tr></table></figure></p><ul><li>参数k与m的键之间必须满足赋值规则。</li><li>m是nil或者k所代表的键值对不存在与m中时，delete(m, k)不会做任何操作，删除操作被忽略，这种删除失败不会被反馈。</li></ul><h4 id="complex函数、real函数和imag函数"><a href="#complex函数、real函数和imag函数" class="headerlink" title="complex函数、real函数和imag函数"></a>complex函数、real函数和imag函数</h4><p>专用于操作复数类型值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cplx128 complex128 = complex(2,-2) //根据浮点数类型的实部和虚部来构造复数类型值</span><br><span class="line"></span><br><span class="line">var im64 = imag(cplx128) //从浮点数类型值中抽取浮点数的虚部部分</span><br><span class="line">var r64 = imag(cplx128)  //从 浮点数类型值中抽取浮点数的实部部分</span><br></pre></td></tr></table></figure></p><h4 id="panic函数和recover函数"><a href="#panic函数和recover函数" class="headerlink" title="panic函数和recover函数"></a>panic函数和recover函数</h4><p>分别用于报告和处理运行时恐慌。  </p><blockquote><p>panic只接受一个参数，参数可以是任意类型的值。要生成和报告一个运行时的恐慌可以直接调用此函数并传递给他一个用以描述恐慌细节的值。参数的类型常常是接口类型error的某个实现类型。        </p></blockquote><blockquote><p>recover不接受任何参数，返回一个interface{}类型的结果值。即其结果值可能是任何类型的，可能是nil。为nil时可能是因为： </p><ul><li>传递给panic函数的参数值就是nil。</li><li>运行时的恐慌根本没有发生，即panic没有被调用。</li><li>函数recover并没有在defer语句中被调用。</li></ul></blockquote><h4 id="print和println函数"><a href="#print和println函数" class="headerlink" title="print和println函数"></a>print和println函数</h4><p>把参数值在标准输出上打印出来且不返回任何结果值。  </p><p>print的作用是依次（从左到右）打印传递给它的参数值，每个参数值对应的打印内容都由它们的具体实现决定。peintln函数在print函数打印的内容基础上在每个参数之间加入空格“ ”，并在最后加入换行符。</p><blockquote><p>Go语言不保证会在以后每个版本中保留和则两个函数，尽量不要使用这两个函数，使用标准库代码包fmt中的函数Print和Println替代。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言的语法和C/C++、Java等有很大的不同，较类似于C。语法设计更为复杂，好处是使用起来会更加方便快捷。Go通过结构类和接口形成面向对象思想，吸取了Python中的切片、字典等数据类型。新增了通道，Go中非常重要的一种数据类型。将函数也作为一等数据类型，能够实现闭包，通过语法特性可以很方便的实现策略模式、泛型等。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(二)</title>
      <link href="/2018/04/11/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/"/>
      <url>/2018/04/11/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、<br> complex64、complex128  </p></blockquote><p> 分为三类。</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><pre><code>&gt;bool：true、false</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p> 特殊rune</p><blockquote><p>类型rune的值由rune类型字面量代表，专用于存储经过Unicode编码的字符。<br>    一个rune常量即是一个Unicode编码值，使用十六进制表示法来表示与Unicode对应的数字值，并使用“U+”作为前缀。<br>    一个rune字面量由外层的单引号和内层的一个或多个字符组成，在包裹字符的单引号中不能出现单引号“’”和换行符“\n”。    </p></blockquote><p>可以用5种方式来表示一个rune字面量  </p><ol><li>该rune字面量所对应的字符。如：’a’、’-‘，字符必须是Unicode编码规范所支持。</li><li>使用“\x”为前导并后跟两位十六进制数。可以表示宽度为一个字皆的值，即一个ASCII编码值。  </li><li>使用“\”为前导并后跟三位八进制数。宽度限制为一个字皆，只能用于表示对应数值在0和255之间的值。</li><li>使用“\u”为前导并后跟四位十六进制数。只能用于表示两个字节宽度的值，为Unicode编码规范中的UCS-2表示法。</li><li>使用“\U”为前导并后跟八位十六进制数。为Unicode编码规范中的UCS-4表示法。为Unicode编码规范和相关国际标准中的规范编码格式。 </li></ol><p> rune字面量可以支持转义符，有固定的几个，在规定之外的以“\”为前导的字符序列都是不合法的，转义符“\””也不能出现在rune字面量中。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串的长度即是底层字节序列中字节的个数，一个字符串常量的长度在编译期间就能够确定。<br>字符串代表了一个连续的字符序列，每一个字符都会被隐含地以Unicode编码规范的UTF-8编码个是编码为若干字节。<br>字符串字面量的两种表示格式：原生字符串字面量和解释型字符串字面量。    </p><blockquote><p>原生字符串字面量在两个反引号“`”之间的字符序列。在反引号之间，除了反引号之外的其他字符都是合法的，两个反引号之间的所有内容都看作是这个原生字符串字面量的值，其内容由在编译期间就可以确定的字符（非解释型字符）组成。原生字符串字面量中，不存在任何转义字符，所有内容都是所见即所得，也包括换行符。原生字符串字面量中的回车符会被编译器移除。    </p></blockquote><blockquote><p>解释型字符串字面量是被两个双引号“””包含的字符序列。解释型字符串中的转义字符都会被成功转义。在解释型字符串字面量中，转义符“\’”是不合法的，而转义字符“\””却是合法的，与rune字面量相反。在字符串字面量中可以包含rune字面量。  </p></blockquote><p>字符串字面量与rune字面量的本质区别是在于他们所代表的Unicode字符的数量上。</p><blockquote><p>字符串值是不可变的，不可能改变一个字符串的内容，对字符串的操作只会返回一个新字符串，而不是改变原字符串并返回</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个数组就是一个由若干个相同类型的元素组成的序列。    </p><h4 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1. 类型表示法"></a>1. 类型表示法</h4><p> 声明要指明长度和元素类型<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[n]T  //[非负整数字面量]元素类型</span><br><span class="line">[2*3*4]byte</span><br><span class="line">[5]struct&#123;name,address string&#125; //自定义匿名结构体类型</span><br></pre></td></tr></table></figure></p><h4 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2. 值表示法"></a>2. 值表示法</h4><p>值由符合字面量表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125; </span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;.&quot;, 5:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;2:&quot;I&quot;, 1:&quot;am&quot;, 5:&quot;a&quot;, 4:&quot;loser&quot;, 0:&quot;.&quot;, 3:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;5:&quot;I&quot;, 0:&quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;&quot;, 5:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;1:&quot;I&quot;, &quot;am&quot;, 4:&quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;1:&quot;I&quot;, 2:&quot;am&quot;, 3:&quot;&quot;, 4:&quot;a&quot;, 5:&quot;loser&quot;&#125;</span><br><span class="line"></span><br><span class="line">[...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[4]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">``` </span><br><span class="line">* 默认第一个元素值对应索引值0，之后的每个元素值的索引值都是在前一个元素值的索引值的基础上再加1，可以显式的指定索引值。</span><br><span class="line">* 在数组中未指定的元素将会被填充为元素类型的零值，可以通过显式地指定索引值来改变被填充元素值的位置。</span><br><span class="line">* 用特殊标记“...”替换为数组长度，意为并不显式地指定数组值的长度，而让Go语言编辑器为我们计算该值所包含的元素值的数量并以此确定这个长度的值。可以避免由于指定的长度和元素值的实际数量不相符而导致的多于零值元素或编译错误。</span><br><span class="line">&gt;0 &lt;= 索引值 &lt; 数组长度  </span><br><span class="line">指定的索引值不能与其他元素值的索引值重复，不论其他元素值的索引值是隐含对应的还是显式对应的。  </span><br><span class="line">####  3. 属性和基本操作  </span><br><span class="line">使用函数len计算数组值长度</span><br><span class="line">```code</span><br><span class="line">len([...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot; &#125;)</span><br></pre></td></tr></table></figure></p><p>通过索引值访问元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;[0] =&gt; &quot;bighua&quot;</span><br></pre></td></tr></table></figure></p><p>通过索引值改变对应元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array1 := [...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array1[0] = &quot;cocowh.github&quot;</span><br><span class="line">array1[2] = &quot;io&quot;</span><br></pre></td></tr></table></figure></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>Slice可以看作是Array的一种包装形式，是针对其底层包装数组中某个连续片段的描述苻，包装的数组称为该切片的底层数组。</p><h4 id="类型表示法"><a href="#类型表示法" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>由一对中间没有任何内容的方括号和代表其元素类型的标识符组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]T</span><br></pre></td></tr></table></figure></p><p>长度并不是切片类型的一部分，不会出现在表示切片类型的类型字面量中，切片的长度是可变的，相同类型的切片值可能会有不同的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]rune</span><br><span class="line">[]struct&#123;name,department string&#125;</span><br></pre></td></tr></table></figure></p><p>切片类型声明中的元素类型可以是任意一个有效的Go语言数据类型。</p><h4 id="值表示法"><a href="#值表示法" class="headerlink" title="值表示法"></a>值表示法</h4><p>切片的零值为nil，在初始化之前，一个切片类型的变量值为nil。</p><blockquote><p>切片值的长度为其所含的元素值的实际数量，使用函数len获取切片值的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len([]string&#123;4:&quot;bighua&quot;, 2: &quot;.&quot;,  &quot;com&quot;&#125;)  ##= 5</span><br></pre></td></tr></table></figure><p>在切片类型的零值（即nil）上应用内建函数len将会得到0。</p><blockquote><p>一个切片一旦被初始化，就会与一个包含了其中元素值的数组相关联，即一个切片值总会持有一个对某个数组值的引用。</p></blockquote><p>多个切片值可能会共用同一个底层数组。把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的值，这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对其底层数组上的对应元素的修改，作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片之上。切片值类似于指向底层数组的指针。  </p><blockquote><p>切片值的容量是其能够访问到的当前底层数组中的元素值的最大数量，即从其中的指针指向的那个元素值到底层数组的最后一个元素值的计数值，用内建函数cap获取。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap([]string&#123;4:&quot;bighua&quot;, 2:&quot;.&quot;, &quot;com&quot;&#125;)   //=5</span><br></pre></td></tr></table></figure><p>此例中切片值的容量就等于它的长度，对切片类型的零值应用内建函数cap也会得到0。</p><blockquote><p>一个切片值的底层数据结构中包含一个指向底层数组的指针类型值、一个代表切片长度的int类型值和一个代表切片容量的int类型值。  </p></blockquote><blockquote><p>使用复合字面量初始化一个切片值的时候，首先创建的是这个切片值所引用的底层数组，该底层数组与这个切片值有相同的元素类型、元素值及其排列顺序和长度，因此切片值的长度和容量一定相同。  </p></blockquote><blockquote><p>切片表达式的作用不是复制数组值中某个连续片段所包含的元素值，而是创建一个新的切片值，新的切片值中包含了指向这个连续片段中的第一个元素值的指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;a&quot;, &quot;loser&quot;&#125;     //底层数组长度5，即切片容量5</span><br><span class="line">slice := array[:4]      //切片长度4，能够访问前4个元素值</span><br><span class="line">slice = slice[:cap(slice)] //扩大窗口，改变长度为容量，能够访问所有元素值</span><br></pre></td></tr></table></figure><p>通过切片的方式把slicede的窗口扩展到最大，此时slice的值的长度等于其容量，窗口只能向索引值递增的方向拓展。当一个切片的索引值不在切片的长度范围内时，会引起一个运行时恐慌。<br>使用内建函数append对切片值进行拓展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array[:4]</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">slice ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">长度扩展到最大容量7，此时array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">slice1 := append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">不会改变slice的值，声明并初始化一个新变量slice1</span><br><span class="line">slice1 ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>第一个参数为将要被拓展的切片，第二个可变长参数类型应与第一个参数元素类型相同，与作为拓展内容的一个或多个元素值绑定。此函数又返回结果，结果的类型与其第一个参数的类型完全一致。<br>append函数不是在原始切片值上进行拓展，而是创建一个新的切片值，在无需扩容时，此切片值与原切片值共用一个底层数组，指针类型值和容量值与原切片值保持一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">此时长度超出容量，会创建一个新的长度大于需要存储的元素值总和的底层数组，新切片指针、长度、容量改变。</span><br><span class="line">*/相似</span><br></pre></td></tr></table></figure></p><p>上例中slice长度超出容量，此时会有一个新的数组值被创建并初始化，新的数组值将作为在append函数新创建的切片值的底层数组，包含原切片之中的全部元素值以及作为拓展内容的所有元素值。此底层数组的长度总是大于需要存储的元素值的总和，新切片值中的指针将指向其底层数组的第一个元素值，长度和容量与其底层数组的长度相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice = append(slice, slice1...)</span><br><span class="line">---</span><br><span class="line">slice1 = nil</span><br><span class="line">slice1 = append(slice2, slice...)</span><br><span class="line">---</span><br><span class="line">var slice2 []string</span><br><span class="line">slice2 = append(slice2, slice...)</span><br></pre></td></tr></table></figure></p><p>运用“…”符号，集合追加方式。</p><blockquote><p>如果容量上限索引被指定，作为切片表达式的求值结果的新切片值的容量则为容量上界索引与元素下界索引之间的差值。指定容量上界索引的目的是为了缩小新切片值的容量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arrray = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">slice := array[2:6]</span><br><span class="line">/*可直接修改array对应索引值在[2,6)的元素值，通过扩大slice窗口，可修改array对应索引值[6,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice :=array[2:6:8]</span><br><span class="line">/*即使扩大长度也仅能访问修改array中对应索引值[2,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice = append(slice, []int&#123;10 ,11, 12, 13, 14, 15&#125;...)</span><br><span class="line">/*拓展超出容量创建新的底层数组，指针指向新底层数组，彻底无法访问修改array的元素值*/</span><br></pre></td></tr></table></figure><blockquote><p>使用容量上限索引能有效的精细控制切片值对其底层数组的访问权限。<br>指定容量上限索引时，元素上界索引时不能够省略的，可以省略元素下界索引。</p></blockquote><p>使用内建函数copy批量赋值切片值中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []string&#123;&quot;I&quot;, &quot;love&quot;, &quot;my&quot;, &quot;family&quot;&#125;</span><br><span class="line">slice2 := []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">n1 := copy(slice1,slice2)</span><br><span class="line">/*</span><br><span class="line">n1 = 3</span><br><span class="line">slice =&gt; []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;, &quot;family&quot;&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>把原切片值（参数二）中的元素值复制到目标切片值（参数一）中，返回被复制的元素值的数量。参数一和参数二的元素类型必须一致，实际复制的元素值的数量等于长度较短的切片值的长度。<br>切片类型相当于于其他编程语言中的动态数组类型，扩展机制也与动态数组类型相似。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典（Map）是哈希表（Hash Table）的一个实现。哈希表是一个实现了关联数组的数据结构，关联数组是用于代表键值对的集合的一种抽象数据类型，在一个键值对集合中，一个键最多能够出现一次。与这个抽象数据结构相关联的操作有：  </p><ul><li>向集合中添加键值对。</li><li>从集合中删除键值对。</li><li>修改集合中已存在的键值对的值。</li><li>查找一个特定键所对应的值。</li></ul><p>哈希表通过哈希函数建立键值对的内部关联，键值对之间是没有顺序关系的。</p><h4 id="类型表示法-1"><a href="#类型表示法-1" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>如果一个字典类型中的键的类型为K，且元素的类型为T，字典类型的类型字面量为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map[K]T</span><br><span class="line">---</span><br><span class="line">map[int]string</span><br><span class="line">map[string]struct&#123;name,department string&#125;</span><br><span class="line">map[string]interface&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>字典类型的键类型和元素类型都需要在其声明中指定，元素类型可以是任意一个有效的Go语言数据类型，键类型不能是函数类型、字典类型或切片类型，键类型必须是可比较的。若键类型是接口类型，在程序运行期间，该类型的字典值中的每一个键值的动态类型都必须是可比较的，否则引起运行时异常。</p><h4 id="值表示法-1"><a href="#值表示法-1" class="headerlink" title="值表示法"></a>值表示法</h4><p>由复合字面量表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]bool&#123;&quot;bighua&quot;:true, &quot;cool&quot;:true, &quot;smart&quot;:true, &quot;ugly&quot;:false&#125;</span><br><span class="line">---</span><br><span class="line">map[string]bool&#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>同指针类型和切片类型，字典类型是一个引用类型。字典会持有一个针对某个底层数据结构值的引用，将一个字典值传递给一个会改变它的函数，这个改变对于函数的调用方是可见的。  </p><blockquote><p>在Go语言中只有“传值”没有“传引用”，函数内部对参数值的改变是否会在该函数之外体现出来，只取决于这个被改变的值的类型是值类型还是引用类型。  </p></blockquote><p>字典的零值是nil，类似一个长度为零的字典，可对其进行读取操作，对其进行写操作引发运行时恐慌。为初始化的字典类型的变量的值为nil。<br>用内建函数len获取字典值的长度，代表当前所包含的键值对的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">editorSign := map[string]bool&#123;&quot;cool&quot;:true, &quot;smart&quot;:true, &quot;stupid&quot;:false&#125;</span><br><span class="line">editorSign[&quot;ugly&quot;] = false</span><br><span class="line">/*新增*/</span><br><span class="line">---</span><br><span class="line">sign1 := editorSign[&quot;smart&quot;]</span><br><span class="line">sign1,ok := editorSign[&quot;smart&quot;]</span><br><span class="line">/*查找获取，消除不存在歧义*/</span><br><span class="line">---</span><br><span class="line">delete(editorSign,&quot;stupid&quot;)</span><br><span class="line">/*删除键为&quot;stupid&quot;的键值对，无返回结果，即使不存在要删的键值对也不引起恐慌*/</span><br></pre></td></tr></table></figure></p><blockquote><p>字典类型不是并发安全的，官方认为在大多数使用字典值的地方并不需要多线程场景下的安全访问控制，为了少数的并发使用场景而强制要求所有的字典都满足互斥操作将会降低大多数程序的速度。  </p></blockquote><blockquote><p>对一个非并发安全的字典值进行不受控制的并发访问可能会导致程序行为错乱，可以使用标准库代码包sync中的结构体类型RWMutex扩展字典类来保证并发安全性。RWMutex是一个读写互斥量，常用于多线程环境下的并发读写控制。</p></blockquote><h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数类型是一等类型，可以把函数当作一个值来传递和使用，即可以作为其他函数的参数，也可以作为其他函数的结果，可以利用函数的和则以特性生成闭包。</p><h4 id="类型表示法-2"><a href="#类型表示法-2" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>函数类型指代了所有可以接受若干参数并能够返回若干结果的函数。<br>声明一个函数以关键字func作为开始，其后紧跟函数签名，包括参数声明列表和结果声明列表。参数声明一般参数名在前，参数类型在后，中间空格分隔，参数名称唯一。若相邻两个参数的类型一致，可以只写第二个参数的参数类型。可以在函数声明的参数列表中略去所有参数的名称。可添加可变长参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(name string, age int)</span><br><span class="line">---</span><br><span class="line">(name string, age, seniority int)</span><br><span class="line">---</span><br><span class="line">(string,int,int)</span><br><span class="line">---</span><br><span class="line">(name string,age int,seniority int,informations ...string)</span><br></pre></td></tr></table></figure></p><p>结果声明列表的编写规则与参数声明基本一致，区别于：  </p><ul><li>只存在可变长参数的声明不存在可变长结果的声明。</li><li>如果结果声明列表中只有一个结果声明且这个结果声明中并不包含结果的名称，则可以忽略圆括号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int, seniority int, informations ...string)bool</span><br><span class="line">-&gt;</span><br><span class="line">func (name string, age int, seniority int, informations ...string)(done bool)</span><br><span class="line">/*命名结果*/</span><br></pre></td></tr></table></figure><p>Go语言的函数可以有多个结果，为函数声明多个结果可以让每个结果的职责更单一。可以利用此特性将错误值作为结果返回给调用它的代码，而不是把错误抛出来，然后在调用它的地方编写代码处理这个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int , seniority int)(effected uint, err error)</span><br></pre></td></tr></table></figure></p><h4 id="值表示法-2"><a href="#值表示法-2" class="headerlink" title="值表示法"></a>值表示法</h4><p>函数类型的零值是nil，未被初始化的函数类型的变量的值为nil，在一个未被初始化的函数类型的变量上调用表达式会引发一个运行时的恐慌。<br>函数类型的值分为命名函数值和匿名函数值。<br>命名函数由关键字func、函数名、函数的签名和函数体组成。若签名中包含了结果声明列表，则在函数体中的任何可到达的流程分支的最后一条语句都必须是终止语句。终止语句有多种，return或goto开始的语句，针对内建函数panic的调用表达式的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Module(x, y int) int&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在关键字return之后的结果必须在数量上与该函数的结果声明列表中的内容完全一致，对应位置的结果的类型上存在可赋予的关系。</p><blockquote><p>函数的声明可以省略掉函数体，表示会由外部程序（如汇编语言程序）实现，而不会由Go语言程序实现。</p></blockquote><p>匿名函数由函数字面量表示，函数没有名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作-1"><a href="#属性和基本操作-1" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>函数类型是Go语言的基本类型，可以把函数类型作为一个变量的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var recoder func (name string, age int, seniority int) (done bool)</span><br></pre></td></tr></table></figure></p><p>之后所有符合这个函数的实现都可以被赋给变量recoder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recoder = func(name string, age int, seniority int) (done bool)&#123;</span><br><span class="line">    //tudo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被赋给变量recoder的函数字面量必须与recoder的类型拥有相同的函数签名。像“面向接口编程”原则的一种实现方式。可以在一个函数类型的变量上直接应用调用表达式来调用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done := recoder(&quot;Harry&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>可以把函数类型的变量的值看作是一个函数值，所有的函数值都可以被调用，函数字面量也是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(name tsring, age int, seniority)(done bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;(&quot;HuaGe&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>一个函数即可以作为其他函数的参数，也可以作为其他函数的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//声明加密算法函数类型</span><br><span class="line">type Encipher func(plaintext string) []byte</span><br><span class="line"></span><br><span class="line">//声明生成加密函数的函数</span><br><span class="line">func GenEncryptionFunc(encrypt Encipher) func(string) (ciphertest string)&#123;</span><br><span class="line">    return func(plaintext string) string&#123;</span><br><span class="line">        return fmt.Sprintf(&quot;%x&quot;,encrypt(plaintext))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">实现了闭包</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>函数GenEncryptionFunc的签名中包含一个参数声明和一个结果声明。参数声明“(encrypt Encipher)”中的参数类型是定义的用于封装加密算法的函数类型,结果声明“func(string)(ciphertext string)”表示了一个函数类型的结果，这个函数类型则是GetEncryptionFunc函数所生成的加密函数的类型，接收一个string类型的明文作为参数，并返回一个string类型的密文作为结果。<br>函数GenEncryptionFunc的函数体内直接返回了符合加密函数类型的匿名函数，匿名函数调用名称未encrypt的函数，把作为该匿名函数的参数的明文加密，然后使用标准代码库代码包fmt中的Sprintf函数，把encrypt的函数的调用结果转换成字符串。字符串内容是十六进制数表示的加密结果，是[]byte类型的。</p><blockquote><p>每一次调用GenEncryptionFunc函数，传递给它的加密算法函数都会一直被对应的加密函数引用着。只要生成的加密函数还可以被访问，其中的加密算法函数就会一直存在，不会被Go语言的垃圾回收期回收。</p></blockquote><p>只有当函数类型是一等类型并且其值可以作为其他函数的参数或结果的时候，才能够实现闭包。  </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法是附属于某个自定义的数据类型的函数，一个方法就是一个于某个接收者关联的函数。<br>方法的签名中不但包含了函数签名，还包含了一个与接收者有关的声明，即方法的声明包含了关键字func、接收者声明、方法名称、参数声明列表、结果声明列表和方法体。接收者由被圆括号括起来的两个标识符组成，标识符间空格分隔，左边标识符为接收者的值在当前方法中的名称，右边标识符代表接收者的类型，前者称为接收者标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type MyIntSlice []int</span><br><span class="line">func (self MyIntSlice) Max() (result) &#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收者声明编写规则</p><ul><li>接收者声明中的类型必须是某个自定义的数据类型，或者是一个与某个自定义数据类型对应的指针类型。接收者的类型既不能是一个指针类型，也不能是一个接口类型。</li><li>接受者声明中的类型必须由非限定标识符代表。</li><li>接收者标识符不能是空标识符“_”。</li><li>接收者的值未在当前方法体内被引用，可以将接收者标识符从当前方法的接受者声明中删除掉。（同参数声明不推荐</li></ul><p>方法的类型与从其声明中去掉函数接收者之后的函数的类型相似，把接收者声明中的两个标识符加到参数列表声明的首位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (self *MyIntSlice) Min() (result int)</span><br><span class="line">//类型为</span><br><span class="line">func Min()(self *MyIntSlice, result int)</span><br></pre></td></tr></table></figure></p><p>选择接收者的类型  </p><ul><li>在某个自定义数据类型上，值能够调用与这个数据类型相关联的值方法，在这个值的指针值上，能够调用与其数据类型相关联的值方法和指针方法。</li><li>在指针方法中能够改变接收者的值，在值的方法中，对接收者的值的改变对于该方法之一般是无效的。  </li></ul><p>接收者的类型如果是引用类型的别名类型，在该类型值的值方法中对该值的改变也是对外有效的。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> Go语言的接口由一个方法的集合代表。只要一个数据类型（或与其对应的指针类型）附带的方法集合是某一个接口的方法集合的超级，就可以判定该类型实现了这个接口。</p><h4 id="类型表示法-3"><a href="#类型表示法-3" class="headerlink" title="类型表示法"></a>类型表示法</h4><p> 接口由方法集合代表。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//标准库代码包sort中的接口类型Interface</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">   Len() int</span><br><span class="line">   Less(i, j int) bool</span><br><span class="line">   Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将一个接口类型嵌入到另一个接口类型中，亦接口间的继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Sortable interface &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Sort()</span><br><span class="line">&#125;</span><br><span class="line">//嵌入了sort中的接口类型Interface</span><br></pre></td></tr></table></figure></p><blockquote><p>接口的嵌入不能嵌入自身，包括直接的嵌入和间接的嵌入，当前接口类型中声明的方法也不能与任何被嵌入其中的接口类型的方法重名，错误的嵌入会造成编译错误。</p></blockquote><p>interface{}为空接口，不包含任何方法声明的接口，Go语言中所有数据类ixng都是它的实现。</p><h4 id="值表示法-3"><a href="#值表示法-3" class="headerlink" title="值表示法"></a>值表示法</h4><p>Go语言的接口没有相应的值表示法，接口是规范而不是实现。一个接口类型的变量可以被赋予任何实现了这个接口类型的数据类型的值，因此接口类型的值可以由任何其它数据类型的值来表示。</p><h4 id="属性和基本操作-2"><a href="#属性和基本操作-2" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>接口的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type SortableStrings [3]string</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Len() int &#123;</span><br><span class="line">    return Len(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Less(i, j int) bool &#123;</span><br><span class="line">    return self[i] &lt; self[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Swap(i, j int) &#123;</span><br><span class="line">    self[i],self[j] = self[j],self[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(sort.Interface)</span><br><span class="line">//类型断言SorableStrings类型是一个sort.Interface接口类型的实现。</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//断言SorableStrings类型实现了接口类型Sortable。</span><br><span class="line"></span><br><span class="line">func (self *SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(&amp;SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//验证方法接收对象规则值方法和指针方法</span><br></pre></td></tr></table></figure></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体类型既可以包含若干个命名元素（字段），又可以与若干个方法相关联。字段代表了该类型的属性，方法可以看作是针对这些属性的操作。</p><h4 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">    Sortable        // 匿名字段</span><br><span class="line">    sortableArray sort.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把类型相同的字段写在同一行中(不建议):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len, cap int</span><br></pre></td></tr></table></figure></p><p>只有类型而没有指定名称的字段叫做匿名字段，也称嵌入式的字段（结构体类型的嵌入类型），必须由一个数据类型的名称或者一个与非接口类型对应的指针类型类型的名称代表，代表匿名字段类型的非限定名称被隐含地作为该字段的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Anonymities struct &#123;</span><br><span class="line">    T1      //隐含名称T1</span><br><span class="line">    *T2     //隐含名称T2</span><br><span class="line">    P.T3    //隐含名称T3</span><br><span class="line">    *P.T4   //隐含名称T4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体自动地实现它包含的所有嵌入类型所实现的接口类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当Sequence类型中由与Sortable接口类型的Sort方法的名称和签名都相同的方法时，调用seq.Sort()是调用Sequence自身的Sort方法，嵌入类型Sortable的方法Sort被隐藏了。类似装饰器模式。若名称相同签名不同，Sortable的Sort方法依然被隐藏。此时调用Sequence自身的Sort方法需要依据Sort的签名来编写调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (self *Sequence) Sort (quicksort bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br><span class="line">seq.Sort(true) //调用自身</span><br><span class="line">seq.Sortable.Sort() //调用嵌入类型Sortable的Sort</span><br></pre></td></tr></table></figure></p><p>假设有结构体类型S和非指针类型的数据类型T，则：  </p><ul><li>S中包含一个嵌入类型T，S和*S的方法集合中都包含接收者类型为T的方法。*S的方法集合中还包含接收者类型为*T的方法。</li><li>S中包含了一个嵌入类型*T，S和*S的方法集合中都会包含接收者类型T或*T的所有方法。</li></ul><p>对于结构体的多层嵌入：  </p><ul><li>在被嵌入的结构体类型的值上像调用它自己的字段或方法那样调用任意深度的嵌入类型值的字段或方法。前提是这些嵌入类型的字段或者方法没有被隐藏，被隐藏则需要通过链式的选择表达式调用或者访问。</li><li>被嵌入的结构体类型的字段或者方法可以隐藏任意深度的嵌入类型的同名字段或方法。字段可以隐藏方法，方法可以隐藏字段，名称相同即可。</li></ul><p>匿名结构体类型比命名结构体类型少了关键字type和类型名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以在数组类型、切片类型活字典类型的声明中，将一个匿名的结构体类型作为它们的元素的类型。可以直接将匿名结构体作为一个变量的类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var anonym struct &#123;</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更常用的是在声明以匿名结构体类型为类型的变量的同时对其初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anonym := struct &#123;</span><br><span class="line">    a int </span><br><span class="line">    b string</span><br><span class="line">&#125;&#123;0, &quot;wuhua&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>匿名结构体类型不具有通用性，常常用在临时数据存储和传递的场景中。可以在结构体类型声明中的字段声明的后面添加一个字符串字面量标签，以作为对应字段的附加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Persion struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint   `json:&quot;age&quot; `</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常该标签对该结构体类型及其值的代码来说是不可见的，可以使用标准库代码包reflect中提供的函数查看到结构体类型中字段的标签。会在一些特殊的应用场景下使用，如标签库代码包encoding/json中的函数会根据这种标签的内容确定与该结构体中的字段对应的JSON节点的名称。</p><h4 id="值表示法-4"><a href="#值表示法-4" class="headerlink" title="值表示法"></a>值表示法</h4><p>一般由复合字面量表达。<br>对Sequence有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;Sortable:SortableStrings&#123;&quot;3&quot;,&quot;2&quot;,&quot;1&quot;&#125;,sorted:false &#125;</span><br></pre></td></tr></table></figure></p><p>可以忽略掉结构体字面量字段的名字，即不添加架构体字面量中的键值对的键。有限制：  </p><ul><li>要省略都省略。</li><li>字段值之间的顺序与结构体类型声明中的字段声明的顺序一致，不能省略对任何一字段的赋值。</li></ul><p>可以在结构体字面量中不指定任何字段的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>此时此值中的两个字段被赋予他们所属类型的零值。结构体类型属于值类型，零值为不为任何字段赋值的结构体字面量。<br>在字段访问权限允许下访问操作字段，字段名称首字母小写，只能在结构体类型声明所属的代码包中访问到该类型的值中的字段，或对其赋值。</p><h4 id="属性和基本操作-3"><a href="#属性和基本操作-3" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>结构体类型的属性既其所包含的字段和关联的方法。<br>只存在内嵌不存在继承的概念。<br>在结构体类型的别名类型的值上，既不能调用该结构体类型的方法，也不能调用该结构体类型对应的指针类型的方法。</p><blockquote><p>通过结构体中嵌入接口，嵌入的接口能够存储所有实现了该接口类型的数据类型的值，该结构体可以在一定程度上模拟泛型。</p></blockquote><p>很多预定义类型都属于泛型类型（数组、切片、字典、通道），不支持自定义的泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">type GenericSeq interface &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    Append(e interface&#123;&#125;) bool</span><br><span class="line">    Set(index int,e interface&#123;&#125;) bool</span><br><span class="line">    Delete(index int)(interface&#123;&#125;,bool)</span><br><span class="line">    ElemValue(index int)interface &#123;&#125;</span><br><span class="line">    ElemType() reflect.Type</span><br><span class="line">    Value() interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Sequence struct &#123;</span><br><span class="line">    GenericSeq</span><br><span class="line">    sorted bool</span><br><span class="line">    elemType reflect.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Sort()&#123;</span><br><span class="line">    self.GenericSeq.Sort()</span><br><span class="line">    self.sorted = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Append(e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Append(e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Set(index int, e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Set(index,e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) ElemType() reflect.Type&#123;</span><br><span class="line">    //todo</span><br><span class="line">    self.elemType = self.GenericSeq.ElemType()</span><br><span class="line">    //todo</span><br><span class="line">    return self.elemType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口类型GenericSeq中声明了用于添加、修改、删除、查询元素和获取元素类型的方法。实现GenericSeq接口类型，也必须实现Sortable接口类型。将嵌入到Sequence类型的Sortable接口类型改为GenericSeq接口类型，在类型声明中添加reflect.Type类型（标准库代码包reflect中的Type类型）的字段elemType，用于缓存GenericSeq字段中存储的值的元素类型。<br>通过创建与Sequence类型关联的方法，方法与接口GenericSeq或Sortable中声明的某个方法有着相同的方法名和方法签名，隐藏了GenericSeq字段中存储的值的同名方法，达到扩展效果。<br>结构体类型在多数场景中比预定义数据类型的别名类型更适合作为接口类型的实现，是Go语言支持面向对象编程的主要体现。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>代表着某个内存地址的值。是复合类型之一。</p><h4 id="类型表示法-4"><a href="#类型表示法-4" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>通过于有效数据类型的左边插入符号“*”获取与之对应的指针类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[]int</span><br><span class="line">*Sequence</span><br><span class="line">*sort.StringSlice</span><br></pre></td></tr></table></figure></p><p>专门用于存储内存地址的类型uintptr，与int和uint一样属于数值类型。其值能够保存一个指针值的32位或64位（与程序运行的计算机架构有关）无符号整数，亦称其值为指针类型值的位模式。</p><h4 id="值表示法-5"><a href="#值表示法-5" class="headerlink" title="值表示法"></a>值表示法</h4><p>若变量可寻址，使用取址操作符“&amp;”取对应指针值。</p><h4 id="属性和基本类型"><a href="#属性和基本类型" class="headerlink" title="属性和基本类型"></a>属性和基本类型</h4><p>指针类型属于引用类型，零值为nil。<br>标准库代码包unsafe提供不安全的操作绕过Go语言类型安全机制。<br>包中有个int类型的别名类型ArbitraryType，可以代表任意的Go语言表达式的结果类型。包中声明了一个名为Pointer的类型，unsafe.Pointer类型代表了ArbitarayType类型的指针类型。有特殊转换操作：  </p><ul><li><p>指向其他类型值的指针值可以被转换为unsafe.Pointer类型值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer := unsafe.Pointer(float32(32))</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型值可以被转换为对应的指针类型的值。对于内存上的同一段数据，将其作为int类型的值和float32类型的值来解析得出的结果不同，某些情况，会引起一个运行时的恐慌。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vptr := (*int)(pointer)</span><br><span class="line">---</span><br><span class="line">vptr := (*string)(pointer) //引发运行时恐慌</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型的值可以被转换为一个uintptr类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptr := uintptr(pointer)</span><br></pre></td></tr></table></figure></li><li><p>uintptr类型的值也可转换为unsafe.Pointer类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer2 ：= unsafe.Poniter(uptr)</span><br></pre></td></tr></table></figure></li></ul><p>可通过unsafe.Pointer绕过类型系统在任意的内存地址上进行读写操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint8  `json:&quot;age&quot;`</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br><span class="line">pp := &amp;Person&#123;&quot;Bighau&quot;,23,&quot;Henan,China&quot;&#125;</span><br><span class="line">var puptr = uintptr(unsafe.Pointer(pp))</span><br><span class="line">var npp uintptr = puptr + unsafe.Offsetof(pp.Name)</span><br><span class="line">var name *string = (*string)(unsafe.Pointer(npp))</span><br></pre></td></tr></table></figure></p><p>使用unsafe包中的Offsetof函数返回Name在Person中的存储偏移量，将Person的内存地址与Name的存储偏移量相加得Name的内存地址，可利用特殊转换操作的规则2和4还原指向Name字段值的指针类型值。最后通过*name直接获取Name字段的值。<br>总结为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unssafe.Pointer(&amp;s.f))</span><br></pre></td></tr></table></figure></p><h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>指对某个数据类型的值或变量的初始化。专门用于数据初始化的内建函数new和make。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>用于为值分配内存。不同于其他编程语言，此处不会初始化分配到的内存，只会清零。<br>调用new(T)意味着为T类型的新值分配并清零一块内存空间，将这块内存空间的地址作为结果返回。结果即为指向这个新的T类型值的指针值，指向一个T类型的零值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = new(string)     //s-&gt;&quot;&quot;</span><br><span class="line">[]int = new([3]int) //n -&gt;[3]int&#123;0,0,0&#125;</span><br></pre></td></tr></table></figure></p><p>标准库代码包sync中的结构体内类型Mutex是一个new后即用的数据类型，零值为一个处于未锁定状态的互斥量。</p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>只能被用于创建切片类型、字典类型和通道类型的值，并返回一个已经被初始化的（非零值）的对应类型的值。  在创建这三个引用类型的值的时候，将内存分配和数据初始化两个步骤绑定在一起。三个类型的零值都是nil，使用new得到的是一个指向空值nil的指针。<br>除了接受一个表示目标类型的类型字面量，还接受一个或两个额外的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 10, 100)</span><br><span class="line">make([]int, 10)</span><br><span class="line"></span><br><span class="line">=&gt;[]int&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;</span><br><span class="line">//创建一个新的[]int类型的值，长度为10、容量为100，可省略参数3，此时为不指定新值的容量。</span><br><span class="line">---</span><br><span class="line">make(map[string]int, 100)</span><br><span class="line">make(map[string]int)</span><br><span class="line"></span><br><span class="line">=&gt;map[string]int&#123;&#125;</span><br><span class="line">//可忽略用于表示底层数据结构长度的参数，不建议</span><br><span class="line">---</span><br><span class="line">make(chan int, 10)</span><br><span class="line">//参数一通道类型，参数二通道长度，参数二可省略</span><br></pre></td></tr></table></figure></p><p>make函数只能被应用在引用类型的值的创建上，其结果是第一个参数所代表的类型的值，而不是指向这个值的指针值。在调用make函数的表达式的求值结果上使用“&amp;”取址操作符获取指针值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]int, 100)</span><br><span class="line">mp := &amp;m</span><br></pre></td></tr></table></figure></p><p>规则总结：</p><ul><li><p>字面量可以被用于初始化除接口类型和通道类型外的所有数据类型的值，接口类型没有值，通道类型只能使用make函数创建。</p></li><li><p>内建函数new主要被用于创建值类型的值，不适合用来创建引用类型的值，其结果是指向被创建值的指针值。</p></li><li><p>内建函数make仅能被用于切片、字典和通道类型的值的创建，结果值是被创建的值本身。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(一)</title>
      <link href="/2018/04/10/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/"/>
      <url>/2018/04/10/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="初识Golang"><a href="#初识Golang" class="headerlink" title="初识Golang"></a>初识Golang</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>步骤：  </p><ul><li>在<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a>选择合适的版本</li><li><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://storage.googleapis.com/golang/go1.10.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local/ -zxvf go1.10.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>添加系统环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile.d/go.sh</span><br></pre></td></tr></table></figure></li><li><p>添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure></li><li><p>使其生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile.d/go.sh</span><br></pre></td></tr></table></figure></li><li><p>也可直接命令行输入<code>export PATH=$PATH:/usr/local/go/bin</code>或者在bash文件中添加。</p></li><li><p>添加GOPATH目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/dev/go</span><br><span class="line">vim /etc/profile.d/gopath.sh</span><br></pre></td></tr></table></figure></li><li><p>添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/root/dev/go</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure></li><li><p>使其生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile.d/gopath.sh</span><br></pre></td></tr></table></figure></li></ul><p>一般将软件安装到usr/local中，下载的压缩包解压缩后可直接使用，将其添加置环境变量并为其设置好工作目录即可。GOPATH目录为项目所在目录，可设置多个且随意设置，下方细说。</p><h3 id="Go安装包文件夹"><a href="#Go安装包文件夹" class="headerlink" title="Go安装包文件夹"></a>Go安装包文件夹</h3><ul><li>api文件夹：Go API检查器的辅助文件。</li><li>bin文件夹：官方提供的Go语言相关工具的可执行文件。</li><li>lib文件夹：特殊的库文件。</li><li>pkg文件夹：构架安装后，保存Go语言标准库的所有归档文件。</li><li>src文件夹：所有标准库、Go语言工具，以及相关底层（C语言实现）的源码。</li><li>test文件夹：测试Go语言自身代码的文件。</li></ul><h3 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h3><p>需要将工作区目录路径添加至环境变量GOPATH中,可指定多个工作区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/路径/工作区文件夹名:$HOME/路径/工作区文件夹名</span><br></pre></td></tr></table></figure></p><p>可使用命令行，要保证$HOME值为正确的当前用户home路径，在此踩到过坑，centos7的HOME值为root（好几次在命令行设置后过一段时间又自动变为root），最后在.bash_profile中设置了HOME值，将上方的设置语句也添加到.bash_profile中，这样能保证每次启动都会设置此值为正确值。</p><p>工作区文件夹即为我们的项目编码区，多个工作区可用“:”分开在后面继续添加，命令go get会将指定项目的源码下载到第一个工作区，在其中完成构建和安装，所以一般将第一个工作区设置为用来存放第三方代码库的工作区，存放自己的项目工程的工作区从第二个起。</p><h3 id="代码包"><a href="#代码包" class="headerlink" title="代码包"></a>代码包</h3><p>Go的代码包是对代码进行构建和打包的基本单元，每个源码文件都必须以包声明语句作为文件中代码的第一句，包名即源码文件所在的文件夹名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package 文件夹名</span><br><span class="line">import 其他包名</span><br><span class="line">import (</span><br><span class="line">    其他包名</span><br><span class="line">    其他包名    </span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">import (</span><br><span class="line">    别名 其他包名</span><br><span class="line">    别名 其他包名</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上面给出了声明包以及导入包的三种形式。别名为“.”时可直接进行代码调用，别名为“_”时，仅对包初始化，无法调用。</p><blockquote><p>Go通过标示符首字母的大小写控制对应程序实体的访问权限，标示符首字母大写则其对应的程序实体可被本代码包之外的代码访问到，即可导出的。小写则对应的程序实体就只能被本包内的代码访问。</p></blockquote><p>init函数进行包初始化，main函数为程序入口。</p><h3 id="main函数额init函数"><a href="#main函数额init函数" class="headerlink" title="main函数额init函数"></a>main函数额init函数</h3><p>init函数能够应用于所有的package，main函数只能应用于package main。这两个函数在定义时不能有任何的参数和返回值。一个package里面可以写任意多个init函数，为可读性和可维护性，建议在一个package中每个文件只写一个init函数。</p><p>Go程序会自动调用init()和main()，不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。  </p><p>程序的初始化和执行都起始于main包，若main中还导入了其他的包，会在编译时将他们依次导入。若一个包被多个包同时导入，则只会被导入一次。若一个包被导入时该包还导入了其他的包，会先将其他包导入进来，然后再对这些包中的常量和变量进行初始化，接着执行init函数（若有），依次类推。所有被导入的包都加载完毕，开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（若有），最后执行main函数。</p><h3 id="标准命令"><a href="#标准命令" class="headerlink" title="标准命令"></a>标准命令</h3><p>go命令是Go语言的基本命令之一，于命令行中输入go，会直接输出所有常见的其他可用命令和相关信息。</p><h2 id="基本词法"><a href="#基本词法" class="headerlink" title="基本词法"></a>基本词法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h4 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h4><ol><li>基本数据类型名称。  </li><li>接口类型error。  </li><li>常量true、false和iota。  </li><li>所有内建函数的名称，即append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、println、real和recover。</li></ol><h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>由一个下划线_表示。一般用在不需要引入一个新邦定的声明中。例如在代码中存在一个变量x，但是却不存在对它的使用。这样的代码会使编译器报错。在变量x的声明代码后添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = x</span><br></pre></td></tr></table></figure></p><p>可以绕过编译器检查，使它不产生任何编译错误。因为x在此处被使用到，但是对x未进行任何操作。在导入声明中，当我们只想执行一下某个代码包中的初始化函数，而不需要使用这个代码包中的任何程序实体的时候，可以编写导入语句为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;runtime/cgo&quot;</span><br></pre></td></tr></table></figure></p><p>引入了这个代码包所需的所有操作，没有绑定到一个具体的名称上，在当前的源码文件中，我们无法对这个代码包中的任何程序实体进行调用。<br>以上，”_”会导致赋值或导入操作的相关准备工作的进行。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-程序声明-："><a href="#1-程序声明-：" class="headerlink" title="1. 程序声明 ："></a>1. 程序声明 ：</h4><pre><code>&gt; import、package</code></pre><h4 id="2-程序实体声明和定义："><a href="#2-程序实体声明和定义：" class="headerlink" title="2. 程序实体声明和定义："></a>2. 程序实体声明和定义：</h4><pre><code>&gt;chan、const、func、interface、map、struct、type、var</code></pre><h4 id="3-程序流程控制："><a href="#3-程序流程控制：" class="headerlink" title="3. 程序流程控制："></a>3. 程序流程控制：</h4><pre><code>&gt;go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><p>用于表示基础数据类型值的各种字面量。基本数据类型。</p><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><p> 用于构造各种自定义的符合数据类型的类型字面量。自定义数据类型如结构体。</p><h4 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h4><p> 用于表示符合数据类型的值的符合字面量。会被用来构造类型Struct结构体、Array(数组)、Slice(切片)、Map(字典)的值。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="基本类型（预定义类型）："><a href="#基本类型（预定义类型）：" class="headerlink" title="基本类型（预定义类型）："></a>基本类型（预定义类型）：</h4><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、complex64、complex128</p></blockquote><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><blockquote><p>Array(数组)、Struct(结构体)、Function(函数)、Interface(接口)、Slice(切片)、Map(字典)、Channel(通道)、Pointer(指针)</p></blockquote><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><blockquote><p>在变量声明中示出的类型。动态类型，在运行时与改变量绑定在一起的实际类型，实际类型可以是实现了这个接口的任何类型。接口类型的变量既拥有静态类型，也有动态类型。接口类型的变量的动态类型可以在执行期间变化，但是变量的静态类型永远只能是它声明时被指定的那个类型。</p></blockquote><h4 id="潜在类型"><a href="#潜在类型" class="headerlink" title="潜在类型"></a>潜在类型</h4><blockquote><p>每一个类型都会有一个潜在类型，若是预定义类型或者由类型字面量构造的符合类型，潜在类型就是它自身。</p></blockquote><p>可以用type声明自定义类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">type iString MyString</span><br><span class="line">type MyStrings [3]string</span><br></pre></td></tr></table></figure></p><p>可以把MyString看作string类型的一个别名类型，MyStrings、iString和MyString的潜在类型都是string。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="与C语言基本一致"><a href="#与C语言基本一致" class="headerlink" title="与C语言基本一致"></a>与C语言基本一致</h4><p>注意:</p><blockquote><p>“+”可以用于操作字符串类型的值，作为字符串连接符使用。<br>“bighua” + “.” + “com” //“bighua.com”<br>字符串连接操作只会创建并使用一个新的字符串值来保存操作结果，不会改变任何操作数值。</p></blockquote><p>新增：</p><blockquote><p>&amp;^     按位清除操作，即根据第二个操作数的二进制值对第一个操作数的二进制值进行相应的清零操作。二元操作符，属于算术操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 7       &amp;^ 13       = 2</span><br><span class="line">00000111 &amp;^ 00001101 = 00000010</span><br><span class="line">      00000111</span><br><span class="line">&amp;^    00001101</span><br><span class="line">=     00000010</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>&lt;- 接收操作，一元操作符，属于接收操作符。只作用于通道类型的值。对于通道ch，表达式&lt;-的含义是从此通道中接收一个值。前提是通道的方向必须允许接收操作，并且该操作的结果的类型必须与通道元素的类型之间存在可赋予的关系。这个表达式会被阻塞直到通道中有一个值可用。</p></blockquote><p>需要注意：</p><ul><li>从一个通道类型的空值（即nil）接收值的表达式将会永远阻塞.</li><li>从一个已经被关闭的通道类型值接收值会永远成功并且立即返回一个其元素类型的零值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">v,ok  = &lt;-ch</span><br><span class="line">v,ok := &lt;-ch</span><br></pre></td></tr></table></figure><blockquote><p>“=”用于将一个值赋给一个已被声明的变量或常量，”:=”用于在声明一个变量的同时对这个变量进行赋值，”:=”只能在函数体内使用。v1，v2，v用于接收值，ok为布尔类型的值，代表了接收操作的成功与否，可用来判断一个通道是否被关闭了，为false时表明通道已经关闭。</p></blockquote><p>操作符优先级：</p><blockquote><p>5      * / % &lt;&lt; &gt;&gt; &amp; &amp;^<br>4     + - | ^<br>3      == !=  &lt;  &lt;=  &gt;  &gt;=<br>2     &amp;&amp;<br>1     ||</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="1-基本表达式"><a href="#1-基本表达式" class="headerlink" title="1. 基本表达式"></a>1. 基本表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[2]</span><br><span class="line">int(v1) + v2</span><br><span class="line">len(v3)</span><br><span class="line">x.f</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3]</span><br><span class="line">interface&#123;&#125;(num).(int)</span><br><span class="line">os.Open(&quot;/etc/profile&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-选择符号和选择表达式"><a href="#2-选择符号和选择表达式" class="headerlink" title="2. 选择符号和选择表达式"></a>2. 选择符号和选择表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.f      //深度0</span><br><span class="line">x.f.f2   //深度1</span><br></pre></td></tr></table></figure><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>对于一个类型T或者对应的指针类型*T的值x，表达式x.f表示类型T的最浅深度（即深度0）的字段或者方法。前提是：T不能是接口类型；类型T必须要有名称为f的字段或者方法。  </li><li>对于一个接口类型I的变量x，表达式x.f表示赋给x的那个值(实现了接口类型I的那个类型的值)的方法f。如果接口类型I的方法法集合中不包含名称为f的方法，那么选择表达式x.f非法。</li></ul><h5 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h5><ul><li>如果x是一个与某个构体类型对应的指针类型的变量，并且它的值为nil，那么针对表达式x.f的赋值和求值都会引起一个运行时的恐慌。不论f是字段还是方法。</li><li>如果x是一个接口类型的变量且它的值为nil，那么针对表达式x.f的调用和求值都会引起一个运行时恐慌，前提是f是该接口类型的一个方法。</li></ul><p>自动解引用：如果x是一个结构体类型对应的指针类型的值，那么x.f就是表达式(*x).f的一个速记法，不论f代表的是一个字段还是一个方法，如果f代表了一个字段且也是一个与结构体类型对应的指针类型，那么x.f.f2就是表达式(*(*x.f).f2的一个速记法，不论f2是一个字段还是方法。</p><h4 id="3-索引符号和索引表达式"><a href="#3-索引符号和索引表达式" class="headerlink" title="3. 索引符号和索引表达式"></a>3. 索引符号和索引表达式</h4><p>一个索引表达式有一个基本表达式和一个索引符号组成，形如a[x]，会求索引值为x的a中的那个元素的值。  </p><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ul><li>a不是字典类型的值，x必须是一个int类型或者无类型的证书字面量，x大于0且小于a的长度。否则引起一个与越界有关的运行时的恐慌。  </li><li>a是一个数组类型A的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个切片S类型的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个字符串类型T的变量，x必须在a的长度的有效范围内，a[x]表示字符串a中索引值为x对应的那个字节类型值。不能对a[x]进行赋值操作，字符串类型值是不能改变的。</li><li>a是一个字典类型M的变量，x的类型必须是可以赋值给M的键的类型，即键x的类型可以通过类型推断符号判定为M的键的类型。a[x]表示a中的、与键x对应的那个值，且a[x]的类型与字典M的元素的类型相同。若a为nil或者其中不包含以x为键的键值对，那么a[x]的求值结果就会是字典M的元素的类型的零值。通过赋值语句<br>v,ok := a[x]<br>判断是因为上方原因导致的零值还是与键x对应的值本身就是这个零值。ok为true表示赋值成功，原本就是零值，为false则表明由上方情况引起。当a为nil时对a[x]赋值会引起一个运行时恐慌。</li></ul><h4 id="4-切片符号和切片表达式"><a href="#4-切片符号和切片表达式" class="headerlink" title="4. 切片符号和切片表达式"></a>4. 切片符号和切片表达式</h4><p>切片符号可以是操作字符串、数组、数组的指针以及切片类型的值。<br>对于这样一个类型的值a，切片表达式为a[x:y:z]。<br>x代表元素下界索引，y代表元素上界索引，z代表切片的容量上界索引。<br>有如下约束：</p><blockquote><p>0 &lt;= 元素下界索引 &lt;= 元素上界索引 &lt;= 容量上界索引 &lt;= 操作对象的容量  </p></blockquote><p>若不满足，则在表达式求值时造成一个越界错误并引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3] = []int&#123;2,3&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[3:] = []int&#123;1,2,3,4,5&#125;[3:5] = []int&#123;4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[:3] = []int&#123;1,2,3,4,5&#125;[0:3] = []int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></p><p>若a代表的是一个切片类型的值，那么表达式a[:]就等同于复制a所代表的值并将其作为此表达式的求值结果。否则表达式a[:]就意味着有一个包含了指向a的第一个元素的指针的切片类型值被创建。</p><h4 id="5-类型断言"><a href="#5-类型断言" class="headerlink" title="5. 类型断言"></a>5. 类型断言</h4><p>对于一个求值结果为接口类型值表达式x和一个类型T，对应的类型断言为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure></p><p>用于判断“x不为nil且存储在其中的值是T类型的”这一假设是否成立。如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致，即为关于“类型T是否为x的动态类型”的判断。  类型T必须是x的一个实现类型，x必须是一个接口类型的值。<br>int(123).(int)引发编译错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid type assertion: 123.(int)(non-interface type int on left )</span><br></pre></td></tr></table></figure></p><p>即表达式int(123)的求值结果是int类型，而int类型并不是一个接口类型。将表达式改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;(123).(int)</span><br></pre></td></tr></table></figure></p><p>则会顺利通过编译，表达式interface{}(123)将字面量123转换为interface{}类型的值。interface{}是一个特殊的接口类型，代表空接口，所有类型都是他的实现类型。<br>如果T不是一个接口类型且类型T不是x的类型的一个实现，那么类型断言x.(T)就是失败的，会引发一个运行时恐慌。</p><blockquote><p>只有在程序运行期间，x的动态类型才能够被获知，而在编译期间能够确定的只有T所代表的类型。  </p></blockquote><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v,ok := x.(T)</span><br><span class="line">``` </span><br><span class="line">断言成功v为已经被转换为T类型的表达式x的求值结果，否着为类型T的零值。ok可以判断断言是否成功，此时类型断言失败也不会引发运行时恐慌。</span><br><span class="line">#### 6. 调用</span><br><span class="line">如果由函数类型F的值f，表达式f(a1,a2,a3)表达了对函数f的调用，同时以a1、a2和a3作为参数传递给函数f。  </span><br><span class="line">方法是函数的一种，比函数多了一个接收者。接收者可以是该方法所属的结构体类型的值，或者与该结构体类型对应的那个指针类型的值。</span><br><span class="line">&gt;在求值一个表达式、赋值语句或者返回语句中包含的操作数的时候，所有的函数调用、方法调用和通信调用都会按照从左到右的顺序被求值。</span><br><span class="line">```code</span><br><span class="line">a := 10</span><br><span class="line">f := func()int&#123; a = a*2;return 5&#125;</span><br><span class="line">x := []int&#123;a,f()&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中，x的值可能是[]int{10,5},也可能是[]int{20,5}。（有待考证</p><h4 id="7-可变长参数"><a href="#7-可变长参数" class="headerlink" title="7. 可变长参数"></a>7. 可变长参数</h4><p>如果函数f可以接受的参数的数量是不固定的，那么函数f就是一个能够接受可变长参数的函数，简称为可变参函数。<br>在可变函数的参数列表的最后总会出现一个可变长参数，这个可变长参数的类型声明形如…T。用于接受数量不定但类型均为T或其实现类型的参数值。等同于一个元素类型为T的切片类型的参数。对于函数f的每一次调用，被传递给可变长参数的值实际上都是包含了实际参数、元素类型为T的切片类型值。对可变参函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func appendIfAbsent(s []string,t ...string)[]string</span><br></pre></td></tr></table></figure></p><p>可以这样编写针对他的调用表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,&quot;C&quot;,&quot;N&quot;,&quot;E&quot;)</span><br></pre></td></tr></table></figure></p><p>其中，与可变长参数t绑定的切片类型值为[]string{“C”,”B”,”E”}。<br>可以直接把一个类型T的切片类型值赋给…T类型的可变长参数，需要在欲赋予可变长参数的那个切片类型值的后面追加…。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,[]string&#123;&quot;C&quot;,&quot;B&quot;,&quot;E&quot;&#125;...)</span><br></pre></td></tr></table></figure></p><p>若有元素类型为string的切片类型的变量s，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,s...)</span><br></pre></td></tr></table></figure></p><p>此时可变长参数t的值就是变量s的值，即不会专门创建于个切片类型值来存储其中的实际参数。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启航</title>
      <link href="/2018/04/05/%E5%90%AF%E8%88%AA/"/>
      <url>/2018/04/05/%E5%90%AF%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建缘由"><a href="#搭建缘由" class="headerlink" title="搭建缘由"></a>搭建缘由</h3><p> 在前段时间又重新搭建了一系列的开发环境，安装了数遍双系统和虚拟机，折腾ubuntu和centos，搭建php+nginx+go+mariadb+node等等，期间遇到了很多的新问题，也有一些老问题，学到了很多东西，越来越感觉到笔记的重要性。想要自己搭建一套博客，怕是ui丑到自己都下不去笔。另外耽误时间、服务器配置以及相关稳定性长久性等也是个问题。从今开始，将所学所得所感记录在此。</p><h3 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h3><p>本博客由hexo驱动，尝试过很多主题，例如yilia、material等，最终选择了next主题。之前也尝试过rubuy的jekyll，但是更偏向于比较熟悉的基于node的hexo。使用yilia主题时，强迫症改liyia的侧滑抖动动画，改侧滑背景颜色，最终还是感觉界面不理想，在移动端每个页面上都挂着个人prefile，有种特沙比的感觉，非常浪费空间影响阅读体验，而且作者留了个badjs report收集异常信息和用户信息，感觉很是不爽，并且对应的提交端口貌似没有在维护了，调试时一个红色的eroor简直逼死强迫症。</p><p>使用material主题时也有类似yilia冗余的一点，有个logo perfile简直累赘，而且对应的官方网站相应文档总是加载不出来，貌似被墙了，很遗憾，没搭建完美就放弃了。</p><p>后来用到next主题，对于用户来说要比前两个友好很多，简洁大方，留给了用户更多的配置项，在移动端浏览更简洁舒服，封装了更多的第三方插件。评论插件建议畅言，加载快多了。但是目前有个问题，编写tags、about等page页面时，在page页面配置comments为false，编译后对应的页面虽然不出现畅言插件，即没加入相应的html页面块，但是却加入了相应的js用，然后在控制台会一直报js未寻找到畅言对应html节点的错误。使用来必力虽然也加入了相应的js调用，但是不会出现此类错误，应该编译过程未处理好。等以后有机会再探究修改一番，作为强迫症，把所有的页面评论功能都打开了。。。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望自己能够</p><blockquote><p>勤操代码多读书，善用时间少偷懒。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> next主题 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>BUG制造师</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>姓名：吴桦</li><li>性别：男</li><li>出生年月：1995/02</li><li>Email： <a href="mailto:cocowh@qq.com" target="_blank" rel="noopener">cocowh@qq.com</a></li><li>博客： <a href="http://bighua.top">http://bighua.top</a></li><li>GitHub： <a href="https://github.com/cocowh" target="_blank" rel="noopener">https://github.com/cocowh</a></li></ul><hr><h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><p>2014/09-2018/06</p><ul><li>学历：本科</li><li>学校：华中农业大学</li><li>专业：计算机科学与技术</li></ul><hr><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p>2018/07-至今</p><ul><li>公司：好未来</li><li>职位：后台研发</li></ul><hr><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>PHP</li><li>Golang</li><li>Java</li><li>Redis</li><li>MySQL</li></ul>]]></content>
      
    </entry>
    
  
</search>
