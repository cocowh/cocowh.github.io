<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Golang笔记-channel</title>
      <link href="/2018/05/02/Golang%E7%AC%94%E8%AE%B0-channel/"/>
      <url>/2018/05/02/Golang%E7%AC%94%E8%AE%B0-channel/</url>
      <content type="html"><![CDATA[<p>channel——提倡“以通信作为手段来共享内存”最直接和最重要的体现。<br>Go使用通道类型值在不同的goroutine之间传递值。channel类似一个类型安全的通用型管道。</p><p>channel提供了一种机制，既可以同步两个并发执行的函数，又可以让这两个函数通过相互传递特定类型的值来通信。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>channel既值通道类型，指代可以传递某种类型的值的通道。通道即某一个通道类型的值，是该类型的一个实例。</p><h3 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1.类型表示法"></a>1.类型表示法</h3><p>属于引用类型。泛化的通道类型的声明：</p><blockquote><p><code>chan T</code></p></blockquote><p>声明别名类型：</p><blockquote><p><code>chan IntChan chan int</code></p></blockquote><p>声明一个chan int类型的变量：</p><blockquote><p><code>var intChan chan int</code></p></blockquote><p>通道类型是双向的，既可以向此类通道发送元素值，也可以从那里接收元素值。使用<code>&lt;-</code>接收操作符声明单向的通道类型，下面会i只能用于发送值的通道类型的泛化表示：</p><blockquote><p><code>chan &lt;- T</code>    //发送通道类型</p></blockquote><p>声明只能从其中接收元素值的通道类型：</p><blockquote><p><code>&lt;-chan T</code>     //接收通道类型</p></blockquote><h3 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2.值表示法"></a>2.值表示法</h3><p>通道类型的变量在被初始化前，值为nil。通道类型的变量是用来传递值的而不是存储值的。通道类型并没有对应的值表示法。其值具有即时性，无法准确用字面量来表达。</p><h3 id="3-操作的特性"><a href="#3-操作的特性" class="headerlink" title="3.操作的特性"></a>3.操作的特性</h3><p>通道是在多个goroutine之间传递数据和同步的重要手段，对通道操作的本身也是同步的。在同一时刻，仅有一个goroutine能向一个通道发送元素值，同时也仅有一个goroutine能从它那里接收元素值。通道中，各个元素值都是严格按照发送到此的先后顺序排列的，最早发送至通道的元素值会最先被接收。通道相当于一个FIFO的消息队列。通道中的元素具有原子性，是不可被分割的。通道中的每一个元素值都只可能被某一个goroutine接收，已被接受的值会立刻从通道中删除。</p><h3 id="4-初始化通道"><a href="#4-初始化通道" class="headerlink" title="4.初始化通道"></a>4.初始化通道</h3><p>引用类型的值都需要内建函数make来初始化。</p><blockquote><p><code>make(chan int, 10)</code></p></blockquote><p>初始化一个在同一时刻最多可以缓冲10个元素值且元素类型为int的通道类型。</p><blockquote><p><code>make(chan int)</code></p></blockquote><p>一个通道值的缓冲容量总是固定不变的，省略参数二意味着初始化的这个通道永远无法缓冲任何元素值。发送给它的元素值应该被立刻取走，否则发送方的goroutine就会暂停（阻塞），直到有接收方接收这个元素值。</p><p>将第二个参数值大于0的通道称为缓冲通道，未给定第二个参数值或给定值为0的通道称为非缓冲通道。</p><h3 id="5-接收元素值"><a href="#5-接收元素值" class="headerlink" title="5.接收元素值"></a>5.接收元素值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strChan := make(chan string, 3) //声明一个双向通道类型strChan</span><br><span class="line"></span><br><span class="line">elsm, ok := &lt;- strChan</span><br><span class="line">elem := &lt;- strChan //从该通道中接收元素值，无值时goroutine被阻塞直到有值时被唤醒</span><br></pre></td></tr></table></figure><p>从未初始化的通道中接收值会造成当前goroutine永久阻塞。</p><h3 id="6-Happens-before"><a href="#6-Happens-before" class="headerlink" title="6.Happens before"></a>6.Happens before</h3><p>对于一个缓冲通道有：  </p><ul><li>发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，则阻塞正在进行发送操作的goroutine。复制的目的地址有两种。当通道已空且有接收方在等待元素值时，它会是最早等待的那个接收方持有的内存地址，否则会是通道持有的缓冲中的内存地址。</li><li>接收操作会使通道给出一个已发送它的元素值的副本，若因通道的缓冲空间已空而无法立即给出，则阻塞正在进行接收操作的goroutine。一般情况下，接收方会从通道持有的缓冲中得到元素值。</li><li>对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道中接收它的操作完成之前完成。在通道完全复制一个元素值之前，任何goroutine都不可能从它那里接收到这个元素值的副本。</li></ul><h3 id="7-发送元素值"><a href="#7-发送元素值" class="headerlink" title="7.发送元素值"></a>7.发送元素值</h3><p>对接收操作符&lt;-两边的表达式的求值会先于发送操作执行，在对两个表达式求值完成之前，发送操作被阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var strChan = make(chan string, 3)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">syncChan1 := make(chan struct&#123;&#125;, 1)</span><br><span class="line">syncChan2 := make(chan struct&#123;&#125;, 2)</span><br><span class="line">go func() &#123; // 用于演示接收操作。</span><br><span class="line">&lt;-syncChan1</span><br><span class="line">fmt.Println(&quot;Received a sync signal and wait a second... [receiver]&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">for &#123;</span><br><span class="line">if elem, ok := &lt;-strChan; ok &#123;</span><br><span class="line">fmt.Println(&quot;Received:&quot;, elem, &quot;[receiver]&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Stopped. [receiver]&quot;)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123; // 用于演示发送操作。</span><br><span class="line">for _, elem := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; &#123;</span><br><span class="line">strChan &lt;- elem</span><br><span class="line">fmt.Println(&quot;Sent:&quot;, elem, &quot;[sender]&quot;)</span><br><span class="line">if elem == &quot;c&quot; &#123;</span><br><span class="line">syncChan1 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(&quot;Sent a sync signal. [sender]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Wait 2 seconds... [sender]&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">close(strChan)</span><br><span class="line">syncChan2 &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&lt;-syncChan2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sent: a [sender]</span><br><span class="line">Sent: b [sender]</span><br><span class="line">Sent: c [sender]</span><br><span class="line">Sent a sync signal. [sender]</span><br><span class="line">Received a sync signal and wait a second... [receiver]</span><br><span class="line">Received: a [receiver]</span><br><span class="line">Received: b [receiver]</span><br><span class="line">Received: c [receiver]</span><br><span class="line">Received: d [receiver]</span><br><span class="line">Sent: d [sender]</span><br><span class="line">Wait 2 seconds... [sender]</span><br><span class="line">Stopped. [receiver]</span><br></pre></td></tr></table></figure></p><p>由于运行时系统的调度，每次运行的输出语句顺序可能不同。</p><p>syncChan通道是为了不让主goroutine过早地结束运行。一旦goroutine过早的结束运行，Go程序的运行也就结束了。main函数最后试图从syncChan接收值两次，接收完成之前主goroutine阻塞于此。两个goroutine都像syncChan发送值后，主goroutine恢复运行，随后结束运行。</p><p>syncChan1和syncChan2的元素类型都是struct{}。代表的是不包含任何字段的结构体类型，也称空结构体类型。空结构体的变量不占内存空间，并且所有该类型的变量都拥有相同的内存地址。建议用于传递“信号”的通道都用struct{}作为元素类型，除非需要传递更多的信息。</p><p>向一个值为nil的通道类型的变量发送元素值时，当前goroutine也会被永久的阻塞。若试图从一个已关闭的通道中发送元素值，会立即引发一个运行时恐慌，即使发送通道正在因通道已满而被阻塞。为避免此类流程中段可以在select代码块中执行发送操作。</p><p>若由多个goroutine向同一个已满的通道发送元素值而被阻塞，那么当该通道中有多余空间的时候，最早被阻塞的goroutine会最先被唤醒。对接收操作也是如此。运行时系统每次只会唤醒一个goroutine。</p><p>发送方向通道发送的值会被复制，接收方接收的总是该值的副本，而不是该值本身。通道的缓冲队列属于环形队列。当接收方从通道接收到一个类型的值时，对该值的修改不会影响发送方持有的源值。</p><h3 id="8-关闭通道"><a href="#8-关闭通道" class="headerlink" title="8.关闭通道"></a>8.关闭通道</h3>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chan </tag>
            
            <tag> 通道 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-goroutine</title>
      <link href="/2018/05/02/Golang%E7%AC%94%E8%AE%B0-goroutine/"/>
      <url>/2018/05/02/Golang%E7%AC%94%E8%AE%B0-goroutine/</url>
      <content type="html"><![CDATA[<p>go语句是启用goroutine的唯一途径。</p><h2 id="go语句与Goroutine"><a href="#go语句与Goroutine" class="headerlink" title="go语句与Goroutine"></a>go语句与Goroutine</h2><p>一条go语句意味着一个函数或方法的并发执行，由go关键字和表达式组成。针对如下函数的调用表达式不能称为表达式语句：append、cap、complex、imag、len、make、new、real、unsafe.Alignof、unsafe.Offsetof和unsafe.Sizeof。前8个函数是Go语言的内建函数，后3个函数是标准库代码包unsafe中的函数。</p><blockquote><p>code example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">---</span><br><span class="line">go func()&#123;</span><br><span class="line">    println(&quot;Go! Goroutine!&quot;)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p></blockquote><p>Go语言的运行时系统对go语句中的函数或方法（go函数）的执行是并发的，当go语言被执行的时候，其中的go函数会被单独地放入到一个goroutine中，该go函数的执行会独立于当前goroutine的运行。go函数并发执行，但执行的先后顺序不确定。</p><p>当go函数被执行完毕的时候，相应的goroutine会进入到死亡状态（Ghead）。标志着该goroutine的一次运行的完成。作为go函数的函数或方法可以有结果声明，但是返回的结果值会在它们被执行完成时被丢弃。需要用channel将go函数的结果传递给其他程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于执行的先后顺序不确定，go语句后无其他语句，main函数所在的G可能先于go函数所在的G执行结束，意味着可能go函数所在的G未来得及执行。</p><p>使用time包中的Sleep函数干预多个G的执行顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    go println(&quot;Go!Goroutine!&quot;)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>time.Sleep函数让调用它的goroutine暂停（进入Gwaiting状态）一段时间。此种情况最好的方法时调用runtime.Gosched()函数，暂停当前的G，让其他的G有运行的机会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    names := []string&#123;&quot;Eric&quot;, &quot;Harry&quot;, &quot;Robert&quot;, &quot;Jim&quot;, &quot;Mark&quot;&#125;</span><br><span class="line">    for _, name := range names &#123;</span><br><span class="line">        go func (who string) &#123;</span><br><span class="line">            fmt.Printf(&quot;Hello, %s!\n &quot;, who)</span><br><span class="line">        &#125;(name) </span><br><span class="line">    &#125;</span><br><span class="line">    runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主goroutine的运作"><a href="#主goroutine的运作" class="headerlink" title="主goroutine的运作"></a>主goroutine的运作</h2><p>封装main函数的goroutine是Go语言运行时系统创建的第一个goroutine(主goroutine)，主Goroutine在runtime.m0上被运行。runtime.m0在运行完runtime.g0中的引导程序之后，会接着运行主goroutine。</p><p>主goroutine不仅执行main函数。它首先：设定每一个goroutine所能申请的栈空间的最大尺寸。在32位的计算机系统中此最大尺寸为250MB，在64位的计算机系统中此尺寸为1GB。若有某个goroutine的栈空间尺寸大于这个限制，运行时系统就会发出一个栈溢出（stack overflow）的运行时恐慌。随即，Go程序的运行也会被终止。</p><p>设定好goroutine的最大栈尺寸后，主goroutine会在当前M的g0上执行系统监测任务。系统监测任务的作用是调度器查缺补漏。</p><p>此后，主goroutine会进行一系列的初始化工作，涉及的工作内容大致有。  </p><ul><li>检查当前M是否为runtime.m0。若不是，说明之前的程序出现了某种问题，主goroutine会立即抛出异常，意味着Go程序的启动失败。</li><li>创建一个特殊的defer语句，用于在主goroutine退出时做必要的善后处理。因为主goroutine可能非正常的结束。</li><li>启用专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识。</li><li>执行main包中的init函数。</li></ul><p>在上述初始化工作完成之后，主goroutine就会去执行main函数。在执行main函数之后，会检查主goroutine是否引发了运行时恐慌，并进行必要的处理。最后，主goroutine会结束自己以及当前进程的运行。</p><p>main函数执行期间，运行时系统会根据Go程序中的go语句，复用或新建goroutine来封装go函数。这些goroutine都会放入相应P的可运行G队列中，然后等待调度器的调度。</p><h2 id="runtime包与goroutine"><a href="#runtime包与goroutine" class="headerlink" title="runtime包与goroutine"></a>runtime包与goroutine</h2><p>Go的标准库代码包runtime中的程序实体，提供了各种可以使用户程序与Go运行时系统交互的功能。</p><h3 id="1-runtime-GOMAXPROCS函数"><a href="#1-runtime-GOMAXPROCS函数" class="headerlink" title="1.runtime.GOMAXPROCS函数"></a>1.runtime.GOMAXPROCS函数</h3><p>用户程序在运行期间，设置常规运行时系统中的P的最大数量。调用会引起“Stop the world”，应在应用程序尽量早的调用，更好的方式是设置环境变量GOMAXPROCS。P的最大数量范围在1～256。</p><h3 id="2-runtime-Goexit函数"><a href="#2-runtime-Goexit函数" class="headerlink" title="2.runtime.Goexit函数"></a>2.runtime.Goexit函数</h3><p>立即使当前goroutine的运行终止，而其他goroutine并不会受此影响。runtime.Goexit函数在终止当前goroutine之前，会先执行该goroutine中所有还未执行的defer语句。</p><p>该函数将被终止的goroutine置于Gdead状态，并将其放入本地P的自由G列表，然后触发调度器的一轮调度流程。</p><blockquote><p>不应在主goroutine中调用此函数，否则引发运行时恐慌。</p></blockquote><h3 id="3-runtime-Gosched函数"><a href="#3-runtime-Gosched函数" class="headerlink" title="3.runtime.Gosched函数"></a>3.runtime.Gosched函数</h3><p>该函数暂停当前goroutine的运行，并将其置为Grunnable状态，放入调度器的可运行G队列。经过调度器的调度，该goroutine马上会再次运行。</p><h3 id="4-runtime-RunGoroutine函数"><a href="#4-runtime-RunGoroutine函数" class="headerlink" title="4.runtime.RunGoroutine函数"></a>4.runtime.RunGoroutine函数</h3><p>返回当前运行时系统中处于非Gdead状态的用户G的数量。这些goroutine被视为“活跃的”或者“可调度的”。返回值总会大于一（废话）。</p><h3 id="5-runtime-LockOSThread函数和runtime-UnLockOSThread函数"><a href="#5-runtime-LockOSThread函数和runtime-UnLockOSThread函数" class="headerlink" title="5.runtime.LockOSThread函数和runtime.UnLockOSThread函数"></a>5.runtime.LockOSThread函数和runtime.UnLockOSThread函数</h3><p>前者的调用使当前goroutine与当前M锁定在一起，后者的调用则会解除这样的锁定。多次调用前者不会造成问题但只有最后一次生效。没有调用前者时调用后者也不会产生任何副作用。</p><h3 id="6-runtime-debug-SetMaxStack函数"><a href="#6-runtime-debug-SetMaxStack函数" class="headerlink" title="6.runtime/debug.SetMaxStack函数"></a>6.runtime/debug.SetMaxStack函数</h3><p>约束单个goroutine所能申请栈空间的最大尺寸。主goroutine会对此值进行默认设置。</p><p>函数接收一个int类型的参数，参数为欲设定的栈空间的最大字节数。执行完毕后会把之前的设定值作为结果返回。</p><p>若运行时系统在为某个goroutine增加栈空间的时候，若其实际尺寸超过设定值，就会发起一个运行时恐慌并终止程序的运行。</p><p>此函数不会像runtime.GOMAXPROCS函数对传入的参数值进行检查和纠正。</p><h3 id="7-runtime-debug-SetMaxThreads函数"><a href="#7-runtime-debug-SetMaxThreads函数" class="headerlink" title="7.runtime/debug.SetMaxThreads函数"></a>7.runtime/debug.SetMaxThreads函数</h3><p>对Go运行时系统所时用的内核线程的数量（也为M的数量，其与内核线程一一对应）进行设置。引导程序中，该数量被设置为10000。</p><p>接收一个int类型的值，返回一个int类型的值。前者代表欲设定的新值，后者代表之前的旧值。若设定的数量小与当前正在使用的M的数量，则会引发一个运行时恐慌。函数调用后，新建M会检查当前所持M的数量，若大于M的数量的设定，运行时系统引发一个运行时恐慌。</p><h3 id="8-与垃圾回收有关的一些函数"><a href="#8-与垃圾回收有关的一些函数" class="headerlink" title="8.与垃圾回收有关的一些函数"></a>8.与垃圾回收有关的一些函数</h3><p>runtime/debug.SetGCPercent、runtime.GC和runtime/debug.FreeOSMemory。前者用于设定触发GC的条件，后两者用于手动触发GC。在后两个函数的执行期间，调度是停止的（阻塞）。runtime/debug.FreeOSMemory函数比runtime.GC多做一件事，在GC之后清扫一次堆内存。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> go语句 </tag>
            
            <tag> goroutine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-Go并发底层</title>
      <link href="/2018/04/27/Golang%E7%AC%94%E8%AE%B0-Go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82/"/>
      <url>/2018/04/27/Golang%E7%AC%94%E8%AE%B0-Go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82/</url>
      <content type="html"><![CDATA[<p>Go在操作系统提供的内核线程之上搭建了一个特有两级线程模型，称为Goroutine。其代表的含义为：</p><blockquote><p>不要用共享内存的方式来通信，作为替代，应该以通信作为手段来共享内存。</p></blockquote><p>Go不推荐以共享内存区的方式传递数据，作为替代，优先使用Channel。被用来在多个Goroutine之间传递数据，并且会保证其过程的同步。提供了一些传统的并发访问控制方式（互斥量、条件变量等）。</p><h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>Go语言的线程实现模型，有3个核心元素支撑线程实现模型的主框架：   </p><ul><li>M：Machine的缩写。一个M代表一个内核线程。</li><li>P：Processor的缩写。一个P代表了M所需的上下文环境。</li><li>G：Goroutine的缩写。一个G代表了对一段需要被并发执行的Go语言代码的封装。</li></ul><p>一个G的执行需要M和P的支持。一个M在与一个P关联之后就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列。该队列中的G会被依次传给与本P关联的M并获得运行时机。</p><p>M与KSE（内核调度实体）之间是一对一关系，一个M仅能代表一个内核线程。Go语言的运行时系统（runtime system）用其代表一个内核调度实体，在一个M的生命周期内，其仅会与一个KSE产生关联。M与P以及P与G之间的关系会在实际调度的过程中被改变。M与P之间也总是一对一的，P与G之间是一对多的。一个G最终由一个M来负责运行。</p><h3 id="1-M"><a href="#1-M" class="headerlink" title="1.M"></a>1.M</h3><p>一个M代表了一个内核线程。大多数情况下，创建一个M的原因是由于没有足够的M来关联P并运行其中的可运行的G。在运行时系统执行系统监控或垃圾回收等任务时也会导致新的M的创建。</p><p>M结构中字段众多。  </p><ul><li>curg：存放当前M正在运行的G的指针。</li><li>p：指向与当前M相关联的P。</li><li>msraerfm：M的起始函数。</li><li>nextp：暂存与当前M有潜在关联关系的P。把调度器将某个P赋给某个M的nextp字段的操作称为对M和P的预联。有时运行时系统会把被重新启用的M和已与它预联的P关联在一起。</li></ul><p>M在被创建之初会被加入到全局的M列表（runtimr.allm）中。然后它的起始函数和准备关联的P（大多数情况下是导致此M创建操作的P）会被设置。最后运行时系统会为它专门创建一个新的内核线程并与之相关联。此时新的M就为执行G做好了准备。起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。全局M列表无特殊意义，运行时系统会通过它获取到所有M的信息。可以防止M被当作垃圾回收掉。</p><p>新的M被创建完成后会先进行一些初始化工作，包括对自身所持的栈空间以及信号处理方面的初始化。初始化完成后M的起始函数会被执行（若存在）。若起始函数代表的是系统监控任务，则M会一直在那里执行而不会继续后面的流程。否则在初始化函数执行完毕后，当前M会与准备与它关联的P完成关联。此时一个并发执行环境才形成。</p><p>运行时系统管辖的M有时会被停止，例如运行时系统开始执行垃圾回收任务的时候。运行时系统停止M时，在对其属性进行必要的重置之后，把它放入调度器的空闲M列表（runtime.sched.midle）。在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。</p><p>M本身是无状态的，M是否空闲仅以它是否存在于调度器的空闲M列表中为依据。</p><p>单个Go程序所使用的M的最大数量可以被设置。<code>使用命令运行Go程序时，一个引导程序先会被启动。引导程序为Go程序的运行建立必要的环境</code>。引导程序会对M的最大数量进行初始设置，为10000，即一个Go程序最多可以使用10000个M。意味着最理想情况下，同时可以有10000个内核线程被同时运行。操作系统内核对进程的虚拟内存的布局的控制以及大小的限制，此数量级线程可能很难共存，Go语言本身对于线程数量的限制几乎可以被忽略。除此之外可以在Go程序中对该限制进行限制。调用标准库代码包runtime/debug中的SetMaxThreads函数并提供新的M最大数量。执行后会把旧的M最大数量作为结果值返回。若传入的值比当时M的实际数量小，运行时系统会发起一个运行时恐慌。若需要设置M的最大数量，越早调用此函数越好。</p><h3 id="2-P"><a href="#2-P" class="headerlink" title="2.P"></a>2.P</h3><p>P是使G能够在M中运行的关键。运行时系统会适时地让P与不同的M建立或断开关联，以使P中的可运行的G能够在需要的时候及时获得运行时机。类似操作系统内核在CPU之上实时切换不同的进程或线程。</p><p>调用runtime.GOMAXPROCS函数，可以改变单个Go程序可以间接拥有的P的最大数量。此外，可以在运行Go程序之前设置环境变量GOMAXPROCS的值来对Go程序可以拥有的P的最大数量做出预先设定。P的最大数量相当于是对可以被并发运行的用户级别的G的数量做出限制。每个P都需要关联一个M才能使其中的可运行的G得到执行，不意味着环境变量GOMAXPROCS的值会限制住M的总数量。当M因系统调用的进行而被阻塞（运行的G进入了系统调用）时，运行时系统会将M和与之关联的P分离出来。此时，这个P的可运行G队列中还有未被运行的G，则运行时系统会找到一个空闲M或创建出一个新的M，并与该P关联以满足这些G的运行需要。若Go程序中创建的大部分Goroutine中都包含了很多需要间接地进行各种系统调用的代码时，即使环境变量GOMAXPROCS的值被设定为1，也可能会有多个M被创建出来。实际的M总数量很可能会比环境变量GOMAXPROCS所指代的数量多。真正使用的内核线程的数量不会因此而环境变量受到限制。</p><p>Go程序开始被运行时，引导程序也会对P的最大数量进行设置。默认值为1。默认情况下，无论我们在程序中用go语句启用出多少Goroutine，它们都只会被塞入同一个P的可运行G的队列中。P最大数量值绝不会比引导程序中的硬性上限值大，超过时会被硬性上限值取代。</p><p>runtime.GOMAXPROCS函数的执行会暂时使所有的P都相继进入停止状态并试图阻止任何用户级别的G的运行。只有在新的P最大数量被设定完成之后，运行时系统才会开始陆续恢复它们。对程序性能损耗大。即只在Go程序的main函数的开始处调用runtime.GOMAXPROCS函数较好，最好不对其进行调用而只预先设置GOMAXPROCS。</p><p>确定P最大数量后，运行时系统会根据这个数值初始化全局P列表（runtime.allp）。包含了当前运行时系统创建的所有P。然后运行时系统把调度器的可运行G队列中的所有G均匀的放入到全局P列表中的各个P的可运行G队列中。此时，运行时系统需要用到的所有P都以就绪。</p><p>同空闲M列表，在运行时系统中存在着调度器的空闲P列表（runtime.sched.pidle）。当一个P不再与任何M关联的时候，运行时系统会把它放入到该列表，当运行时系统需要一个空闲的P关联某个M时，会从此列表中取出一个。即使P进入到空闲P列表，它的可运行G列表也不一定是空的。</p><p>P本身是有状体的：  </p><ul><li>Pidle：表明当前P未与任何M存在关联。</li><li>Prunning：表明当前P正在与某个M关联。</li><li>Psyscall：表明当前P中的被运行的那个G正在被系统调用。</li><li>Pgcstop：表明运行时系统正在进行垃圾回收。在运行时系统进行垃圾回收时，会试图把全局P列表中的都置于此状态。</li><li>Pdead：表明当前P已经不会再被使用。当在Go程序运行的过程中通过调用runtime.GOMAXPROCS函数减少P最大数量时，多余的P会被运行时系统置于此状态。</li></ul><p>P的初始状态时Pgcstop，虽然运行时系统并不会在这时进行垃圾回收。初始化和填充P中的可运行G队列之后，运行时系统会将状态设置为Pidle并放入到调度器的空闲P列表中。空闲P列表中的所有P都会由调度器根据实际情况进行取用。除了Pdead之外的其他状态的P都会在运行时系统进行垃圾回收的时候被置于Pgcstop状态，等到垃圾回收结束之后并不会恢复至原有状态，而会被统一地换为Pidle状态。意味着它们会被重新调度。除了Pgcstop状态，处于其他状态的P都有可能由于全局P列表的缩小而被认为是多余的并置于Pdead状态。P被转换为Pdead状态之前，其可运行G队列中的G都会被转移至调度器的可运行G队列中，其自由G列表中的G都会被转移到调度器的自由G列表中。</p><p>每个P中都有一个可运行G列表，还包含一个自由G列表（gfree）。自由G列表中包含一些已经被运行完成的G。随着被运行完成的G的增多，该自由列表可能会很长。若增长到一定程度，运行时系统会把其中的部分G转移到调度器的自由G列表（runtime.sched.gfree）中。当使用go语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G来封装我们提供的函数，仅当获取不到这样的一个G时才有可能区创建一个新的G。若相应P的自由G列表为空而获取不到自由G时，运行时系统若在这个过程中发现其中的自由G太少，则会先尝试从调度器的自由G列表中转移过来一些G。只有在调度器的自由G列表也为空时才会有新的G被创建。很大程度上提高了G的复用率。当一个P被运行时系统认为不会再被使用（被置于Pdead状态）的时候，其中的自由G列表中的所有G都会转移至调度器的自由G列表中。</p><p>P的结构中，可运行G队列和自由G列表是最重要的两个成员，间接的体现运行时系统对相应的G的调度情况。</p><h3 id="3-G"><a href="#3-G" class="headerlink" title="3.G"></a>3.G</h3><p>一个G就相当于一个Goroutine(或者称Go程)，对应使用go语句欲并发执行的一个匿名或命名的函数。</p><p>Go语言的编译器会把我们编写的go语句（go关键字和其后的函数的统称）变成对一个运行时系统中的函数调用，并把go语句中的函数（go函数）即其参数都作为参数传递给这个运行时系统中的函数。go语句代表了我们向运行时系统递交的一个并发任务。</p><p>运行时系统在接到这样一个调用之后，先检查go函数即其参数的合法性，然后会试图从本地P的自由G列表和调度器的自由G列表获取可用的G。没有获取到则会新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（runtime.allg）。新建的G会在第一时间被加入到该列表中。该列表的主要作用是集中存放当前运行时系统中的所有G的指针。无论将会封装当前的go函数的G是否是新的，运行时系统都会对它进行一次初始化。包括关联go函数以及设置G的状态的ID等步骤。初始化完成后，这个G被放入到本地P的可运行G队列中。时机成熟，调度会立即进行以使这个G尽快被运行。</p><p>每个G都会由运行时系统根据其实际状况设置不同的状态：  </p><ul><li>Gidle：当前G被创建但还完全未被初始化的时候。</li><li>Grunnable：表示当前G是可运行的并且正在等待被运行。</li><li>Grunning：表示当前G正在被运行。</li><li>Gsyscall：表示当前G正在进行系统调用。</li><li>Gwaiting：表示当前G正在因某个原因而等待。</li><li>Gdead：表示当前G已被运行完成。</li></ul><p>运行时系统用一个G封装我们通过go语句递交的go函数的时候，先对这个G进行初始化。其中的一步就是初始化这个G的状态为Grunnable，即一个G真正被使用是在其状态被设置为Gorunnable之后。</p><p>一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。</p><p>G在退出系统调用时，运行时系统先会尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为Grunnable状态并放入到调度器的自由G列表中。</p><p>进入死亡状态（Gdead）的G可以被重新初始化并使用。相比之下，P在进入死亡状态（Pdead）之后则只能面临被销毁的结局。Gdead与Pdead状态所表达的含义完全不同。处于Gdead状态的G会被放入本地P或调度器的自由G列表，为重用提供了条件。</p><h3 id="4-核心元素的容器"><a href="#4-核心元素的容器" class="headerlink" title="4.核心元素的容器"></a>4.核心元素的容器</h3><p>M，P和G的容器：<br>名称 | 源码 | 作用域 | 说明<br>:- | :- | :- | :-<br>全局P列表 | runtime.allm | 运行时系统 | 用于存放所有M的列表<br>全局P列表 | runtime.allp | 运行时系统 | 用于存放所有P的列表<br>全局G列表 | runtime.allg | 运行时系统 | 用于存放所有G的列表<br>调度器的空闲M列表 | runtime.sched.midle | 调度器 | 用于存放空闲M的列表<br>调度器的空闲P列表 | runtime.sched.pidle | 调度器 | 用于存放空闲P的列表<br>调度器的可运行G队列 | runtime.sched.runq | 调度器 | 用于存放可运行G的队列<br>调度器的自由G列表 | runtime.sched.gfree | 调度器 | 用于存放自由G的列表<br>P的可运行G队列 | runq | 本地P | 用于存放当前P中的可运行G的队列<br>P的自由G列表 | gfree | 本地P | 用于存放当前P中的自由G的列表<br>全局的3个列表存在的主要目的是为了统计运行时系统中的所有M、P或G。运行时系统创建出的任何G都会存在于全局G列表中，其于的4个与G有关的列表只会存放在当前作用域内的具有特定状态的G。调度器的可运行G队列和P的可运行G队列都拥有几乎平等的运行机会。运行时系统调度的过程中会先后对它们进行检查，并会运行第一个被发现的可运行的G。从Gsysycall状态和Ggcstop状态转出的G，会被放入调度器的可运行G队列，被运行时系统初始化的G，会被放入本地P的可运行G队列。从Gwaiting状态转出的G，除因网络I/O陷于等待的G，都会被放入到本地P的可运行G队列。调用runtime.GOMAXPROCS函数，可能会导致运行时系统清空调度器的可运行G队列。其中所有G都会被均匀地放入到全局P列表中的各个P的可运行G队列当中。在G转入Gdead状态后，先会被放入本地P的自由G列表，在运行时系统需要用自由G封装go函数时，先尝试从本地P的自由G列表中获取。调度器的自由G列表只起到一个暂存自由G的作用。</p><p>与M和P相关的非全局容器被用于存放暂时不被使用的元素的实例。在运行时系统有需要时，会从中获取相应元素的实例并重新启用它。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>两级线程模型中的一部分调度任务会由操作系统内核之外的程序承担，Go语言中，其运行时系统中的调度器会负责这一部分调度任务。调度的主要对象是M、P和G的实例，调度的辅助设施是各种容器。每个M（每个内核线程）在运行过程中都会按需执行一些调度任务。</p><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1.基本结构"></a>1.基本结构</h3><p>调度器有它自己的数据结构，这一数据结构的主要目的是为了更加方便地管理和调度各个核心元素的实例。调度器的部分字段：<br>字段名称 | 数据类型 | 用途<br> :- | :- | :-<br> gcwaiting | uint32 | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制<br> stopwait | int32 | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制<br> stopnote | Note | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制<br> sysmonwait | unit32 | 作为系统检测任务被执行期间的停止和通知机制<br> sysmonnote | Note | 作为系统检测任务被执行期间的停止和通知机制<br>通过调度器gcwaiting的值，可知垃圾回收器是否已经开始准备或正在进行垃圾回收。stopwait字段是为了对还未被停止调度的P进行计数。当计数器为0时，说明调度工作已被完全停止，垃圾回收器会立即开始执行垃圾回收任务。stopnode字段被用来向垃圾回收器告知调度工作已经完全被停止的通知机制的重要部分。</p><p>辅助协调手段存在的意义在于保证所有的P在垃圾回收期间都处于Pgcstop状态。<code>Go语言的垃圾回收器先停止一切调度工作（包括对M和P的调度），然后进行垃圾回收，最后待垃圾回收完成之后再重启调度工作。</code>即Go语言的垃圾回收任务是在“stop the world”执行垃圾回收任务）的环境下被执行的。“Stop the world”即指运行时系统要放下手头所有工作并专心(无其它并发任务）执行垃圾回收任务。</p><p>垃圾回收器在准备执行垃圾回收任务的时候，先把调度器的gcwaiting字段的值设置为1，告诉调度器，它已经开始准备执行垃圾回收任务。垃圾回收器会利用stopnode字段将自身阻塞，以等待调度器完全停止调度。调度器在发现gcwaiting字段的值被置为1之后，会积极响应，并陆续停止正在进行的调度工作。待所有的调度工作均已停止（计数器的stopwait字段的值为0）之后，调度器回利用stopnode字段向垃圾回收器发送通知。垃圾回收器在收到通知后才会真正开始垃圾回收，通知机制在底层由信号灯实现。</p><p>垃圾回收器进行垃圾回收的时候，被持续执行的系统检测任务也需要被暂停，sysmonwait和sysmonnode的作用就是及时地暂停和恢复监测任务的执行。sysmonwait字段表示系统监测任务是否已经被暂停的标记，sysmonnode字段则是被用来向执行系统监测任务的程序发送通知。</p><p>系统监测任务是被持续执行的，即被置于无尽的循环中。在每次迭代之初，相关程序（系统监测器）会先检查调度器的gcwaiting字段的值，若其值为1，则说明垃圾回收器已经开始准备或正在执行垃圾回收任务。系统监测器会先将调度器的sysmonwait字段的值设置为1以表示系统监测任务已被暂停。然后利用sysmonnode字段阻塞自身以等待垃圾回收的完成。在调度工作被重启之后，调度器若发现其sysmonwait字段值为1则会利用sysmonnode字段向系统检测器发送通知。系统监测器在收到该通知之后会立即执行当次迭代的后续流程并继续进行之后的迭代。</p><h3 id="2-一轮调度"><a href="#2-一轮调度" class="headerlink" title="2.一轮调度"></a>2.一轮调度</h3><p>引导程序为Go程序的运行建立必要的环境。在引导程序完成工作之后，Go程序的main函数才会被真正地执行。引导程序在最后让调度器进行一轮调度，才能让main函数所在的G马上有机会被运行（封装main函数的G总是Go语言运行时系统创建的第一个G）。</p><center><p><img src="https://git-blog.oss-cn-beijing.aliyuncs.com/gfayilundiaodu.png" alt="一轮调度"><br></p></center><br>调度器的一轮调度中，有5个子流程。由标准库代码包runtime中的schedule函数代表。调度器会先从一些比较容易找到可运行G的地方入手，即全局的可运行G队列和本地的可运行G队列。若找不到，调度程序进入强力查找模式（子流程“全力查找可运行的G”）。若仍未找到可运行的G，该子流程就会暂停，直到有可运行的G出现才会继续下去。<p></p><p>在一轮调度的开始，调度器会先判断当前M是否已被锁定。M和G可以成对地锁定在一起。调度器会按照一定的策略动态地关联M、P和G，并以此高效地执行并发程序。</p><p>锁定M和G的操作是为CGO准备的，CGO代表了Go中的一种机制，时Go程序和C程序之间的一种调用机制。</p><p>若调度器在一轮调度之初发现当前M已与某个G锁定，就会停止调度并停止当前M（让其暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前M意味着相关的内核线程并不能再去做其他事情。调度器也不会为当前M寻找可运行的G。若当前M找到一个可运行G，但G与某个M锁定，就会唤醒与之锁定的M以运行该G，并重新为当前M寻找可运行的G。</p><p>若调度器判断当前M未与任何G锁定，则一轮调度的主流程就会继续运行。调度器会检查是否有运行时串行任务正在等待执行。通过判断gcwaiting字段的值，若不为0则一轮调度流程走进另一个分支:停止并阻塞当前M以等待运行时串行任务执行完。一旦串行任务执行完成,该M就会被唤醒,一轮调度也会再次开始。</p><p>若调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的寻找G。一旦找到一个可运行的G，调度器在判断该G未与任何M绑定之后，立即让当前M运行它。</p><p>一轮调度是调度器中最核心的流程，运行时系统在调度过程中经常使用。例如，在用户程序启动时的一系列工作之后之后，一轮调度会首次启动并使封装main的G被调度运行。某个G的运行时阻塞、结束、退出系统调用、栈的增长都会使调度器进行一轮调度。用户程序对某些标准库函数的调用也会触发一轮调度流程。调用runtime.Gosched函数相当于手动让调度器进行了新一轮的调度，使其他Goroutine能够得到运行机会。调用runtime.Goexit函数会在终结调用它的那个Goroutine之后，立即开始进行新一轮调度以使其他等待运行的Goroutine获得机会。</p><h3 id="3-全力查找可运行的G"><a href="#3-全力查找可运行的G" class="headerlink" title="3.全力查找可运行的G"></a>3.全力查找可运行的G</h3><p>“全力查找可运行G”子流程会尝试从各处搜索可运行的G，甚至会从别的P（非本地P）偷取可运行的G。由runtime.findrunnable函数代表，该函数返回一个处于Grunnable状态的G。搜索流程大致分为2个阶段和10个步骤。  </p><ul><li>（1）获取执行终结器的G。一个终结器（或称终结函数）可以与一个对象关联，通过调用runtime.SetFinalizer函数产生这种关联。当一个对象变为不可达（未被其他任何对象引用）时，垃圾回收器在回收该对象之前，会执行与之关联的终结函数（若有）。所有终结函数的执行都会由一个专用的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态并放入本地P的可运行G队列。</li><li>（2）从本地P的可运行G队列获取G。</li><li>（3）从调度器的可运行G队列获取G。</li><li>（4）从网络I/O轮询器（netpoller）处获取G。若netpoller已被初始化且已有过网络I/O操作，那么调度器会试着从netpoller获取获取一个G列表，并把表头的G作为结果返回。同时把其余的G放入调度器的可运行G队列。若netpoller未初始化或还未有过网络I/O操作，这一步会跳过。这里的获取浅尝辄止，非阻塞。</li><li>（5）从其他P的可运行G队列获取G。条件允许情况下，调度器使用一种伪随机算法在全局P列表中选取P，然后试着从它们的可运行G队列中盗取（或者说转移）一半的G到本地P的可运行G队列。选取P和盗取G的过程会重复多次，成功则停止。成功会把盗取的一个G作为结果返回，否则搜索的第一阶段就结束。</li><li>（6）获取执行GC标记任务的G。搜索第二阶段，调度器会判断是否正处在GC的标记阶段，以及本地P是否可用于GC标记任务。若答案都是true，调度器会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回。</li><li>（7）从调度器的可运行G队列获取G。调度器再次尝试从该处获取一个G，并把它作为结果返回。若依然找不到可运行的G，会解除本地P与当前M的关联并把该P放入调度器的空闲P列表。</li><li>（8）从全局P列表中的每个P的可运行G队列中获取G。遍历全局P列表中的P，并检查他们的可运行G队列。只要发现某个P的可运行G队列不为空，取该iP，判定可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。若所有P可运行G队列都为空，继续后面的搜索。</li><li>（9）获取GC任务标记的G。判断是否正处于GC的标记阶段，以及GC标记任务相关的全局资源是否可用。若答案都是true，调度器就会从其空闲P列表拿出一个P。若该P持有一个GC专用标记G，关联该P与当前M，再次执行第二阶段（步骤（6）开始）。</li><li>（10）网络I/O轮询器（netpoller）获取G。若netpoller已被初始化，并且有过网络I/O操作，调度器再次试着从netpoller获取一个G列表。与步骤（4）基本相同，区别于此处是阻塞的，只有当netpoller有可用的G时阻塞才会解除。若netpoller未被初始化或者未有过网络I/O操作，跳过此步。</li></ul><p>若经过上述步骤仍未找到可运行的G，调度器就会停止当前的M。在之后的某个时刻，该M被唤醒之后，会重新进入“全力查找可运行的G”的子流程。</p><p>网络I/O轮询器（netpoller）是Go为了在操作系统提供的异步I/O基础组件之上，实现自己的阻塞式I/O而编写的一个子程序。当一个G试图在一个网络连接上进行读/写操作时，底层程序（包括基础组件）就会开始为此做准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就回返回相应的事件，让netpoller立即通知为此等待的G。从netpoller获取G意味着获取那些已经接收到通知的G。调度器让它们转入Grunnable状态并等待运行。</p><p>全力查找可运行G的子流程会想方设法去搜寻G，执行比较耗时费力，会调用多方资源来满足当前M运行G的需要。因始终未找到G而停止的M在被唤醒后，依然会执行该子流程，直到找到一个可运行的G，M才会结束它的执行。</p><h3 id="4-启用或停止M"><a href="#4-启用或停止M" class="headerlink" title="4.启用或停止M"></a>4.启用或停止M</h3><p>调度器有时会停止当前M，由如下函数负责M的启用或者停止。  </p><ul><li>stopm()。停止当前M的执行，直到因有新的G变得可运行而被唤醒。</li><li>gcstopm。为串行运行时任务的执行让路，停止当前M的执行，串行运行时任务执行完毕后会被唤醒。</li><li>stoplockedm()。停止已经与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒。</li><li>startlockedm(gp * g)。唤醒与gp绑定的那个M，并让该M去执行gp。</li><li>startm(_p_  *p, spinning bool)。唤醒或创建一个M去关联_p_并开始执行。<blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote></li></ul><h3 id="5-系统监测任务"><a href="#5-系统监测任务" class="headerlink" title="5.系统监测任务"></a>5.系统监测任务</h3><p>由sysmon函数实现。监测任务主要做：  </p><ul><li>在需要时抢夺符合条件的G和P；</li><li>在需要时进行强制GC；</li><li>在需要时清扫堆；</li><li>在需要时打印调度器跟踪信息。<blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote></li></ul><h3 id="6-变更P的最大数量"><a href="#6-变更P的最大数量" class="headerlink" title="6.变更P的最大数量"></a>6.变更P的最大数量</h3><p>P最大数量变更直接影响Go程序的并发性能。调用runtime.GOMAXPROC函数时，会先进行下面两项检查，确保变更合法和有效。  </p><ul><li>若传入的参数值（新值）比运行时系统为此设定的硬性上限值（256）大，前者会被后者替代。</li><li>新值不是正整数，或者与存储在运行时系统中的P最大数量值（旧值）相同，该函数或略此变更直接返回旧值。<blockquote><p>底层待完善，见《Go 并发编程实战 第二版》</p></blockquote></li></ul><h2 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h2><h3 id="1-g0和m0"><a href="#1-g0和m0" class="headerlink" title="1.g0和m0"></a>1.g0和m0</h3><p>运行时系统中的每个M都拥有一个特殊的G，称为M的g0。M的g0管辖的内存称为M的调度栈，对应于操作系统为相应线程创建的栈。M的调度栈也成为OS线程栈或系统栈（参runtime.systemstack函数）。</p><p>M的g0由Go运行时系统在初始化M时创建并分配给M的，一般用于执行调度、垃圾回收、栈管理等方面的工作。M还有一个专用于处理信号的G，称为<code>gsignal</code>。它的栈称为信号栈。系统栈和信号栈不会自动增长，但一定会有足够的空间执行代码。</p><p>除g0，其他由M运行的G都可以视为用户级别G，称为用户G，g0和gsignal称为系统G。g0不会被阻塞，不包含在任何G队列或列表中。栈不会在垃圾回收中被扫描。</p><p>除每个M都有属于自己的g0外，还存在一个runtime.g0。runtime.g0用于执行引导程序，运行在Go程序拥有的<code>第一个内核线程</code>中，该内核线程称为runtime.m0。runtime.m0和runtime.g0都是静态分配的，引导程序无需为它们分配内存。</p><h3 id="2-调度器锁和原子操作"><a href="#2-调度器锁和原子操作" class="headerlink" title="2.调度器锁和原子操作"></a>2.调度器锁和原子操作</h3><p>并发调度时，调度器会在读写一些全局变量以及它的字段的时候动用调度器锁进行保护。</p><p>Go运行时系统在一些需要保证并发安全的变量的存取上使用原子操作。原子操作比锁操作可以有效的节约系统资源和提升系统性能。</p><h3 id="3-调整GC"><a href="#3-调整GC" class="headerlink" title="3.调整GC"></a>3.调整GC</h3><p>目前的GC基于CMS（Concurrent Mark-Sweep，并发标记-清扫）算法，时非分代的和非压缩的。</p><p>目前的GC有3种执行模式：  </p><ul><li>gcBackgroundMode，并发地执行垃圾收集和清扫；</li><li>gcFroceMode，串行地值执行垃圾收集（即执行时停止调度），但并发地执行清扫。</li><li>gcFroceBlockMode，串行地执行垃圾收集和清扫。</li></ul><p>调度器驱使的自动GC和系统监测任务中的强制GC，都会以gcBackgroundMode模式执行。前者会检查Go程序当前的内存使用量，仅当使用量过大时才真正执行GC，后者无视此条件。</p><p>可以通过GODEBUG控制自动GC的并发性，使其值包含gcstoptheworld=1或gcstoptheworld=2，让GC的执行模式由gcBackgroundMode变为gcForceMode或gcForceBlockMode。相当于让并发的GC进入调试模式。</p><p>GC会在为Go程序分配的内存翻倍增长时被触发。Go运行时系统会在分配新内存时检查Go程序的内存使用增量。可以通过调用runtime/debug.SetGCPercent函数改变这个增量的阀值，该函数接受一个int类型的参数：在新分配的内存是上次记录的已分配的内存的百分之几时触发GC。若为负数会导致自动GC的关闭；预设值是100。SetGCPercent函数在被调用后会返回旧的增量阀值。设置环境量变量GOGC亦可，含义规则与SetGCPercent一致。将其值设置为off会关闭自动GC。对GOGC的设置需要在Go程序启动之前进行，否则不生效。</p><p>关闭自动GC意味着需要在程序中手动GC，调用runtime.GC函数可以手动触发一次GC，该函数会阻塞调用方直到GC完成。这种情况下的GC会以gcForceBlockMode模式执行。调用runtime/debug包的FreeOSMemory函数也会手动触发一次完全串行的GC，并且在GC完成之后还会做一次清除堆的操作。两者在执行时都不会检查Go程序的内存使用增量。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git使用中发生的一些莫名错误</title>
      <link href="/2018/04/27/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E9%94%99%E8%AF%AF/"/>
      <url>/2018/04/27/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%8E%AB%E5%90%8D%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<h3 id="git-push报错-Tags-index-master"><a href="#git-push报错-Tags-index-master" class="headerlink" title="git push报错 Tags:[index,master]"></a>git push报错 Tags:[index,master]</h3><p>背景：<code>git add</code>和<code>git commit</code>后未及时<code>git push</code>，第二天<code>git push</code>报错。<br>错误详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: index file smaller than expected</span><br><span class="line">fatal: index file smaller than expected</span><br><span class="line">error: unable to resolve reference refs/remotes/origin/master: ??</span><br><span class="line">error: Cannot lock the ref &apos;refs/remotes/origin/master&apos;.</span><br></pre></td></tr></table></figure></p><p>解决方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm .git/index</span><br><span class="line">rm .git/refs/remotes/origin/master</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>原因：查询stackoverflow得上方解决结果，直接删除相应的报错文件，然后再重新将改变的工作提交到仓库中，最后再推倒远程仓库。可能原因猜测index文件和master文件被污染，不知具体原因。</p>]]></content>
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-多线程编程理论</title>
      <link href="/2018/04/25/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/25/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>Linux操作系统提供以POSIX（Portable Operating System Interface of Unix）标准中定义的线程为中心的各种系统调用，最贴近POSIX线程标准的线程实现称为NPTL（Native POSIX Threads Library），已成为Linux默认的线程实现。</p><p>Go语言的并发编程模型在底层是由操作系统所提供的线程库支撑的。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个线程可以被看作是在某个进程中的一个控制流。一个进程至少包含一个线程，进程的第一个线程随着进程的启动被创建，被称为该进程的主线程。一个进程的其他线程由当前进程中已存在的线程所执行相应的系统调用（pthread_create函数）创建，拥有多个线程的进程可以并发的执行多个任务，并且即使某个或某些任务被阻塞也不会影响到其他任务的正常执行。可以改善程序的响应时间和吞吐量。一个线程必属于某一个进程，生命周期不可逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己的线程栈，存储自己的私有数据。线程栈被包含在操作系统内核分配给其所属进程的虚拟内存地址中。一个进程中的很多资源会被其中的所有资源共享，共享资源包括在当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数，以及当前进程所持有的文件描述符等。</p><p>操作系统内核提供若干个系统调用以使应用程序能够管理当前进程中的所有线程，应用程序可以通过相应的系统功能协调这些线程的运行。系统功能由一些同步原语代表。</p><h3 id="1-线程的标识"><a href="#1-线程的标识" class="headerlink" title="1.线程的标识"></a>1.线程的标识</h3><p>同进程一样，每个线程也都有属于它自己的ID，称为线程ID或TID。线程ID在系统范围内可以不是唯一的，在其所属进程的范围内必须是唯一的。Linux操作系统的线程实现确保每个线程在系统范围内的唯一性。线程不复存在后，其线程ID可被其他线程复用。</p><p>线程的ID由操作系统内核分配。应用程序无需关注。在调试时，线程ID帮助区别不同的线程。</p><h3 id="2-线程间的控制"><a href="#2-线程间的控制" class="headerlink" title="2.线程间的控制"></a>2.线程间的控制</h3><p>同一个进程中的任意两个线程的关系都是平等的，不存在层级关系。任何线程都可以对其所属的进程中的其他线程进行有限的管理。主要有：  </p><ul><li>创建线程：主线程在其所属进程启动的时候被创建，此处针对其他线程的创建。任何线程都可以通过调用系统调用<code>pthread_create</code>来创建新的线程。创建线程时，调用线程需要给定新线程将要执行的函数以及传入该函数的参数值。代表该函数的参数被命名为start，通常称start函数。start函数可有返回值。在其他线程中通过与新线程的连接得到在该新线程中执行的start函数的返回值，若新线程创建成功，调用线程得到新线程的ID。</li><li>终止线程：线程可以通过多种方式终止其所属进程的其他线程。例如调用系统调用<code>pthread_cancel</code>。<code>pthread_cancel</code>函数取消给定的线程ID代表的线程。它会向目标线程发出一个请求，要求它立即终止执行。该函数只是发送请求并立即返回，不会等待目标线程对该请求做出响应。至于目标线程什么时候对此请求做出响应、做出怎样的响应，则取决于另外的因素（目标线程的取消状态即类型）。默认情况，目标线程总是会接收线程取消请求，等到时机成熟（执行到某个取消点）的时候目标线程才会去响应线程取消请求。</li><li>连接已终结的线程：由系统调用pthread_join代表。该函数会一直等待（阻塞）与给定的线程ID对应的线程的终止，并把该线程执行的start函数的返回值告知给调用线程。如果目标线程已经处于终止状态，该函数会立即返回。类似把调用线程放置在目标线程后面，当目标线程把流程控制权交出后，调用线程接过流程控制权并继续执行pthread_join函数调用之后的代码。如果一个线程是可被连接的，终止之时必须被连接，否则会变成一个僵尸线程。僵尸线程导致系统资源的浪费，使所属进程的可创建线程数量被无意义减少。</li><li>分离线程：将一个线程分离，意味着它不再是一个可被连接的线程。默认情况下，一个线程总是可以被其他线程连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自动进行清理和销毁工作。分离操作是不可逆的，无法使一个不可连接的线程变回到可被连接的状态。但是对于一个已处于分离状态的线程执行终止操作仍然会起作用。分离操作由系统调用pthread_detach代表，接受一个代表了线程ID的参数值。</li></ul><p>一个线程对自身也可以进行两种控制：终止和分离。线程终止自身的方式有很多种，在线程执行的start函数中执行return语句会使该i线程随着start函数的执行结束而终止。在主线程中执行了return语句，当前进程中的所有线程都会被终止。在任意线程中调用系统调用exit也会达到一样效果。另一种显示地调用系统调用pthread_exit。在主线程中调用pthread_exit函数，只有主线程自己会被终止，其他线程仍然会正常运行。线程分离自身与分离其他线程的方式一致，调用pthread_detach函数。区别在于调用线程传递给该函数的线程ID是自己的ID还是其他线程的ID。</p><h3 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3.线程的状态"></a>3.线程的状态</h3><p>线程只是进程的一个控制流，对进程的状态描述几乎都适用于线程。</p><p>线程在被创建出来之后会进入就绪状态，处于就绪状态的线程会等待被运行的时机。</p><p>一旦该线程被真正地运行，就会由就绪状态转换至运行状态。正在运行的线程可能会由于某些原因（等待未完成的I/O操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量）被阻塞，进而由运行状体转换至睡眠状态。当阻塞线程等待的事件或条件发生或满足时，线程被唤醒。从睡眠状态转出，先进入就绪状态等待运行时机。若CPU处于空闲状态则会立即运行。处于运行状态的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待下一个运行时机。操作系统内核的调度器会按照一定的算法和策略使线程在这三个状态之间状态之间转换。线程在其生命周期的大部分时间里都会处于就绪状态、运行状态或睡眠状态之中。</p><p>在当前线程自我终结或者其他线程向当前线程发出取消请求且取消时机已到之后，当前线程就会试图进入终止状态。若当前线程之前没有被分离，且此时没有其他线程与它连接，则当前线程进入僵尸状态而非终止状态。当且仅当有其他线程与之连接之后，当前进程才会从僵尸状态转换至终止状态。处于终止状态的线程才会被操作系统内核回收。在任意线程中调用exit函数以及在主线程中执行return语句，都不但会使其所属进程中的所有线程立即终止，还会结束该进程的运行，无论当前线程是否被分离。</p><h3 id="4-线程的调度"><a href="#4-线程的调度" class="headerlink" title="4.线程的调度"></a>4.线程的调度</h3><p>调度器的实时调度和切换，产生众多线程并行运行的现象。调度器把时间划分成极小的时间片并把这些时间片分配给不同的线程，以使众多线程都能有机会在CPU上运行。</p><p>线程的执行总是趋向于CPU受限或I/O受限。即线程要么需要花费一定的时间使用CPU进行计算，要么花费一些时间等待相对较慢的I/O操作的完成。一个线程的趋向性并不总是清晰的，调度器往往需要猜测它们，依据对线程的趋向性的猜测把它们进行分类，并让I/O受限的线程具有更高的动态优先级以优先使用CPU。因为I/O操作往往花费很长的时间，应让其尽早地开始执行</p><p>线程的动态优先级可以被调度器实时调整，线程的静态优先级只能由程序指定。若程序没有显示的指定一个线程的静态优先级，则将被设定为0。调度器不会改变线程的静态优先级。线程的动态优先级是调度器根据其静态优先级调整得出。线程的静态优先级决定线程单次能够在CPU上运行的最长时间，即调度器分配给它的时间片的大小。</p><p>所有等待CPU的线程会被按照动态优先级从高到低的顺序排入到与该CPU对应的运行队列中。下一个被运行的线程总是动态优先级最高的一个。每一个CPU的运行队列中都包含两个优先级阵列，其中的一个用于存放正在等待运行的线程（激活的优先级阵列），另一个用于存放已经运行过但还未完成的线程（过期的优先级阵列）。优先级阵列是一个由若干个链表组成的数组。一个链表只会包含具有相同优先级的线程，一个线程也只会被放到与它的优先级相对应的哪一个链表中。当一个线程被放入某个优先级阵列的时候，实际上是被放入与它的优先级相对应的那个链表的末尾处。</p><p>下一个被运行的线程总是会从激活的优先级阵列中选出。若调度器发现某个线程已经占用了CPU很长时间（小于或等于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器会让等待的线程在CPU上运行。被换下来线程被排入过期的优先级阵列。当激活的优先级阵列中没有待运行的线程的时候，调度器会把这两个优先级阵列的身份互换，即之前的激活的优先级阵列称为新的过期的优先级阵列，之前的过期的优先级阵列成为新的激活的优先级阵列。被放入过期的优先级阵列的线程就又有机会被运行了。</p><p>线程被阻塞进入睡眠状态会从运行队列中被移除，不能够被调度和运行。睡眠状态分为可中断的睡眠状态和不可中断的睡眠状态，同多进程篇释意。</p><p>线程因等待某个事件或条件的发生而被加入到对应的等待队列中，并随即进入睡眠状态。当事件或条件发生时，内核通知对应的等待队列中的所有线程，线程被唤醒从等待队列转移至适当的运行队列中。调度器会稍稍调高被唤醒的线程动态优先级，使这类线程能够更早地被运行。</p><p>若计算机上有多个CPU，平衡它们之间的负载也是调度器的工作。调度器尽量使一个线程在一个特定的CPU上运行。有利于维护高速缓存的高命中率以及高效使用就进的内存。内核会为每个CPU都建立一个运行队列，每个队列中都保存对应CPU的负载系数。调度器根据这一系数了解并调整各个CPU的负载（还有其他因素），把在较忙碌的CPU上运行的线程迁移至其他较空闲的CPU上运行。</p><p>操作系统内核的调度器使用若干策略对众多线程在CPU上的运行进行干涉，使得操作系统中的各个任务都能够有条不紊地进行，同时兼顾效率和公平性。通过协调各个线程的状态达到调度的目的。</p><h3 id="5-线程实现模型"><a href="#5-线程实现模型" class="headerlink" title="5.线程实现模型"></a>5.线程实现模型</h3><p>线程的实现模型主要有3个：用户级线程模型、内核级线程模型和两级线程模型。差异于线程与内核调度实体（Kernel Scheduling Entity,简称KSE）之间的对应关系上。内核调度实体是可以被内核的调度器调度的对象。也被称为内核级线程，是操作系统内核的最小调度单元。  </p><ul><li>用户级线程模型：由用户级别的线程库全权管理。线程库并不是内核的一部分，只被存储在进程的用户空间之中。进程中的线程的存在对于内核来说是无法感知的，不是内核调度器的调度对象。对线程的各种管理和协调是用户级程序的自主行为，与内核无关。应用程序在对线程进行创建、终止、切换或同步等操作的时候，并不需要让CPU从用户态切换到内核态。用户线程模型在线程操作的速度上存在优势，对线程的管理不需要内核参入，程序的移植性更强。在此模型下的多线程不能够被真正地并发运行。当线程在I/O操作过程中被阻塞，其所属进程也会被阻塞，由线程无法被内核调度造成。调度器将进程看作一个无法再被分割的调度单元，无论其中存在多少个线程。即使计算机上存在多个CPU进程中的多个CPU也无法被分配给不同的CPU运行。对于CPU的负载均衡来说，进程的粒度太粗，让不同的进程在不同的CPU上运行的意义微乎其微。线程的优先级页形同虚设。同一个进程中的所有线程的优先级只能由该进程的优先级来体现。线程库对线程的调度不受内核控制，与内核为进程设定的优先级是没有关系的。现代操作系统都不是使用这种模型来实现线程的。由于包含了多个用户级线程的进程只与一个KSE相对应，这种线程实现模式也被称为多对一（M：1）的线程实现。</li><li>内核级线程模型：该模型下的线程由内核负责管理。是内核的一部分，应用程序对线程的创建、终止和同步都必须通过内核提供的系统调用来完成，进程中的每一个线程都与一个KSE相对应。内核可以分别对每一个线程进行调度。内核级线程模型又被称为一对一（1：1）的线程实现。线程完全由内核管理和调度，可以真正实现线程的并发运行。这些线程完全由内核来管理和调度，内核在极短的时间快速切换和运行各个线程使得它们看起来像正在被同时运行。即使进程中的一个线程由于某种原因进入到了阻塞状态，其他线程也不会受到影响并可以正常的运行。使得内核在多个CPU上进行负载平衡变得容易和有效。如果一个线程与被阻塞的线程之间存在同步关系，则可能受到影响。这是一种应用级别的干预，不属于线程本身的特质。内核对线程的全权接管使操作系统在库级别几乎无需为线程管理做什么事情。与用户级别线程模型形成鲜明的对比。内核线程的管理成本比用户级别线程高出很多。线程的创建会使用到内核资源。创建线程、切换线程、同步线程等操作所花费的时间也会更多。如果一个进程包含了大量的线程，会给内核的调度器造成非常大的负担，会影响到操作系统的整体性能。<code>采用内核级线程模型的操作系统对一个进程中可以创建的线程的数量有直接或间接的限制</code>。很多现代操作系统都是以内核级线程模型实现线程的，包括Linux操作系统。</li><li>两级线程模型：两极线程模型的目标是取前两种模型的精华，去二者只糟粕。被称为多对多（M：N）的线程实现。在此模型下，一个进程可以与多个KSE相关联。这与内核级线程模型是相似的。不同的是，进程中的线程（应用程序线程）并不与KSE一一对应。应用程序线程可以被映射到同一个已关联的KSL上。已被加载到进程的虚拟内存中的实现两级线程模型的线程库会通过操作系统内核创建多个内核级线程。然后，通过这些内核级线程对应用程序线程进行调度。大多数此类线程库都可以为实际运行运行的应用程序线程动态地分配若干个内核级线程。使线程的管理工作更加复杂，需要内核和线程库的共同努力和协作才能正确、有效地进行。但是内核资源的消耗得以减少，使线程管理操作的效能提高。因实现的复杂性，往往不会被操作系统内核的开发者采纳。但可以很好地在编程语言层面上实现并发挥出其应有的作用。<code>Go的并发编程模型与两级线程模型在理念上相似</code>，具体实现方式更加高级优雅些。<code>Go的并发编程模型中</code>，不受操作系统内核管理的独立控制流并不被叫作应用程序线程或者线程，而被称为Goroutine(也可称为Go程)。</li></ul><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>同步，永远是多线程编程中最核心和重要的话题之一。为多个线程更好地协同工作或者维持共享数据的一致性，以后者为目的的同步比较常见。</p><h3 id="1-共享数据的一致性"><a href="#1-共享数据的一致性" class="headerlink" title="1.共享数据的一致性"></a>1.共享数据的一致性</h3><p>包含多个线程的程序（多线程程序）多以共享数据作为在线程之间传递数据的手段。一个进程所拥有的相当一部分虚拟内存地址都可以被该进程中的所有线程所共享，这些被共享的数据大多以内存空间作为载体。共享数据的一致性代表着某种约定，在该约定成立的前提下，多线程程序中的各个线程才能够使相应的流程被正确地执行。</p><p>临界区是只能被串行化地访问或执行的某个资源或某段代码。亦被称作串行区域。保证临界区有效的最佳方式是利用同步机制，针对多线程的同步机制有：原子操作、互斥量、条件变量。</p><h3 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h3><p>在同一时刻只允许一个线程处于临界区之内的约束被称为互斥。每一线程在进入临界区之前都必须先锁定某个对象。只有成功锁定对象的线程才会被允许进入到临界区之内，否则就会被阻塞。这个对象被称为互斥对象或互斥量。</p><p>互斥量有两种可能的状态，锁定状态和未锁定状态。每次只能被锁定一次，任何线程都不能对它进行二次加锁。成功锁定互斥量的线程成为该互斥量的所有者，只有互斥量所有者才能对该互斥量进行解锁。锁定即对互斥量的获取，解锁即对互斥量的释放。</p><p>为合理、安全使用共享数据，应把操作同一个共享数据的代码都置于一个或多个临界区之内，并使用一个互斥量对它们进行保护。互斥量必须能够被使用相应的共享资源的线程访问到，因此互斥量的变量或常量一般不是局部的。为尽量少的暴露程序的实现细节，应该在满足要求的前提下最小化互斥量的访问权限。初始化互斥量应该在任何线程真正使用它之前进行。若多个线程将要执行的代码中都包含了对同一个互斥量的初始化操作，必须保证该互斥量只会被初始化一次。互斥量对每个想要锁定它的线程都是平等的。</p><blockquote><p>对互斥量的初始化必须要保证唯一性，线程在离开临界区时候必须要及时解锁互斥量，以免造成不必要的性能损耗甚至死锁。</p></blockquote><p>在一般情况下，应该尽量少地使用互斥量。每个互斥量保护的临界区应该在合理范围内并尽量地大。若多个线程频繁地进入某个较大的临界区，并且之间经常存在访问冲突，应该把这个较大的临界区切分成若干个较小的临界区，并使用不同的互斥量加以保护。目的是让等待进入同一个临界区的线程数变少，降低线程被阻塞的几率，减少处于睡眠状态的时间。从一定程度上提高程序的整体性能。若切分后不同的互斥量保护的临界区中包含了对同一个共享资源的同一种操作，则临界区的切分是不成功的。尽量不要让不同的互斥量所保护的临界区重叠，会增加<code>死锁</code>发生的几率。</p><p>当进程中的所有线程发生死锁，进程会停滞，只能重新启动，会丢失运行时数据甚至造成各种不一致的状态。</p><p>使用操作系统提供的线程库的功能，<code>试锁定和回退</code>：在执行一个代码块的时候需要先后锁定两个互斥量，在锁定其中一个互斥量成功之后使用<code>试锁定</code>的方法锁定另一个互斥量，若<code>试锁定</code>第二个互斥量不成功，就把第一个互斥量解锁，并重新对这两个互斥量进行锁定和<code>试锁定</code>。若需要需定的互斥量有多个，则总是先锁定其中一个，再按照上述流程<code>试锁定</code>其他互斥量并在必要时进行回退。<code>试锁定</code>指操作系统的线程库提供的一个函数，会尝试对一个互斥量进行锁定，锁定失败函数直接返回一个错误码，而不是阻塞在那里。</p><p><code>固定顺序锁定</code>：需要先后对多个对个互斥量进行锁定的场景下，总以固定不变的顺序锁定它们。避免因多个线程先后对多个互斥量锁定顺序不一致，导致互相等待对方释放锁并占用对方所需而造成的死锁。</p><p>互斥量的实现会使用到机器语言级别的原子操作，并仅在锁定冲突时才会涉及系统调用的执行。互斥量比其他同步方法（例如信号灯）的速度快。</p><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><p>条件变量不保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据状态发生发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥量组合使用，互斥量为共享数据的访问提供互斥支持，条件变量可以就共享数据的状态的变化向相关线程发出通知。当线程成功锁定互斥量从而访问到共享数据的时候，共享数据的状态并不一定正好满足它的要求。</p><p>条件变量在使用之前必须创建和初始化，初始化必须要保证唯一性，在被真正使用前必须要与某个互斥量进行绑定。在一个条件变量之上进行的操作有3种：  </p><ul><li>等待通知（wait）：阻塞当前线程，直至收到该条件变量发来的通知。</li><li>单发通知（signal）：让该条件变量向至少一个正在等待它的通知的线程发送通知，以表示某个共享数据的状态已经被改变。</li><li>广播通知（broadcast）：让条件变量给正在等待它的通知的所有线程都发通知，以表示某个共享数据的状态已经改变。</li></ul><p>等待通知会先解锁与该条件变量绑定在一起的互斥量，然后再使当前线程阻塞。只有在当前的共享数据的状态不满足条件时，才执行等待通知操作，检查共享数据的状态需要受到互斥量的保护，即检查共享数据状态的操作和等待通知操作都需要再相应的临界区内进行。等待通知操作所包含的解锁互斥量的操作和阻塞当前线程的操作共同形成一个原子操作。</p><p>等待通知操作因收到条件变量发送的通知而唤醒当前线程之后，会首先重新锁定与该条件变量绑定在一起的互斥量，若互斥量已经被其他线程抢先锁定，则当前线程再次进入睡眠状态。</p><p>条件变量的通知具有即时性，通知只是负责向等待线程发送一个信号以告知共享数据的状态发生了某种变化，而不会存储相关信息。在通知被发送的时候，若没有任何线程正在等待此条件变量的通知，该通知就会被无视，不会被传到在它被发送之后才开始等待它的线程。在互斥量的保护下执行单发通知操作通常会更加安全。</p><p>广播通知的发送线程无法得知有哪些线程正在等待共享数据的当前状态，不会知道在执行单发通知操作之后哪一个线程会接收到该通知，发送线程只执行广播通知操作以向所有的等待线程告知共享数据的状态已发生变化，不会关心哪些等待线程会对这一状态变化进行应答。等待线程被唤醒后会重新检查共享数据的状态，并自行决定是对此作出响应还是等待下一个通知。</p><h3 id="4-线程的安全性"><a href="#4-线程的安全性" class="headerlink" title="4.线程的安全性"></a>4.线程的安全性</h3><p>若一个代码块可以被多个线程并发地执行，并总能够产生预期的结果，则该代码块就是线程安全的（thread-safe）。例如若代码块中包含了对共享数据的更新操作，则此代码块就是非线程安全的。若该代码块中的类似操作都处于临界区之中，则此代码块是线程安全的。</p><p>常被置于线程安全问题之中的代码块是函数。函数是最常用的代码块，其线程安全性有着更多的含义。使函数具有安全性的最有效的方式是使其可重入（reentrant）。若某个进程中的所有线程都可以并发地对一个函数进行调用，并且无论它们调用该函数的实际执行情况怎样，该函数都可以产生预期的结果，则该函数是可重入的。即若多个线程并发的调用该函数与它们以任意的顺序依次地调用它所产生的效果总是相同的，则该函数的可重入的。</p><p>若一个函数把共享数据的值作为其返回的结果或者包含于其返回的结果中，则该函数不是可重入函数。为使函数可重入，杜绝在函数的返回结果中含有任何共享数据，除非共享数据是完全不可被更新的。任何内含了对共享数据进行操作的代码的函数都可以被视为不可重入函数。</p><p>为实现线程安全的函数，可将代码置于临界区之中，但低效。应从函数体中找出操作共享数据的代码并用互斥量把它门保护起来。更好的方式是将这些代码从函数体中分离出来，有利于施加保护措施。</p><p>若代码块中仅包含共享数据的访问操作而不包含对他们的更新操作，则代码块内可以不使用互斥量。但线程需要自己维护一份其需要使用道德共享数据的副本，线程会在使用共享数据之前就把它们完全复制到当前线程的线程栈之中。对于函数，副本作为其局部变量存在。某个线程对某个函数的第一次调用会致使该i函数中的局部变量陆续被创建在该线程的线程栈中。在不同线程的线程栈中，因调用相同的函数而被创建的同名局部变量之间是完全独立的，并且不会相互干扰。一般这样的函数是可重入的，即线程安全的。</p><h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><p>多线程在系统资源的利用和程序性能的提高方面具有优势，在某些情况（信号的处理、同时运行多套不同的程序以及包含多个需要超大内存支持的任务等），多进程编程更加合适。</p><h2 id="多核时代的并发编程"><a href="#多核时代的并发编程" class="headerlink" title="多核时代的并发编程"></a>多核时代的并发编程</h2><p>并发运行是指多个任务被同时发起运行，但是在同一时刻这些任务不一定都处于运行状态，取决于CPU核心或者CPU的数量。并行运行指在同一时刻可以有多个任务真正地同时运行，并行运行的必要条件是多CPU核心或多CPU的计算环境。并行运行的一个必要条件就是并发运行，是并发运行的一个更高级的层次。</p><p>提高并行程序的性能：  </p><ul><li>控制临界区的纯度。</li><li>控制临界区的粒度。</li><li>减少临界区中代码的执行耗时。</li><li>避免长时间持有互斥量。</li><li>优先使用原子操作而不是互斥量。</li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-多进程编程理论</title>
      <link href="/2018/04/24/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/24/Golang%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>进程间的通讯常被称为IPC（Interprocess Communication）。Linux操作系统中分为基于通讯的IPC方法、基于信号的IPC方法以及基于同步的IPC方法。  基于通讯的IPC方法又分为以数据传送为手段的IPC方法和以共享内存为手段的IPC方法。  </p><ul><li>数据传送：管道（用以被传送子节流），消息队列（用以被传送结构化的消息对象）。</li><li>共享内存：共享内存区，最快的一种IPC方法。</li><li>基于信号：信号（signal）机制。</li><li>基于同步：信号灯（semaphore）。</li></ul><p>Go语言支持的IPC方法：管道、信号和Socket。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>用于描述程序的执行过程，程序与进程形成一对相依的概念，分别描述一个程序的静态形式和动态特征。进程是操作系统进行资源分配的一个基本单位。</p><h4 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h4><p>一个进程可以使用系统调用fork创建若干个新的进程，前者被称为后者的父进程，后者被称为前者的子进程。</p><blockquote><p>子进程源自它的父进程的一个副本，获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。每一份副本都是独立的，子进程对属于它的副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。</p></blockquote><p>Linux的操作内核使用写时复制（Copy On  Write，简称COW）等技术提高进程创建的效率。被创建的子进程可以通过系统调用exec把一个新的程序加载到自己的内存中，替换掉原先在其内存中的数据段、堆、栈以及代码段，之后子进程执行被加载进来的程序。</p><p>内核启动进程作为进程树的根负责系统的初始化操作，是所有进程的祖先，其父进程是其自己。若一个进程先于它的子进程结束，那么这些子进程将会被内核启动进程“收养”，成为它的直接子进程。</p><h4 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h4><p>为了进程管理，内核必须对每个进程的属性和行为进行详细的记录，包括优先级、状态、虚拟地址范围以及各种访问权限等等，被记录在每个进程的进程描述符中。</p><p>进程描述符是一个复杂的数据结构，被保存在进程描述符中的进程ID（常被称为PID）是进程在操作系统中的唯一标识。进程ID为1的进程是内核启动进程。进程ID是一个非负整数且总是递增的编号，新创建的进程的ID是前一个被创建的进程的ID递增的结果。进程ID可以被重复使用。当进程ID达到最大限值，内核从头开始查找已被闲置的进程ID并使用最先找到的哪一个作为新进程的ID。进程描述符中还包含当前进程的父进程ID（常被称为PPID）。</p><p>Go中使用标准库代码包os提供的API来查看当前进程的PID和PPPID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid := os.Getpid()</span><br><span class="line">ppid := os.Getppid()</span><br></pre></td></tr></table></figure></p><p>PID不传达与进程有关的任何信息，仅是一个用来唯一标识进程的数字。进程属性信息只被包含在内核中的、与PID对应的进程描述符中。PPID也是，可用于查找守护进程的踪迹。</p><p>进程ID对内核以外的程序非常有用，可以高效地把进程ID转换成对应进程的描述符。可以用shell命令kill终止某个进程ID所对应的进程，可以通过进程ID找到对应的进程并向它发送信号。</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>可运行状态、可中断的睡眠状体、不可中断的睡眠状体、暂停状态或跟踪状态、僵尸状态和退出状态。   </p><ul><li>可运行状态：（TASK_RUNNING，简称R）：处在该状态的进程将要、立即或正在CPU上运行。运行时机不确定由进程调度器来决定。</li><li>可中断的睡眠状态（TASK_INTERRUPTIBLE，简称S）：当进程正在等待某个事件（网络连接或信号灯）的发生时会进入此状体。会被放入对应事件的等待队列中，事件发生时，一个或多个进程就会被唤醒。</li><li>不可中断睡眠状态（TASK_UNINTERRUPTIBLE，简称D）:与可中断的睡眠状态的唯一区别是不可被打断，意味着处在此种状态的进程不会对任何信号作出响应。发送给处于此状态中进程的信号直到该进程转出该状态才会被传递过去。处于此状体的进程通常是由于在等待一个特殊的事件。例如等待同步的I/O操作（磁盘I/O等）的完成。</li><li>暂停状态或跟踪状态（TASK_STOPPED或TASK_TRACED，简称T）：向进程发送SIGSTOP信号就会使该进程处于暂停状态，除非该进程正处于不可中断的睡眠状态。向处于暂停状态的进程发动SIGCONT信号会使进程转向可运形状体。处于被跟踪状态的进程会暂停并等待跟踪它的进程对它进行操作。跟踪状态与暂停状态非常相似，但是，向处于跟踪状态的进程发送SIGCONT信号并不能使它被恢复。只有当调试进程进行了相应的系统调用或退出之后，它才能够被恢复。</li><li>僵尸进程（TASK_DEAD-EXIT_ZOMBIE，简称Z）：处于此状态的进程即将要结束。该进程占用的绝大多数资源也都已经被回收。还有一些信息还未被删除，例如退出码以及一些统计信息。保留这些信息考虑到该进程的父进程可能需要它们。由于此时的进程主体已经被删除而只留下了一个空壳，故此状态常被称为僵尸状态。</li><li>退出状态（TASK_DAED-EXIT_DEAD，简称X）：在进程退出过程中，有可能连退出码和统计信息都不需要被保留。造成原因可能是显示地让该进程的父进程忽略掉SIGCHLD信号（当一个进程消亡的时候，内核会给其父进程发送一个SIGCHLD信号以告之），也可能是该进程已经被分离（让子进程和父进程分别独立的运行）。分离后的子进程将不会再使用和执行父进程共享的代码段中的指令，而是加载并运行一个全新的程序。在此情况下，改进程在退出的时候就不会转入僵尸状态，而会直接转入退出状态。处于退出状态的进程会被结束掉，所占用的系统资源会被操作系统自动回收。</li></ul><p>进程的状态只会在可运行状态和非可运行状态之间转换。</p><h4 id="进程的空间"><a href="#进程的空间" class="headerlink" title="进程的空间"></a>进程的空间</h4><p>一个用户进程（程序的执行实例）总会生存于用户空间中，这些进程可以做很多事，但是却不能与其所在的计算机的硬件进行交互。内核可以与硬件交互，但是却生存在内核空间中。用户进程无法直接访问内核空间。用户空间和内核空间体现了Linux操作系统对物理内存的划分。即这两个空间指的都是操作系统在内存上划分出的一个范围，共同瓜分操作系统能够支配的内存区域。</p><p>内存空间中的每一个单元都是有地址的，由指针来标识和定位。这里所指的地址并非物理内存中的真实地址，被称为虚拟地址。由虚拟地址来标识的内存区域又被称为虚拟地址空间，或虚拟内存。虚拟内存的最大容量与实际可用的物理内存的大小是无关的。内核和CPU会负责维护虚拟内存与物理内存之间的映射关系。</p><p>内核为每个用户进程分配的是虚拟内存而不是物理内存，每个用户进程被分配到的虚拟内存总是在用户空间中的，而内核空间被留给内核专用。每个用户进程都会认为分配给它的虚拟内存就是整个用户空间。一个用户进程不可能操纵另一个用户进程的虚拟内存，因为后者的虚拟内存对于前者来说是不可见的。即进程间的虚拟内存几乎是彼此独立、互不干扰的。由于它们基本被映射到了不同的物理内存之上。</p><p>内核把进程的虚拟内存划分为若干页（page）。物理内存单元的划分由CPU负责。一个物理内存单元被称为一个页框（page frame）。不同进程的大多数页都会与不同的页框相对应。</p><p>进程之间共享页框是被允许的，是作为IPC方法之一的共享内存区的基础。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>内核会暴露一些接口给用户进程，使用户进程能够使用操作系统更底层的功能，是用户进程能够使用内核功能（包括操纵计算机硬件）的唯一手段。用户进程使用这些接口的行为被称为系统调用，有时“系统调用”也指内核提供了这些接口。系统调用是向内核空间发出的一个明确的请求，而普通的函数只是定义了如何获取一个给定的服务。系统调用会导致内核空间中的数据的存取和指令的执行，而普通函数只能在用户空间中进行操作。系统调用是内核的一部分。</p><p>为保证操作系统的稳定性和安全，内核依据CPU提供的、可以让进程驻留的特权级别建立了两个特权状态。即内核态和用户态。大部分时间里CPU都处于用户态，这时CPU只能对用户空间进行访问，即CPU在用户态下运行的用户进程不能与内核接触。当用户进程发出一个系统调用时，内核会把CPU从用户态切换到内核态，而后会让CPU执行对应的内核函数。CPU在内核态下由权限访问内核空间。相当于使用户进程通过系统调用使用到了内核提供的功能。当内核函数被执行完毕，内核会把CPU从内核态切换回用户态，并把执行结果返回给用户进程。</p><blockquote><p>只有当CPU被切换至内核态之后才可以执行内核空间中的函数，而在内核函数执行完毕后，CPU状态也会被及时地切换回用户态。</p></blockquote><h4 id="进程的切换和调度"><a href="#进程的切换和调度" class="headerlink" title="进程的切换和调度"></a>进程的切换和调度</h4><p>Linux操作系统通过CPU，可以在多个进程间进行切换（也称为进程间的上下文切换），以产生多个进程在同时运行的假象。每个进程会认为自己独占CPU。在进程切换时，需要保存当前进程的运行时状态，若要执行的另一个进程不是第一次运行则需要将该进程恢复到之前被换下时的运行时状态。进程切换主要是由内核来完成，除了进程切换之外，为了使各个生存着的进程都有被u运行的机会、让它们共享CPU，内核还需考虑把哪一个进程应该作为下一个被运行的进程、应该在哪一时刻进行切换，以及切换下的进程需要在哪一时刻再被换上，等等。解决类似问题的反感和任务被统称为进程调度。</p><p>进程切换和进程调度是程序并发执行的基础。</p><h3 id="关于同步"><a href="#关于同步" class="headerlink" title="关于同步"></a>关于同步</h3><p>当几个进程同时对同一个资源进行访问的时候，可能造成互相的干扰，即竟态条件。造成竟态条件的根本原因在于进程在进行某些操作的时候被中断了。虽然进程再次运行的时候其状态会恢复如初，但是外界环境很可能已经在这极短的时间内改变了。</p><p>我们把执行过程中不能被中断的操作称为原子操作（atomic operation），把只能被串行化的访问或执行的某个资源或某段代码称为临界区（critical section）。原子操作是不能被中断的，临界区对是否可以被中断没有强制的规定。只要保证一个访问者在临界区中的时候其他访问者不被允许进入。所有的系统调用都属于原子操作，执行不会被中断。</p><p>原子操作必须由一个单一的汇编指令代表，并且需要得到芯片级别的支持。原子操作能够做到绝对的并发安全，并且比其他同步机制要快很多。原子操作只适合细粒度的简单操作。Go在CPU和各个操作系统的底层支撑之上提供了对原子操作的支持。由标准库代码包<code>sync/atomic</code>中的一些函数代表。</p><p>让要求被串行执行的若干代码形成临界区的做法更通用，保证只有一个进程或线程在临界区之内的做法是——互斥（mutual exclusion，简称mutex）。实现互斥的方法必须确保排他原则（exclusion principle），并且保证不能依赖于任何计算机硬件（包括CPU）。即互斥方法必须有效且通用。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道（pipe）是一种半双工（单向）通讯方式。只能用于父进程与子进程以及同祖先的子进程之间的通讯。例如shell:</p><blockquote><p><code>ps aux | grep go</code></p></blockquote><p>shell为每个命令都创建一个进程，然后把左边的命令的标准输出用管道与右边的命令的标准输入连接起来。优点简单，缺点只能单向通讯以及通讯双方关系上的严格限制。</p><p>使用标准库代码包os/exec中的API，可以执行操作系统命令并在此之上建立管道。</p><blockquote><p><code>cmd := exec.Command(&quot;echo&quot;,&quot;-n&quot;,&quot;command from golang.&quot;)</code></p></blockquote><p>cmd同操作系统命令</p><blockquote><p><code>echo -n &quot;command from golang&quot;</code></p></blockquote><p>对应。</p><p>可以使用exec.Cmd类型之上的Start方法启动一个操作系统命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := cmd.Start();err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not be startup:%s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用cmd的值的StdoutPipe方法创建一个能够获取此命令输出的管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stdout, err := cmd.StdoutPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdout pipe for command: %s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出管道stdout类型是io.ReadCloser，这是接口类型并扩展了接口类型io.Reader。启动命令之后可以调用stdout的值的Read方法获取命令的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">output := make([]byte,30)</span><br><span class="line">n, err := stdout.Read(output)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;,err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, output[:n])</span><br><span class="line">----</span><br><span class="line">var outputBuf bytes.Buffer  //标准库代码包bytes</span><br><span class="line">for &#123;</span><br><span class="line">    tempOutput := make([]byte, 5)</span><br><span class="line">    n, err := stdout.Read(tempOutput)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        if err == io.EOF &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;,err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if n &gt; 0 &#123;</span><br><span class="line">        outputBuf.Write(tempOutput[:n])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, outputBuf.String())</span><br></pre></td></tr></table></figure></p><p>Read方法把读出的输出数据存入调用方法传递给它的字节切片中并返回一个int类型值和一个error类型值。命令输出小于output的值的长度，n的值代表命令实际输出的字节的数量。否则我们并没有完全读出输出管道中的数据，n的值等于output的值的长度，需要再去读取一次或者多次。若输出管道中没有可读数据，Read方法返回的第二个结果值为变量io.EOF的值，可判断是否被读完。</p><p>使用带缓冲的读取器从输出管道中读取数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">putputBuf := bufio.NewReader(stdout)</span><br><span class="line">output, _, err := outputBuf.ReadLine()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not read data from the pipe: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;,string(output))</span><br></pre></td></tr></table></figure></p><p>stdout的值是io.Reader类型，作为bufio.NewReader函数的参数，返回一个bufio.Reader类型的值。即缓冲读取器。默认缓冲读取器携带一个长度4096的缓冲区，长度代表了一次可以读取的字节的最大数量。cmd代表的命令只有一行输出，使用outputBuf的ReadLine方法读取。第二个bool类型结果代表当前行是否还未被读完，若为false可以利用for语句读取剩余的数据。</p><p>使用Go实现<code>ps aux | grep go</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cmd1 := exec.Command(&quot;ps&quot;, &quot;aux&quot;)</span><br><span class="line">cmd2 := exec.Command(&quot;grep&quot;, &quot;go&quot;)</span><br><span class="line">stdout1, err := cmd1.StdoutPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdout pipe for command: %s&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if err := cmd1.Start(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not running: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">outputBuf1 := bufio.NewReader(stdout1)</span><br><span class="line">stdin2, err := cmd2.StdinPipe()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not obtain the stdin pipe for command: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">outputBuf1.WriteTo(stdin2)</span><br><span class="line">var outputBuf2 bytes.Buffer</span><br><span class="line">cmd2.Stdout = &amp;outputBuf2</span><br><span class="line">if err := cmd2.Start(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: The command can not be startup: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">err = stdin2.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not close the stdio pipe: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if err := cmd2.Wait(); err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Error: Can not wait for the command: %s\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过StdinPipe方法在cmd2之上创建一个输入管道，然后把cmd1连接的输出管道中的数据全部写入到这个输入管道中。返回与该命令连接的输入管道，是io.WriteCloser接口类型类型的值，扩展了io.Writer接口类型，可被作为outputBuf1的WriteTo方法的参数。把所属值中缓冲的数据全部写入到参数值代表的写入器中。等于把第一个命令的输出内容通过管道传递给第二个命令。之后需启动cmd2并关闭与它连接的输入通道。调用cmd2的Wait方法阻塞其所属的命令直到完全运行结束为止，然后再读取outputBuf2的内容。</p><p>以上为<code>匿名管道</code>，对应的是<code>命名管道</code>，任何进程都可以通过命名管道交换数据，以文件的形式存在于文件系统中。linux中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[joker@localhost Test]$ mkfifo -m 644 myfifo</span><br><span class="line">[joker@localhost Test]$ tee dst.log &lt; myfifo &amp;</span><br><span class="line">[1] 13315</span><br><span class="line">[joker@localhost Test]$ cat src.log &gt;myfifo</span><br><span class="line">12345</span><br><span class="line">[1]+  完成                  tee dst.log &lt; myfifo</span><br></pre></td></tr></table></figure></p><p>创建命名管道myfifo，将src.log的内容写道dst.log。命名管道是阻塞式的，只有在对这个命令管道的读操作和写操作都已经准备就绪之后数据才会开始流转。相对于匿名管道，命名管道的通讯双方可以毫不相干，仍是单向的。可以使用它建立非线性的连接实现数据的多路复用，需要考虑多个进程同时向命名管道写数据的情况下的操作原子性问题。</p><p>Go标准库代码包os中包含了可以创建独立管道的API。</p><blockquote><p><code>reader, writer, err := os.Pipe()</code></p></blockquote><p><code>reader</code>代表了该管道输出端的*os.File类型值。  </p><p><code>writer</code>代表了该管道输入端的*os.File类型值。  </p><p>可以在其之上调用*os.File类型包含的所有方法。  </p><p>在Go底层使用系统函数来创建管道，并将两端封装成两的*os.File类型的值。</p><p>命名管道默认在其中一端还未就绪的时候阻塞另一端的进程。不能反过来使用reader或者writer，在reader上调用Write方法或在writer上调用Read方法获取的第二个结果值都将是一个非nil的error类型值。无论在哪一方调用Close方法都不会影响另一方的读取或写入数据的操作。</p><blockquote><p>在exec.Cmd类型值上调用StdinPipe或StdoutPipe方法后得到的输入管道或输出管道也是通过os.Pipe函数生成的。在两个方法内部对生成的管道做了附加处理。输入管道的输出端在所属命令启动后被立即关闭，输入端在所属命令运行结束后被关闭。输出管道的两端的自动关闭时机与输入管道相反。有些命令会等到输入管道被关闭之后才结束运行，需要在数据被读取之后尽早地手动关闭输入管道。</p></blockquote><p>由于通过os.Pipe函数生成的管道在底由系统级别的管道支持，所以在使用时，要注意操作系统对管道的限制。例如匿名管道会在管道缓冲被写满之后使用写数据的进程阻塞，命名管道会在其中一端未就绪前阻塞另一端的进程。</p><p>当有多个输入端同时写入数据时，需要考虑原子性问题。操作系统提供的管道不提供原子操作支持。Go在标准库代码包io中提供一个被存于内存中的、有原子性操作保证的管道（内存管道）。生成方法:  </p><blockquote><p><code>reader, writer := io.Pipe()</code></p></blockquote><p><code>reader</code>代表该管道输出端的*PipeReader类型值。  </p><p><code>writer</code>代表该管道输入端的*PipeWriter类型值。</p><p><em>PipeReader类型和 </em>PipeWriter类型分别对管道的输出端和输入端做了很好的限制。在 <em>PipeReader类型的值上只能使用Read方法从管道中读取数据，在 </em>PipeWriter类型的值上只能使用Write方法向管道写入数据，避免管道使用者对管道的反向使用。使用Close方法关闭管道的某一端之后，另一端在写入数据或者读取数据的时候会得到一个预定义的error类型值。可以通过调用CloseWithError来自定义另一端将会得到的error类型值。</p><p>于os.Pipe函数生成的管道相同的是，仍然需要并发的运行被用来在内存管道的两端进行操作的代码。在内存管道的内部通过充分使用sync代码包中提供的API从根本上保证操作的原子性。这种管道不是基于文件系统，没有作为中介的缓冲区，通过它传递的数据只会被复制一次，提高数据的传递效率。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>操作系统中的信号（Signal）是IPC中唯一一种异步的通讯方法。本质是用软件来模拟硬件的中断机制。被用于通知某个进程有某个事件发生。</p><p>每一个信号都有一个以“SIG”为前缀的名字，在操作系统内部，信号都由正整数代表，称为信号编号，Linux系统可使用<code>kill -l</code>命令查看所支持的信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure></p><p>支持62种信号（没有编号为32和33的信号），编号1-31的信号属于标准信号（不可靠信号），编号34-64的信号属于实时信号（可靠信号）。对于同一个进程，每种标准信号只会被记录并处理一次。若发送给某一进程的标准信号的种类有多个，被处理的顺序是完全不确定的。而多个实时信号都可以被记录，并且按照信号的发送顺序被处理。</p><p>信号的来源有键盘输入、硬件故障、系统函数调用和软件中的非法运算。进程响应信号的方式有3种：忽略、捕捉和执行默认操作。</p><p>Linux操作系统对每一个标准信号都有默认的操作方式，针对不同种类的标准信号，其默认的操作方式一定会是以下操作中的一个：终止进程、忽略该信号、终止进程并保存内存信息、停止进程、恢复停止的进程。对大多数标准信号可以自定义当进程接收到它们之后应该进行怎样的处理。自定义信号响应的唯一方法是：进程告知操作系统内核，当某种信号到来时，需要执行某种操作。在程序中，信号响应的自定义操作常由函数实现。</p><p>Go使用标准库代码包中<code>os/signal</code>中的处理信号的API对<code>标准信号</code>作出响应。指定了需要被处理的信号并用一种方式（使用到通道类型的变量）来监听信号的到来。</p><p>os.Signal接口类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal()//to distinguish from other Stringers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Signal</code>方法的声明无实际意义，作为os.Signal接口类型的一个标识。此接口的所有实现接口的Signal方法都是空方法。</p><p>所有此接口类型的实现类型的值都可以代表一个操作系统信号，每一个操作系统都需要由操作系统所支持。</p><p>标准库代码包syscall中，为不同的操作系统所支持的每一个<code>标准信号</code>都声明一个相应的同名常量(信号常量)，信号常量的类型都是syscall.Signal的，是os.Signal接口类型的一个实现，同时也是int类型的别名类型。意味着每一个信号常量都隐含着一个整数值，信号常量的整数值与其所代表的信号在所属操作系统中的编号一致。在syscall.Signal类型的String方法，有一个包级私有名为signal的数组类型的变量，每个索引值代表了一个<code>标准信号</code>的编号，对应的元素则是针对该信号的一个简短的描述。</p><p>代码包os/signal中的Notify函数用来把操作系统发送给当前进程的指定信号通知给该函数的调用方。</p><blockquote><p><code>func Notify(c chan &lt;- os.Signal, sig ...os.Signal)</code></p></blockquote><p>第一个参数是通道类型，该通道中只能传递os.Signal类型的值（信号值），在signal.Notify中，只能向该通道类型值放入信号值，不能从该值中取出信号值。此函数把当前进程收到的指定信号放入参数c代表的通道类型值（signal接收通道）中，调用方代码可以从signal接收通道中按顺序获取操作系统法送来的信号并进行相应的处理。</p><p>第二个参数是一个可变长参数，在调用signal.Notify函数时，可以在第一个参数值之后附加任意个os.Signal类型的值，sig代表的参数值包含我们希望自行处理的所有信号。接收到希望自行处理的信号之后，os/signal包中的处理程序（signal处理程序）会把它封装成syscall.Signal类型的值并放入到signal接收通道中。只为第一个参数绑定实际值被当作自行处理所有信号，并把接收到的几乎所有的信号都逐一进行封装并放入到signal接收通道中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigRecv := make(chan os.Signal, 1)</span><br><span class="line">sigs := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;</span><br><span class="line">signal.Notify(sigRecv, sigs..)</span><br><span class="line">for sig := range sigRecv &#123;</span><br><span class="line">    fmt.Printf(&quot;Received a signal :%s\n&quot;,sig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建调用signal.Notify函数所需的两个参数的值。sigRecv是signal接收通道，sigs切片代表了希望自定义处理的SIGINT和SIGQUIT信号。只要sigRecv的值中存在元素值，for语句就会把它们按顺序地接收并赋给迭代变量sig。在sigRecv代表的通道类型值被关闭后，for语句会立即被退出执行，不用担心程序在这里死循环。</p><p>signal处理程序在向signl接收通道发送值的时候，不会因为通道已满而产生阻塞。signal.Notify函数的调用方必须保证signal接收通道会由足够的空间缓存并传递接收到的信号。应此可以创建一个足够长的接收通道，或者只创建一个长度为1的通道并时刻准备从该通道中接收信号。</p><p>当接收到不想自定义处理的信号，执行操作系统指定的默认操作。指定了想要自行处理的信号但没有在接收到信号时执行必要的处理动作，相当于使当前进程忽略了这些信号。</p><p>在类Unix操作系统下的SIGKILL和SIGSTOP信号既不能被自行处理也不会被忽略，对他们的操作只能是执行默认操作。因为它们向系统的超级用户提供了使进程终止或停止的可靠方法，系统不允许任何程序消除或改变与这两个信号所对应的处理动作。</p><p>对于其他信号，除了能够自行处理它们之外，还可以使用os/signal包中的Stop方法在之后的任意时刻恢复针对它们的系统默认操作。其声明为：</p><blockquote><p><code>func Stop(c chan &lt;- os.Signal)</code></p></blockquote><p>参数声明与signal.Notify函数的第一个参数声明完全一致。函数signal.Stop取消掉在之前调用signal.Notify函数的时候告知signal处理程序需要自行处理的若干信号的行为。把当初传递给signal.Notify函数的signal接收通道作为调用signal.Stop函数的参数。调用signal.Stop函数后，作为其参数的signal接收通道将不会再被发送任何信号。这会使之前被用于从signal接收通道接收信号值的for语句一直阻塞，需要再调用signal.Stop函数之后使用内建函数close关闭该signal接收通道。此是for语句会退出执行。</p><p>只取消部分自行处理信号的行为，可再次调用signal.Notify函数并重新设定于其参数sig绑定的、以os.Signal为元素类型的切片类型值（信号集合），第一个参数的signal接收通道要相同。若signal接收通道不同，signal处理程序会将两次调用视为毫不相干，分别看待这两次调用时所设定的信号集合。</p><p>signal处理程序内部存在一个包级私有字典（信号集合字典）用于存放signal接收通道为键、以信号集合的变体为元素的键值对。调用sianal.Notify函数时，signal处理程序就会在信号集合字典中查找相应的键值对，如果键值对不存在，就向信号集合字典添加这个新的键值对，否则就更新该键值对中信号集合的变体。前者相当于向signal处理程序注册一个信号接收保证的申请，后者相当于更新该申请，signal接收通道作为调用方接收信号的为一途经，成为申请的标识。调用signal.Stop函数时，signal处理程序会删除掉信号集合字典中以该函数的参数值（某个signal接收通道）为键的键值对。</p><p>当接收到一个发送当前进程且已被标识为应用程序想要自行处理的操作系统信号之后，signal处理程序会对它进行封装，然后遍历信号集合字典中的所有键值对，并查看它们的元素中是否包含了该信号。若包含，就会立即把它发送给作为键的signal接收通道。</p><!-- signal接收通道再Go提供的操作系统信号通知机制中起到了很重要的作用，能否合理地处理操作系统的信号，基本在于signal接收通道的初始化和使用的方式。 --><p>使用os.StartProcess函数启动一个进程,或者使用os.FindProcess函数查找一个进程,两个函数都返回一个*os.Process类型的值(进程值)和一个error类型的值。可以调用该进程值的Signal方法向该进程发送一个信号，其接受一个os.Signal类型的参数值并返回一个error类型值。</p><blockquote><p><code>ps aux | grep &quot;mysignal&quot; | grep -v &quot;grep&quot; | awk &#39;{print $2}&#39;</code></p></blockquote><p><code>go run</code>命令程序中执行一系列的操作，包括依赖查找、编译、打包、链接等步骤，完成之后会有一个与被运行的命令源码文件的主文件名同名的可执行文件被生成在相应的临时工作目录中。实际上与<code>go build</code>命令生成的可执行文件一致，但是运行执行可执行文件而产生的进程是一个全新的进程，与代表了<code>go run mysignal.go</code>命令的进程毫不相干。即两个进程互相独立，都拥有自己的进程ID。使用<code>go run</code>命令运行mysignal.go，命令会生成并执行可执行文件mysignal，然后该可执行文件所产生的输出会通过该命令程序打印到标准输出上。即该命令程序被挂起、停止或终止后，mysignal中程序所打印的内容也再不会出现在标准输出上。</p><blockquote><p><code>ps aux | grep &quot;mysignal&quot; | grep -v &quot;grep&quot; | grep -v &quot;go run&quot; | awk &#39;{print $2}&#39;</code></p></blockquote><p>加入<code>grep -v &quot;go run&quot;</code>过滤掉原先进程列表中的与<code>go run</code>命令对应的进程。</p><p>信号与管道都被称为基础的IPC方法。再基于数据传递的解决方案中，要保证数据的原子性，管道不提供这种原子性保证，Go标准库中提供的API也没有附加这种保证。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket，常被译为套接字，通过网络连接来使两个或更多的进程建立通讯并相互传递数据。使通讯端的位置透明化。</p><h4 id="1-Socket的基本特征"><a href="#1-Socket的基本特征" class="headerlink" title="1.Socket的基本特征"></a>1.Socket的基本特征</h4><p>在Linux操作系统中存在一个名为Socket的系统调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure></p><p>接收三个参数分别代表了这个Socket的通讯域、类型和所用协议。通讯域决定了该Socket的地址格式和通讯范围。<br>通讯域 | 含义 | 地址形式 | 通讯范围<br> :- |:- |:- | :-<br> AF_INET | IPv4域 | IPv4地址（4个字节），端口号（两个字节）| 在基于IPv4协议的网络中的任意两台计算机之上的两个应用程序<br> AF_INET6 | IPv6域 | IPv6地址（16个字节），端口号（两个字节） | 在基于IPv6协议的网络中的任意两台计算机之上的两个应用程序<br> AF_UNIX | Unix域 | 路径名称 | 在同一台计算机上的两个应用程序</p><p><code>AF</code>是“address family”的缩写。</p><p>Socket的类型有SOCK_STREAM、SOCK_DGRAM、面向更底层的SOCK_RAW、针对某个新兴数据传输技术的SOCK_SEQPACKET。<br>特性 | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET | SOCK_STREAM<br>:- | :- |:- | :- | :-<br>数据形式 | 数据报 | 数据报 | 字节流 | 字节流<br>数据边界 | 有 | 有 | 有 | 没有<br>逻辑边界 | 没有 | 没有 | 有 | 有<br>数据有序性 | 不能保证 | 不能保证 | 能够保证 | 能够保证<br>传输可靠性 | 不具备 | 不具备 | 具备 | 具备</p><blockquote><p>以数据报为数据形式意味着数据接收方的Socket接口程序可以意识到数据的边界并会对他们进行切分。省去接收方的应用程序寻找数据边界和切分数据的工作量。</p></blockquote><blockquote><p>以字节流为数据形式的数据传输传输的是一个字节接着一个字节的串，类似很长的字节数组。一般情况字节流并不能出哪些字节属于哪个数据包。Socket接口程序无法从中分离出独立的数据包。这一工作由应用程序完成。SOCK_SEQPACKET类型的Socket的接口程序不同，数据发送方的Socket接口程序可以记录数据边界，即应用程序每次发送的字节流片段之间的分界点。数据边界信息随着字节流一同被发往数据接收方。数据接收方的Socket接口程序会根据数据边界把字节流切分成（或者说还原成）若干个字节流片段并按照需要依次传递给应用程序。</p></blockquote><p>面向有连接的Socket之间在进行数据传输之前必须要先建立逻辑连接，之后通讯双方可以互相传输数据。连接暗含双方地址，在传输数据时不必再指定目标地址。面向无链接的Socket再进行通讯时无需建立连接，传递的每一个数据包都是独立的，被直接发送到网络上，每个数据包都含有目标地址，数据流是单向的。不能用同一个面向无连接的Socket实例既发送数据又接收数据。</p><p>SOCK_RAW类型的Socket提供了一个可以直接通过底层（TCP/IP协议栈中的网络互联层）传递数据。应用程序必须具有操作系统的超级用户权限才能够使用这种方式，使用成本相对较高，应用程序一般需要自己构建数据传输格式（像TCP/IP协议栈中的TCP协议的数据段格式和UDP协议的数据报格式）。应用程序极少使用这种类型的Socket。</p><p>一般把0作为Socket的第三个参数值，含义是让操作系统内核根据第一个参数和第二个参数的值自行决定Socket所使用的协议。既Socket的通讯域和类型与所使用的协议之间存在对应关系。<br>决定因素 | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET | SOCK_STREAM<br>:- | :- | :- | :- | :-<br>AF_INET | UDP | IPv4 | SCTP | TC或SCTP<br>AF_INET6 | UDP | IPv6 | SCTP | TCP或SCTP<br>AF_UNIX | 有效 | 无效 | 有效 | 有效</p><p><code>有效</code>表示该通讯域和类型的组合会使内核选择某个内部的Socket协议。<br><code>无效</code>表示该通讯域和类型的组合是不合法的。</p><p>在没有发生任何错误的情况下，系统调用socket会返回一个int类型的值，该值是作为socket唯一标示符的文件描述符。得到该标示符后，可以调用其他系统调用来进行各种相关操作，例如绑定和监听端口、发送和接收数据以及关闭Socket实例等等。</p><p>通过系统调用来操作系统提供的Socket接口，Socket接口程序与TCP/IP协议栈的实现程序一样，是Linux操作系统内核的一部分。</p><h4 id="基于TCP-IP协议栈的Socket通讯"><a href="#基于TCP-IP协议栈的Socket通讯" class="headerlink" title="基于TCP/IP协议栈的Socket通讯"></a>基于TCP/IP协议栈的Socket通讯</h4><p>通过Socket接口可以建立和监听TCP连接和UDP连接，可以直接与网络互联层的IP协议实现程序进行通讯。</p><p>使用标准库代码包net中的API编写服务端和客户端程序。</p><blockquote><p><code>func Listen(net, laddr string)(Listener, error)</code></p></blockquote><p>函数net.Listen被用于获取一个监听器，接收两个string类型的参数，参数一表示以何种协议在给定的地址上监听，Go中用一些字符串字面量来表示。<br>字面量 | Socket协议 | 备注<br> :- | :- | :-<br> “tcp” | TCP | 无<br> “tcp4” | TCP | 网络互联层协议仅支持IPv4<br> “tcp6” | TCP | 网络互联层协议仅支持Ipv6<br> “udp”  | UDP | 无<br> “udp4” | UDP | 网络互联层协议仅支持IPv4<br> “udp6” | UDP | 网络互联层协议仅支持IPv6<br> “unix” | 有效 | 在通讯域协议为AF_UNIX且类型为SOCK_STREAM的时候内核采用的默认协议<br> “unixgram” | 有效 | 在通讯域协议为AF_UNIX且类型为SOCK_DGRAM的时候内核采用的默认协议<br> “unixpacket”  | 有效 | 在通讯域为AF_UNIX且类型为SOCK_SEQPACKET的时候内核采用的默认协议</p><p>函数net.Listen的第一个参数的值所代表的协议必须是面向流的协议，TCP和SCTP都属于面向流的协议，TCP协议实现程序无法记录和意识到任何消息边界，无法从字节流分离出消息，SCTP协议可以做到，使得应用程序无需再在发送的字节流的中间加入额外的消息分隔符，也无需再去查找所谓的消息分隔符并据此对字节流进行切分。</p><blockquote><p>net.Listen函数的第一个参数的值必须是tcp、tcp4、tcp6、unix和unixpacket中的一个。代表的都是面向流的协议。tcp表示Socket所用的TCP协议会兼容基于IPv4协议的TCP协议和基于IPv6协议的TCP协议。unix和unixpacket代表两个通讯域为Unix域的内部的Socket协议，遵循它们的Socket实例即被用于在本地计算机上的不同应用程序之间的通讯。</p></blockquote><p>第二参数laddr的值代表当前程序在网络中的标识，是Local Address的简写，格式为“host:port”,”host”代表IP地址或主机名，”port”代表当前程序欲监听的端口号。”host”处的内容必须是与当前计算机对应的IP地址或主机名，若是主机名该API中的程序会先通过DNS找到与主机名对应的IP地址，若主机名没有在DNS中注册会造成一个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listener, err := net.Listen(&quot;TCP&quot;, &quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure></p><p>返回的第一个结果是net.Listener类型，是我们欲获取的监听器，第二个结果是一个error类型值，代表可能出现的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := listener.Accept()</span><br></pre></td></tr></table></figure></p><p>调用时流程会被阻塞，直到某台计算机上的某个应用程序与当前程序建立了一个TCP连接。返回的第一个结果值代表当前TCP连接的net.Conn类型值，第二个结果值是一个error类型值。</p><p>代码包net的Dial函数用于向网络中的某个地址发送数据。  </p><blockquote><p><code>func Dial(network, address string)(Conn, error)</code>   </p></blockquote><p>参数一与net.Listen函数的第一个参数含义类似，拥有更多可选值。发送数据前不一定建立连接，UDP协议和IP协议都是面向无连接型的协议，udp、udp4、udp6、ip、ip4和ip6都可以作为network的值。unixgram也是network参数的可选值之一，代表了一个基于Unix域的内部Socket协议，以数据报作为传输形式。</p><p>参数二与net.Listen函数的第二个参数laddr完全一致。名称可由raddr（Remote Address）代替。laddr与raddr相对，前者指当前程序所使用的地址（本地地址），后者指参与通讯的另一端所使用的地址（远程地址）。</p><p>客户端的地址不用给出，端口号可以由程序指定，也可由操作系统内核动态分配。使用net.Dial建立Socket连接的客户端程序，占用的端口号由操作系统内核动态分配。客户端程序的地址中的”host”是本地计算机的主机名或IP地址，由操作系统内核指定。也可以自己去指定当前程序的地址，由另外的函数建立连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure></p><p>结果值一是net.Conn类型值，结果值二是一个error类型值。<br>网络延时表现在此行代码会一直阻塞，超过等待时间后函数的执行就会结束并返回相应的error类型值。不同操作系统对基于不同协议的连接请求的超时时间有不同的设定。Go可使用net包的DialTimeout函数设置超时时间。</p><blockquote><p><code>func DialTimeout(network, address string, timeout time.Duration ) (Conn, error)</code></p></blockquote><p>参数三设置超时间，类型为time.Duration，单位是纳秒。可用常量来表示时间，time.Nanosecond代表1纳秒，值为1。常量time.Microsecond代表1微秒，值为1000*Nanosecond，即1000纳秒。time.Second代表1秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;, 2*time.Second)</span><br></pre></td></tr></table></figure></p><p>此超时时间不是值此函数执行耗时，还包括DNS解析等耗时。</p><p>使用操作系统内核提供的API创建Socket等操作被隐藏在Go提供的Socket API中。</p><blockquote><p>通过调用net.Listen函数得到一个net.Listener类型值之后，调用该值的Accept方法等待客户端连接请求的到来，收到客户端的连接请求后，服务端与客户端建立TCP连接（三次握手）。成功建立连接后，通过Accept方法得到一个代表了该TCP连接的net.Conn类型值。通讯两端可以分别利用各自获得的net.Conn类型值交换数据。</p></blockquote><p>Go的Socket编程API在底层获取的是一个非阻塞式的Socket实例，使用Socket接口在一个TCP连接上的数据读取操作是<code>非阻塞式</code>的。在应用程序试图通过系统调用read从Socket的接收缓冲区中读取数据时，即使接收缓冲区中没有任何数据，操作系统内核也不会使系统调用read进入阻塞状态，而是返回一个错误码为“<code>EAGAIN</code>”的错误，应用程序不会视其为真正的错误，稍等片刻后再去尝试读取。若有数据，系统调用read就会携带这些数据立即返回。即使当时接收缓冲区中只包含了一个字节的数据也会是这样，这一特性被称为<code>部分读</code>（partial read）。向发送缓冲区写入一段数据，即使发送缓冲区已经被填满系统调用write也不会被阻塞，而是直接返回错误码为“<code>EAGAIN</code>”的错误，应用程序忽略该错误并稍后再尝试写入数据。若发送缓冲区中有少许剩余空间但不足以放入这段数据，那么系统调用write会尽可能地写入一部分数据然后返回已写入的字节的数据梁，这一特性被称为<code>部分写</code>（partial write）。应用程序每次调用write之后都会区检查该结果值，并发现数据未被完全写入时继续写入剩下的数据。在非阻塞的Socket接口下，系统调用accept也会显示一致的非阻塞风格，不会被阻塞以等待新连接的到来，会直接返回错误码为“<code>EAGAIN</code>”的错误。</p><p>Go语言Socket编程API屏蔽了非阻塞式Socket接口的部分写特性，相关API直到把所有数据全部写入到Socket的发送缓冲之后才会返回，除非在写入的过程中发生了某种错误。保留了非阻塞式Socket接口的部分读特性。在TCP协议之上传输的数据是字节流形式的，数据接收方无法意识到数据的边界（消息边界），Socket编程API程序无从判断函数返回的时机。</p><p>net.Conn类型是一个接口类型，在它的方法集合中包含了8个方法。</p><h5 id="Read方法"><a href="#Read方法" class="headerlink" title="Read方法"></a>Read方法</h5><p>被用来从Socket的接收缓冲区读取数据。</p><blockquote><p><code>Read(b []byte)(n int, err error)</code></p></blockquote><p>接受一个[]byte类型的参数，参数值相当于一个被用来存放从连接上接收到的数据的“容器”。长度由应用程序决定，Read会最多从连接中读取数量等于该参数值的长度的若干字节，并把它们依次放置到该参数值中的相应元素位置上。传递给Read方法的参数值应该是一个不包含任何非零值元素的切片值。一般情况，Read方法只有在把参数值填满之后才会返回。当未填满参数值且参数值靠后部分存在遗留元素时，通过返回的第一个结果值进行真正数据的识别，结果值n代表了实际读取到的字节的个数，即Read方法向参数值中填充的字节的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := make([]byte, 10)</span><br><span class="line">n, err := conn.Read(b)</span><br><span class="line">content := string(b[:n])</span><br></pre></td></tr></table></figure></p><p>若Socket编程API程序在从Socket的接收缓冲区中去读取数据的时候发现TCP连接已经被另一端关闭，则会立即返回一个err处理or类型值，与<code>io.EOF</code>变量的值是相等的，象征着文件内容的完结，此处意味着在TCP连接上再无可被读取的数据，即TCP连接已经无用，可以被关闭。若第二个结果值与io.EOF变量的值相等，则应该中止后续的数据读取操作，并关闭该TCP连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var dataBuffer bytes.Buffer</span><br><span class="line">b := make([]byte, 10)</span><br><span class="line">for &#123;</span><br><span class="line">    n, err := conn.Read(b)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        if err == io.EOF &#123;</span><br><span class="line">            fmt.Println(&quot;The connection is closed.&quot;)</span><br><span class="line">            conn.Close()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Printf(&quot;Read Error : %s\n&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    dataBuffer.Write(b[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可利用标准库代码包<code>bufio</code>（Buffered I/O）中的API实现一些较复杂的数据切分操作，提供了与带缓存的I/O操作有关的支持。net.Conn类型实现了接口类型<code>io.Reader</code>中唯一的方法Read，使用<code>bufio.NewReader</code>函数（接收一个io.Reader类型的参数值）包装变量conn：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(conn)</span><br></pre></td></tr></table></figure></p><p>调用reader变量的值之上的ReadBytes方法依次获取经过切分之后的数据。该方法接受一个byte类型的参数值，该参数值是通讯两端协商一致的边界消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line, err := reader.ReadBytes(&apos;\n&apos;)</span><br></pre></td></tr></table></figure></p><p>每次调用之后会得到一段以该i边界消息为结尾的数据。消息边界的定位比较复杂，HTTP协议规定消息头部信息的末尾是连续的两个空行“\r\n\r\n”，获取消息的头部信息后，相关程序通过其中名为“Cotent-Length”的信息项的值得到HTTP消息的数据部分的长度。bufio代码包提供了高级的API如<code>bufio.NewScanner</code>、<code>bufio.Sacnner</code>等函数处理。</p><h5 id="Write方法"><a href="#Write方法" class="headerlink" title="Write方法"></a>Write方法</h5><p>被用来向Socket的发送缓冲区写入数据。</p><blockquote><p><code>Write(b []byte)(n int, err error)</code></p></blockquote><p>屏蔽了很多非阻塞式Socket接口的细节，可以简单地调用它不用做其他额外的处理，除非操作超时异常。使用bufio的<code>bufio.NewWriter</code>函数（接收接收一个io.Writer类型的参数值）包装变量conn。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer := bufio.NewWriter(conn)</span><br></pre></td></tr></table></figure></p><p>writer的值可被看作针对变量conn代表的TCP连接的缓冲写入器。可以调用其上的以“Write”为名称前缀的方法分批次地向其中的缓冲区写入数据，也可调用<code>ReadFrom</code>方法直接从其他<code>io.Reader</code>类型值中读出并写入数据，调用Reset方法以达到重置和复用它的目的。写入全部数据后，调用<code>Flush</code>方法，保证其中的所有数据都被真正地写入到它的代理对象中。调用<code>bufio.NewWriterSize</code>函数初始化一个缓冲写入器，类似<code>bufio.NewWriter</code>，自定义将要生成的缓冲写入器的缓冲区容量，解决缓冲写入器的缓冲区容量（默认4096字节）小于写入的数据的字节数量的问题。否则<code>Write</code>方法试图把这些数据的全部或一部分直接写入到它代理的对象中，而不会先在自己的缓冲写入器中缓存这些数据。</p><h5 id="Close方法"><a href="#Close方法" class="headerlink" title="Close方法"></a>Close方法</h5><p>关闭当前的连接。不接受任何参数并返回一个error类型值。调用后该连接值上的Read方法、Write方法或Close方法的任何调用都会立即返回一个error类型值。</p><p>当调用Close方法时，Read方法或Write方法正在被程序调用且还未执行结束，会立即结束执行并返回非nil的error类型值，即使它们正处于阻塞状态。</p><h5 id="LocalAddr和RemoteAddr方法"><a href="#LocalAddr和RemoteAddr方法" class="headerlink" title="LocalAddr和RemoteAddr方法"></a>LocalAddr和RemoteAddr方法</h5><p>不接受任何参数并返回一个met.Addr类型的结果。代表了参入当前通讯的某一端的应用程序在网络中的地址。LocalAddr返回代表本地地址的net.Addr类型值，RemoteAddr返回代表远程地址的net.Addr类型值。net.Addr类型是一个接口类型，方法集合中有两个方法——Network和String，前者返回当前连接所使用的协议的名称，后者返回相应的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.LocalAddr().Network()  //协议名称</span><br><span class="line">conn.RemoteAddr().String()  //于服务端获取另一端（客户端）应用程序的网络地址</span><br><span class="line">conn.LocalAddr().String()   //于客户端获取操作系统内核为该客户端程序分配的网络地址</span><br></pre></td></tr></table></figure></p><h5 id="SetDeadline、SetReadDeadline、SetWriteDeadline方法"><a href="#SetDeadline、SetReadDeadline、SetWriteDeadline方法" class="headerlink" title="SetDeadline、SetReadDeadline、SetWriteDeadline方法"></a>SetDeadline、SetReadDeadline、SetWriteDeadline方法</h5><p>接收一个time.Time类型值，返回一个error类型值。</p><p><code>SetDeadline</code>:设置在当前连接上的I/O（包括但不限于读和写）操作的超时时间。为绝对时间对之后的每个I/O操作都起作用，循环从一个连接上读取数据，设定超时时间需要在每次迭代中的读取数据操作之前都设定一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b := make([]byte, 10)</span><br><span class="line">for &#123;</span><br><span class="line">    conn.SetDeadline(time.Now().Add(2 * time.Second))</span><br><span class="line">    n, err := conn.Read(b)</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>conn.SetDeadline(time.Time{})</code>//传入time.Time类型的零值取消超时时间</p></blockquote><p><code>SetReadDeadline</code>:针对读操作，即连接值的Read方法的调用的超时时间。</p><p><code>SetWriteDeadline</code>:针对写操作，即连接值的Write方法的调用的超时时间。</p><p>SetDeadline方法相当于先后以同样的参数值对SetReadDeadline和SetWriteDeadline方法进行调用。</p><blockquote><p>在服务端程序中，为了快速，独立地处理已经建立的每一个连接，应该尽量让这些处理过程并发地执行。否则处理已建立的第一个连接的时候，后续连接只能排队等待。</p></blockquote><p>Go语言标准库中，一些实现了某种网络通讯功能的代码包都是以net代码包所提供的Socket编程API为基础，如net/http代码包。标准库代码包net/rpc中的API为我们提供了在两个Go语言程序之间建立通讯和交换数据的另一种方式——远程过程调用（Remote Procedure Call）。基于TCP/IP协议，使用net包以及net/http包提供的API。</p><p>阅读<code>gpoc/src/multiproc/socket/tcpsock.go</code>小demo加深socket编程理解。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-并发理论</title>
      <link href="/2018/04/23/Golang%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/"/>
      <url>/2018/04/23/Golang%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>并发编程含义并不单一，基于一个独立程序（多线程编程）、一台计算机（多进程编程）、一个网络（分布式计算）。此处指在单台计算机的环境下可以使计算机指令同时发生并相互协作的计算机语言级别的并发计算技术。</p><p>主要思想是使多个任务可以在同一时间执行以便能够更快地得到结果。</p><h3 id="串行程序与并发程序"><a href="#串行程序与并发程序" class="headerlink" title="串行程序与并发程序"></a>串行程序与并发程序</h3><blockquote><p>串行程序：一个只能被顺序执行的指令列表。</p></blockquote><blockquote><p>并发程序：被并发的执行的两个或两个以上的串行程序的统称。</p></blockquote><p>并发程序允许其中的串行程序运行在一个或多个可共享的CPU之上，同时也允许每个串行程序都运行在专为它服务的CPU上。前一种方法称为<code>多元程序</code>：由操作系统内核支持并提供多个串行程序复用多个CPU的方法。也被被称为<code>多元处理</code>：计算机中的多个CPU共用一个存储器（即内存），并且在同一时刻可能会有数个串行程序分别运行在不同的CPU之上。</p><h3 id="并发程序与并行程序"><a href="#并发程序与并行程序" class="headerlink" title="并发程序与并行程序"></a>并发程序与并行程序</h3><blockquote><p><code>并发程序</code>：可以被同时发起执行的程序。</p></blockquote><blockquote><p><code>并行程序</code>：被设计成可以在并行的硬件上执行的程序。</p></blockquote><p>并发程序代表了所有可以实现真正的或者可能的并发行为的程序，包含了并行程序。</p><h3 id="并发程序与并发系统"><a href="#并发程序与并发系统" class="headerlink" title="并发程序与并发系统"></a>并发程序与并发系统</h3><p>并发程序属于程序，也可以称之为一个内聚的软件单元。松耦合的程序与程序之间可以通过协商一致的协议进行通讯，它们可以被看作是一个系统而不是程序。并发系统可能是并行的，常常成为并行系统。</p><h3 id="并发程序的不确定性"><a href="#并发程序的不确定性" class="headerlink" title="并发程序的不确定性"></a>并发程序的不确定性</h3><p>串行程序所有活动的先后顺序是固定的，一个并发程序中的活动只是部分有序的，即其中一些活动的发生顺序并没有被明确地指定，被称为不确定性。导致并发程序的每次运行的活动执行路径都是不同的。</p><h3 id="并发程序的内部交互"><a href="#并发程序的内部交互" class="headerlink" title="并发程序的内部交互"></a>并发程序的内部交互</h3><p>同步：避免在并发访问共享数据时可能存在的冲突，确保在互相传递数据时能够顺利地接通。</p><blockquote><p>在同一时刻，某一资源只能被一个程序占用。</p></blockquote><p><code>传递数据</code>是并发程序内部的另一种交互方式，被称为并发程序内部的通讯。也可以使用异步的方式对通讯进行管理，使得数据可以不加延迟地发送给数据接受方。即使在数据接收方还没有立即为接收该数据做好准备的时候，也不会造成数据发送方的等待。数据被临时存放在一个被称为<code>通讯缓存</code>的数据结构中。<code>通讯缓存</code>是一种特殊的共享资源，可以同时被多个程序使用，数据接收方可以在准备就绪后按照数据被存入通讯缓存的顺序从通讯缓存中接收它们。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 并发理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-测试</title>
      <link href="/2018/04/21/Golang%E7%AC%94%E8%AE%B0-%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/04/21/Golang%E7%AC%94%E8%AE%B0-%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p>可使用go test命令或者标准库提供的testing代码包。</p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>测试源码文件应该与被测试源码文件处于同一代码包内。testing中的API和go test命令协同使用，testing提供自动化测试支持，自动执行目标代码包中的任何测试函数。</p><h4 id="功能测试函数"><a href="#功能测试函数" class="headerlink" title="功能测试函数"></a>功能测试函数</h4><p>功能测试程序以函数为单位，被用于测试程序实体功能的函数的名称和签名形如:<br><code>func TestXxx (t *testing.T)</code></p><h4 id="常规记录"><a href="#常规记录" class="headerlink" title="常规记录"></a>常规记录</h4><p>参数t上的Log和Logf方法一般用于记录一些常规信息，以展示测试程序的运行过程以及被测试程序的实时状态。  </p><blockquote><p>t.Logf方法与fmt.Printf函数的使用方法类似。<br>t.Log方法于fmt.Println函数的使用方法类似。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Log(Test tcp listener &amp; sender(serverAddr= &quot;,&quot;127.0.0.1:8000&quot;,&quot;)...&quot;)</span><br><span class="line">t.Log(Test tcp listener &amp; sender(serverAddr= %s&quot;,&quot;127.0.0.1:8000&quot;)</span><br></pre></td></tr></table></figure><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><p>Error,Errorf方法，当测试的程序实体的状态不正确的时候，及时对当前的错误状态进行记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actLen := Len(s)</span><br><span class="line">if acrLen != expLen &#123;</span><br><span class="line">    t.Errorf(&quot;Error:The length of slice should be %d but %d.\n&quot;, expLen, actLen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>t.Error方法相当于先后对t.Log和t.Fail方法进行调用。<br>t.Errof相当于先后t.Logf和t.Fail方法进行调用。</p></blockquote><h4 id="致命错误记录"><a href="#致命错误记录" class="headerlink" title="致命错误记录"></a>致命错误记录</h4><p>Fatal和Fatalf方法用于记录致命状体错误，即错误无法进行的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if listener == nil &#123;</span><br><span class="line">    t.Fatalf(&quot;Listener startup failing!(addr = %s)!n\&quot;, severAddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>t.Fatal相当于先后调用t.Log和t.FailNow。<br>t.Fatalf相当于先后调用t.Logf和t.FailNow方法。</p></blockquote><h4 id="失败标记"><a href="#失败标记" class="headerlink" title="失败标记"></a>失败标记</h4><p>t.FailNow与t.Fail的不同:前者被调用时会立即终止当前测试函数的执行，使当前测试运行的程序转去执行其他的测试函数。</p><blockquote><p>只能在运行测试函数的Coroutine中调用t.FailNow方法，不能在测试代码创建的Goroutine中调用，但不会报错，因不产生任何结果。</p></blockquote><h4 id="失败判断"><a href="#失败判断" class="headerlink" title="失败判断"></a>失败判断</h4><p>调用t.Failed方法，返回bool结果，代表当前测试函数中的测试是否已被标记为失败。</p><h4 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h4><p>t.SkipNow:当前测试函数为已经被忽略的并且立即终止该函数的执行，测试运行程序转去执行其他测试函数。同t.FailNow，只能在运行测试函数的Goroutine中被调用。</p><blockquote><p>t,Skip方法相当于先后对t.Log和t.SkipNow进行调用。<br>t.Skipf方法相当于先后对t.Logf和t.SkipNow进行调用。</p></blockquote><p>t.Skipped方结果告知当前测试是否已被忽略。</p><h4 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h4><p>t.Parallel:标记当前测试函数为可并行运行的，使测试运行程序可以并发地执行它以及其他可并行运行的测试函数。</p><h4 id="功能测试的运行"><a href="#功能测试的运行" class="headerlink" title="功能测试的运行"></a>功能测试的运行</h4><p>go test命令。  </p><p><code>go test 代码包 代码包</code>:运行代码包中的测试。  </p><p><code>go test 测试源码文件 被测试源码文件</code>:部分测试，仅运行测试源码文件的测试。  </p><p><code>go test -run=Prime 代码包</code>:-run标记值为正则表达式，名称与正则表达时匹配的功能测试函数才会在当次的测试运行过程中被执行。</p><p>默认通过方法t.Log和t.Logf记录测试不会显示，使用标记<code>-v(冗长模式)</code>在测试运行结束后打印出所有在测试运行过程中被记录的日志。<br><code>go test -v 代码包 代码包</code></p><h4 id="测试运行时间"><a href="#测试运行时间" class="headerlink" title="测试运行时间"></a>测试运行时间</h4><p><code>go  test -timeout</code>:在达到其值所代表的时间上限时测试还未结束引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -timeout 100ms 代码包</span><br></pre></td></tr></table></figure></p><p><code>go test -short</code>:让测试尽快结束。<br>代码包testing中的Short函数表明是否在执行<code>go test</code>命令的时候加入了<code>-short</code>标记，返回bool值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if testing.Short() &#123;</span><br><span class="line">    multiSend(severAddr, &quot;SenderT&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    multiSend(severAddr, &quot;SenderT1&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">    multiSend(severAddr, &quot;SenderT2&quot;, 1, (2 * time.Second), showLog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="测试的并发执行"><a href="#测试的并发执行" class="headerlink" title="测试的并发执行"></a>测试的并发执行</h4><p><code>go test -parallel</code>:设置允许并发执行的功能测试函数的最大数量。在多核CPU或者多CPU的计算机上，使用并发执行的方式执行测试。  </p><p>前提：功能测试函数的开始处加入<code>t.Parallel()</code>。调用<code>t.Parallel</code>方法时，执行功能测试函数的测试运行程序会阻塞，等待其他同样满足并发执行条件的测试函数被清点且阻塞后，命令根据<code>-parallel</code>标记的值全部或者部分地并发执行这些功能测试函数中的在语句<code>t.Parallel()</code>之后的那些代码。</p><p><code>-parallel</code>的默认值是通过标准库代码包runtime的函数GOMAXPROCS设置的值。即使给予<code>-parallel</code>标记的值，真正能够并发执行功能测试函数的数量也不会比默认值多。通常不需要在命令中加入<code>-parallel</code>标记。</p><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>Benchmark Test，通过一些科学手段实现对一类测试对象的某项性能指标进行可测量、可重复和可比对的测试。即性能测试。</p><h4 id="编写基准测试函数"><a href="#编写基准测试函数" class="headerlink" title="编写基准测试函数"></a>编写基准测试函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkXxxx(b *testing.B)</span><br></pre></td></tr></table></figure><p>有Log<em>、Error</em>、Fatal<em>、Fail</em>、Skip<em> 系列方法。 同</em>testing.T类型的同名方法相同。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p><code>b.StartTimer()</code>:开始对当前的测试函数的执行进行计时。总会在开始执行基准函数的时候被自动的调用，此函数用于计时器被停止后重新启动。  </p><p><code>b.StopTimer()</code>:使当前函数的计时器停止。</p><p><code>b.ResetTimer()</code>:重置当前基准测试函数，即将函数的执行时间重值为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package **</span><br><span class="line">import (</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func BenchMark(b *testing.B) &#123;</span><br><span class="line">    customTimerTag := false</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StopTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StartTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost bmt]# go test -bench=&quot;.&quot; -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark-2          11000200756 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  testing/bmt1.009s</span><br></pre></td></tr></table></figure><blockquote><p>testing包中限制：在基准测试函数单次执行时间超过指定值（默认1s，可由<code>-benchtime</code>标记自定义）的情况下，只执行该基准测试函数一次，即在不超过此执行时间上限的情况下尽可能多地执行一个基准测试函数。</p></blockquote><h4 id="内存分配统计"><a href="#内存分配统计" class="headerlink" title="内存分配统计"></a>内存分配统计</h4><p><code>b.ReportAllocs()</code>:判断在启动当前测试的<code>go test</code>命令的后面是否有<code>-benchmark</code>标记，返回bool值。  </p><p><code>b.SetBytes()</code>:接受一个int64类型的值，用于记录在单次操作中被处理的字节的数量。帮助统计被测试的程序实体的实际性能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func BenchMark(b *testing.B) &#123;</span><br><span class="line">    customTimerTag := false</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StopTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    b.SetBytes(12345678)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    if customTimerTag &#123;</span><br><span class="line">        b.StartTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost bmt]# go test -bench=&quot;.&quot; -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark-2          11000449919 ns/op  12.34 MB/s</span><br><span class="line">PASS</span><br><span class="line">ok  testing/bmt1.047s</span><br></pre></td></tr></table></figure><p><code>12.34 MB/s</code>:每秒被处理的字节的数量（MB为单位）。等于测试运行程序在执行（可能是多次）Benchmark函数的过程中每秒调用b.SetBytes方法的次数乘以传入的整数值。</p><h4 id="基准测试的运行"><a href="#基准测试的运行" class="headerlink" title="基准测试的运行"></a>基准测试的运行</h4><p>go test命令运行基准测试的标记：<br>标记名称 | 标记描述<br>:-: | :-:<br><code>-bench regexp</code> | 默认情况下不会运行任何基准测试，使用该标记以执行匹配“regexp”处的正则表达式所代表的基准测试函数。若需要运行所有的基准测试函数，可以写为:<code>-bench .</code>或<code>-bench=.</code>。<br><code>-benchmem</code> | 在输出内容中包含基准测试的内存分配统计信息。<br><code>-benchtime t</code> | 间接地控制单个基准测试函数的操作次数。<code>t</code>指执行单个测试函数的累计耗时上限，默认<code>1s</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# go test -bench=Prime cnet/ctcp</span><br><span class="line">BenchmarkPrimeFuncs-2          13006791258 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.023s</span><br></pre></td></tr></table></figure><blockquote><p>结构体类型testing.B的字段N可以用于设置对基准测试函数中的某一个代码块重复执行的次数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test -bench=Prime -benchtime 1s -v cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestPrimeFuncs</span><br><span class="line">--- PASS: TestPrimeFuncs (2.00s)</span><br><span class="line">tcp_test.go:27: Test tcp listener &amp; sender (serverAddr=127.0.0.1:8080)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=4]</span><br><span class="line">BenchmarkPrimeFuncs-2          13003077128 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.020s</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test -bench=Prime -benchmem  cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkPrimeFuncs-2          13002297558 ns/op   22184 B/op     108 allocs/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp5.048s</span><br></pre></td></tr></table></figure><p> <code>22184 B/op</code>:每次操作分配的字节的平均数为22184个。<br> <code>108 allocs/op</code>:没次操作分配内存的次数为108次。</p><p> <code>-cpu</code>标记:自定义测试运行次数并在测试运行期间多次改变Go语言最大并发处理数。  </p><ul><li>设置Go最大并发处理数，即调用runtime.GOMAXPROCS函数并把对应的整数作为参数传入。</li><li>运行目标代码包内的所有功能测试。</li></ul><blockquote><p>测试运行程序对<code>-cpu</code>标记的处理方式与<code>-parallel</code>标记正好相反。后者默认使用最大并发处理数，前者直接设置它。前者不会影响后者的默认值。</p></blockquote><blockquote><p><code>[root@localhost src]# go test -bench=Prime -cpu=1,2,4,8,12,16,20 cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkPrimeFuncs              13007500941 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=4]</span><br><span class="line">BenchmarkPrimeFuncs-2        10000    137119 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-2</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=6]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=2, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-4        10000    183526 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-4</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=4, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-8        10000    157748 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-8</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=8, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-12       10000    154919 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-12</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=12, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-16       10000    152336 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-16</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=16, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">BenchmarkPrimeFuncs-20       10000    134758 ns/op</span><br><span class="line">--- BENCH: BenchmarkPrimeFuncs-20</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">tcp_test.go:57: Benchmark tcp listener &amp; sender (serverAddr=127.0.0.1:8081)... [GOMAXPROCS=20, NUM_CPU=2, NUM_GOROUTINE=3]</span><br><span class="line">PASS</span><br><span class="line">ok  cnet/ctcp26.474s</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:center">使用示例</th><th style="text-align:left">说明 </th></tr></thead><tbody><tr><td style="text-align:center"><code>-parallel</code></td><td style="text-align:center"><code>-parallel 4</code></td><td style="text-align:left">功能：设置并发执行的功能测试函数的最大数量。  默认值：调用runtime.GOMAXPROCS(0)的结果，即最大并发处理数量。先决条件：功能测试函数开始处调用结构体testing,T类型的参数值的Parallel方法。生肖的测试：功能测试。</td></tr><tr><td style="text-align:center"><code>-cpu</code></td><td style="text-align:center"><code>-cpu 1,2,4</code></td><td style="text-align:left">功能：根据标记的值，迭代设置Go语言并发处理最大书并执行全部功能测试或全部基准测试。默认值：“”，即空字符串。先决条件：无。生效的测试：功能测试和基准测试。</td></tr></tbody></table><blockquote><p>这两个标记的作用域都是代码包，只能用于控制某一个代码包内的测试的流程。多个代码包的功能测试是可并发执行，基准测试串行执行。</p></blockquote><h3 id="样本测试"><a href="#样本测试" class="headerlink" title="样本测试"></a>样本测试</h3><p>编写不需要testing代码包的API，使用<code>go test</code>命令解析和执行。</p><h4 id="编写样本测试函数"><a href="#编写样本测试函数" class="headerlink" title="编写样本测试函数"></a>编写样本测试函数</h4><p>名称以<code>Example</code>开始，函数体最后可有若干个注释行，用于比较该测试函数被执行期间，标准输出上出现的内容是否与预期相符。</p><p>注释被正确解析需满足:  </p><ul><li>必须出现在函数体的末尾，与结束符<code>}</code>之间没有代码。</li><li>在第一行注释中紧跟在注释前导符<code>//</code>之后的永远应该是<code>Output:</code>。</li><li>在<code>Output:</code>右边的内容以及后续注释中的内容都分别代表了标准输出中的一行内容。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package et</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func ExampleHello() &#123;</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">fmt.Println(&quot;Hello, Golang~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output: Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若测试函数被执行的过程中向标准输出打印的内容是<code>Output:</code>右边内容”Hello, Golang~”，则该测试函数中的测试就是通过的，否则就是失败的。</p><h4 id="样本测试的运行"><a href="#样本测试的运行" class="headerlink" title="样本测试的运行"></a>样本测试的运行</h4><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_test.go:18: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- PASS: ExampleHello (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok  testing/et0.006s</span><br></pre></td></tr></table></figure><p>修改<code>Output:</code>右边内容”Hello, Erlang”。</p><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_test.go:18: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- FAIL: ExampleHello (0.00s)</span><br><span class="line">got:</span><br><span class="line">Hello, Erlang~</span><br><span class="line">want:</span><br><span class="line">Hello, Golang~</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAILtesting/et0.026s</span><br></pre></td></tr></table></figure><p>修改<code>Output:</code>右边内容多行，对应多行输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func ExampleHello() &#123;</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">fmt.Println(&quot;Hello, Golang~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output: Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br><span class="line">// Hello, Golang~</span><br></pre></td></tr></table></figure></p><blockquote><p><code>[root@localhost et]# go test -v</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestOne</span><br><span class="line">--- PASS: TestOne (0.00s)</span><br><span class="line">et_test.go:19: Hi~</span><br><span class="line">=== RUN   ExampleHello</span><br><span class="line">--- PASS: ExampleHello (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok  testing/et0.007s</span><br></pre></td></tr></table></figure><h4 id="样本测试函数的命名"><a href="#样本测试函数的命名" class="headerlink" title="样本测试函数的命名"></a>样本测试函数的命名</h4><ul><li>被测试对像为整个代码包，名称<code>Example</code>。</li><li>被测试对象为一个函数，对于函数F，名称<code>ExampleF</code>。</li><li>被测试对象为一个类型，对于类型T，名称<code>ExampleT</code>。</li><li>被测试对象为某个类型中的一个方法，对于类型T中的方法M，名称<code>ExampleT_M</code>。</li><li>加入后缀需用下划线“_”隔开且后缀首字母小写。针对类型T的方法M加入后缀“basic”，名称<code>ExampleT_M_basic</code>。</li></ul><h3 id="测试运行记录"><a href="#测试运行记录" class="headerlink" title="测试运行记录"></a>测试运行记录</h3><p>在<code>go test</code>命令后跟标记的方式来启动和定制用于在测试运行时记录性能的方法。</p><h4 id="收集资源使用情况"><a href="#收集资源使用情况" class="headerlink" title="收集资源使用情况"></a>收集资源使用情况</h4><table><thead><tr><th style="text-align:center">标记名称</th><th style="text-align:left">标记描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>-cpuprofile cpu.out</code></td><td style="text-align:left">记录CPU使用情况，并写到指定的文件中直到测试退出。<code>cpu.out</code>作为指定文件的文件名可以被其他任何名称代替。</td></tr><tr><td style="text-align:center"><code>-memprofile mem.out</code></td><td style="text-align:left">记录内存使用情况，并在测试通过后将内存使用概要写到指定文件<code>mem.out</code>中。</td></tr><tr><td style="text-align:center"><code>-memprofilerate n</code></td><td style="text-align:left">控制着记录内存分配操作的行为，记录i将会被写到内存使用概要文件中。<code>n</code>代表着分析器的取样间隔，单位为字节，即当有n个字节的内存被分配时，分析器就会取样一次。</td></tr></tbody></table><blockquote><p><code>[root@localhost et]# go test -cpuprofile cpu.out et_test.go</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  command-line-arguments0.043s</span><br></pre></td></tr></table></figure><p>在执行命令的当前目录中窜县一个用于运行测试的可执行文件<code>et.test</code>，可通过执行文件运行相应的测试。在目标代码包的所在目录中会出现一个名为<code>cpu.out</code>的文件，使用<code>go tool pprof</code>命令对来交互式的对这个概要文件进行查阅。</p><blockquote><p><code>go tool pprof ./**.test cpu.out</code></p></blockquote><p>标记<code>-cpuprofile</code>相当于一个开关，决定了在测试运行期间是否对CPU使用情况进行取样操作，取样操作的时间固定，每10毫秒进行一次取样，当<code>-cpuprofile</code>标记有效时，运行测试的程序会通过标准库代码包<code>runtime/pprof</code>中的API来控制该操作的启动和停止。<code>pprof.StartCPUProfile</code>用来启动CPU使用情况记录操作，<code>pprof.StopCPUProfile</code>同来停止CPU使用情况记录操作。</p><p><code>-memprofile</code>标记有效时，测试运行程序会在测试运行的同时记录他们对内存的使用情况，即程序运行期间堆内存的分配情况，单位是字节，值越小意味着取样间隔会更短效果越好。<code>-memprofilerate</code>标记的值会赋给runtime包中的int类型的变量MemProfileRate，默认值为512*1024，即512K字节。如果设置为0则代表停止取样。</p><blockquote><p><code>go test -memprofile mem.out -memprofilerate 10 测试代码包</code></p></blockquote><p>会生成两个文件，一个在执行该命令所在目录下的可执行文件<code>测试代码包.test</code>，每次运行会重新生成替换原文件。另一个在目标代码包所在目录下的概要文件<code>mem.out</code>，可用<code>go tool pprof</code>命令对概要文件进行查询和分析。</p><blockquote><p><code>go tool pprof ./测试代码包.test 代码包路径/mem.out</code></p></blockquote><p>要获得最好的取样效果，可以将<code>-memprofilerate</code>标记的值设置为1，当有一个字节被分配，分析器就会进行一次取样。消耗比较大，可将<code>GOGC</code>设置为”off”，使垃圾回收器处于不可用状态。但会让程序运行在一个没有垃圾回收器的环境中，可用的内存只会不断的减少，没有可用的内存时程序会崩溃。</p><h4 id="记录程序阻塞事件"><a href="#记录程序阻塞事件" class="headerlink" title="记录程序阻塞事件"></a>记录程序阻塞事件</h4><p>在<code>go test</code>命令添加<code>-blockprofile</code>和<code>-blockprofilerate</code>标记来达到记录线程阻塞事件。<br>标记名称 | 标记描述<br>:-: | :-<br><code>-blockprofile block.out</code> | 记录Goroutine阻塞事件，并在所有测试通过后将概要信息写到指定的文件<code>block.out</code>中。<br><code>-blockprofilerate b</code> | 用于控制记录Goroutine阻塞事件的时间间隔，单位为次，默认值为1</p><blockquote><p><code>go test -blockprofile block.out -blockprofilerate 100 代码包</code></p></blockquote><blockquote><p><code>go tool pprof ./代码包.test 代码包路径/block.out</code></p></blockquote><p><code>-blockprofilerate</code>的值通过标准库代码包runtime中的API函数<code>SetBlockProfileRate</code>传递给Go运行时系统。传入参数0，意味着取消记录操作，传入参数1，每一个阻塞事件都将被记录。默认值1，可省略<code>-blockprofilerate</code>标记。</p><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>go test命令可接受的与测试覆盖率有关的标记。<br>标记名称 | 使用示例 | 说明<br>:- | :- | :-<br><code>-cover</code> | <code>-cover</code> | 启用测试覆盖率分析<br><code>-covermode</code> | <code>-covermode=set</code> | 自动添加<code>-cover</code>标记并设置不同的覆盖率统计模式。支持的模式有：set:只记录语句是否被执行过，count:记录语句被执行的次数，atomic:记录语句被执行次数并保证在并发时也能正确计数。模式不能同时使用，默认set。<br><code>-coverpkg</code> | <code>-coverpkg bufio,net</code> | 自动添加<code>-cover</code>标记并对该标记后所罗列的代码包中的程序进行测试覆盖率统计。默认情况下，测试运行程序只会被直接测试的代码包中的程序进行统计。意味着在测试中被间接使用到的其他代码包中的程序也可以被统计。代码包由导入路径指定，多个代码包之间“,”分隔。<br><code>-coverprofile</code> | <code>-coverprofile cover.out</code> | 自动添加<code>-cover</code>标记并将所有已经通过测试的覆盖率的概要写入指定文件中。</p><blockquote><p><code>root@localhost src]# go test -cover cnet/ctcp</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.010scoverage: 68.6% of statements</span><br></pre></td></tr></table></figure><p>标记<code>-coverpkg</code>使我们可以获得间接被使用的代码包中的程序在测试期间的执行率。</p><blockquote><p><code>[root@localhost src]# go test cnet/ctcp -coverpkg=bufio,net</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.015scoverage: 14.8% of statements in bufio, net</span><br></pre></td></tr></table></figure><blockquote><p><code>[root@localhost src]# go test cnet/ctcp -coverprofile=cover.out</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok  cnet/ctcp2.018scoverage: 68.6% of statements</span><br></pre></td></tr></table></figure><p>使用cover工具查看概要文件中的内容。  </p><ul><li>根据指定的规则重写某一个源码文件中的代码，并输出到指定的目标上。</li><li>读取测试覆盖率的统计信息文件，并以指定的方式呈现。</li></ul><p>重写：计数器。</p><p>可通过<code>-mode</code>标记将统计模式直接传递给cover工具，与<code>-covermode</code>标记的用法和含义一致。实际上go test命令将<code>-covermode</code>标记的值原封不动地作为运行cover工具时提送给它的<code>-mode</code>标记的值，<code>-mode</code>标记没有默认值。</p><blockquote><p><code>go tool cover -mode=set -var=&quot;GoCover&quot; -o dst.go src.go</code></p></blockquote><p>查看覆盖率概要文件：</p><blockquote><p><code>go tool cover -func=cover.out</code></p></blockquote><p><code>-func</code>标记可以让cover工具把概要文件中包含的每个函数的测试覆盖率概要信息打印到标准输出上。</p><blockquote><p><code>go tool cover -html=cover.out</code></p></blockquote><p><code>-html</code>标记用更加图形化的信息来反应统计情况，该命令会立即返回并且在标准输出上也不会出现任何内容，默认浏览器会被启动并显示cover工具根据概要文件生成的html格式的页面文件。被测试语句以绿色显示，未被测试的语句以红色显示，未参加测试覆盖率计算的语句以灰色表示。不同统计模式下生成的概要文件不同，对应的html文件也不同。</p><p>cover工具可接受的标记。<br>标记名称 | 使用示例 | 说明<br>:- | :- | :-<br><code>-func</code> | <code>-func=cover.out</code> | 根据根要文件中的内容输出每一个被测试函数的测试覆盖率概要信息。<br><code>-html</code> | <code>-html=cover.out</code> | 把概要文件中的内容换成HTML格式的文件，并使用默认浏览器查看它。<br><code>-mode</code> | <code>-mode=count</code> | 被用于设置测试概要文件的统计模式。<br><code>-o</code> | <code>-o=cover.out</code> | 把重写后的源代码的输出到指定文件中，如果不添加此标记，那么重写后的源代码会输出到标准输出上。<br><code>-var</code> | <code>-var=GoCover</code> | 设置被添加到原先的源代码中的额外变量的名称</p><h2 id="程序文档"><a href="#程序文档" class="headerlink" title="程序文档"></a>程序文档</h2><p>使用<code>godoc</code>命令在本机启动一个可被用于查看本机所有工作区域中的所有代码包文档的web服务。</p><blockquote><p><code>godoc -http=:9090 -index</code></p></blockquote><h3 id="编写程序注释"><a href="#编写程序注释" class="headerlink" title="编写程序注释"></a>编写程序注释</h3><p>行注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//行注释</span><br></pre></td></tr></table></figure></p><p>块注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">块注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h3 id="代码包的注释"><a href="#代码包的注释" class="headerlink" title="代码包的注释"></a>代码包的注释</h3><p>对当前代码包的功能和用途进行总体性的介绍。被存放到当前代码包目录下的<code>doc.go</code>文件中。应有与包中其他源码文件相同的代码包声明语句，并在声明语句之上以块注释的方式插入代码包注释。</p><p>代码包注释总会出现在godoc命令生成的对应文档页面的首要位置上，即代码包注释会作为该代码包的文档的第一段说明出现。</p><h3 id="程序实体的注释"><a href="#程序实体的注释" class="headerlink" title="程序实体的注释"></a>程序实体的注释</h3><p>程序实体的文档即是它的声明代码以及紧挨着在上面的行注释。</p><h3 id="变量和变量的注释"><a href="#变量和变量的注释" class="headerlink" title="变量和变量的注释"></a>变量和变量的注释</h3><p>将注释描述统一放在常量或变量之上。</p><h3 id="文档中的示例"><a href="#文档中的示例" class="headerlink" title="文档中的示例"></a>文档中的示例</h3><p>代码包的文档页面中包含有针对性的示例代码。是godoc命令程序自动从代码中的测试源码文件中取得的。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些小技巧</title>
      <link href="/2018/04/20/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/04/20/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="使用shell真的很方便"><a href="#使用shell真的很方便" class="headerlink" title="使用shell真的很方便"></a>使用shell真的很方便</h2><p>在搭建此博客时参见某博客主的一个方案（没找到该博客，搭建时参考了很多），不使用hexo自带的hexo d，而是自己创建一个shell脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/cocowh.github.io</span><br><span class="line">cd .deploy/cocowh.github.io</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>执行编译后将编译好的public文件夹里的静态页面复制到自己的gitpage仓库，然后再切换到仓库目录执行git。</p><p>然后今天觉得hexo n也比较麻烦，执行后需要赋予权限，所以也利用shel直接将两个步骤进行了合并。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">hexo new $1</span><br><span class="line">chmod -R 777 source</span><br></pre></td></tr></table></figure></p><p>有时shell真的能给一些事情带来方便，根据场景多多使用，脚本小子，哈哈。</p>]]></content>
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程学习资料库</title>
      <link href="/2018/04/16/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%BA%93/"/>
      <url>/2018/04/16/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="编程资源收集"><a href="#编程资源收集" class="headerlink" title="编程资源收集"></a>编程资源收集</h2><ul><li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">EbookFoundation编程中文书籍索引</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">justjavac编程中文书籍索引</a></li></ul><h2 id="语言社区"><a href="#语言社区" class="headerlink" title="语言社区"></a>语言社区</h2><ul><li><a href="https://studygolang.com/" target="_blank" rel="noopener">go语言中文网</a></li><li><a href="https://laravel-china.org/" target="_blank" rel="noopener">laravel-china</a></li></ul><h2 id="安全社区"><a href="#安全社区" class="headerlink" title="安全社区"></a>安全社区</h2><ul><li><a href="https://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a></li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://github.com/changkun/modern-cpp-tutorial" target="_blank" rel="noopener">高速上手 C++11/14/17</a>（gitpage）</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2>]]></content>
      
      <categories>
          
          <category> 资料库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于golang的一些资料整理</title>
      <link href="/2018/04/16/%E5%85%B3%E4%BA%8EGolang%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/16/%E5%85%B3%E4%BA%8EGolang%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>大多数采集于<a href="https://github.com/justjavac/free-programming-books-zh_CN#go" target="_blank" rel="noopener">justjavac</a></p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="https://github.com/cocowh/books" target="_blank" rel="noopener">英文版系列书籍(go实战、web等pdf格式)</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md" target="_blank" rel="noopener">《Go入门指南》(gitpage)</a></li><li><a href="https://mikespook.com/learning-go/" target="_blank" rel="noopener">《学习Go语言》中文版(pdf+git)</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">《Go Web 编程》中文版(gitpage)</a></li><li><a href="https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/preface.md" target="_blank" rel="noopener">《go实战开发》(gitpage半成品)</a></li><li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="noopener">《Network programming with Go》中文版(gitpage)</a></li><li><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/" target="_blank" rel="noopener">《Go语言标准库》(git)</a></li><li><a href="https://github.com/hyper0x/go_command_tutorial" target="_blank" rel="noopener">《GO 命令教程》(gitpage)</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action" target="_blank" rel="noopener">《Go语言博客实践》(gitpage)</a></li><li><a href="https://www.ctolib.com/docs-magical-go-c-web-page-download.html" target="_blank" rel="noopener">《神奇的 Go 语言》(webpage)</a><!-- * [《深入解析Go》](https://github.com/tiancaiamao/go-internals) --></li></ul><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><ul><li><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></li><li><a href="http://gorevel.cn/docs/manual/index.html" target="_blank" rel="noopener">Revel 框架手册</a></li><li><a href="https://github.com/golang-china/golangdoc.translations" target="_blank" rel="noopener">Go 官方文档翻译</a></li></ul><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul><li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="noopener">《Go 编程基础》</a></li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 资料库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祝自己生日快乐</title>
      <link href="/2018/04/14/%E7%A5%9D%E8%87%AA%E5%B7%B1%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2018/04/14/%E7%A5%9D%E8%87%AA%E5%B7%B1%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
      <content type="html"><![CDATA[<h2 id="那些年阿"><a href="#那些年阿" class="headerlink" title="那些年阿"></a><center>那些年阿<center></center></center></h2><p> 四年就要混过去了，这是在大学过的第四个生日，回忆以前的每一年的这一天真是感慨万千！</p><h3 id="第一年，大一"><a href="#第一年，大一" class="headerlink" title="第一年，大一"></a>第一年，大一</h3><p> 大一的生活可以说是最不操心的。  </p><p> 初入大学，自己也没有目标，高三熬夜刷题养成了白天语文课睡觉的坏习惯，到了大学变本加厉。大一开始的日子，随波逐流，什么都想学，什么都想参加。面试学生会，加入吉他协会，打游戏，玩手游…没想过读研还是找工作，没想过大学该怎么走。</p><p>下学期生日，很巧的在这一个月里，班里差不多有四五名同学生日，每个人的生日都有所不同，慢慢的会发现，圈子在慢慢的形成。回想起那时，还是很幼稚青涩，脸皮薄，放不开，现在依旧如此。  </p><p>如果说上学期贪玩，下学期则是彻底的堕落。上学期有时上课还在前面认真听讲，下学期则是基本节节课睡觉。期末考试成绩烂的一塌糊涂，挂了一门主修课，替别人跑南湖，挂了体育。慢慢的开始思考自己的出路了，开始焦虑了。 </p><p>农村孩子，爸妈辛苦了这么多年，不容易，岁月催人老。  </p><p>可怜之人必有可恨之处，用在自己毫不过分。眼高手低，眼不着地。</p><h3 id="第二年，大二"><a href="#第二年，大二" class="headerlink" title="第二年，大二"></a>第二年，大二</h3><p>如过时间可以重来过的话，要学会对自己的每一句话负责。明晰自己的喜好，取自己所需，争自己想得。学会做人做事留有余地。  </p><p>这一年，班里变化很大，一个网瘾太大当兵退学了，几个挂科严重留级了。这学期开始自己也开始认真学习了，该掉了上课睡觉的毛病，因为想要读研，也因为她。   </p><p>她，感谢她的陪伴和前期的包容，对不起。 如果说恋爱是一门学问的话，我应该还在小学生级别，青涩不勇敢，使你承担了太多。在最美好的的时间里遇见不是很合适、也没有能够好好珍惜的人，如今看来，谈不上遗憾，只是一段经历了。有个疙瘩是跟班里的一个女同学因她闹僵了，唉～如今都找到工作了，祝我们都有美好的明天。  </p><p>上学期的考试成绩还不错，努力也有了收获，但是跟那些学霸级的还是没的比，期末考试那段时间也是挺纠结的。期末前和同学加入了计协web组，一个刚成立的组，感谢这个选择，大学总学了点什么。</p><p>下学期的时间基本都是在逸夫楼度过的。开始带我们的是一个很厉害的学姐，学期初她在忙着找实习，工作室还有另一个学长也在找实习，学姐找到了很好的实习，去了腾讯，然而学长学的不好，找实习都很难找。给我很大的压迫感，有种大学就要结束了，明天就要毕业了的感觉，而我大学什么都没学会，担心自己的以后。学期初的心情很是不好，上学期期末和寒假、开学丢手机、努力一学期成绩仅仅为中上、跟同学关系闹僵等等。此时将所有的情绪都放在了努力学习web开发上，不停的学习，有时为了弄好一个东西很晚才回宿舍。  </p><p>生日前不久跟一起加入工作室的同学关系也弄僵了，以前关系还可以，开学时的情绪一直持续了很久，那时也久久未平，闹僵的原因就不说了，很大原因自己小气吧。生日那天也在忙着学习，忙着配置搭建服务器，十点多舍友发消息问几点回宿舍才知道给准备了生日蛋糕，很是感动。很可惜后来跟他的关系也闹僵了。    </p><p>这一年宿舍的关系也不好，两个舍友闹僵了，大二上学期我还想着找机会聚一聚缓和以下这两位舍友的关系，可惜其中一位不愿意，很是遗憾。现在想想也无所谓了，本性都是自私自利的，性格也相差太大，不能够互相包容。</p><p>如果说大学最大的改变，就是在这学期形成的吧。不相信任何人，不相信任何事，不能够包容，自私自利。拿得起，放不下。但是也找到了自己的目标，找到了自己的方向，最大的收获，也在这年。</p><h3 id="第三年、大三"><a href="#第三年、大三" class="headerlink" title="第三年、大三"></a>第三年、大三</h3><p>业精于勤荒于嬉，行成于思毁于随。  </p><p>上学期开始就退出工作室了，对工作室产生了意见。环境太吵闹，没有学习和做技术的感觉，静不下心。开学初，和同学合作做了第二个小项目，很简单很low，九月下旬接了一个页面小项目。然后这学期比较堕落，微信公众号开发了解皮毛，前端学习也是混，没怎么精进，也没好好上课，回归了游戏的老本行。  这一学期，技术没什么长进，吃老本原地踏步。</p><p>可怜之人必有可恨之处阿，下学期开始准备春招找实习了，结果很遗憾，除了最开始的作业帮没有一个offer，然而自己开始拒了作业帮的offe想要找到更好的r。这一学期还是找不准自己的工作方向，前端弄一点，后端看一点，投的也很乱。技术上除了学了下vue，php基础巩固了以下，专业课基础知识回忆巩固了下，其他长进很少。找实习找的很焦虑，最后跟了学校实习。</p><p>这学期跟班里几个同学一期报名了学车，一边找实习一边学车，生日那天，请一起练车的同学 吃了顿饭，也算是为自己庆祝生日了。   </p><p>感谢大三暑假的勇敢，感谢新浪面试官的答疑解惑，坚持了php的路，没半路又转java，实习前接了个公众号开发的项目，跟校企合作的实习公司请假做自己的项目，事实证明是对的。</p><h3 id="第四年、大四"><a href="#第四年、大四" class="headerlink" title="第四年、大四"></a>第四年、大四</h3><p>行道水穷处，坐看云起时。</p><p>上学期主要就在准备秋招了，投了很多公司，感觉比春招找实习要难很多。基本的生活节奏就是投简历、笔试、面试，这时已经确定了自己的方向，做php。很遗憾的是好几个大公司在笔试就被刷掉了，还有些公司没注意到就已经招完了。班里的同学拿到好offer的也很少，可以说没几个，考研的在努力跑图书馆跑教室，保研的就很舒服了。十月国庆回家返校后开始怀疑自己的方向了，有放弃转java的念头，相关的岗位太少了。最后在十月底第二次跑校宣时收获了第一个较理想的offer，之前有武汉小公司的offer，看不上，没接受。之所以说较理想，是因为上市公司给的薪资高，超出自己预期很多，比肩一线互联网公司甚至超过，但是公司非互联网，技术上较BAT等互联网公司有很大差距，不知道以后发展会怎么样。或许面试真的看缘分的，还有校宣机会真的很重要，这仅仅是跑第二次校宣。感谢陪我跑校宣的同学，第一次一起去的武汉理工录取了他，第二次取得武大录取了我，如果他不去我可能也不会去了，就错失去了这个机会，祝我们都有美好的明天。  </p><p>拿到offer后就很堕落了，想做技术上的学习总是静不下心，天天睡到自然醒，吃喝玩乐。最后学期末选毕设，坑开始了，老师太认真，放假还留学校做了十天。</p><p>这学期也是大部分时间都耗在毕设上了，想去实习都没有足够的时间了，被hr挽拒。每周的生活是检查上周的任务，布置这周的任务，每天看代码，看相关的文档，翻译文档，写总结。越做越烦，毁不该没去跟同学一起去养猪公司混毕设的想法越来越明显。</p><p>前段时间正式的学习了golang的语法知识，golang的底层也是c和汇编，做的毕设正式c和汇编为主，而自己的主要是c部分，php的底层学习拓展也要用到c，希望自己能够坚持把毕设搞下去，将c语言再好好学习一遍，收获一定会很大。徐老师是个好老师，可以说是非常的尽职尽责了，毕设相关的软硬件平台，相关资料全部给我们找好了，有不懂的可以随时问他，只能说自己不争气阿，惰性十足。</p><p>这两周坚持了几天的夜跑，看来又是三天打鱼两天晒网了，明天继续跑吧。</p><p>今天的生日，又在逸夫楼看了一天的代码，唉～后天又要检查。感谢爸妈姐姐的祝福，祝福爸妈和两个姐姐身体健康、两个姐姐家庭幸福、外甥外女健康快乐成长！</p><p>23了，要毕业了，要工作了，愿能够顺利开心毕业，愿工作如意，愿所有是非烟消云散，愿我们都有美好的明天！</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(四)</title>
      <link href="/2018/04/13/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%9B%9B/"/>
      <url>/2018/04/13/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="Go流程控制像C，也有很多方面与C不同："><a href="#Go流程控制像C，也有很多方面与C不同：" class="headerlink" title="Go流程控制像C，也有很多方面与C不同："></a>Go流程控制像C，也有很多方面与C不同：</h2><ul><li>没有do和while循环，只有更加广义的for。</li><li>switch更加灵活，可以被用于进行类型判断。</li><li>与for类似，if和switch语句都可以接受一个可选的初始化语句。</li><li>支持在break语句和continue语句之后跟一个可选的标记（Label）语句，表示需要终止或继续的代码块。</li><li>有类似多路转接器的select语句。</li><li>语句可以被用于地启用Coroutine。</li><li>使用defer语句可以更方便地执行异常捕获和资源回收任务。</li></ul><hr><h2 id="基本流程控制"><a href="#基本流程控制" class="headerlink" title="基本流程控制"></a>基本流程控制</h2><h3 id="代码块和作用域"><a href="#代码块和作用域" class="headerlink" title="代码块和作用域"></a>代码块和作用域</h3><p>由花括号“{”和“}”括起来的若干表达式和语句的序列。不包含任何内容为空代码块。<br>隐式代码块：  </p><ul><li>Go语言源码，全域代码块。</li><li>代码包，代码包代码块。</li><li>源码文件，源码文件代码块。</li><li>每个if语句、for语句、switch语句和select语句都是一个代码块。</li><li>每个switch或select语句中的字句都是一个代码块。</li></ul><p>每一个标识符都有它的作用域，使用代码块表示作用域范围：  </p><ul><li>预定义标识符作用域全局代码块。</li><li>代表常量、类型、变量或函数的、被声明在顶层的标识符的作用域时代码包代码块。</li><li>…</li></ul><p>可以重声明外层代码块声明过的标识符，将外层同名标识符屏蔽。</p><blockquote><p>Go通过标示符首字母的大小写控制对应程序实体的访问权限，标示符首字母大写则其对应的程序实体可被本代码包之外的代码访问到，即可导出的。小写则对应的程序实体就只能被本包内的代码访问。</p></blockquote><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><h4 id="组成和编写方法"><a href="#组成和编写方法" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>条件表达式可不用括号括起来，条件表达式之后和else关键字之后必须由花括号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if 100 &lt; number &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">if diff := 100 - number; 100 &lt; number &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else if 200 &lt; diff&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if语句接受一条初始化语句。</p><h4 id="惯用法"><a href="#惯用法" class="headerlink" title="惯用法"></a>惯用法</h4><p>作为卫述语句用来检查关键的先决条件的合法性并在检查未通过的情况下立即终止当前代码块的执行的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">标准库代码包os函数</span><br><span class="line">func Open(name string) (file *File, err error)</span><br><span class="line">/*</span><br><span class="line">f, err := os.Open(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func update(id int,deptment) bool&#123;</span><br><span class="line">    if id &lt;= 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">func update(id int,deptment) errorl&#123;</span><br><span class="line">    if id &lt;= 0 &#123;</span><br><span class="line">        return errors.New(&quot;The id is INVALID&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //todo</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="组成和编写方式"><a href="#组成和编写方式" class="headerlink" title="组成和编写方式"></a>组成和编写方式</h4><p>同其他（C/C++等）语言，判定条件无括号。</p><h4 id="表达式switch语言"><a href="#表达式switch语言" class="headerlink" title="表达式switch语言"></a>表达式switch语言</h4><p>选择case执行后直接忽略其他case，而不需要break打断，没有case选择执行则执行default case，default case非必须作为最后一个case出现。不同于其他语言，break的使用方法也有些不一样。条件表达式可不用括号括起来，可接受一条初始化语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch content := getContent(); content &#123;</span><br><span class="line">    default:</span><br><span class="line">        ftm.Println(&quot;Unknown language&quot;)</span><br><span class="line">    case &quot;PHP&quot;:</span><br><span class="line">        ftm.Println(&quot;Protect Hair Prefact&quot;)</span><br><span class="line">    case &quot;Java&quot;:</span><br><span class="line">        ftm.Println(&quot;shit language&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在除了最后一条case语句的每一条case语句中的语句列表的最后一条语句可以是fallthrough语句，会将流程控制权转移到下一条case语句上。可以把多个case值放在一个case上。break语句被执行，包含它的switch语句、for语句或selet语句的执行会被立即终止执行，流程控制权被转移到这些语句后面的语句上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch content := getContent(); content &#123;</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;wuhua is cool&quot;)</span><br><span class="line">    case &quot;smart&quot;:</span><br><span class="line">        fallthrough</span><br><span class="line">    case &quot;fool&quot;:</span><br><span class="line">        break</span><br><span class="line">        fmt.Println(&quot;Bye&quot;)</span><br><span class="line">    case &quot;cute&quot;, &quot;handsome&quot;, &quot;honest&quot;:</span><br><span class="line">        fmt.Println(&quot;yes, he is&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="类型seitch语句"><a href="#类型seitch语句" class="headerlink" title="类型seitch语句"></a>类型seitch语句</h4><p>对类型进行判断而不是值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">switch v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;The string is &apos;%s&apos;.\n&quot;,v.(string))</span><br><span class="line">    case int, uint, int8, uint64:</span><br><span class="line">        fmt.Printf(&quot;The integer is %d.\n&quot;,v)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unsupported value.(type = %T).\n&quot;,v)</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">switch i := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;The string is &apos;%s&apos;.\n&quot;, i)</span><br><span class="line">    case int, uint, int8, uint64:</span><br><span class="line">        fmt.Printf(&quot;The integer is %d.\n&quot;, i)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unsupported value.(type = %T).\n&quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>fallthrough语句不允许出现在类型switch语句中的任何case语句的语句列表中。</p></blockquote><h4 id="惯用法-1"><a href="#惯用法-1" class="headerlink" title="惯用法"></a>惯用法</h4><p>替换串连if语句。在switch表达式缺失时，判定目标被时为布尔值true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch number := 1995; &#123;</span><br><span class="line">    case number &lt; 1990:</span><br><span class="line">        fmt.Println(&quot;90前&quot;)</span><br><span class="line">    case number &gt;= 2000:</span><br><span class="line">        fmt.Println(&quot;00后&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;90后&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><h4 id="组成和编写方法-1"><a href="#组成和编写方法-1" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>同其他语言。若无条件，则true将会作为缺省的条件。</p><h4 id="for子句"><a href="#for子句" class="headerlink" title="for子句"></a>for子句</h4><p>一条for语句可以携带一个for字句提供条件对迭代进行控制。由初始化字句、条件、后置字句组成，同其他语言。省略括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">var j uint = 1;</span><br><span class="line">for ;j % 5 != 0; j *= 3&#123;</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">for k := 1; k % 5 != 0; &#123;</span><br><span class="line">    k *= 3</span><br><span class="line">    number++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="range子句"><a href="#range子句" class="headerlink" title="range子句"></a>range子句</h4><p>for语句可携带一个range子句，迭代出一个数组或切片值中的每个元素、一个字符串中的每个字符或者一个字典之中的每个键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ints := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">for i,d := range ints &#123;</span><br><span class="line">    fmt.Printf(&quot;%d: %d\n&quot;, i, d)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">ints := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">length := len(ints)</span><br><span class="line">indexesMirror := make([]int, length)</span><br><span class="line">elementsMirror := make([]int, length)</span><br><span class="line">var i int</span><br><span class="line">for indexesMirror[length - i - 1],elementsMirror[length - i - 1] = range ints&#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随着range表达式的结果值的不同，range字句会有不同的表现：  </p><ul><li>数组、数组指针、切片，range循环的迭代产出值可以是一个也可以是两个。迭代顺序与索引递增顺序一致。第一个产出值为索引，第二个为索引对应元素值。</li><li>字符串，遍历其Unicode代码点。第一个产出值为索引，第二个为索引对应元素值，类型为rune。</li><li>字典，迭代顺序不固定，迭代过程中键值对被删除，相应的迭代值不会被产出，新增，相应的迭代值是否被产出不确定。第一个产出值为键值对中键的值，第二个为与键对应元素值。</li><li>通道类型，迭代效果类似于连续不断的从该通道中接收元素值，直到通道被关闭。若通道为nil，range表达式被永远阻塞。每次迭代，仅会产出一个通道类型值。</li></ul><h4 id="惯用法-2"><a href="#惯用法-2" class="headerlink" title="惯用法"></a>惯用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m := map[uint]string&#123;1:&quot;A&quot;, 6:&quot;C&quot;, 7:&quot;B&quot;&#125;</span><br><span class="line">var maxKey uint</span><br><span class="line">for k := range m &#123;</span><br><span class="line">    if k &gt; maxKey &#123;</span><br><span class="line">        maxKey = k</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">var values []string</span><br><span class="line">for _, v := range m &#123;</span><br><span class="line">    values = append(values, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用break终止for循环，可配合标记（Lable）语句一起使用。一条标记语句可以成为goto语句、break语句、continue语句的目标。标记语句中的标记只是一个标识符，可以放在任何语句的左边以作为这个语句的标签，标记和被标记的语句之间用冒号“:”来分隔。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">    for k, v := range namesCount&#123;</span><br><span class="line">        //todo</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在break语句后跟标记，意味着终止执行的对象就是标记代表的那条语句。continue只在for语句中使用，会是直接包含它的那个for循环直接进入下一次迭代。在continue后跟标记，意味着跳过后面的执行语句，开始执行标记代表的那条语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var namesCount map[string]int</span><br><span class="line">//为用户昵称及其重复次数，统计只包含中文的用户昵称的计数信息</span><br><span class="line">targetsCount := make(map[string]int)    </span><br><span class="line">for k,v := range namesCount &#123;</span><br><span class="line">    matched := true</span><br><span class="line">    for _,r := range k &#123;</span><br><span class="line">        if r &lt; &apos;\u4e00&apos; || r &gt; &apos;\u9fbf&apos; &#123;</span><br><span class="line">            matched = false</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if !matched &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    targetsCounts[v] = v</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">targetsCount := make(map[string]int)    </span><br><span class="line">L:</span><br><span class="line">    for k,v := range namesCount &#123;</span><br><span class="line">        for _,r := range k &#123;</span><br><span class="line">            if r &lt; &apos;\u4e00&apos; || r &gt; &apos;\u9fbf&apos; &#123;</span><br><span class="line">               continue L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        targetsCounts[v] = v</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用for循环反转一个切片类型值中的所有元素值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i, j := 0, len(numbers) - 1; i &lt; j; i ,j = i + 1, j -1&#123;</span><br><span class="line">    numbers[i], numbers[j] = numbers[j], numbers[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>把流程控制权限无条件转移到标记所代表的语句上。</p><h4 id="组成和编写方法-2"><a href="#组成和编写方法-2" class="headerlink" title="组成和编写方法"></a>组成和编写方法</h4><p>只能与标记语句连用。需要注意goto语句跳过的某些声明语句，导致标签所代表的语句缺少应有的变量。标记语句的直属代码块应为goto语句的直属代码块的外层代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    if n % 3 != 0 &#123;</span><br><span class="line">        goto L</span><br><span class="line">    &#125;</span><br><span class="line">    switch &#123;</span><br><span class="line">        case n % 7 == 0:</span><br><span class="line">            n = 200</span><br><span class="line">            fmt.Printf(&quot;%v is a common multiple of 7 and 3.\n&quot;, n)</span><br><span class="line">        default:</span><br><span class="line">    &#125;</span><br><span class="line">L1:</span><br><span class="line">    fmt.Printf(&quot;%v isn&apos;t a multiple of 3.\n &quot;, n)</span><br></pre></td></tr></table></figure></p><h4 id="惯用法-3"><a href="#惯用法-3" class="headerlink" title="惯用法"></a>惯用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//查找name中的第一个非法字符并返回</span><br><span class="line">//如果返回的是空字符就是明name中不包含任何非法字符</span><br><span class="line">func findEvildoer(name string) string &#123;</span><br><span class="line">    var evildoer string</span><br><span class="line">    for _, r := range name &#123;</span><br><span class="line">            switch &#123;</span><br><span class="line">                case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">                case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">                case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">                default:</span><br><span class="line">                    evildoer = string(r)</span><br><span class="line">                    goto L1</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goto L2</span><br><span class="line">L1:</span><br><span class="line">    fmt.Printf(&quot;The first evildoer of name &apos;%s&apos; is &apos;%s&apos; !\n&quot;, name, evildoer)</span><br><span class="line">L2:</span><br><span class="line">    return evildoer</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func findEvildoer(name string) string &#123;</span><br><span class="line">    var evildoer string</span><br><span class="line">L1:</span><br><span class="line">    for _, r := range name &#123;</span><br><span class="line">            switch &#123;</span><br><span class="line">                case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">                case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">                case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">                default:</span><br><span class="line">                    evildoer = string(r)</span><br><span class="line">                    break L1</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if evildoer != &quot;&quot;&#123;</span><br><span class="line">        fmt.Printf(&quot;The first evildoer of name &apos;%s&apos; is &apos;%s&apos; !\n&quot;, name, evildoer)</span><br><span class="line">    &#125;</span><br><span class="line">    return evildoer</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func checkValidity(name string) error &#123;</span><br><span class="line">    var srrDetail string</span><br><span class="line">    for i, r := range name &#123;</span><br><span class="line">        switch &#123;</span><br><span class="line">            case r &gt;= &apos;\u0041&apos; &amp;&amp; r &lt;= &apos;\u005a&apos;: //a-z</span><br><span class="line">            case r &gt;= &apos;\u0061&apos; &amp;&amp; r &lt;= &apos;\u007a&apos;: //A-z</span><br><span class="line">            case r &gt;= &apos;\u4e00&apos; &amp;&amp; r &lt;= &apos;\u9fbf&apos;: //中文字符</span><br><span class="line">            case r == &apos;_&apos; || r == &apos;-&apos; || r == &apos;.&apos;:</span><br><span class="line">            default:</span><br><span class="line">                    errDetail = &quot;The name contains some illagal characters.&quot;</span><br><span class="line">                    goto L</span><br><span class="line">        &#125;</span><br><span class="line">        if i == 0 &#123;</span><br><span class="line">            switch r &#123;</span><br><span class="line">                case &apos;_&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;_&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">                case &apos;-&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;-&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">                case &apos;.&apos;:</span><br><span class="line">                errDetail = &quot;The name can not begin with a &apos;.&apos;.&quot;</span><br><span class="line">                goto L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">L:</span><br><span class="line">    return errors.New(&quot;Validity check failure:&quot; + errDetail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其它语言编程风格一样，为代码简洁清晰，有节制使用goto。</p><hr><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>特有的流程控制语句，被用于预定对一个函数的调用，称为延迟函数，只能出现在方法或者函数的内部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer fmt.Println(&quot;The finishing touches.&quot;)</span><br></pre></td></tr></table></figure></p><p>外围函数（调用defer的函数）执行的结束会由于defer语句的执行而被推迟，所有的defer语句执行完，外围函数才执行结束。  </p><p>使用defer语句执行释放资源或异常处理等收尾任务。</p><p>defer语句调用函数的参数会按普通从上到下的执行顺序初始化，但defer语句调用的函数仅在外围函数的执行将要结束时才会执行，可将defer语句置于函数或方法体内任何位置。多个defer语句的函数的顺序调用，按LIFO的执行顺序，但参数按FIFO的顺序初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">defer func()&#123;</span><br><span class="line">    fmt.Println(&quot;The finishing touches.&quot;)</span><br><span class="line">&#125;()//调用匿名函数</span><br><span class="line">---</span><br><span class="line">func start(tag string) string&#123;</span><br><span class="line">    fmt.Ptintf(&quot;start function %s.\n&quot;, tag)</span><br><span class="line">    return tag</span><br><span class="line">&#125;</span><br><span class="line">func finish(tag string) &#123;</span><br><span class="line">    fmt.Printf(&quot;finish function %s.\n&quot;, tag)</span><br><span class="line">&#125;</span><br><span class="line">func tag()&#123;</span><br><span class="line">    defer finish(start(&quot;sign&quot;))</span><br><span class="line">    fmt.println(&quot;record the tag  sign&quot;)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    start function sign</span><br><span class="line">    record the tag sign</span><br><span class="line">    finish function sign</span><br><span class="line">*/</span><br><span class="line">---</span><br><span class="line">func printNumbers() &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    4 3 2 1 0</span><br><span class="line">*/</span><br><span class="line">---</span><br><span class="line">func printNumbers() &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">       defer func() &#123;</span><br><span class="line">           fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    5 5 5 5 5</span><br><span class="line">*/</span><br><span class="line">//defer 在循环结束后执行，此时i = 5，未传参，引入的是外层变量i。</span><br><span class="line">---</span><br><span class="line">func modify(n int) (number int) &#123;</span><br><span class="line">    defer func(plus int) (result int) &#123;</span><br><span class="line">        result = n + plus   //result初始0，result = 2 + 3 = 5</span><br><span class="line">        number += result    //number = 1 + 5 = 6</span><br><span class="line">        return</span><br><span class="line">    &#125;(3)</span><br><span class="line">    number++    //指定结果初始零值0，number = 0 + 1 = 1</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    modify(2) = 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>使用error类型值表明非正常的状态。属于预定义标识符，代表Go语言内建的接口类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Error为方法调用提供当前错误的详细信息。任何数据类型只要实现这个可以返回string类型值的Error方法就可以成为一个error接口类型的实现。标准库代码包errors提供用于创建error类型值的函数New。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func New(text string) error &#123;</span><br><span class="line">    return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line">type errorString struct &#123;</span><br><span class="line">    s string</span><br><span class="line">&#125;</span><br><span class="line">func (e *errorString) Error () string &#123;</span><br><span class="line">    return e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传递给errors.New函数的参数值是调用它的Error方法的时候返回的结果值，即传递给errors.New的参数值是其返回的error类型值的字符串表示形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(&quot;%s\n&quot;, &quot;A normal error.&quot;)</span><br></pre></td></tr></table></figure></p><p>fmt&gt;Errorf函数根据格式说明符和后续参数生成一个字符串类型值，用此字符串类型值初始化一个error类型值并作为结果值返回给调用方。fmt.Errorf函数内部，创建和初始化error类型值的操作通过调用errors.New函数完成。  </p><p>可根据需要定义自己的error类型。例如osPathError：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string   //&quot;Open&quot;, &quot;unlink&quot;,etc</span><br><span class="line">    Path string //The associated file</span><br><span class="line">    Err error   //Returned bu the system call</span><br><span class="line">&#125;</span><br><span class="line">func (e *PathError) string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对此例，通常为遵循面向接口编程的原则，函数或方法中的相关结果声明的类型应该是error类型，不该是某一个error类型的实现类型。需要先判定获取到的error类型值的动态类型，再依此来进行必要的类型转换和后续操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(&quot;/etc/profile&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    if pe, ok := err.(*os.PathError); ok&#123;</span><br><span class="line">        fmt.Printf(&quot;Path Error: %s (op = %s, path = %s)&quot;, pe,Err, pe.Op, pe.Path)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;Uknown Error: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h3><p>不应该通过调用painc函数来报告普通的错误，而应该把它作为报告致命错误的一种方式。</p><h4 id="painc"><a href="#painc" class="headerlink" title="painc"></a>painc</h4><p>用于报告程序运行期间的、不可恢复的错误状态，停止当前控制流程的执行并报告一个运行时的恐慌。接受任意类型的参数值，通常是string或者error类型。  </p><p>运行时恐慌会沿着调用栈方向进行传达，直至到达当前Goroutine(Go程，一个能够独占一个系统线程并在其中运行程序的独立环境)调用栈的顶层。此时当前Goroutine的调用栈的所有函数的执行都被停止，意味着程序崩溃。运行时恐慌也可以由Go语言的运行时系统来引发。</p><h4 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h4><p>运行时恐慌一旦被引发就会像调用方传递直至程序崩溃。recover函数可以“拦截”运行时恐慌，将当前程序从运行时恐慌的状态中恢复并重新获得流程控制权。<br>defer语句重的延迟函数总会执行，只有在defer语句的延迟函数中调用recover函数才能够起到“拦截”运行时恐慌的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">//import **</span><br><span class="line">func main() &#123;</span><br><span class="line">    fetchDemo()</span><br><span class="line">    fmt.Println(&quot;The main function is excuted.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func fetchDemo()&#123;</span><br><span class="line">    defer func()&#123;</span><br><span class="line">        if v := recover(); v!= nil &#123;</span><br><span class="line">            fmt.Printf(&quot;Recovered a painc.[index = %d]\n&quot;, v)</span><br><span class="line">        &#125;打印语句</span><br><span class="line">    &#125;()</span><br><span class="line">    ss := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</span><br><span class="line">    fmt.Printf(&quot;Fetch the elements in %v one by one...\n&quot;,ss)</span><br><span class="line">    fetchElement(ss, 0)</span><br><span class="line">    fmt.Println(&quot;The elements fetching is done.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func fetchElement(ss []string, index int) (element string) &#123;</span><br><span class="line">    if index &gt;= len(ss) &#123;</span><br><span class="line">        fmt.Printf(&quot;Occur a panic! [index = %d]\n&quot;, index)</span><br><span class="line">        panic(index)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt,Printf(&quot;Fetching the element...[index = %d]\n&quot;,index)</span><br><span class="line">    element = ss[index]</span><br><span class="line">    defer fmt.Printf(&quot;The element is \&quot;%s\&quot;.[index = %d]&quot;, element, index)打印语句</span><br><span class="line">    fetchElement(ss, index + 1)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1:  Fetch the elements in [A B C ] one by one...</span><br><span class="line">2:  Fetching the element...[index = 0]</span><br><span class="line">3:  Fetching the element...[index = 1]</span><br><span class="line">4:  Fetching the element...[index = 2]</span><br><span class="line">5:  Occur a panic! [index = 3]</span><br><span class="line">6:  The element is &quot;C&quot;.[index = 2]</span><br><span class="line">7:  The element is &quot;B&quot;.[index = 1]</span><br><span class="line">8:  The element is &quot;A&quot;.[index = 0]</span><br><span class="line">9:  Recovered a painc.[index = 3]</span><br><span class="line">10: The main function is excuted.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>索引超出主动引发运行时恐慌沿着调用栈逐一向上层传达，在向上层传达前只执行本代码块（fetchElement）的defer语句的函数。直到上层（fetchDemo）在传达恐慌前执行defer中recover函数“拦截”恐慌，此时意味着此层代码已经执行结束，打印语句<br>  fmt.Println(“The elements fetching is done.”)<br>没能够执行。调用fetchDemo的mian函数重获流程控制权限。<br>常用处理：</p><blockquote><p>程序实体内部发生运行时恐慌，会在被传递给调用方之前被“平息”并以error类型值的形式返回给调用方。<br>应该在遇到知名的、不可恢复的错误状态时才去引发一个运行时恐慌，否则可以利用函数或方法的结果值来向程序调用方传达错误状态。<br>应该仅在程序处理模块的边界位置上的函数或方法中对运行时恐慌进行“拦截”和“平息”。  </p></blockquote>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(三)</title>
      <link href="/2018/04/12/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/"/>
      <url>/2018/04/12/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="数据的使用"><a href="#数据的使用" class="headerlink" title="数据的使用"></a>数据的使用</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>若值x可以被赋给类型为T的变量，则：</p><ul><li>值x的类型是T。</li><li>值x的类型是V，V和T具有相同的潜在类型，V和T至少有一个是未命名的类型。</li><li>类型T是一个接口类型，值x的类型实现了T。</li><li>值x是一个双向通道类型的值，T是一个通道类型。</li><li>值x是预定义标识符nil，可赋给切片、字典、函数、接口、指针、通道等类型的变量。</li><li>值x是一个由某个数据类型的值代表的无类型的常量，可以被赋给该数据类型的变量。</li><li>所有值都可以赋给空标识符“_”。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ints = []int&#123;1, 2, 3&#125;</span><br><span class="line">ints[1], ints[2] = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], _ = (ints[1] + 1), (ints[2] + 2)</span><br><span class="line">ints[1], ints[2] = (ints[1] * (ints[0] + 1)), (ints[2] * (ints[0] + 2))</span><br><span class="line">i1 += 1 //i1 = i1 + 2</span><br><span class="line">i2 &amp;= 2 &lt;&lt; 3 //i2 = i2 &amp; (2&lt;&lt;3)</span><br></pre></td></tr></table></figure><p>“=”两边的表达式的数量不相等，左边可以有多个，对于右边的唯一表达式有：  </p><ul><li>表达式是一个调用会返回多个结果的函数或者方法的表达式。</li><li>表达式是一个应用于字典之上的索引表达式。v, ok := map[“k”]。</li><li>表达式是一个类型断言表达式。v, ok ：= x.(string)。</li><li>表达式是一个由接收操作符和通道类型值组成的表达式。v,ok := &lt;-ch。  </li></ul><p>除此之外赋值操作符两边的表达式数量必须一致，并都都是单值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">s := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</span><br><span class="line">i,s[i-1] = 2, &quot;Z&quot;</span><br></pre></td></tr></table></figure></p><p>s值是[]string{“Z”, “B”, “C”}而不是[]string{“A”, “Z”, “C”}，对表达式i-1的求值先于赋值，在赋值之前，第二个赋值对象被确定为s[0]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a             //交换变量值</span><br><span class="line">x := []int&#123;1, 2, 3&#125;     //切片初始化</span><br><span class="line">x[0], x[0] = 1, 2       //从做到有执行最终x[0=2</span><br><span class="line">x[2], x[3] = 4, 5       //索引超范围引发恐慌，但x[2]=4已被变更</span><br></pre></td></tr></table></figure></p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>某量保持不变称为常量，否则称为变量。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量在编译期间被创建，作为局部变量被定义在函数内部，由字面量或常量表达式赋值。  </p><p>分为布尔常量、rune常量（字符常量）、整数常量、浮点数常量、复数常量和字符串常量。  </p><p>常量可以是有类型的也可以是无类型，可以被显式地给定类型，也可以被隐含地给定类型。  </p><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><p>仅以常量作为操作数的表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 + 3.0         //无类型的浮点数常量5.0</span><br><span class="line">15 / 4.0        //无类型的浮点数常量3.75</span><br><span class="line">&apos;w&apos; + 1         //无类型的rune常量&apos;x&apos;</span><br><span class="line">---</span><br><span class="line">1 &lt;&lt; 3.0        //无类型整数常量8</span><br><span class="line">1.0 &lt;&lt;3         //无类型整数常量8</span><br><span class="line">1 &lt;&lt; 100        //无类型的整数常量1267650600228229401496703205376超出范围</span><br><span class="line">---</span><br><span class="line">&quot;A&quot; &gt; &quot;C&quot;       //无类型的布尔常量false</span><br></pre></td></tr></table></figure></p><h5 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h5><p>使用关键字const将字面常量或常量表达式与标识符绑定在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const untypedConstant = 10.0    //无类型常量</span><br><span class="line">const typedConstant int64 = 1024  //类型为int64的常量</span><br><span class="line"></span><br><span class="line">const tc1, tc2, tc3 int64 = 1024, -10, 88 //平行赋值</span><br></pre></td></tr></table></figure></p><p>左侧只允许插入一个类型字面量，规定作则标识符的类型，右侧的常量类型需与其一致，未给定类型，则右侧常量类型彼此独立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const utc1, utc2, utc3 = 6.3, false, &quot;C&quot;</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc  = 6.3</span><br><span class="line">    utc2 = false</span><br><span class="line">    utc3 = &quot;c&quot;</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;c&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>并不需要显式的对所有常量赋值，被省略赋值的常量，会被隐含地赋与其上面的、最近的且被显式赋值的那个常量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false恒等</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4</span><br><span class="line">    utc5 </span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    utc1, utc2 = 6.3, false</span><br><span class="line">    utc3       = &quot;C&quot;</span><br><span class="line">    utc4       = &quot;C&quot;</span><br><span class="line">    utc5       = &quot;C&quot;</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    utc1         =       6.3</span><br><span class="line">    utc2, ytc3   =   false, &quot;C&quot;</span><br><span class="line">    utc4, utc5</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line">对此有规则：  </span><br><span class="line">* 若有未被显式赋值的常量，同一行的常量的赋值都必须被省略。</span><br><span class="line">* 未显式赋值的那一行的常量声明中的常量标识符数量必须与在它上面的、最近的且显式赋值的那一行常量声明中的常量标识符的数量相等。</span><br><span class="line"></span><br><span class="line">iota代表了连续的、无类型的整数常量，第一次出现在一个以const开始的常量声明语句中的时候总会表示整数常量0。随着在同一条常量声明语句中包含iota的常量的递增，iota所表示的整数值也会递增。</span><br><span class="line">```code</span><br><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    c = 2</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; iota</span><br><span class="line">    v</span><br><span class="line">    w</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1 &lt;&lt; 0</span><br><span class="line">    v = 1 &lt;&lt; 1</span><br><span class="line">    w = 1 &lt;&lt; 2恒等</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    u = 1</span><br><span class="line">    v = 2</span><br><span class="line">    w = 4</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">    e, f = 0, 1</span><br><span class="line">    g, h = 1, 2</span><br><span class="line">    i, j = 2, 4 </span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">const (</span><br><span class="line">    e, f = iota, 1 &lt;&lt; iota</span><br><span class="line">    _, _</span><br><span class="line">    g, h</span><br><span class="line">    i, j</span><br><span class="line">)</span><br><span class="line">=</span><br><span class="line">const (</span><br><span class="line">     e, f = 0, 1</span><br><span class="line">     g, h = 2, 4</span><br><span class="line">     i, j = 3, 8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>在同一条常量声明语句中，iota代表的整数常量的是否递增取决于是否又有一个常量声明包含了它，而不是它是否又在常量声明中出现了一次。可用空标识符“_”跳过iota表示的递增序列中的某个或某些值。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在声明之后可以被赋值任意次，值在程序运行期间才被计算。</p><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>以关键字var开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v int64 = 0 //声明变量的类型</span><br><span class="line">var x = 0       //省略变量的类型</span><br></pre></td></tr></table></figure></p><p>变量的类型未被显示指定将由变量值推导得出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    v1 = 0</span><br><span class="line">    v2 = -1</span><br><span class="line">)</span><br><span class="line">---</span><br><span class="line">var v3, v4, v5 float64</span><br><span class="line">=</span><br><span class="line">var v3, v4, v5 float64 = 0.0, 0.0, 0.0</span><br></pre></td></tr></table></figure></p><p>隐式赋值在变量声明中不可用，未被显示赋值的变量值将会是与改变量的类型相对应的零值，此时变量的类型不可省略。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>变量声明可以作为源码文件中的顶级元素，也可以称为函数体内容的一部分，前者全局变量，后者局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">var v6 bool //全局变量</span><br><span class="line">func main()&#123;</span><br><span class="line">    var v6 bool = true  //局部变量</span><br><span class="line">    fmt.Printf(&quot;v6: %v\n&quot;, v6)恒等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在函数体内部，局部变量会遮蔽与其同名的全局变量。<br>函数体内部的短变量声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v6 := true</span><br><span class="line">v7, v8 := &quot;Go&quot;, 1.2</span><br><span class="line">v8, v9 := 2.0, false    //v8重声明</span><br></pre></td></tr></table></figure></p><p>重声明为对在当前上下文环境中的已存在变量的又一次赋值，赋的值与改变量的类型之间应满足赋值规则。  </p><p>重声明仅出现在短变量声明中，不能用普通的声明方式重新声明一个在当前上下文环境中已存在的变量，不论改变量是一个全局变量还是一个局部变量。<br>短变量声明条件：  </p><ul><li>仅能够在函数体内部声明变量的时候使用。     </li><li>:=的左边的标识符至少有一个代表在当前上下文环境中的新变量。</li></ul><p>空标识符“_”代表的不是新变量。短变量声明可以出现在if、for和switch等语句的初始化器中，并被用来声明仅存在于这些语句块中的局部临时变量。  </p><p>在当前上下文环境中声明了某个局部变量但没有使用它，会造成一个编译错误，对变量的赋值不算对其使用。  </p><h3 id="可比性与有序性"><a href="#可比性与有序性" class="headerlink" title="可比性与有序性"></a>可比性与有序性</h3><h4 id="类型的恒等"><a href="#类型的恒等" class="headerlink" title="类型的恒等"></a>类型的恒等</h4><p>对于两个命名类型来说，名称不同，肯定不恒等，名称相同且源于相同的类型声明，则是恒等的。别名类型与它的源类型是两个完全不同的类型，命名类型和匿名类型总是不相等的。  </p><p>恒等判断规则：  </p><ul><li>数组类型，长度一致且元素的数据类型一致。</li><li>切片类型，元素的数据类型一致。</li><li>结构体类型，字段声明的数量相同且对应位置上的字段具有相同的字段名称和恒等的数据类型。字段声明的标签实际上是一个字符串字面量，标签一致也为判断恒等的依据。</li><li>指针类型，基本类型（指向的那个类型）恒等。</li><li>函数，包含了相同数量的参数和结果声明，并且对应位置上的参数和类型都是恒等的。不关注参数和结果名称，只关注数量、顺序和类型。若为可变参函数则都为可变参函数。</li><li>接口类型，拥有相同的方法集合。</li><li>字典类型，具有恒等的元素类型和键类型。</li><li>通道类型，具有恒等的元素类型且方向相同。</li></ul><h4 id="数据的可比性和有序性"><a href="#数据的可比性和有序性" class="headerlink" title="数据的可比性和有序性"></a>数据的可比性和有序性</h4><p>可比性是可以判断相等与否，有序性是可以比较大小。  </p><ul><li>布尔值具有可比性。</li><li>整数类型值具有可比性和有序性。</li><li>浮点数类型值具有可比性和有序性。</li><li>复数类型值具有可比性。</li><li>字符串值具有可比性和有序性。</li><li>指针值具有可比性。指向同一个变量或者都为空值nil。</li><li>通道类型值具有可比性。元素类型和缓冲区大小都一致。</li><li>接口类型值具有可比性。拥有相等的动态类型和相同的动态值。若都为空值也相等。</li><li>非接口类型X的值可以与接口类型T的值t判断相等，当且仅当接口类型T具有可比性且类型性X式接口类型T的实现类型。</li><li>结构体类型中的所有字段都具有可比性，则结构体类型的值具有可比性。</li><li>数组类型值具有可比性。元素类型的值具有可比性。</li></ul><p>切片类型、字典类型和函数类型的值不具有可比性，这些值可以与空值nil进行判等。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>把一个类型的值转换为另一个类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T(x)</span><br><span class="line">---</span><br><span class="line">*string(v)</span><br><span class="line">---</span><br><span class="line">&lt;-chan int(v) = &lt;-(chan int(v))//将v转换为chan int类型的值，在从此通道中接收一个int类型的值</span><br><span class="line"></span><br><span class="line">(&lt;-chan int)(v) //将v转换成通道类&lt;-chan int的值</span><br><span class="line">---</span><br><span class="line">func()(v) //结果为v的无参数匿名函数</span><br><span class="line"></span><br><span class="line">(func())(v) //将v转换为函数类型的值</span><br><span class="line"></span><br><span class="line">func() int(v)  = (func() int)(v) //将v转换为函数结果为int类型的函数类型。</span><br></pre></td></tr></table></figure></p><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>…</p><h4 id="与string类型相关的转换"><a href="#与string类型相关的转换" class="headerlink" title="与string类型相关的转换"></a>与string类型相关的转换</h4><p>…</p><h4 id="别名类型值之间的转换"><a href="#别名类型值之间的转换" class="headerlink" title="别名类型值之间的转换"></a>别名类型值之间的转换</h4><p>…</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><p>只接受通道类型的值作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int,1)</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p><p>使作为参数的通道无法在接受任何元素值。若试图关闭一个仅能接受元素值的通道，则造成一个编译错误。通道关闭之后再向它发送元素值或者试图再次关闭它，都会引发一个运行时恐慌。试图关闭一个nil的通道值也会引发一个运行时恐慌。<br>关闭一个通道不会影响关闭之前已经发送的那些元素值，关闭之后所有的接收操作都会立即返回一个该通道的元素类型的零值。</p><h4 id="len函数和cap函数"><a href="#len函数和cap函数" class="headerlink" title="len函数和cap函数"></a>len函数和cap函数</h4><p>len的使用：</p><blockquote><p>参数类型为字符串类型，返回string类型值的字节长度；<br>参数类型为数组类型或数组指针类型，返回数组类型值的长度；<br>参数类型为切片类型，返回切片类型的长度；<br>参数类型为字典类型，返回字典类型值的长度，即其中已包含的键的数量；<br>参数类型为通道类型，返回通道类型值当前包含的元素的数量。</p></blockquote><p>cap的使用：</p><blockquote><p>参数类型为数组类型或数组类型指针，返回数组类型的长度；<br>参数类型为切片类型，返回切片类型值的容量；<br>参数类型为通道类型，返回通道类型值的容量。</p></blockquote><h4 id="new函数和make函数"><a href="#new函数和make函数" class="headerlink" title="new函数和make函数"></a>new函数和make函数</h4><p>参见<a href="/2018/04/11/Golang笔记-基础篇-二/" title="Golang笔记-基础篇(二)">Golang笔记-基础篇(二)</a>数据初始化部分。</p><h4 id="append函数和copy函数"><a href="#append函数和copy函数" class="headerlink" title="append函数和copy函数"></a>append函数和copy函数</h4><p>参见<a href="/2018/04/11/Golang笔记-基础篇-二/" title="Golang笔记-基础篇(二)">Golang笔记-基础篇(二)</a>切片部分。</p><h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><p>专用于删除一个字典类型之中的某个键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, k)//m为字典类型值，k为要删除键值对的键</span><br></pre></td></tr></table></figure></p><ul><li>参数k与m的键之间必须满足赋值规则。</li><li>m是nil或者k所代表的键值对不存在与m中时，delete(m, k)不会做任何操作，删除操作被忽略，这种删除失败不会被反馈。<h4 id="complex函数、real函数和imag函数"><a href="#complex函数、real函数和imag函数" class="headerlink" title="complex函数、real函数和imag函数"></a>complex函数、real函数和imag函数</h4>专用于操作复数类型值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cplx128 complex128 = complex(2,-2) //根据浮点数类型的实部和虚部来构造复数类型值</span><br><span class="line"></span><br><span class="line">var im64 = imag(cplx128) //从浮点数类型值中抽取浮点数的虚部部分</span><br><span class="line">var r64 = imag(cplx128)  //从 浮点数类型值中抽取浮点数的实部部分</span><br></pre></td></tr></table></figure></li></ul><h4 id="panic函数和recover函数"><a href="#panic函数和recover函数" class="headerlink" title="panic函数和recover函数"></a>panic函数和recover函数</h4><p>分别用于报告和处理运行时恐慌。  </p><blockquote><p>panic只接受一个参数，参数可以是任意类型的值。要生成和报告一个运行时的恐慌可以直接调用此函数并传递给他一个用以描述恐慌细节的值。参数的类型常常是接口类型error的某个实现类型。        </p></blockquote><blockquote><p>recover不接受任何参数，返回一个interface{}类型的结果值。即其结果值可能是任何类型的，可能是nil。为nil时可能是因为： </p><ul><li>传递给panic函数的参数值就是nil。</li><li>运行时的恐慌根本没有发生，即panic没有被调用。</li><li>函数recover并没有在defer语句中被调用。</li></ul></blockquote><h4 id="print和println函数"><a href="#print和println函数" class="headerlink" title="print和println函数"></a>print和println函数</h4><p>把参数值在标准输出上打印出来且不返回任何结果值。  </p><p>print的作用是依次（从左到右）打印传递给它的参数值，每个参数值对应的打印内容都由它们的具体实现决定。peintln函数在print函数打印的内容基础上在每个参数之间加入空格“ ”，并在最后加入换行符。</p><blockquote><p>Go语言不保证会在以后每个版本中保留和则两个函数，尽量不要使用这两个函数，使用标准库代码包fmt中的函数Print和Println替代。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言的语法和C/C++、Java等有很大的不同，较类似于C。语法设计更为复杂，好处是使用起来会更加方便快捷。Go通过结构类和接口形成面向对象思想，吸取了Python中的切片、字典等数据类型。新增了通道，Go中非常重要的一种数据类型。将函数也作为一等数据类型，能够实现闭包，通过语法特性可以很方便的实现策略模式、泛型等。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(二)</title>
      <link href="/2018/04/11/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/"/>
      <url>/2018/04/11/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、<br> complex64、complex128  </p></blockquote><p> 分为三类。</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><pre><code>&gt;bool：true、false</code></pre><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p> 特殊rune</p><blockquote><p>类型rune的值由rune类型字面量代表，专用于存储经过Unicode编码的字符。<br>    一个rune常量即是一个Unicode编码值，使用十六进制表示法来表示与Unicode对应的数字值，并使用“U+”作为前缀。<br>    一个rune字面量由外层的单引号和内层的一个或多个字符组成，在包裹字符的单引号中不能出现单引号“’”和换行符“\n”。    </p></blockquote><p>可以用5种方式来表示一个rune字面量  </p><ol><li>该rune字面量所对应的字符。如：’a’、’-‘，字符必须是Unicode编码规范所支持。</li><li>使用“\x”为前导并后跟两位十六进制数。可以表示宽度为一个字皆的值，即一个ASCII编码值。  </li><li>使用“\”为前导并后跟三位八进制数。宽度限制为一个字皆，只能用于表示对应数值在0和255之间的值。</li><li>使用“\u”为前导并后跟四位十六进制数。只能用于表示两个字节宽度的值，为Unicode编码规范中的UCS-2表示法。</li><li>使用“\U”为前导并后跟八位十六进制数。为Unicode编码规范中的UCS-4表示法。为Unicode编码规范和相关国际标准中的规范编码格式。 </li></ol><p> rune字面量可以支持转义符，有固定的几个，在规定之外的以“\”为前导的字符序列都是不合法的，转义符“\””也不能出现在rune字面量中。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串的长度即是底层字节序列中字节的个数，一个字符串常量的长度在编译期间就能够确定。<br>字符串代表了一个连续的字符序列，每一个字符都会被隐含地以Unicode编码规范的UTF-8编码个是编码为若干字节。<br>字符串字面量的两种表示格式：原生字符串字面量和解释型字符串字面量。    </p><blockquote><p>原生字符串字面量在两个反引号“`”之间的字符序列。在反引号之间，除了反引号之外的其他字符都是合法的，两个反引号之间的所有内容都看作是这个原生字符串字面量的值，其内容由在编译期间就可以确定的字符（非解释型字符）组成。原生字符串字面量中，不存在任何转义字符，所有内容都是所见即所得，也包括换行符。原生字符串字面量中的回车符会被编译器移除。    </p></blockquote><blockquote><p>解释型字符串字面量是被两个双引号“””包含的字符序列。解释型字符串中的转义字符都会被成功转义。在解释型字符串字面量中，转义符“\’”是不合法的，而转义字符“\””却是合法的，与rune字面量相反。在字符串字面量中可以包含rune字面量。  </p></blockquote><p>字符串字面量与rune字面量的本质区别是在于他们所代表的Unicode字符的数量上。</p><blockquote><p>字符串值是不可变的，不可能改变一个字符串的内容，对字符串的操作只会返回一个新字符串，而不是改变原字符串并返回</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个数组就是一个由若干个相同类型的元素组成的序列。    </p><h4 id="1-类型表示法"><a href="#1-类型表示法" class="headerlink" title="1. 类型表示法"></a>1. 类型表示法</h4><p> 声明要指明长度和元素类型<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[n]T  //[非负整数字面量]元素类型</span><br><span class="line">[2*3*4]byte</span><br><span class="line">[5]struct&#123;name,address string&#125; //自定义匿名结构体类型</span><br></pre></td></tr></table></figure></p><h4 id="2-值表示法"><a href="#2-值表示法" class="headerlink" title="2. 值表示法"></a>2. 值表示法</h4><p>值由符合字面量表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125; </span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;.&quot;, 5:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;2:&quot;I&quot;, 1:&quot;am&quot;, 5:&quot;a&quot;, 4:&quot;loser&quot;, 0:&quot;.&quot;, 3:&quot;yes&quot;&#125;</span><br><span class="line">-&gt;[6]string&#123;5:&quot;I&quot;, 0:&quot;am&quot;, &quot;a&quot;, &quot;loser&quot;, &quot;.&quot;, &quot;yes&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;0:&quot;I&quot;, 1:&quot;am&quot;, 2:&quot;a&quot;, 3:&quot;loser&quot;, 4:&quot;&quot;, 5:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">[6]string&#123;1:&quot;I&quot;, &quot;am&quot;, 4:&quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[6]string&#123;1:&quot;I&quot;, 2:&quot;am&quot;, 3:&quot;&quot;, 4:&quot;a&quot;, 5:&quot;loser&quot;&#125;</span><br><span class="line"></span><br><span class="line">[...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">=&gt;[4]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;</span><br><span class="line">``` </span><br><span class="line">* 默认第一个元素值对应索引值0，之后的每个元素值的索引值都是在前一个元素值的索引值的基础上再加1，可以显式的指定索引值。</span><br><span class="line">* 在数组中未指定的元素将会被填充为元素类型的零值，可以通过显式地指定索引值来改变被填充元素值的位置。</span><br><span class="line">* 用特殊标记“...”替换为数组长度，意为并不显式地指定数组值的长度，而让Go语言编辑器为我们计算该值所包含的元素值的数量并以此确定这个长度的值。可以避免由于指定的长度和元素值的实际数量不相符而导致的多于零值元素或编译错误。</span><br><span class="line">&gt;0 &lt;= 索引值 &lt; 数组长度  </span><br><span class="line">指定的索引值不能与其他元素值的索引值重复，不论其他元素值的索引值是隐含对应的还是显式对应的。  </span><br><span class="line">####  3. 属性和基本操作  </span><br><span class="line">使用函数len计算数组值长度</span><br><span class="line">```code</span><br><span class="line">len([...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot; &#125;)</span><br></pre></td></tr></table></figure></p><p>通过索引值访问元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;[0] =&gt; &quot;bighua&quot;</span><br></pre></td></tr></table></figure></p><p>通过索引值改变对应元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array1 := [...]string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array1[0] = &quot;cocowh.github&quot;</span><br><span class="line">array1[2] = &quot;io&quot;</span><br></pre></td></tr></table></figure></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>Slice可以看作是Array的一种包装形式，是针对其底层包装数组中某个连续片段的描述苻，包装的数组称为该切片的底层数组。</p><h4 id="类型表示法"><a href="#类型表示法" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>由一对中间没有任何内容的方括号和代表其元素类型的标识符组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]T</span><br></pre></td></tr></table></figure></p><p>长度并不是切片类型的一部分，不会出现在表示切片类型的类型字面量中，切片的长度是可变的，相同类型的切片值可能会有不同的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]rune</span><br><span class="line">[]struct&#123;name,department string&#125;</span><br></pre></td></tr></table></figure></p><p>切片类型声明中的元素类型可以是任意一个有效的Go语言数据类型。</p><h4 id="值表示法"><a href="#值表示法" class="headerlink" title="值表示法"></a>值表示法</h4><p>切片的零值为nil，在初始化之前，一个切片类型的变量值为nil。</p><blockquote><p>切片值的长度为其所含的元素值的实际数量，使用函数len获取切片值的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len([]string&#123;4:&quot;bighua&quot;, 2: &quot;.&quot;,  &quot;com&quot;&#125;)  ##= 5</span><br></pre></td></tr></table></figure><p>在切片类型的零值（即nil）上应用内建函数len将会得到0。</p><blockquote><p>一个切片一旦被初始化，就会与一个包含了其中元素值的数组相关联，即一个切片值总会持有一个对某个数组值的引用。</p></blockquote><p>多个切片值可能会共用同一个底层数组。把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的值，这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对其底层数组上的对应元素的修改，作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片之上。切片值类似于指向底层数组的指针。  </p><blockquote><p>切片值的容量是其能够访问到的当前底层数组中的元素值的最大数量，即从其中的指针指向的那个元素值到底层数组的最后一个元素值的计数值，用内建函数cap获取。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap([]string&#123;4:&quot;bighua&quot;, 2:&quot;.&quot;, &quot;com&quot;&#125;)   //=5</span><br></pre></td></tr></table></figure><p>此例中切片值的容量就等于它的长度，对切片类型的零值应用内建函数cap也会得到0。</p><blockquote><p>一个切片值的底层数据结构中包含一个指向底层数组的指针类型值、一个代表切片长度的int类型值和一个代表切片容量的int类型值。  </p></blockquote><blockquote><p>使用复合字面量初始化一个切片值的时候，首先创建的是这个切片值所引用的底层数组，该底层数组与这个切片值有相同的元素类型、元素值及其排列顺序和长度，因此切片值的长度和容量一定相同。  </p></blockquote><blockquote><p>切片表达式的作用不是复制数组值中某个连续片段所包含的元素值，而是创建一个新的切片值，新的切片值中包含了指向这个连续片段中的第一个元素值的指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;a&quot;, &quot;loser&quot;&#125;     //底层数组长度5，即切片容量5</span><br><span class="line">slice := array[:4]      //切片长度4，能够访问前4个元素值</span><br><span class="line">slice = slice[:cap(slice)] //扩大窗口，改变长度为容量，能够访问所有元素值</span><br></pre></td></tr></table></figure><p>通过切片的方式把slicede的窗口扩展到最大，此时slice的值的长度等于其容量，窗口只能向索引值递增的方向拓展。当一个切片的索引值不在切片的长度范围内时，会引起一个运行时恐慌。<br>使用内建函数append对切片值进行拓展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array[:4]</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">slice ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">长度扩展到最大容量7，此时array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">slice1 := append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">不会改变slice的值，声明并初始化一个新变量slice1</span><br><span class="line">slice1 ===&gt; []string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">array第5、6、7元素被改变</span><br><span class="line">array ===&gt; [7]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;,&quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;&#125;  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>第一个参数为将要被拓展的切片，第二个可变长参数类型应与第一个参数元素类型相同，与作为拓展内容的一个或多个元素值绑定。此函数又返回结果，结果的类型与其第一个参数的类型完全一致。<br>append函数不是在原始切片值上进行拓展，而是创建一个新的切片值，在无需扩容时，此切片值与原切片值共用一个底层数组，指针类型值和容量值与原切片值保持一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array := [...]string&#123;&quot;I&quot;, &quot;am&quot;, &quot;wuhua&quot;, &quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;loser&quot;&#125;  </span><br><span class="line">slice := array</span><br><span class="line">slice = append(slice, &quot;bughua&quot;, &quot;.&quot;, &quot;com&quot;)</span><br><span class="line">/*</span><br><span class="line">此时长度超出容量，会创建一个新的长度大于需要存储的元素值总和的底层数组，新切片指针、长度、容量改变。</span><br><span class="line">*/相似</span><br></pre></td></tr></table></figure></p><p>上例中slice长度超出容量，此时会有一个新的数组值被创建并初始化，新的数组值将作为在append函数新创建的切片值的底层数组，包含原切片之中的全部元素值以及作为拓展内容的所有元素值。此底层数组的长度总是大于需要存储的元素值的总和，新切片值中的指针将指向其底层数组的第一个元素值，长度和容量与其底层数组的长度相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice = append(slice, slice1...)</span><br><span class="line">---</span><br><span class="line">slice1 = nil</span><br><span class="line">slice1 = append(slice2, slice...)</span><br><span class="line">---</span><br><span class="line">var slice2 []string</span><br><span class="line">slice2 = append(slice2, slice...)</span><br></pre></td></tr></table></figure></p><p>运用“…”符号，集合追加方式。</p><blockquote><p>如果容量上限索引被指定，作为切片表达式的求值结果的新切片值的容量则为容量上界索引与元素下界索引之间的差值。指定容量上界索引的目的是为了缩小新切片值的容量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arrray = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">slice := array[2:6]</span><br><span class="line">/*可直接修改array对应索引值在[2,6)的元素值，通过扩大slice窗口，可修改array对应索引值[6,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice :=array[2:6:8]</span><br><span class="line">/*即使扩大长度也仅能访问修改array中对应索引值[2,8)的元素值*/</span><br><span class="line">---</span><br><span class="line">slice = append(slice, []int&#123;10 ,11, 12, 13, 14, 15&#125;...)</span><br><span class="line">/*拓展超出容量创建新的底层数组，指针指向新底层数组，彻底无法访问修改array的元素值*/</span><br></pre></td></tr></table></figure><blockquote><p>使用容量上限索引能有效的精细控制切片值对其底层数组的访问权限。<br>指定容量上限索引时，元素上界索引时不能够省略的，可以省略元素下界索引。</p></blockquote><p>使用内建函数copy批量赋值切片值中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []string&#123;&quot;I&quot;, &quot;love&quot;, &quot;my&quot;, &quot;family&quot;&#125;</span><br><span class="line">slice2 := []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;&#125;</span><br><span class="line">n1 := copy(slice1,slice2)</span><br><span class="line">/*</span><br><span class="line">n1 = 3</span><br><span class="line">slice =&gt; []string&#123;&quot;bighua&quot;, &quot;.&quot;, &quot;com&quot;, &quot;family&quot;&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>把原切片值（参数二）中的元素值复制到目标切片值（参数一）中，返回被复制的元素值的数量。参数一和参数二的元素类型必须一致，实际复制的元素值的数量等于长度较短的切片值的长度。<br>切片类型相当于于其他编程语言中的动态数组类型，扩展机制也与动态数组类型相似。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典（Map）是哈希表（Hash Table）的一个实现。哈希表是一个实现了关联数组的数据结构，关联数组是用于代表键值对的集合的一种抽象数据类型，在一个键值对集合中，一个键最多能够出现一次。与这个抽象数据结构相关联的操作有：  </p><ul><li>向集合中添加键值对。</li><li>从集合中删除键值对。</li><li>修改集合中已存在的键值对的值。</li><li>查找一个特定键所对应的值。</li></ul><p>哈希表通过哈希函数建立键值对的内部关联，键值对之间是没有顺序关系的。</p><h4 id="类型表示法-1"><a href="#类型表示法-1" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>如果一个字典类型中的键的类型为K，且元素的类型为T，字典类型的类型字面量为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map[K]T</span><br><span class="line">---</span><br><span class="line">map[int]string</span><br><span class="line">map[string]struct&#123;name,department string&#125;</span><br><span class="line">map[string]interface&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>字典类型的键类型和元素类型都需要在其声明中指定，元素类型可以是任意一个有效的Go语言数据类型，键类型不能是函数类型、字典类型或切片类型，键类型必须是可比较的。若键类型是接口类型，在程序运行期间，该类型的字典值中的每一个键值的动态类型都必须是可比较的，否则引起运行时异常。</p><h4 id="值表示法-1"><a href="#值表示法-1" class="headerlink" title="值表示法"></a>值表示法</h4><p>由复合字面量表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[string]bool&#123;&quot;bighua&quot;:true, &quot;cool&quot;:true, &quot;smart&quot;:true, &quot;ugly&quot;:false&#125;</span><br><span class="line">---</span><br><span class="line">map[string]bool&#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>同指针类型和切片类型，字典类型是一个引用类型。字典会持有一个针对某个底层数据结构值的引用，将一个字典值传递给一个会改变它的函数，这个改变对于函数的调用方是可见的。  </p><blockquote><p>在Go语言中只有“传值”没有“传引用”，函数内部对参数值的改变是否会在该函数之外体现出来，只取决于这个被改变的值的类型是值类型还是引用类型。  </p></blockquote><p>字典的零值是nil，类似一个长度为零的字典，可对其进行读取操作，对其进行写操作引发运行时恐慌。为初始化的字典类型的变量的值为nil。<br>用内建函数len获取字典值的长度，代表当前所包含的键值对的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">editorSign := map[string]bool&#123;&quot;cool&quot;:true, &quot;smart&quot;:true, &quot;stupid&quot;:false&#125;</span><br><span class="line">editorSign[&quot;ugly&quot;] = false</span><br><span class="line">/*新增*/</span><br><span class="line">---</span><br><span class="line">sign1 := editorSign[&quot;smart&quot;]</span><br><span class="line">sign1,ok := editorSign[&quot;smart&quot;]</span><br><span class="line">/*查找获取，消除不存在歧义*/</span><br><span class="line">---</span><br><span class="line">delete(editorSign,&quot;stupid&quot;)</span><br><span class="line">/*删除键为&quot;stupid&quot;的键值对，无返回结果，即使不存在要删的键值对也不引起恐慌*/</span><br></pre></td></tr></table></figure></p><blockquote><p>字典类型不是并发安全的，官方认为在大多数使用字典值的地方并不需要多线程场景下的安全访问控制，为了少数的并发使用场景而强制要求所有的字典都满足互斥操作将会降低大多数程序的速度。  </p></blockquote><blockquote><p>对一个非并发安全的字典值进行不受控制的并发访问可能会导致程序行为错乱，可以使用标准库代码包sync中的结构体类型RWMutex扩展字典类来保证并发安全性。RWMutex是一个读写互斥量，常用于多线程环境下的并发读写控制。</p></blockquote><h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数类型是一等类型，可以把函数当作一个值来传递和使用，即可以作为其他函数的参数，也可以作为其他函数的结果，可以利用函数的和则以特性生成闭包。</p><h4 id="类型表示法-2"><a href="#类型表示法-2" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>函数类型指代了所有可以接受若干参数并能够返回若干结果的函数。<br>声明一个函数以关键字func作为开始，其后紧跟函数签名，包括参数声明列表和结果声明列表。参数声明一般参数名在前，参数类型在后，中间空格分隔，参数名称唯一。若相邻两个参数的类型一致，可以只写第二个参数的参数类型。可以在函数声明的参数列表中略去所有参数的名称。可添加可变长参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(name string, age int)</span><br><span class="line">---</span><br><span class="line">(name string, age, seniority int)</span><br><span class="line">---</span><br><span class="line">(string,int,int)</span><br><span class="line">---</span><br><span class="line">(name string,age int,seniority int,informations ...string)</span><br></pre></td></tr></table></figure></p><p>结果声明列表的编写规则与参数声明基本一致，区别于：  </p><ul><li>只存在可变长参数的声明不存在可变长结果的声明。</li><li>如果结果声明列表中只有一个结果声明且这个结果声明中并不包含结果的名称，则可以忽略圆括号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int, seniority int, informations ...string)bool</span><br><span class="line">-&gt;</span><br><span class="line">func (name string, age int, seniority int, informations ...string)(done bool)</span><br><span class="line">/*命名结果*/</span><br></pre></td></tr></table></figure><p>Go语言的函数可以有多个结果，为函数声明多个结果可以让每个结果的职责更单一。可以利用此特性将错误值作为结果返回给调用它的代码，而不是把错误抛出来，然后在调用它的地方编写代码处理这个错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (name string, age int , seniority int)(effected uint, err error)</span><br></pre></td></tr></table></figure></p><h4 id="值表示法-2"><a href="#值表示法-2" class="headerlink" title="值表示法"></a>值表示法</h4><p>函数类型的零值是nil，未被初始化的函数类型的变量的值为nil，在一个未被初始化的函数类型的变量上调用表达式会引发一个运行时的恐慌。<br>函数类型的值分为命名函数值和匿名函数值。<br>命名函数由关键字func、函数名、函数的签名和函数体组成。若签名中包含了结果声明列表，则在函数体中的任何可到达的流程分支的最后一条语句都必须是终止语句。终止语句有多种，return或goto开始的语句，针对内建函数panic的调用表达式的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Module(x, y int) int&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    return x % y</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">func Module(x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在关键字return之后的结果必须在数量上与该函数的结果声明列表中的内容完全一致，对应位置的结果的类型上存在可赋予的关系。</p><blockquote><p>函数的声明可以省略掉函数体，表示会由外部程序（如汇编语言程序）实现，而不会由Go语言程序实现。</p></blockquote><p>匿名函数由函数字面量表示，函数没有名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (x, y int) (result int)&#123;</span><br><span class="line">    result =  x % y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性和基本操作-1"><a href="#属性和基本操作-1" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>函数类型是Go语言的基本类型，可以把函数类型作为一个变量的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var recoder func (name string, age int, seniority int) (done bool)</span><br></pre></td></tr></table></figure></p><p>之后所有符合这个函数的实现都可以被赋给变量recoder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recoder = func(name string, age int, seniority int) (done bool)&#123;</span><br><span class="line">    //tudo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被赋给变量recoder的函数字面量必须与recoder的类型拥有相同的函数签名。像“面向接口编程”原则的一种实现方式。可以在一个函数类型的变量上直接应用调用表达式来调用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done := recoder(&quot;Harry&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>可以把函数类型的变量的值看作是一个函数值，所有的函数值都可以被调用，函数字面量也是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(name tsring, age int, seniority)(done bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;(&quot;HuaGe&quot;, 32, 10)</span><br></pre></td></tr></table></figure></p><p>一个函数即可以作为其他函数的参数，也可以作为其他函数的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//声明加密算法函数类型</span><br><span class="line">type Encipher func(plaintext string) []byte</span><br><span class="line"></span><br><span class="line">//声明生成加密函数的函数</span><br><span class="line">func GenEncryptionFunc(encrypt Encipher) func(string) (ciphertest string)&#123;</span><br><span class="line">    return func(plaintext string) string&#123;</span><br><span class="line">        return fmt.Sprintf(&quot;%x&quot;,encrypt(plaintext))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">实现了闭包</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>函数GenEncryptionFunc的签名中包含一个参数声明和一个结果声明。参数声明“(encrypt Encipher)”中的参数类型是定义的用于封装加密算法的函数类型,结果声明“func(string)(ciphertext string)”表示了一个函数类型的结果，这个函数类型则是GetEncryptionFunc函数所生成的加密函数的类型，接收一个string类型的明文作为参数，并返回一个string类型的密文作为结果。<br>函数GenEncryptionFunc的函数体内直接返回了符合加密函数类型的匿名函数，匿名函数调用名称未encrypt的函数，把作为该匿名函数的参数的明文加密，然后使用标准代码库代码包fmt中的Sprintf函数，把encrypt的函数的调用结果转换成字符串。字符串内容是十六进制数表示的加密结果，是[]byte类型的。</p><blockquote><p>每一次调用GenEncryptionFunc函数，传递给它的加密算法函数都会一直被对应的加密函数引用着。只要生成的加密函数还可以被访问，其中的加密算法函数就会一直存在，不会被Go语言的垃圾回收期回收。</p></blockquote><p>只有当函数类型是一等类型并且其值可以作为其他函数的参数或结果的时候，才能够实现闭包。  </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法是附属于某个自定义的数据类型的函数，一个方法就是一个于某个接收者关联的函数。<br>方法的签名中不但包含了函数签名，还包含了一个与接收者有关的声明，即方法的声明包含了关键字func、接收者声明、方法名称、参数声明列表、结果声明列表和方法体。接收者由被圆括号括起来的两个标识符组成，标识符间空格分隔，左边标识符为接收者的值在当前方法中的名称，右边标识符代表接收者的类型，前者称为接收者标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type MyIntSlice []int</span><br><span class="line">func (self MyIntSlice) Max() (result) &#123;</span><br><span class="line">    //todo</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收者声明编写规则</p><ul><li>接收者声明中的类型必须是某个自定义的数据类型，或者是一个与某个自定义数据类型对应的指针类型。接收者的类型既不能是一个指针类型，也不能是一个接口类型。</li><li>接受者声明中的类型必须由非限定标识符代表。</li><li>接收者标识符不能是空标识符“_”。</li><li>接收者的值未在当前方法体内被引用，可以将接收者标识符从当前方法的接受者声明中删除掉。（同参数声明不推荐</li></ul><p>方法的类型与从其声明中去掉函数接收者之后的函数的类型相似，把接收者声明中的两个标识符加到参数列表声明的首位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (self *MyIntSlice) Min() (result int)</span><br><span class="line">//类型为</span><br><span class="line">func Min()(self *MyIntSlice, result int)</span><br></pre></td></tr></table></figure></p><p>选择接收者的类型  </p><ul><li>在某个自定义数据类型上，值能够调用与这个数据类型相关联的值方法，在这个值的指针值上，能够调用与其数据类型相关联的值方法和指针方法。</li><li>在指针方法中能够改变接收者的值，在值的方法中，对接收者的值的改变对于该方法之一般是无效的。  </li></ul><p>接收者的类型如果是引用类型的别名类型，在该类型值的值方法中对该值的改变也是对外有效的。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> Go语言的接口由一个方法的集合代表。只要一个数据类型（或与其对应的指针类型）附带的方法集合是某一个接口的方法集合的超级，就可以判定该类型实现了这个接口。</p><h4 id="类型表示法-3"><a href="#类型表示法-3" class="headerlink" title="类型表示法"></a>类型表示法</h4><p> 接口由方法集合代表。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//标准库代码包sort中的接口类型Interface</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">   Len() int</span><br><span class="line">   Less(i, j int) bool</span><br><span class="line">   Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将一个接口类型嵌入到另一个接口类型中，亦接口间的继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Sortable interface &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Sort()</span><br><span class="line">&#125;</span><br><span class="line">//嵌入了sort中的接口类型Interface</span><br></pre></td></tr></table></figure></p><blockquote><p>接口的嵌入不能嵌入自身，包括直接的嵌入和间接的嵌入，当前接口类型中声明的方法也不能与任何被嵌入其中的接口类型的方法重名，错误的嵌入会造成编译错误。</p></blockquote><p>interface{}为空接口，不包含任何方法声明的接口，Go语言中所有数据类ixng都是它的实现。</p><h4 id="值表示法-3"><a href="#值表示法-3" class="headerlink" title="值表示法"></a>值表示法</h4><p>Go语言的接口没有相应的值表示法，接口是规范而不是实现。一个接口类型的变量可以被赋予任何实现了这个接口类型的数据类型的值，因此接口类型的值可以由任何其它数据类型的值来表示。</p><h4 id="属性和基本操作-2"><a href="#属性和基本操作-2" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>接口的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type SortableStrings [3]string</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Len() int &#123;</span><br><span class="line">    return Len(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Less(i, j int) bool &#123;</span><br><span class="line">    return self[i] &lt; self[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Swap(i, j int) &#123;</span><br><span class="line">    self[i],self[j] = self[j],self[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(sort.Interface)</span><br><span class="line">//类型断言SorableStrings类型是一个sort.Interface接口类型的实现。</span><br><span class="line"></span><br><span class="line">func (self SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//断言SorableStrings类型实现了接口类型Sortable。</span><br><span class="line"></span><br><span class="line">func (self *SortableStrings) Sort()&#123;</span><br><span class="line">    sort.Sort(self)</span><br><span class="line">&#125;</span><br><span class="line">_,ok := interface&#123;&#125;(&amp;SortableStrings&#123;&#125;).(Sortable)</span><br><span class="line">//验证方法接收对象规则值方法和指针方法</span><br></pre></td></tr></table></figure></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体类型既可以包含若干个命名元素（字段），又可以与若干个方法相关联。字段代表了该类型的属性，方法可以看作是针对这些属性的操作。</p><h4 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">    Sortable        // 匿名字段</span><br><span class="line">    sortableArray sort.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把类型相同的字段写在同一行中(不建议):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len, cap int</span><br></pre></td></tr></table></figure></p><p>只有类型而没有指定名称的字段叫做匿名字段，也称嵌入式的字段（结构体类型的嵌入类型），必须由一个数据类型的名称或者一个与非接口类型对应的指针类型类型的名称代表，代表匿名字段类型的非限定名称被隐含地作为该字段的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Anonymities struct &#123;</span><br><span class="line">    T1      //隐含名称T1</span><br><span class="line">    *T2     //隐含名称T2</span><br><span class="line">    P.T3    //隐含名称T3</span><br><span class="line">    *P.T4   //隐含名称T4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体自动地实现它包含的所有嵌入类型所实现的接口类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Sequence struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当Sequence类型中由与Sortable接口类型的Sort方法的名称和签名都相同的方法时，调用seq.Sort()是调用Sequence自身的Sort方法，嵌入类型Sortable的方法Sort被隐藏了。类似装饰器模式。若名称相同签名不同，Sortable的Sort方法依然被隐藏。此时调用Sequence自身的Sort方法需要依据Sort的签名来编写调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (self *Sequence) Sort (quicksort bool)&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;</span><br><span class="line">seq.Sort(true) //调用自身</span><br><span class="line">seq.Sortable.Sort() //调用嵌入类型Sortable的Sort</span><br></pre></td></tr></table></figure></p><p>假设有结构体类型S和非指针类型的数据类型T，则：  </p><ul><li>S中包含一个嵌入类型T，S和<em>S的方法集合中都包含接收者类型为T的方法。</em>S的方法集合中还包含接收者类型为*T的方法。</li><li>S中包含了一个嵌入类型<em>T，S和</em>S的方法集合中都会包含接收者类型T或*T的所有方法。</li></ul><p>对于结构体的多层嵌入：  </p><ul><li>在被嵌入的结构体类型的值上像调用它自己的字段或方法那样调用任意深度的嵌入类型值的字段或方法。前提是这些嵌入类型的字段或者方法没有被隐藏，被隐藏则需要通过链式的选择表达式调用或者访问。</li><li>被嵌入的结构体类型的字段或者方法可以隐藏任意深度的嵌入类型的同名字段或方法。字段可以隐藏方法，方法可以隐藏字段，名称相同即可。</li></ul><p>匿名结构体类型比命名结构体类型少了关键字type和类型名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    sorted bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以在数组类型、切片类型活字典类型的声明中，将一个匿名的结构体类型作为它们的元素的类型。可以直接将匿名结构体作为一个变量的类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var anonym struct &#123;</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更常用的是在声明以匿名结构体类型为类型的变量的同时对其初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anonym := struct &#123;</span><br><span class="line">    a int </span><br><span class="line">    b string</span><br><span class="line">&#125;&#123;0, &quot;wuhua&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>匿名结构体类型不具有通用性，常常用在临时数据存储和传递的场景中。可以在结构体类型声明中的字段声明的后面添加一个字符串字面量标签，以作为对应字段的附加属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Persion struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint   `json:&quot;age&quot; `</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通常该标签对该结构体类型及其值的代码来说是不可见的，可以使用标准库代码包reflect中提供的函数查看到结构体类型中字段的标签。会在一些特殊的应用场景下使用，如标签库代码包encoding/json中的函数会根据这种标签的内容确定与该结构体中的字段对应的JSON节点的名称。</p><h4 id="值表示法-4"><a href="#值表示法-4" class="headerlink" title="值表示法"></a>值表示法</h4><p>一般由复合字面量表达。<br>对Sequence有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;Sortable:SortableStrings&#123;&quot;3&quot;,&quot;2&quot;,&quot;1&quot;&#125;,sorted:false &#125;</span><br></pre></td></tr></table></figure></p><p>可以忽略掉结构体字面量字段的名字，即不添加架构体字面量中的键值对的键。有限制：  </p><ul><li>要省略都省略。</li><li>字段值之间的顺序与结构体类型声明中的字段声明的顺序一致，不能省略对任何一字段的赋值。</li></ul><p>可以在结构体字面量中不指定任何字段的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequence&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>此时此值中的两个字段被赋予他们所属类型的零值。结构体类型属于值类型，零值为不为任何字段赋值的结构体字面量。<br>在字段访问权限允许下访问操作字段，字段名称首字母小写，只能在结构体类型声明所属的代码包中访问到该类型的值中的字段，或对其赋值。</p><h4 id="属性和基本操作-3"><a href="#属性和基本操作-3" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h4><p>结构体类型的属性既其所包含的字段和关联的方法。<br>只存在内嵌不存在继承的概念。<br>在结构体类型的别名类型的值上，既不能调用该结构体类型的方法，也不能调用该结构体类型对应的指针类型的方法。</p><blockquote><p>通过结构体中嵌入接口，嵌入的接口能够存储所有实现了该接口类型的数据类型的值，该结构体可以在一定程度上模拟泛型。</p></blockquote><p>很多预定义类型都属于泛型类型（数组、切片、字典、通道），不支持自定义的泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">type GenericSeq interface &#123;</span><br><span class="line">    Sortable</span><br><span class="line">    Append(e interface&#123;&#125;) bool</span><br><span class="line">    Set(index int,e interface&#123;&#125;) bool</span><br><span class="line">    Delete(index int)(interface&#123;&#125;,bool)</span><br><span class="line">    ElemValue(index int)interface &#123;&#125;</span><br><span class="line">    ElemType() reflect.Type</span><br><span class="line">    Value() interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Sequence struct &#123;</span><br><span class="line">    GenericSeq</span><br><span class="line">    sorted bool</span><br><span class="line">    elemType reflect.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Sort()&#123;</span><br><span class="line">    self.GenericSeq.Sort()</span><br><span class="line">    self.sorted = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Append(e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Append(e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) Set(index int, e interface&#123;&#125;) bool &#123;</span><br><span class="line">    result := self.GenericSeq.Set(index,e)</span><br><span class="line">    //todo</span><br><span class="line">    self.sorted = false</span><br><span class="line">    //todo</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Sequence) ElemType() reflect.Type&#123;</span><br><span class="line">    //todo</span><br><span class="line">    self.elemType = self.GenericSeq.ElemType()</span><br><span class="line">    //todo</span><br><span class="line">    return self.elemType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口类型GenericSeq中声明了用于添加、修改、删除、查询元素和获取元素类型的方法。实现GenericSeq接口类型，也必须实现Sortable接口类型。将嵌入到Sequence类型的Sortable接口类型改为GenericSeq接口类型，在类型声明中添加reflect.Type类型（标准库代码包reflect中的Type类型）的字段elemType，用于缓存GenericSeq字段中存储的值的元素类型。<br>通过创建与Sequence类型关联的方法，方法与接口GenericSeq或Sortable中声明的某个方法有着相同的方法名和方法签名，隐藏了GenericSeq字段中存储的值的同名方法，达到扩展效果。<br>结构体类型在多数场景中比预定义数据类型的别名类型更适合作为接口类型的实现，是Go语言支持面向对象编程的主要体现。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>代表着某个内存地址的值。是复合类型之一。</p><h4 id="类型表示法-4"><a href="#类型表示法-4" class="headerlink" title="类型表示法"></a>类型表示法</h4><p>通过于有效数据类型的左边插入符号“*”获取与之对应的指针类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[]int</span><br><span class="line">*Sequence</span><br><span class="line">*sort.StringSlice</span><br></pre></td></tr></table></figure></p><p>专门用于存储内存地址的类型uintptr，与int和uint一样属于数值类型。其值能够保存一个指针值的32位或64位（与程序运行的计算机架构有关）无符号整数，亦称其值为指针类型值的位模式。</p><h4 id="值表示法-5"><a href="#值表示法-5" class="headerlink" title="值表示法"></a>值表示法</h4><p>若变量可寻址，使用取址操作符“&amp;”取对应指针值。</p><h4 id="属性和基本类型"><a href="#属性和基本类型" class="headerlink" title="属性和基本类型"></a>属性和基本类型</h4><p>指针类型属于引用类型，零值为nil。<br>标准库代码包unsafe提供不安全的操作绕过Go语言类型安全机制。<br>包中有个int类型的别名类型ArbitraryType，可以代表任意的Go语言表达式的结果类型。包中声明了一个名为Pointer的类型，unsafe.Pointer类型代表了ArbitarayType类型的指针类型。有特殊转换操作：  </p><ul><li><p>指向其他类型值的指针值可以被转换为unsafe.Pointer类型值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer := unsafe.Pointer(float32(32))</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型值可以被转换为对应的指针类型的值。对于内存上的同一段数据，将其作为int类型的值和float32类型的值来解析得出的结果不同，某些情况，会引起一个运行时的恐慌。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vptr := (*int)(pointer)</span><br><span class="line">---</span><br><span class="line">vptr := (*string)(pointer) //引发运行时恐慌</span><br></pre></td></tr></table></figure></li><li><p>unsafe.Pointer类型的值可以被转换为一个uintptr类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptr := uintptr(pointer)</span><br></pre></td></tr></table></figure></li><li><p>uintptr类型的值也可转换为unsafe.Pointer类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer2 ：= unsafe.Poniter(uptr)</span><br></pre></td></tr></table></figure></li></ul><p>可通过unsafe.Pointer绕过类型系统在任意的内存地址上进行读写操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name    string `json:&quot;name&quot;`</span><br><span class="line">    Age     uint8  `json:&quot;age&quot;`</span><br><span class="line">    Address string `json:&quot;addr&quot;`</span><br><span class="line">&#125;</span><br><span class="line">pp := &amp;Person&#123;&quot;Bighau&quot;,23,&quot;Henan,China&quot;&#125;</span><br><span class="line">var puptr = uintptr(unsafe.Pointer(pp))</span><br><span class="line">var npp uintptr = puptr + unsafe.Offsetof(pp.Name)</span><br><span class="line">var name *string = (*string)(unsafe.Pointer(npp))</span><br></pre></td></tr></table></figure></p><p>使用unsafe包中的Offsetof函数返回Name在Person中的存储偏移量，将Person的内存地址与Name的存储偏移量相加得Name的内存地址，可利用特殊转换操作的规则2和4还原指向Name字段值的指针类型值。最后通过*name直接获取Name字段的值。<br>总结为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unssafe.Pointer(&amp;s.f))</span><br></pre></td></tr></table></figure></p><h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>指对某个数据类型的值或变量的初始化。专门用于数据初始化的内建函数new和make。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>用于为值分配内存。不同于其他编程语言，此处不会初始化分配到的内存，只会清零。<br>调用new(T)意味着为T类型的新值分配并清零一块内存空间，将这块内存空间的地址作为结果返回。结果即为指向这个新的T类型值的指针值，指向一个T类型的零值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = new(string)     //s-&gt;&quot;&quot;</span><br><span class="line">[]int = new([3]int) //n -&gt;[3]int&#123;0,0,0&#125;</span><br></pre></td></tr></table></figure></p><p>标准库代码包sync中的结构体内类型Mutex是一个new后即用的数据类型，零值为一个处于未锁定状态的互斥量。</p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>只能被用于创建切片类型、字典类型和通道类型的值，并返回一个已经被初始化的（非零值）的对应类型的值。  在创建这三个引用类型的值的时候，将内存分配和数据初始化两个步骤绑定在一起。三个类型的零值都是nil，使用new得到的是一个指向空值nil的指针。<br>除了接受一个表示目标类型的类型字面量，还接受一个或两个额外的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 10, 100)</span><br><span class="line">make([]int, 10)</span><br><span class="line"></span><br><span class="line">=&gt;[]int&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;</span><br><span class="line">//创建一个新的[]int类型的值，长度为10、容量为100，可省略参数3，此时为不指定新值的容量。</span><br><span class="line">---</span><br><span class="line">make(map[string]int, 100)</span><br><span class="line">make(map[string]int)</span><br><span class="line"></span><br><span class="line">=&gt;map[string]int&#123;&#125;</span><br><span class="line">//可忽略用于表示底层数据结构长度的参数，不建议</span><br><span class="line">---</span><br><span class="line">make(chan int, 10)</span><br><span class="line">//参数一通道类型，参数二通道长度，参数二可省略</span><br></pre></td></tr></table></figure></p><p>make函数只能被应用在引用类型的值的创建上，其结果是第一个参数所代表的类型的值，而不是指向这个值的指针值。在调用make函数的表达式的求值结果上使用“&amp;”取址操作符获取指针值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]int, 100)</span><br><span class="line">mp := &amp;m</span><br></pre></td></tr></table></figure></p><p>规则总结：</p><ul><li><p>字面量可以被用于初始化除接口类型和通道类型外的所有数据类型的值，接口类型没有值，通道类型只能使用make函数创建。</p></li><li><p>内建函数new主要被用于创建值类型的值，不适合用来创建引用类型的值，其结果是指向被创建值的指针值。</p></li><li><p>内建函数make仅能被用于切片、字典和通道类型的值的创建，结果值是被创建的值本身。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang笔记-基础篇(一)</title>
      <link href="/2018/04/10/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/"/>
      <url>/2018/04/10/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="初识Golang"><a href="#初识Golang" class="headerlink" title="初识Golang"></a>初识Golang</h2><h3 id="Go安装包文件夹"><a href="#Go安装包文件夹" class="headerlink" title="Go安装包文件夹"></a>Go安装包文件夹</h3><ul><li>api文件夹：Go API检查器的辅助文件。</li><li>bin文件夹：官方提供的Go语言相关工具的可执行文件。</li><li>lib文件夹：特殊的库文件。</li><li>pkg文件夹：构架安装后，保存Go语言标准库的所有归档文件。</li><li>src文件夹：所有标准库、Go语言工具，以及相关底层（C语言实现）的源码。</li><li>test文件夹：测试Go语言自身代码的文件。<h3 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h3>需要将工作区目录路径添加至环境变量GOPATH中,可指定多个工作区。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/路径/工作区文件夹名:$HOME/路径/工作区文件夹名</span><br></pre></td></tr></table></figure></li></ul><p>可使用命令行，要保证$HOME值为正确的当前用户home路径，在此踩到过坑，centos7的HOME值为root（好几次在命令行设置后过一段时间又自动变为root），最后在.bash_profile中设置了HOME值，将上方的设置语句也添加到.bash_profile中，这样能保证每次启动都会设置此值为正确值。</p><p>工作区文件夹即为我们的项目编码区，多个工作区可用“:”分开在后面继续添加，命令go get会将指定项目的源码下载到第一个工作区，在其中完成构建和安装，所以一般将第一个工作区设置为用来存放第三方代码库的工作区，存放自己的项目工程的工作区从第二个起。</p><h3 id="代码包"><a href="#代码包" class="headerlink" title="代码包"></a>代码包</h3><p>Go的代码包是对代码进行构建和打包的基本单元，每个源码文件都必须以包声明语句作为文件中代码的第一句，包名即源码文件所在的文件夹名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package 文件夹名</span><br><span class="line">import 其他包名</span><br><span class="line">import (</span><br><span class="line">    其他包名</span><br><span class="line">    其他包名    </span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">import (</span><br><span class="line">    别名 其他包名</span><br><span class="line">    别名 其他包名</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上面给出了声明包以及导入包的三种形式。别名为“.”时可直接进行代码调用，别名为“_”时，仅对包初始化，无法调用。</p><blockquote><p>Go通过标示符首字母的大小写控制对应程序实体的访问权限，标示符首字母大写则其对应的程序实体可被本代码包之外的代码访问到，即可导出的。小写则对应的程序实体就只能被本包内的代码访问。</p></blockquote><p>init函数进行包初始化，main函数为程序入口。</p><h3 id="main函数额init函数"><a href="#main函数额init函数" class="headerlink" title="main函数额init函数"></a>main函数额init函数</h3><p>init函数能够应用于所有的package，main函数只能应用于package main。这两个函数在定义时不能有任何的参数和返回值。一个package里面可以写任意多个init函数，为可读性和可维护性，建议在一个package中每个文件只写一个init函数。</p><p>Go程序会自动调用init()和main()，不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。  </p><p>程序的初始化和执行都起始于main包，若main中还导入了其他的包，会在编译时将他们依次导入。若一个包被多个包同时导入，则只会被导入一次。若一个包被导入时该包还导入了其他的包，会先将其他包导入进来，然后再对这些包中的常量和变量进行初始化，接着执行init函数（若有），依次类推。所有被导入的包都加载完毕，开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（若有），最后执行main函数。</p><h3 id="标准命令"><a href="#标准命令" class="headerlink" title="标准命令"></a>标准命令</h3><p>go命令是Go语言的基本命令之一，于命令行中输入go，会直接输出所有常见的其他可用命令和相关信息。</p><h2 id="基本词法"><a href="#基本词法" class="headerlink" title="基本词法"></a>基本词法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h4 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h4><ol><li>基本数据类型名称。  </li><li>接口类型error。  </li><li>常量true、false和iota。  </li><li>所有内建函数的名称，即append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、println、real和recover。</li></ol><h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>由一个下划线_表示。一般用在不需要引入一个新邦定的声明中。例如在代码中存在一个变量x，但是却不存在对它的使用。这样的代码会使编译器报错。在变量x的声明代码后添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = x</span><br></pre></td></tr></table></figure></p><p>可以绕过编译器检查，使它不产生任何编译错误。因为x在此处被使用到，但是对x未进行任何操作。在导入声明中，当我们只想执行一下某个代码包中的初始化函数，而不需要使用这个代码包中的任何程序实体的时候，可以编写导入语句为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;runtime/cgo&quot;</span><br></pre></td></tr></table></figure></p><p>引入了这个代码包所需的所有操作，没有绑定到一个具体的名称上，在当前的源码文件中，我们无法对这个代码包中的任何程序实体进行调用。<br>以上，”_”会导致赋值或导入操作的相关准备工作的进行。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-程序声明-："><a href="#1-程序声明-：" class="headerlink" title="1. 程序声明 ："></a>1. 程序声明 ：</h4><pre><code>&gt; import、package</code></pre><h4 id="2-程序实体声明和定义："><a href="#2-程序实体声明和定义：" class="headerlink" title="2. 程序实体声明和定义："></a>2. 程序实体声明和定义：</h4><pre><code>&gt;chan、const、func、interface、map、struct、type、var</code></pre><h4 id="3-程序流程控制："><a href="#3-程序流程控制：" class="headerlink" title="3. 程序流程控制："></a>3. 程序流程控制：</h4><pre><code>&gt;go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><p>用于表示基础数据类型值的各种字面量。基本数据类型。</p><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><p> 用于构造各种自定义的符合数据类型的类型字面量。自定义数据类型如结构体。</p><h4 id="第三类"><a href="#第三类" class="headerlink" title="第三类"></a>第三类</h4><p> 用于表示符合数据类型的值的符合字面量。会被用来构造类型Struct结构体、Array(数组)、Slice(切片)、Map(字典)的值。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="基本类型（预定义类型）："><a href="#基本类型（预定义类型）：" class="headerlink" title="基本类型（预定义类型）："></a>基本类型（预定义类型）：</h4><blockquote><p>string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、complex64、complex128</p></blockquote><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><blockquote><p>Array(数组)、Struct(结构体)、Function(函数)、Interface(接口)、Slice(切片)、Map(字典)、Channel(通道)、Pointer(指针)</p></blockquote><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><blockquote><p>在变量声明中示出的类型。动态类型，在运行时与改变量绑定在一起的实际类型，实际类型可以是实现了这个接口的任何类型。接口类型的变量既拥有静态类型，也有动态类型。接口类型的变量的动态类型可以在执行期间变化，但是变量的静态类型永远只能是它声明时被指定的那个类型。</p></blockquote><h4 id="潜在类型"><a href="#潜在类型" class="headerlink" title="潜在类型"></a>潜在类型</h4><blockquote><p>每一个类型都会有一个潜在类型，若是预定义类型或者由类型字面量构造的符合类型，潜在类型就是它自身。</p></blockquote><p>可以用type声明自定义类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">type iString MyString</span><br><span class="line">type MyStrings [3]string</span><br></pre></td></tr></table></figure></p><p>可以把MyString看作string类型的一个别名类型，MyStrings、iString和MyString的潜在类型都是string。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="与C语言基本一致"><a href="#与C语言基本一致" class="headerlink" title="与C语言基本一致"></a>与C语言基本一致</h4><p>注意:</p><blockquote><p>“+”可以用于操作字符串类型的值，作为字符串连接符使用。<br>“bighua” + “.” + “com” //“bighua.com”<br>字符串连接操作只会创建并使用一个新的字符串值来保存操作结果，不会改变任何操作数值。</p></blockquote><p>新增：</p><blockquote><p>&amp;^     按位清除操作，即根据第二个操作数的二进制值对第一个操作数的二进制值进行相应的清零操作。二元操作符，属于算术操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 7       &amp;^ 13       = 2</span><br><span class="line">00000111 &amp;^ 00001101 = 00000010</span><br><span class="line">      00000111</span><br><span class="line">&amp;^    00001101</span><br><span class="line">=     00000010</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>&lt;- 接收操作，一元操作符，属于接收操作符。只作用于通道类型的值。对于通道ch，表达式&lt;-的含义是从此通道中接收一个值。前提是通道的方向必须允许接收操作，并且该操作的结果的类型必须与通道元素的类型之间存在可赋予的关系。这个表达式会被阻塞直到通道中有一个值可用。</p></blockquote><p>需要注意：</p><ul><li>从一个通道类型的空值（即nil）接收值的表达式将会永远阻塞.</li><li>从一个已经被关闭的通道类型值接收值会永远成功并且立即返回一个其元素类型的零值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">v,ok  = &lt;-ch</span><br><span class="line">v,ok := &lt;-ch</span><br></pre></td></tr></table></figure><blockquote><p>“=”用于将一个值赋给一个已被声明的变量或常量，”:=”用于在声明一个变量的同时对这个变量进行赋值，”:=”只能在函数体内使用。v1，v2，v用于接收值，ok为布尔类型的值，代表了接收操作的成功与否，可用来判断一个通道是否被关闭了，为false时表明通道已经关闭。</p></blockquote><p>操作符优先级：</p><blockquote><p>5      * / % &lt;&lt; &gt;&gt; &amp; &amp;^<br>4     + - | ^<br>3      == !=  &lt;  &lt;=  &gt;  &gt;=<br>2     &amp;&amp;<br>1     ||</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="1-基本表达式"><a href="#1-基本表达式" class="headerlink" title="1. 基本表达式"></a>1. 基本表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[2]</span><br><span class="line">int(v1) + v2</span><br><span class="line">len(v3)</span><br><span class="line">x.f</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3]</span><br><span class="line">interface&#123;&#125;(num).(int)</span><br><span class="line">os.Open(&quot;/etc/profile&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-选择符号和选择表达式"><a href="#2-选择符号和选择表达式" class="headerlink" title="2. 选择符号和选择表达式"></a>2. 选择符号和选择表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.f      //深度0</span><br><span class="line">x.f.f2   //深度1</span><br></pre></td></tr></table></figure><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>对于一个类型T或者对应的指针类型*T的值x，表达式x.f表示类型T的最浅深度（即深度0）的字段或者方法。前提是：T不能是接口类型；类型T必须要有名称为f的字段或者方法。  </li><li>对于一个接口类型I的变量x，表达式x.f表示赋给x的那个值(实现了接口类型I的那个类型的值)的方法f。如果接口类型I的方法法集合中不包含名称为f的方法，那么选择表达式x.f非法。</li></ul><h5 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h5><ul><li>如果x是一个与某个构体类型对应的指针类型的变量，并且它的值为nil，那么针对表达式x.f的赋值和求值都会引起一个运行时的恐慌。不论f是字段还是方法。</li><li>如果x是一个接口类型的变量且它的值为nil，那么针对表达式x.f的调用和求值都会引起一个运行时恐慌，前提是f是该接口类型的一个方法。</li></ul><p>自动解引用：如果x是一个结构体类型对应的指针类型的值，那么x.f就是表达式(<em>x).f的一个速记法，不论f代表的是一个字段还是一个方法，如果f代表了一个字段且也是一个与结构体类型对应的指针类型，那么x.f.f2就是表达式(</em>(*x.f).f2的一个速记法，不论f2是一个字段还是方法。</p><h4 id="3-索引符号和索引表达式"><a href="#3-索引符号和索引表达式" class="headerlink" title="3. 索引符号和索引表达式"></a>3. 索引符号和索引表达式</h4><p>一个索引表达式有一个基本表达式和一个索引符号组成，形如a[x]，会求索引值为x的a中的那个元素的值。  </p><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ul><li>a不是字典类型的值，x必须是一个int类型或者无类型的证书字面量，x大于0且小于a的长度。否则引起一个与越界有关的运行时的恐慌。  </li><li>a是一个数组类型A的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个切片S类型的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。</li><li>a是一个字符串类型T的变量，x必须在a的长度的有效范围内，a[x]表示字符串a中索引值为x对应的那个字节类型值。不能对a[x]进行赋值操作，字符串类型值是不能改变的。</li><li>a是一个字典类型M的变量，x的类型必须是可以赋值给M的键的类型，即键x的类型可以通过类型推断符号判定为M的键的类型。a[x]表示a中的、与键x对应的那个值，且a[x]的类型与字典M的元素的类型相同。若a为nil或者其中不包含以x为键的键值对，那么a[x]的求值结果就会是字典M的元素的类型的零值。通过赋值语句<br>v,ok := a[x]<br>判断是因为上方原因导致的零值还是与键x对应的值本身就是这个零值。ok为true表示赋值成功，原本就是零值，为false则表明由上方情况引起。当a为nil时对a[x]赋值会引起一个运行时恐慌。</li></ul><h4 id="4-切片符号和切片表达式"><a href="#4-切片符号和切片表达式" class="headerlink" title="4. 切片符号和切片表达式"></a>4. 切片符号和切片表达式</h4><p>切片符号可以是操作字符串、数组、数组的指针以及切片类型的值。<br>对于这样一个类型的值a，切片表达式为a[x:y:z]。<br>x代表元素下界索引，y代表元素上界索引，z代表切片的容量上界索引。<br>有如下约束：</p><blockquote><p>0 &lt;= 元素下界索引 &lt;= 元素上界索引 &lt;= 容量上界索引 &lt;= 操作对象的容量  </p></blockquote><p>若不满足，则在表达式求值时造成一个越界错误并引发一个运行时恐慌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]int&#123;1,2,3,4,5&#125;[1:3] = []int&#123;2,3&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[3:] = []int&#123;1,2,3,4,5&#125;[3:5] = []int&#123;4,5&#125;</span><br><span class="line">[]int&#123;1,2,3,4,5&#125;[:3] = []int&#123;1,2,3,4,5&#125;[0:3] = []int&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></p><p>若a代表的是一个切片类型的值，那么表达式a[:]就等同于复制a所代表的值并将其作为此表达式的求值结果。否则表达式a[:]就意味着有一个包含了指向a的第一个元素的指针的切片类型值被创建。</p><h4 id="5-类型断言"><a href="#5-类型断言" class="headerlink" title="5. 类型断言"></a>5. 类型断言</h4><p>对于一个求值结果为接口类型值表达式x和一个类型T，对应的类型断言为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure></p><p>用于判断“x不为nil且存储在其中的值是T类型的”这一假设是否成立。如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致，即为关于“类型T是否为x的动态类型”的判断。  类型T必须是x的一个实现类型，x必须是一个接口类型的值。<br>int(123).(int)引发编译错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid type assertion: 123.(int)(non-interface type int on left )</span><br></pre></td></tr></table></figure></p><p>即表达式int(123)的求值结果是int类型，而int类型并不是一个接口类型。将表达式改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;(123).(int)</span><br></pre></td></tr></table></figure></p><p>则会顺利通过编译，表达式interface{}(123)将字面量123转换为interface{}类型的值。interface{}是一个特殊的接口类型，代表空接口，所有类型都是他的实现类型。<br>如果T不是一个接口类型且类型T不是x的类型的一个实现，那么类型断言x.(T)就是失败的，会引发一个运行时恐慌。</p><blockquote><p>只有在程序运行期间，x的动态类型才能够被获知，而在编译期间能够确定的只有T所代表的类型。  </p></blockquote><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v,ok := x.(T)</span><br><span class="line">``` </span><br><span class="line">断言成功v为已经被转换为T类型的表达式x的求值结果，否着为类型T的零值。ok可以判断断言是否成功，此时类型断言失败也不会引发运行时恐慌。</span><br><span class="line">#### 6. 调用</span><br><span class="line">如果由函数类型F的值f，表达式f(a1,a2,a3)表达了对函数f的调用，同时以a1、a2和a3作为参数传递给函数f。  </span><br><span class="line">方法是函数的一种，比函数多了一个接收者。接收者可以是该方法所属的结构体类型的值，或者与该结构体类型对应的那个指针类型的值。</span><br><span class="line">&gt;在求值一个表达式、赋值语句或者返回语句中包含的操作数的时候，所有的函数调用、方法调用和通信调用都会按照从左到右的顺序被求值。</span><br><span class="line">```code</span><br><span class="line">a := 10</span><br><span class="line">f := func()int&#123; a = a*2;return 5&#125;</span><br><span class="line">x := []int&#123;a,f()&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中，x的值可能是[]int{10,5},也可能是[]int{20,5}。（有待考证</p><h4 id="7-可变长参数"><a href="#7-可变长参数" class="headerlink" title="7. 可变长参数"></a>7. 可变长参数</h4><p>如果函数f可以接受的参数的数量是不固定的，那么函数f就是一个能够接受可变长参数的函数，简称为可变参函数。<br>在可变函数的参数列表的最后总会出现一个可变长参数，这个可变长参数的类型声明形如…T。用于接受数量不定但类型均为T或其实现类型的参数值。等同于一个元素类型为T的切片类型的参数。对于函数f的每一次调用，被传递给可变长参数的值实际上都是包含了实际参数、元素类型为T的切片类型值。对可变参函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func appendIfAbsent(s []string,t ...string)[]string</span><br></pre></td></tr></table></figure></p><p>可以这样编写针对他的调用表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,&quot;C&quot;,&quot;N&quot;,&quot;E&quot;)</span><br></pre></td></tr></table></figure></p><p>其中，与可变长参数t绑定的切片类型值为[]string{“C”,”B”,”E”}。<br>可以直接把一个类型T的切片类型值赋给…T类型的可变长参数，需要在欲赋予可变长参数的那个切片类型值的后面追加…。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,[]string&#123;&quot;C&quot;,&quot;B&quot;,&quot;E&quot;&#125;...)</span><br></pre></td></tr></table></figure></p><p>若有元素类型为string的切片类型的变量s，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendIfAbsent([]string&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;&#125;,s...)</span><br></pre></td></tr></table></figure></p><p>此时可变长参数t的值就是变量s的值，即不会专门创建于个切片类型值来存储其中的实际参数。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启航</title>
      <link href="/2018/04/05/%E5%90%AF%E8%88%AA/"/>
      <url>/2018/04/05/%E5%90%AF%E8%88%AA/</url>
      <content type="html"><![CDATA[<h3 id="搭建缘由"><a href="#搭建缘由" class="headerlink" title="搭建缘由"></a>搭建缘由</h3><p> 在前段时间又重新搭建了一系列的开发环境，安装了数遍双系统和虚拟机，折腾ubuntu和centos，搭建php+nginx+go+mariadb+node等等，期间遇到了很多的新问题，也有一些老问题，学到了很多东西，越来越感觉到笔记的重要性。想要自己搭建一套博客，怕是ui丑到自己都下不去笔。另外耽误时间、服务器配置以及相关稳定性长久性等也是个问题。从今开始，将所学所得所感记录在此。</p><h3 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h3><p>本博客由hexo驱动，尝试过很多主题，例如yilia、material等，最终选择了next主题。之前也尝试过rubuy的jekyll，但是更偏向于比较熟悉的基于node的hexo。使用yilia主题时，强迫症改liyia的侧滑抖动动画，改侧滑背景颜色，最终还是感觉界面不理想，在移动端每个页面上都挂着个人prefile，有种特沙比的感觉，非常浪费空间影响阅读体验，而且作者留了个badjs report收集异常信息和用户信息，感觉很是不爽，并且对应的提交端口貌似没有在维护了，调试时一个红色的eroor简直逼死强迫症。</p><p>使用material主题时也有类似yilia冗余的一点，有个logo perfile简直累赘，而且对应的官方网站相应文档总是加载不出来，貌似被墙了，很遗憾，没搭建完美就放弃了。</p><p>后来用到next主题，对于用户来说要比前两个友好很多，简洁大方，留给了用户更多的配置项，在移动端浏览更简洁舒服，封装了更多的第三方插件。评论插件建议畅言，加载快多了。但是目前有个问题，编写tags、about等page页面时，在page页面配置comments为false，编译后对应的页面虽然不出现畅言插件，即没加入相应的html页面块，但是却加入了相应的js用，然后在控制台会一直报js未寻找到畅言对应html节点的错误。使用来必力虽然也加入了相应的js调用，但是不会出现此类错误，应该编译过程未处理好。等以后有机会再探究修改一番，作为强迫症，把所有的页面评论功能都打开了。。。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望自己能够</p><blockquote><p>勤操代码多读书，善用时间少偷懒。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>BUG制造师</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li>姓名：吴桦</li><li>性别：男</li><li>出生年月：1995/02</li><li>Email： <a href="mailto:huaweiailin@foxmail.com" target="_blank" rel="noopener">huaweiailin@foxmail.com</a></li><li>博客： cocowh.github.io</li><li>GitHub： <a href="https://github.com/cocowh" target="_blank" rel="noopener">https://github.com/cocowh</a></li></ul><hr><h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><p>2014/09-2018/06</p><ul><li>学历：本科</li><li>学校：华中农业大学</li><li>专业：计算机科学与技术</li></ul><hr><h3 id="技术栈（菜鸟，了解程度）"><a href="#技术栈（菜鸟，了解程度）" class="headerlink" title="技术栈（菜鸟，了解程度）"></a>技术栈（菜鸟，了解程度）</h3><p>PHP+Golang+Swoole+Vue+Node</p>]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
