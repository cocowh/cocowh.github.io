---
title: Golang笔记-Go并发底层
tags: [Golang,笔记,并发,底层]
comments: true
categories: [Golang]
date: 2018-04-27 17:38:02
---
Go在操作系统提供的内核线程之上搭建了一个特有两级线程模型，称为Goroutine。其代表的含义为：
>不要用共享内存的方式来通信，作为替代，应该以通信作为手段来共享内存。

Go不推荐以共享内存区的方式传递数据，作为替代，优先使用Channel。被用来在多个Goroutine之间传递数据，并且会保证其过程的同步。提供了一些传统的并发访问控制方式（互斥量、条件变量等）。

## 线程实现模型
Go语言的线程实现模型，有3个核心元素支撑线程实现模型的主框架：   
* M：Machine的缩写。一个M代表一个内核线程。
* P：Processor的缩写。一个P代表了M所需的上下文环境。
* G：Goroutine的缩写。一个G代表了对一段需要被并发执行的Go语言代码的封装。

一个G的执行需要M和P的支持。一个M在与一个P关联之后就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列。该队列中的G会被依次传给与本P关联的M并获得运行时机。

M与KSE（内核调度实体）之间是一对一关系，一个M仅能代表一个内核线程。Go语言的运行时系统（runtime system）用其代表一个内核调度实体，在一个M的生命周期内，其仅会与一个KSE产生关联。M与P以及P与G之间的关系会在实际调度的过程中被改变。M与P之间也总是一对一的，P与G之间是一对多的。一个G最终由一个M来负责运行。

### 1.M
一个M代表了一个内核线程。大多数情况下，创建一个M的原因是由于没有足够的M来关联P并运行其中的可运行的G。在运行时系统执行系统监控或垃圾回收等任务时也会导致新的M的创建。

M结构中字段众多。  
* curg：存放当前M正在运行的G的指针。
* p：指向与当前M相关联的P。
* msraerfm：M的起始函数。
* nextp：暂存与当前M有潜在关联关系的P。把调度器将某个P赋给某个M的nextp字段的操作称为对M和P的预联。有时运行时系统会把被重新启用的M和已与它预联的P关联在一起。

M在被创建之初会被加入到全局的M列表（runtimr.allm）中。然后它的起始函数和准备关联的P（大多数情况下是导致此M创建操作的P）会被设置。最后运行时系统会为它专门创建一个新的内核线程并与之相关联。此时新的M就为执行G做好了准备。起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。全局M列表无特殊意义，运行时系统会通过它获取到所有M的信息。可以防止M被当作垃圾回收掉。

新的M被创建完成后会先进行一些初始化工作，包括对自身所持的栈空间以及信号处理方面的初始化。初始化完成后M的起始函数会被执行（若存在）。若起始函数代表的是系统监控任务，则M会一直在那里执行而不会继续后面的流程。否则在初始化函数执行完毕后，当前M会与准备与它关联的P完成关联。此时一个并发执行环境才形成。

运行时系统管辖的M有时会被停止，例如运行时系统开始执行垃圾回收任务的时候。运行时系统停止M时，在对其属性进行必要的重置之后，把它放入调度器的空闲M列表（runtime.sched.midle）。在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。

M本身是无状态的，M是否空闲仅以它是否存在于调度器的空闲M列表中为依据。

单个Go程序所使用的M的最大数量可以被设置。`使用命令运行Go程序时，一个引导程序先会被启动。引导程序为Go程序的运行建立必要的环境`。引导程序会对M的最大数量进行初始设置，为10000，即一个Go程序最多可以使用10000个M。意味着最理想情况下，同时可以有10000个内核线程被同时运行。操作系统内核对进程的虚拟内存的布局的控制以及大小的限制，此数量级线程可能很难共存，Go语言本身对于线程数量的限制几乎可以被忽略。除此之外可以在Go程序中对该限制进行限制。调用标准库代码包runtime/debug中的SetMaxThreads函数并提供新的M最大数量。执行后会把旧的M最大数量作为结果值返回。若传入的值比当时M的实际数量小，运行时系统会发起一个运行时恐慌。若需要设置M的最大数量，越早调用此函数越好。

### 2.P
P是使G能够在M中运行的关键。运行时系统会适时地让P与不同的M建立或断开关联，以使P中的可运行的G能够在需要的时候及时获得运行时机。类似操作系统内核在CPU之上实时切换不同的进程或线程。

调用runtime.GOMAXPROCS函数，可以改变单个Go程序可以间接拥有的P的最大数量。此外，可以在运行Go程序之前设置环境变量GOMAXPROCS的值来对Go程序可以拥有的P的最大数量做出预先设定。P的最大数量相当于是对可以被并发运行的用户级别的G的数量做出限制。每个P都需要关联一个M才能使其中的可运行的G得到执行，不意味着环境变量GOMAXPROCS的值会限制住M的总数量。当M因系统调用的进行而被阻塞（运行的G进入了系统调用）时，运行时系统会将M和与之关联的P分离出来。此时，这个P的可运行G队列中还有未被运行的G，则运行时系统会找到一个空闲M或创建出一个新的M，并与该P关联以满足这些G的运行需要。若Go程序中创建的大部分Goroutine中都包含了很多需要间接地进行各种系统调用的代码时，即使环境变量GOMAXPROCS的值被设定为1，也可能会有多个M被创建出来。实际的M总数量很可能会比环境变量GOMAXPROCS所指代的数量多。真正使用的内核线程的数量不会因此而环境变量受到限制。

Go程序开始被运行时，引导程序也会对P的最大数量进行设置。默认值为1。默认情况下，无论我们在程序中用go语句启用出多少Goroutine，它们都只会被塞入同一个P的可运行G的队列中。P最大数量值绝不会比引导程序中的硬性上限值大，超过时会被硬性上限值取代。

runtime.GOMAXPROCS函数的执行会暂时使所有的P都相继进入停止状态并试图阻止任何用户级别的G的运行。只有在新的P最大数量被设定完成之后，运行时系统才会开始陆续恢复它们。对程序性能损耗大。即只在Go程序的main函数的开始处调用runtime.GOMAXPROCS函数较好，最好不对其进行调用而只预先设置GOMAXPROCS。

确定P最大数量后，运行时系统会根据这个数值初始化全局P列表（runtime.allp）。包含了当前运行时系统创建的所有P。然后运行时系统把调度器的可运行G队列中的所有G均匀的放入到全局P列表中的各个P的可运行G队列中。此时，运行时系统需要用到的所有P都以就绪。

同空闲M列表，在运行时系统中存在着调度器的空闲P列表（runtime.sched.pidle）。当一个P不再与任何M关联的时候，运行时系统会把它放入到该列表，当运行时系统需要一个空闲的P关联某个M时，会从此列表中取出一个。即使P进入到空闲P列表，它的可运行G列表也不一定是空的。

P本身是有状体的：  
* Pidle：表明当前P未与任何M存在关联。
* Prunning：表明当前P正在与某个M关联。
* Psyscall：表明当前P中的被运行的那个G正在被系统调用。
* Pgcstop：表明运行时系统正在进行垃圾回收。在运行时系统进行垃圾回收时，会试图把全局P列表中的都置于此状态。
* Pdead：表明当前P已经不会再被使用。当在Go程序运行的过程中通过调用runtime.GOMAXPROCS函数减少P最大数量时，多余的P会被运行时系统置于此状态。

P的初始状态时Pgcstop，虽然运行时系统并不会在这时进行垃圾回收。初始化和填充P中的可运行G队列之后，运行时系统会将状态设置为Pidle并放入到调度器的空闲P列表中。空闲P列表中的所有P都会由调度器根据实际情况进行取用。除了Pdead之外的其他状态的P都会在运行时系统进行垃圾回收的时候被置于Pgcstop状态，等到垃圾回收结束之后并不会恢复至原有状态，而会被统一地换为Pidle状态。意味着它们会被重新调度。除了Pgcstop状态，处于其他状态的P都有可能由于全局P列表的缩小而被认为是多余的并置于Pdead状态。P被转换为Pdead状态之前，其可运行G队列中的G都会被转移至调度器的可运行G队列中，其自由G列表中的G都会被转移到调度器的自由G列表中。

每个P中都有一个可运行G列表，还包含一个自由G列表（gfree）。自由G列表中包含一些已经被运行完成的G。随着被运行完成的G的增多，该自由列表可能会很长。若增长到一定程度，运行时系统会把其中的部分G转移到调度器的自由G列表（runtime.sched.gfree）中。当使用go语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G来封装我们提供的函数，仅当获取不到这样的一个G时才有可能区创建一个新的G。若相应P的自由G列表为空而获取不到自由G时，运行时系统若在这个过程中发现其中的自由G太少，则会先尝试从调度器的自由G列表中转移过来一些G。只有在调度器的自由G列表也为空时才会有新的G被创建。很大程度上提高了G的复用率。当一个P被运行时系统认为不会再被使用（被置于Pdead状态）的时候，其中的自由G列表中的所有G都会转移至调度器的自由G列表中。

P的结构中，可运行G队列和自由G列表是最重要的两个成员，间接的体现运行时系统对相应的G的调度情况。

### 3.G
一个G就相当于一个Goroutine(或者称Go程)，对应使用go语句欲并发执行的一个匿名或命名的函数。

Go语言的编译器会把我们编写的go语句（go关键字和其后的函数的统称）变成对一个运行时系统中的函数调用，并把go语句中的函数（go函数）即其参数都作为参数传递给这个运行时系统中的函数。go语句代表了我们向运行时系统递交的一个并发任务。

运行时系统在接到这样一个调用之后，先检查go函数即其参数的合法性，然后会试图从本地P的自由G列表和调度器的自由G列表获取可用的G。没有获取到则会新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（runtime.allg）。新建的G会在第一时间被加入到该列表中。该列表的主要作用是集中存放当前运行时系统中的所有G的指针。无论将会封装当前的go函数的G是否是新的，运行时系统都会对它进行一次初始化。包括关联go函数以及设置G的状态的ID等步骤。初始化完成后，这个G被放入到本地P的可运行G队列中。时机成熟，调度会立即进行以使这个G尽快被运行。

每个G都会由运行时系统根据其实际状况设置不同的状态：  
* Gidle：当前G被创建但还完全未被初始化的时候。
* Grunnable：表示当前G是可运行的并且正在等待被运行。
* Grunning：表示当前G正在被运行。
* Gsyscall：表示当前G正在进行系统调用。
* Gwaiting：表示当前G正在因某个原因而等待。
* Gdead：表示当前G已被运行完成。

运行时系统用一个G封装我们通过go语句递交的go函数的时候，先对这个G进行初始化。其中的一步就是初始化这个G的状态为Grunnable，即一个G真正被使用是在其状态被设置为Gorunnable之后。

一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。

G在退出系统调用时，运行时系统先会尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为Grunnable状态并放入到调度器的自由G列表中。

进入死亡状态（Gdead）的G可以被重新初始化并使用。相比之下，P在进入死亡状态（Pdead）之后则只能面临被销毁的结局。Gdead与Pdead状态所表达的含义完全不同。处于Gdead状态的G会被放入本地P或调度器的自由G列表，为重用提供了条件。

### 4.核心元素的容器
M，P和G的容器：

名称 | 源码 | 作用域 | 说明
:-: | :-: | :-: | :-
全局P列表 | runtime.allm | 运行时系统 | 用于存放所有M的列表
全局P列表 | runtime.allp | 运行时系统 | 用于存放所有P的列表
全局G列表 | runtime.allg | 运行时系统 | 用于存放所有G的列表
调度器的空闲M列表 | runtime.sched.midle | 调度器 | 用于存放空闲M的列表
调度器的空闲P列表 | runtime.sched.pidle | 调度器 | 用于存放空闲P的列表
调度器的可运行G队列 | runtime.sched.runq | 调度器 | 用于存放可运行G的队列
调度器的自由G列表 | runtime.sched.gfree | 调度器 | 用于存放自由G的列表
P的可运行G队列 | runq | 本地P | 用于存放当前P中的可运行G的队列
P的自由G列表 | gfree | 本地P | 用于存放当前P中的自由G的列表

全局的3个列表存在的主要目的是为了统计运行时系统中的所有M、P或G。运行时系统创建出的任何G都会存在于全局G列表中，其于的4个与G有关的列表只会存放在当前作用域内的具有特定状态的G。调度器的可运行G队列和P的可运行G队列都拥有几乎平等的运行机会。运行时系统调度的过程中会先后对它们进行检查，并会运行第一个被发现的可运行的G。从Gsysycall状态和Ggcstop状态转出的G，会被放入调度器的可运行G队列，被运行时系统初始化的G，会被放入本地P的可运行G队列。从Gwaiting状态转出的G，除因网络I/O陷于等待的G，都会被放入到本地P的可运行G队列。调用runtime.GOMAXPROCS函数，可能会导致运行时系统清空调度器的可运行G队列。其中所有G都会被均匀地放入到全局P列表中的各个P的可运行G队列当中。在G转入Gdead状态后，先会被放入本地P的自由G列表，在运行时系统需要用自由G封装go函数时，先尝试从本地P的自由G列表中获取。调度器的自由G列表只起到一个暂存自由G的作用。

与M和P相关的非全局容器被用于存放暂时不被使用的元素的实例。在运行时系统有需要时，会从中获取相应元素的实例并重新启用它。

## 调度器
两级线程模型中的一部分调度任务会由操作系统内核之外的程序承担，Go语言中，其运行时系统中的调度器会负责这一部分调度任务。调度的主要对象是M、P和G的实例，调度的辅助设施是各种容器。每个M（每个内核线程）在运行过程中都会按需执行一些调度任务。
### 1.基本结构
调度器有它自己的数据结构，这一数据结构的主要目的是为了更加方便地管理和调度各个核心元素的实例。调度器的部分字段：

字段名称 | 数据类型 | 用途
 :-: | :-: | :-
 gcwaiting | uint32 | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制
 stopwait | int32 | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制
 stopnote | Note | 垃圾回收任务被执行期间的辅助标记、停止计数和通知机制
 sysmonwait | unit32 | 作为系统检测任务被执行期间的停止和通知机制
 sysmonnote | Note | 作为系统检测任务被执行期间的停止和通知机制

通过调度器gcwaiting的值，可知垃圾回收器是否已经开始准备或正在进行垃圾回收。stopwait字段是为了对还未被停止调度的P进行计数。当计数器为0时，说明调度工作已被完全停止，垃圾回收器会立即开始执行垃圾回收任务。stopnode字段被用来向垃圾回收器告知调度工作已经完全被停止的通知机制的重要部分。

辅助协调手段存在的意义在于保证所有的P在垃圾回收期间都处于Pgcstop状态。`Go语言的垃圾回收器先停止一切调度工作（包括对M和P的调度），然后进行垃圾回收，最后待垃圾回收完成之后再重启调度工作。`即Go语言的垃圾回收任务是在“stop the world”执行垃圾回收任务）的环境下被执行的。“Stop the world”即指运行时系统要放下手头所有工作并专心(无其它并发任务）执行垃圾回收任务。

垃圾回收器在准备执行垃圾回收任务的时候，先把调度器的gcwaiting字段的值设置为1，告诉调度器，它已经开始准备执行垃圾回收任务。垃圾回收器会利用stopnode字段将自身阻塞，以等待调度器完全停止调度。调度器在发现gcwaiting字段的值被置为1之后，会积极响应，并陆续停止正在进行的调度工作。待所有的调度工作均已停止（计数器的stopwait字段的值为0）之后，调度器回利用stopnode字段向垃圾回收器发送通知。垃圾回收器在收到通知后才会真正开始垃圾回收，通知机制在底层由信号灯实现。

垃圾回收器进行垃圾回收的时候，被持续执行的系统检测任务也需要被暂停，sysmonwait和sysmonnode的作用就是及时地暂停和恢复监测任务的执行。sysmonwait字段表示系统监测任务是否已经被暂停的标记，sysmonnode字段则是被用来向执行系统监测任务的程序发送通知。

系统监测任务是被持续执行的，即被置于无尽的循环中。在每次迭代之初，相关程序（系统监测器）会先检查调度器的gcwaiting字段的值，若其值为1，则说明垃圾回收器已经开始准备或正在执行垃圾回收任务。系统监测器会先将调度器的sysmonwait字段的值设置为1以表示系统监测任务已被暂停。然后利用sysmonnode字段阻塞自身以等待垃圾回收的完成。在调度工作被重启之后，调度器若发现其sysmonwait字段值为1则会利用sysmonnode字段向系统检测器发送通知。系统监测器在收到该通知之后会立即执行当次迭代的后续流程并继续进行之后的迭代。
### 2.一轮调度
引导程序为Go程序的运行建立必要的环境。在引导程序完成工作之后，Go程序的main函数才会被真正地执行。引导程序在最后让调度器进行一轮调度，才能让main函数所在的G马上有机会被运行（封装main函数的G总是Go语言运行时系统创建的第一个G）。
<center>

![一轮调度](https://git-blog.oss-cn-beijing.aliyuncs.com/gfayilundiaodu.png) 
</center>
调度器的一轮调度中，有5个子流程。由标准库代码包runtime中的schedule函数代表。调度器会先从一些比较容易找到可运行G的地方入手，即全局的可运行G队列和本地的可运行G队列。若找不到，调度程序进入强力查找模式（子流程“全力查找可运行的G”）。若仍未找到可运行的G，该子流程就会暂停，直到有可运行的G出现才会继续下去。

在一轮调度的开始，调度器会先判断当前M是否已被锁定。M和G可以成对地锁定在一起。调度器会按照一定的策略动态地关联M、P和G，并以此高效地执行并发程序。

锁定M和G的操作是为CGO准备的，CGO代表了Go中的一种机制，时Go程序和C程序之间的一种调用机制。

若调度器在一轮调度之初发现当前M已与某个G锁定，就会停止调度并停止当前M（让其暂时阻塞）。一旦与它锁定的G处于可运行状态，就会被唤醒并继续运行那个G。停止当前M意味着相关的内核线程并不能再去做其他事情。调度器也不会为当前M寻找可运行的G。若当前M找到一个可运行G，但G与某个M锁定，就会唤醒与之锁定的M以运行该G，并重新为当前M寻找可运行的G。

若调度器判断当前M未与任何G锁定，则一轮调度的主流程就会继续运行。调度器会检查是否有运行时串行任务正在等待执行。通过判断gcwaiting字段的值，若不为0则一轮调度流程走进另一个分支:停止并阻塞当前M以等待运行时串行任务执行完。一旦串行任务执行完成,该M就会被唤醒,一轮调度也会再次开始。

若调度器在此关于锁定和运行时串行任务的判断都为假，就会开始真正的寻找G。一旦找到一个可运行的G，调度器在判断该G未与任何M绑定之后，立即让当前M运行它。

一轮调度是调度器中最核心的流程，运行时系统在调度过程中经常使用。例如，在用户程序启动时的一系列工作之后之后，一轮调度会首次启动并使封装main的G被调度运行。某个G的运行时阻塞、结束、退出系统调用、栈的增长都会使调度器进行一轮调度。用户程序对某些标准库函数的调用也会触发一轮调度流程。调用runtime.Gosched函数相当于手动让调度器进行了新一轮的调度，使其他Goroutine能够得到运行机会。调用runtime.Goexit函数会在终结调用它的那个Goroutine之后，立即开始进行新一轮调度以使其他等待运行的Goroutine获得机会。

### 3.全力查找可运行的G
“全力查找可运行G”子流程会尝试从各处搜索可运行的G，甚至会从别的P（非本地P）偷取可运行的G。由runtime.findrunnable函数代表，该函数返回一个处于Grunnable状态的G。搜索流程大致分为2个阶段和10个步骤。  
* （1）获取执行终结器的G。一个终结器（或称终结函数）可以与一个对象关联，通过调用runtime.SetFinalizer函数产生这种关联。当一个对象变为不可达（未被其他任何对象引用）时，垃圾回收器在回收该对象之前，会执行与之关联的终结函数（若有）。所有终结函数的执行都会由一个专用的G负责。调度器会在判定这个专用G已完成任务之后试图获取它，然后把它置为Grunnable状态并放入本地P的可运行G队列。
* （2）从本地P的可运行G队列获取G。
* （3）从调度器的可运行G队列获取G。
* （4）从网络I/O轮询器（netpoller）处获取G。若netpoller已被初始化且已有过网络I/O操作，那么调度器会试着从netpoller获取获取一个G列表，并把表头的G作为结果返回。同时把其余的G放入调度器的可运行G队列。若netpoller未初始化或还未有过网络I/O操作，这一步会跳过。这里的获取浅尝辄止，非阻塞。
* （5）从其他P的可运行G队列获取G。条件允许情况下，调度器使用一种伪随机算法在全局P列表中选取P，然后试着从它们的可运行G队列中盗取（或者说转移）一半的G到本地P的可运行G队列。选取P和盗取G的过程会重复多次，成功则停止。成功会把盗取的一个G作为结果返回，否则搜索的第一阶段就结束。
* （6）获取执行GC标记任务的G。搜索第二阶段，调度器会判断是否正处在GC的标记阶段，以及本地P是否可用于GC标记任务。若答案都是true，调度器会把本地P持有的GC标记专用G置为Grunnable状态并作为结果返回。
* （7）从调度器的可运行G队列获取G。调度器再次尝试从该处获取一个G，并把它作为结果返回。若依然找不到可运行的G，会解除本地P与当前M的关联并把该P放入调度器的空闲P列表。
* （8）从全局P列表中的每个P的可运行G队列中获取G。遍历全局P列表中的P，并检查他们的可运行G队列。只要发现某个P的可运行G队列不为空，取该iP，判定可用后与当前M关联在一起，然后再返回第一阶段重新搜索可运行的G。若所有P可运行G队列都为空，继续后面的搜索。
* （9）获取GC任务标记的G。判断是否正处于GC的标记阶段，以及GC标记任务相关的全局资源是否可用。若答案都是true，调度器就会从其空闲P列表拿出一个P。若该P持有一个GC专用标记G，关联该P与当前M，再次执行第二阶段（步骤（6）开始）。
* （10）网络I/O轮询器（netpoller）获取G。若netpoller已被初始化，并且有过网络I/O操作，调度器再次试着从netpoller获取一个G列表。与步骤（4）基本相同，区别于此处是阻塞的，只有当netpoller有可用的G时阻塞才会解除。若netpoller未被初始化或者未有过网络I/O操作，跳过此步。

若经过上述步骤仍未找到可运行的G，调度器就会停止当前的M。在之后的某个时刻，该M被唤醒之后，会重新进入“全力查找可运行的G”的子流程。

网络I/O轮询器（netpoller）是Go为了在操作系统提供的异步I/O基础组件之上，实现自己的阻塞式I/O而编写的一个子程序。当一个G试图在一个网络连接上进行读/写操作时，底层程序（包括基础组件）就会开始为此做准备，此时这个G会被迫转入Gwaiting状态。一旦准备就绪，基础组件就回返回相应的事件，让netpoller立即通知为此等待的G。从netpoller获取G意味着获取那些已经接收到通知的G。调度器让它们转入Grunnable状态并等待运行。

全力查找可运行G的子流程会想方设法去搜寻G，执行比较耗时费力，会调用多方资源来满足当前M运行G的需要。因始终未找到G而停止的M在被唤醒后，依然会执行该子流程，直到找到一个可运行的G，M才会结束它的执行。

### 4.启用或停止M
调度器有时会停止当前M，由如下函数负责M的启用或者停止。  
* stopm()。停止当前M的执行，直到因有新的G变得可运行而被唤醒。
* gcstopm。为串行运行时任务的执行让路，停止当前M的执行，串行运行时任务执行完毕后会被唤醒。
* stoplockedm()。停止已经与某个G锁定的当前M的执行，直到因这个G变得可运行而被唤醒。
* startlockedm(gp \*g)。唤醒与gp绑定的那个M，并让该M去执行gp。
* startm(_p_ \*p, spinning bool)。唤醒或创建一个M去关联_p_并开始执行。

>底层待完善，见《Go 并发编程实战 第二版》


### 5.系统监测任务
由sysmon函数实现。监测任务主要做：  
* 在需要时抢夺符合条件的G和P；
* 在需要时进行强制GC；
* 在需要时清扫堆；
* 在需要时打印调度器跟踪信息。

>底层待完善，见《Go 并发编程实战 第二版》


### 6.变更P的最大数量
P最大数量变更直接影响Go程序的并发性能。调用runtime.GOMAXPROC函数时，会先进行下面两项检查，确保变更合法和有效。  
* 若传入的参数值（新值）比运行时系统为此设定的硬性上限值（256）大，前者会被后者替代。
* 新值不是正整数，或者与存储在运行时系统中的P最大数量值（旧值）相同，该函数或略此变更直接返回旧值。

>底层待完善，见《Go 并发编程实战 第二版》


## 更多的细节
### 1.g0和m0
运行时系统中的每个M都拥有一个特殊的G，称为M的g0。M的g0管辖的内存称为M的调度栈，对应于操作系统为相应线程创建的栈。M的调度栈也成为OS线程栈或系统栈（参runtime.systemstack函数）。

M的g0由Go运行时系统在初始化M时创建并分配给M的，一般用于执行调度、垃圾回收、栈管理等方面的工作。M还有一个专用于处理信号的G，称为`gsignal`。它的栈称为信号栈。系统栈和信号栈不会自动增长，但一定会有足够的空间执行代码。

除g0，其他由M运行的G都可以视为用户级别G，称为用户G，g0和gsignal称为系统G。g0不会被阻塞，不包含在任何G队列或列表中。栈不会在垃圾回收中被扫描。

除每个M都有属于自己的g0外，还存在一个runtime.g0。runtime.g0用于执行引导程序，运行在Go程序拥有的`第一个内核线程`中，该内核线程称为runtime.m0。runtime.m0和runtime.g0都是静态分配的，引导程序无需为它们分配内存。

### 2.调度器锁和原子操作
并发调度时，调度器会在读写一些全局变量以及它的字段的时候动用调度器锁进行保护。

Go运行时系统在一些需要保证并发安全的变量的存取上使用原子操作。原子操作比锁操作可以有效的节约系统资源和提升系统性能。

### 3.调整GC
目前的GC基于CMS（Concurrent Mark-Sweep，并发标记-清扫）算法，时非分代的和非压缩的。

目前的GC有3种执行模式：  
* gcBackgroundMode，并发地执行垃圾收集和清扫；
* gcFroceMode，串行地值执行垃圾收集（即执行时停止调度），但并发地执行清扫。
* gcFroceBlockMode，串行地执行垃圾收集和清扫。

调度器驱使的自动GC和系统监测任务中的强制GC，都会以gcBackgroundMode模式执行。前者会检查Go程序当前的内存使用量，仅当使用量过大时才真正执行GC，后者无视此条件。

可以通过GODEBUG控制自动GC的并发性，使其值包含gcstoptheworld=1或gcstoptheworld=2，让GC的执行模式由gcBackgroundMode变为gcForceMode或gcForceBlockMode。相当于让并发的GC进入调试模式。

GC会在为Go程序分配的内存翻倍增长时被触发。Go运行时系统会在分配新内存时检查Go程序的内存使用增量。可以通过调用runtime/debug.SetGCPercent函数改变这个增量的阀值，该函数接受一个int类型的参数：在新分配的内存是上次记录的已分配的内存的百分之几时触发GC。若为负数会导致自动GC的关闭；预设值是100。SetGCPercent函数在被调用后会返回旧的增量阀值。设置环境量变量GOGC亦可，含义规则与SetGCPercent一致。将其值设置为off会关闭自动GC。对GOGC的设置需要在Go程序启动之前进行，否则不生效。

关闭自动GC意味着需要在程序中手动GC，调用runtime.GC函数可以手动触发一次GC，该函数会阻塞调用方直到GC完成。这种情况下的GC会以gcForceBlockMode模式执行。调用runtime/debug包的FreeOSMemory函数也会手动触发一次完全串行的GC，并且在GC完成之后还会做一次清除堆的操作。两者在执行时都不会检查Go程序的内存使用增量。





