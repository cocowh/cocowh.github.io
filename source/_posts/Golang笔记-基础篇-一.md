---
title: Golang笔记-基础篇(一)
tags: [Golang,笔记,基础]
comments:   true
categories: [Golang]
date: 2018-04-10 15:24:09
---
## 初识Golang
### 安装
步骤：  

* 在[https://golang.google.cn/dl/](https://golang.google.cn/dl/)选择合适的版本
* 下载

```code
wget -c https://storage.googleapis.com/golang/go1.10.2.linux-amd64.tar.gz
```
* 解压

```code
tar -C /usr/local/ -zxvf go1.10.2.linux-amd64.tar.gz
```

* 添加系统环境变量

```code
vi /etc/profile.d/go.sh
```

* 添加内容

```code
export PATH=$PATH:/usr/local/go/bin
:wq!
```

* 使其生效

```code
source /etc/profile.d/go.sh
```

* 也可直接命令行输入`export PATH=$PATH:/usr/local/go/bin`或者在bash文件中添加。  
* 添加GOPATH目录

```code
mkdir -p ~/dev/go
vim /etc/profile.d/gopath.sh
```

* 添加内容

```code
export GOPATH=/root/dev/go
:wq!
```

* 使其生效

```code
source /etc/profile.d/gopath.sh 
```

一般将软件安装到usr/local中，下载的压缩包解压缩后可直接使用，将其添加置环境变量并为其设置好工作目录即可。GOPATH目录为项目所在目录，可设置多个且随意设置，下方细说。

### Go安装包文件夹

* api文件夹：Go API检查器的辅助文件。
* bin文件夹：官方提供的Go语言相关工具的可执行文件。
* lib文件夹：特殊的库文件。
* pkg文件夹：构架安装后，保存Go语言标准库的所有归档文件。
* src文件夹：所有标准库、Go语言工具，以及相关底层（C语言实现）的源码。
* test文件夹：测试Go语言自身代码的文件。

### 安装注意事项

需要将工作区目录路径添加至环境变量GOPATH中,可指定多个工作区。  

```code
export GOPATH=$HOME/路径/工作区文件夹名:$HOME/路径/工作区文件夹名
```

可使用命令行，要保证$HOME值为正确的当前用户home路径，在此踩到过坑，centos7的HOME值为root（好几次在命令行设置后过一段时间又自动变为root），最后在.bash_profile中设置了HOME值，将上方的设置语句也添加到.bash_profile中，这样能保证每次启动都会设置此值为正确值。

工作区文件夹即为我们的项目编码区，多个工作区可用“:”分开在后面继续添加，命令go get会将指定项目的源码下载到第一个工作区，在其中完成构建和安装，所以一般将第一个工作区设置为用来存放第三方代码库的工作区，存放自己的项目工程的工作区从第二个起。

### 代码包

Go的代码包是对代码进行构建和打包的基本单元，每个源码文件都必须以包声明语句作为文件中代码的第一句，包名即源码文件所在的文件夹名。

```code
package 文件夹名
import 其他包名
import (
    其他包名
    其他包名    
    ...
)
import (
    别名 其他包名
    别名 其他包名
)
```

上面给出了声明包以及导入包的三种形式。别名为“.”时可直接进行代码调用，别名为“_”时，仅对包初始化，无法调用。

>Go通过标示符首字母的大小写控制对应程序实体的访问权限，标示符首字母大写则其对应的程序实体可被本代码包之外的代码访问到，即可导出的。小写则对应的程序实体就只能被本包内的代码访问。

init函数进行包初始化，main函数为程序入口。

### main函数和init函数

init函数能够应用于所有的package，main函数只能应用于package main。这两个函数在定义时不能有任何的参数和返回值。一个package里面可以写任意多个init函数，为可读性和可维护性，建议在一个package中每个文件只写一个init函数。

Go程序会自动调用init()和main()，不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。  

程序的初始化和执行都起始于main包，若main中还导入了其他的包，会在编译时将他们依次导入。若一个包被多个包同时导入，则只会被导入一次。若一个包被导入时该包还导入了其他的包，会先将其他包导入进来，然后再对这些包中的常量和变量进行初始化，接着执行init函数（若有），依次类推。所有被导入的包都加载完毕，开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（若有），最后执行main函数。

### 标准命令
go命令是Go语言的基本命令之一，于命令行中输入go，会直接输出所有常见的其他可用命令和相关信息。

## 基本词法
### 标识符
#### 预定义标识符
1. 基本数据类型名称。  
2. 接口类型error。  
3. 常量true、false和iota。  
4. 所有内建函数的名称，即append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、println、real和recover。

#### 空标识符

由一个下划线_表示。一般用在不需要引入一个新邦定的声明中。例如在代码中存在一个变量x，但是却不存在对它的使用。这样的代码会使编译器报错。在变量x的声明代码后添加：

```code
_ = x
```

可以绕过编译器检查，使它不产生任何编译错误。因为x在此处被使用到，但是对x未进行任何操作。在导入声明中，当我们只想执行一下某个代码包中的初始化函数，而不需要使用这个代码包中的任何程序实体的时候，可以编写导入语句为：

```code
import _ "runtime/cgo"
```
引入了这个代码包所需的所有操作，没有绑定到一个具体的名称上，在当前的源码文件中，我们无法对这个代码包中的任何程序实体进行调用。
以上，"_"会导致赋值或导入操作的相关准备工作的进行。

### 关键字
#### 1. 程序声明 ：

    > import、package

#### 2. 程序实体声明和定义：

    >chan、const、func、interface、map、struct、type、var

#### 3. 程序流程控制：

    >go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch

### 字面量
#### 第一类    

用于表示基础数据类型值的各种字面量。基本数据类型。
#### 第二类

 用于构造各种自定义的符合数据类型的类型字面量。自定义数据类型如结构体。
#### 第三类

 用于表示符合数据类型的值的符合字面量。会被用来构造类型Struct结构体、Array(数组)、Slice(切片)、Map(字典)的值。

### 类型
#### 基本类型（预定义类型）：

 >string、bool、byte、rune、int/uint、int8/uint8、int16\uint16、int32/uint32、int64/uint64、float32、float64、complex64、complex128

#### 复合类型

> Array(数组)、Struct(结构体)、Function(函数)、Interface(接口)、Slice(切片)、Map(字典)、Channel(通道)、Pointer(指针)

#### 静态类型

>在变量声明中示出的类型。动态类型，在运行时与改变量绑定在一起的实际类型，实际类型可以是实现了这个接口的任何类型。接口类型的变量既拥有静态类型，也有动态类型。接口类型的变量的动态类型可以在执行期间变化，但是变量的静态类型永远只能是它声明时被指定的那个类型。

#### 潜在类型

>每一个类型都会有一个潜在类型，若是预定义类型或者由类型字面量构造的符合类型，潜在类型就是它自身。

可以用type声明自定义类型:

```code
type MyString string
type iString MyString
type MyStrings [3]string
```
可以把MyString看作string类型的一个别名类型，MyStrings、iString和MyString的潜在类型都是string。

### 操作符
#### 与C语言基本一致

注意:
> "+"可以用于操作字符串类型的值，作为字符串连接符使用。  
"bighua" + "." + "com" //"bighua.com"       
字符串连接操作只会创建并使用一个新的字符串值来保存操作结果，不会改变任何操作数值。

新增：
> &^     按位清除操作，即根据第二个操作数的二进制值对第一个操作数的二进制值进行相应的清零操作。二元操作符，属于算术操作符。
```code
 7       &^ 13       = 2
00000111 &^ 00001101 = 00000010
      00000111
&^    00001101
=     00000010
```
> <- 接收操作，一元操作符，属于接收操作符。只作用于通道类型的值。对于通道ch，表达式<-的含义是从此通道中接收一个值。前提是通道的方向必须允许接收操作，并且该操作的结果的类型必须与通道元素的类型之间存在可赋予的关系。这个表达式会被阻塞直到通道中有一个值可用。
  
需要注意：

* 从一个通道类型的空值（即nil）接收值的表达式将会永远阻塞.
* 从一个已经被关闭的通道类型值接收值会永远成功并且立即返回一个其元素类型的零值。

```code
v1 := <-ch
v2 = <-ch
v,ok  = <-ch
v,ok := <-ch
```
>"="用于将一个值赋给一个已被声明的变量或常量，":="用于在声明一个变量的同时对这个变量进行赋值，":="只能在函数体内使用。v1，v2，v用于接收值，ok为布尔类型的值，代表了接收操作的成功与否，可用来判断一个通道是否被关闭了，为false时表明通道已经关闭。

操作符优先级：
>5      * / % << >> & &^  
4     + - | ^  
3      == !=  <  <=  >  >=  
2     &&  
1     ||

### 表达式
#### 1. 基本表达式

```code
[]int{1,2,3,4,5}
[]int{1,2,3,4,5}[2]
int(v1) + v2
len(v3)
x.f
[]int{1,2,3,4,5}[1:3]
interface{}(num).(int)
os.Open("/etc/profile")
```
#### 2. 选择符号和选择表达式

```code
x.f      //深度0
x.f.f2   //深度1
```
##### 规则

* 对于一个类型T或者对应的指针类型*T的值x，表达式x.f表示类型T的最浅深度（即深度0）的字段或者方法。前提是：T不能是接口类型；类型T必须要有名称为f的字段或者方法。  
* 对于一个接口类型I的变量x，表达式x.f表示赋给x的那个值(实现了接口类型I的那个类型的值)的方法f。如果接口类型I的方法法集合中不包含名称为f的方法，那么选择表达式x.f非法。

##### 其它情况

* 如果x是一个与某个构体类型对应的指针类型的变量，并且它的值为nil，那么针对表达式x.f的赋值和求值都会引起一个运行时的恐慌。不论f是字段还是方法。
* 如果x是一个接口类型的变量且它的值为nil，那么针对表达式x.f的调用和求值都会引起一个运行时恐慌，前提是f是该接口类型的一个方法。

自动解引用：如果x是一个结构体类型对应的指针类型的值，那么x.f就是表达式(\*x).f的一个速记法，不论f代表的是一个字段还是一个方法，如果f代表了一个字段且也是一个与结构体类型对应的指针类型，那么x.f.f2就是表达式(\*(\*x.f).f2的一个速记法，不论f2是一个字段还是方法。

#### 3. 索引符号和索引表达式
一个索引表达式有一个基本表达式和一个索引符号组成，形如a[x]，会求索引值为x的a中的那个元素的值。  

##### 规则 

* a不是字典类型的值，x必须是一个int类型或者无类型的证书字面量，x大于0且小于a的长度。否则引起一个与越界有关的运行时的恐慌。  
* a是一个数组类型A的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。
* a是一个切片S类型的变量，x需满足上条，若a为nil或x超范围，引起一个运行时恐慌。
* a是一个字符串类型T的变量，x必须在a的长度的有效范围内，a[x]表示字符串a中索引值为x对应的那个字节类型值。不能对a[x]进行赋值操作，字符串类型值是不能改变的。
*  a是一个字典类型M的变量，x的类型必须是可以赋值给M的键的类型，即键x的类型可以通过类型推断符号判定为M的键的类型。a[x]表示a中的、与键x对应的那个值，且a[x]的类型与字典M的元素的类型相同。若a为nil或者其中不包含以x为键的键值对，那么a[x]的求值结果就会是字典M的元素的类型的零值。通过赋值语句  
v,ok := a[x]  
判断是因为上方原因导致的零值还是与键x对应的值本身就是这个零值。ok为true表示赋值成功，原本就是零值，为false则表明由上方情况引起。当a为nil时对a[x]赋值会引起一个运行时恐慌。

#### 4. 切片符号和切片表达式

切片符号可以是操作字符串、数组、数组的指针以及切片类型的值。  
对于这样一个类型的值a，切片表达式为a[x:y:z]。       
x代表元素下界索引，y代表元素上界索引，z代表切片的容量上界索引。  
有如下约束：
>0 <= 元素下界索引 <= 元素上界索引 <= 容量上界索引 <= 操作对象的容量  

若不满足，则在表达式求值时造成一个越界错误并引发一个运行时恐慌。

```code
[]int{1,2,3,4,5}[1:3] = []int{2,3}
[]int{1,2,3,4,5}[3:] = []int{1,2,3,4,5}[3:5] = []int{4,5}
[]int{1,2,3,4,5}[:3] = []int{1,2,3,4,5}[0:3] = []int{1,2,3}
```
若a代表的是一个切片类型的值，那么表达式a[:]就等同于复制a所代表的值并将其作为此表达式的求值结果。否则表达式a[:]就意味着有一个包含了指向a的第一个元素的指针的切片类型值被创建。

#### 5. 类型断言

对于一个求值结果为接口类型值表达式x和一个类型T，对应的类型断言为：

```code
   x.(T)
```

用于判断“x不为nil且存储在其中的值是T类型的”这一假设是否成立。如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致，即为关于“类型T是否为x的动态类型”的判断。  类型T必须是x的一个实现类型，x必须是一个接口类型的值。  
int(123).(int)引发编译错误:

```code
invalid type assertion: 123.(int)(non-interface type int on left )
```

即表达式int(123)的求值结果是int类型，而int类型并不是一个接口类型。将表达式改为：  

```code
interface{}(123).(int)  
```
则会顺利通过编译，表达式interface{}(123)将字面量123转换为interface{}类型的值。interface{}是一个特殊的接口类型，代表空接口，所有类型都是他的实现类型。  
如果T不是一个接口类型且类型T不是x的类型的一个实现，那么类型断言x.(T)就是失败的，会引发一个运行时恐慌。

>只有在程序运行期间，x的动态类型才能够被获知，而在编译期间能够确定的只有T所代表的类型。  

使用

```code
v,ok := x.(T)
``` 
断言成功v为已经被转换为T类型的表达式x的求值结果，否着为类型T的零值。ok可以判断断言是否成功，此时类型断言失败也不会引发运行时恐慌。

#### 6. 调用

如果由函数类型F的值f，表达式f(a1,a2,a3)表达了对函数f的调用，同时以a1、a2和a3作为参数传递给函数f。  
方法是函数的一种，比函数多了一个接收者。接收者可以是该方法所属的结构体类型的值，或者与该结构体类型对应的那个指针类型的值。

>在求值一个表达式、赋值语句或者返回语句中包含的操作数的时候，所有的函数调用、方法调用和通信调用都会按照从左到右的顺序被求值。

```code
a := 10
f := func()int{ a = a*2;return 5}
x := []int{a,f()}
```
在上例中，x的值可能是[]int{10,5},也可能是[]int{20,5}。（有待考证
#### 7. 可变长参数
如果函数f可以接受的参数的数量是不固定的，那么函数f就是一个能够接受可变长参数的函数，简称为可变参函数。  
在可变函数的参数列表的最后总会出现一个可变长参数，这个可变长参数的类型声明形如...T。用于接受数量不定但类型均为T或其实现类型的参数值。等同于一个元素类型为T的切片类型的参数。对于函数f的每一次调用，被传递给可变长参数的值实际上都是包含了实际参数、元素类型为T的切片类型值。对可变参函数：

```code
func appendIfAbsent(s []string,t ...string)[]string
```

可以这样编写针对他的调用表达式：

```code
appendIfAbsent([]string{"A","B","C"},"C","N","E")
```

其中，与可变长参数t绑定的切片类型值为[]string{"C","B","E"}。  
可以直接把一个类型T的切片类型值赋给...T类型的可变长参数，需要在欲赋予可变长参数的那个切片类型值的后面追加...。例如：

```code
appendIfAbsent([]string{"A","B","C"},[]string{"C","B","E"}...)
```
若有元素类型为string的切片类型的变量s，则可以：

```code
appendIfAbsent([]string{"A","B","C"},s...)
```
此时可变长参数t的值就是变量s的值，即不会专门创建于个切片类型值来存储其中的实际参数。