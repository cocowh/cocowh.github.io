---
title: Golang笔记-基础篇(三)
tags: [Golang,笔记,基础]
comments: true
categories: [Golang]
date: 2018-04-12 18:20:31
---
## 数据的使用
### 赋值语句
若值x可以被赋给类型为T的变量，则：

* 值x的类型是T。
* 值x的类型是V，V和T具有相同的潜在类型，V和T至少有一个是未命名的类型。
* 类型T是一个接口类型，值x的类型实现了T。
* 值x是一个双向通道类型的值，T是一个通道类型。
* 值x是预定义标识符nil，可赋给切片、字典、函数、接口、指针、通道等类型的变量。
* 值x是一个由某个数据类型的值代表的无类型的常量，可以被赋给该数据类型的变量。
* 所有值都可以赋给空标识符“_”。

```code
var ints = []int{1, 2, 3}
ints[1], ints[2] = (ints[1] + 1), (ints[2] + 2)
ints[1], _ = (ints[1] + 1), (ints[2] + 2)
ints[1], ints[2] = (ints[1] * (ints[0] + 1)), (ints[2] * (ints[0] + 2))
i1 += 1 //i1 = i1 + 2
i2 &= 2 << 3 //i2 = i2 & (2<<3)
```

“=”两边的表达式的数量不相等，左边可以有多个，对于右边的唯一表达式有：  

* 表达式是一个调用会返回多个结果的函数或者方法的表达式。
* 表达式是一个应用于字典之上的索引表达式。v, ok := map["k"]。
* 表达式是一个类型断言表达式。v, ok ：= x.(string)。
* 表达式是一个由接收操作符和通道类型值组成的表达式。v,ok := <-ch。  

除此之外赋值操作符两边的表达式数量必须一致，并都都是单值表达式。

```code
i := 1
s := []string{"A", "B", "C"}
i,s[i-1] = 2, "Z"
```
s值是[]string{"Z", "B", "C"}而不是[]string{"A", "Z", "C"}，对表达式i-1的求值先于赋值，在赋值之前，第二个赋值对象被确定为s[0]。

```code
a, b = b, a             //交换变量值
x := []int{1, 2, 3}     //切片初始化
x[0], x[0] = 1, 2       //从做到有执行最终x[0=2
x[2], x[3] = 4, 5       //索引超范围引发恐慌，但x[2]=4已被变更 
```
### 常量与变量
某量保持不变称为常量，否则称为变量。
#### 常量
常量在编译期间被创建，作为局部变量被定义在函数内部，由字面量或常量表达式赋值。  

分为布尔常量、rune常量（字符常量）、整数常量、浮点数常量、复数常量和字符串常量。  

常量可以是有类型的也可以是无类型，可以被显式地给定类型，也可以被隐含地给定类型。  
##### 常量表达式
仅以常量作为操作数的表达式。

```code
2 + 3.0         //无类型的浮点数常量5.0
15 / 4.0        //无类型的浮点数常量3.75
'w' + 1         //无类型的rune常量'x'
---
1 << 3.0        //无类型整数常量8
1.0 <<3         //无类型整数常量8
1 << 100        //无类型的整数常量1267650600228229401496703205376超出范围
---
"A" > "C"       //无类型的布尔常量false
```
##### 常量的声明
使用关键字const将字面常量或常量表达式与标识符绑定在一起。

```code
const untypedConstant = 10.0    //无类型常量
const typedConstant int64 = 1024  //类型为int64的常量

const tc1, tc2, tc3 int64 = 1024, -10, 88 //平行赋值
```
左侧只允许插入一个类型字面量，规定作则标识符的类型，右侧的常量类型需与其一致，未给定类型，则右侧常量类型彼此独立。

```code
const utc1, utc2, utc3 = 6.3, false, "C"
=
const (
    utc  = 6.3
    utc2 = false
    utc3 = "c"
)
=
const (
    utc1, utc2 = 6.3, false
    utc3       = "c"
)
```

并不需要显式的对所有常量赋值，被省略赋值的常量，会被隐含地赋与其上面的、最近的且被显式赋值的那个常量的值。

```code
const (
    utc1, utc2 = 6.3, false恒等
    utc3       = "C"
    utc4
    utc5 
)
=
const (
    utc1, utc2 = 6.3, false
    utc3       = "C"
    utc4       = "C"
    utc5       = "C"
)
---
const (
    utc1         =       6.3
    utc2, ytc3   =   false, "C"
    utc4, utc5
)
```

对此有规则：  

* 若有未被显式赋值的常量，同一行的常量的赋值都必须被省略。
* 未显式赋值的那一行的常量声明中的常量标识符数量必须与在它上面的、最近的且显式赋值的那一行常量声明中的常量标识符的数量相等。

iota代表了连续的、无类型的整数常量，第一次出现在一个以const开始的常量声明语句中的时候总会表示整数常量0。随着在同一条常量声明语句中包含iota的常量的递增，iota所表示的整数值也会递增。

```code
const (
    a = iota
    b
    c
)
=
const (
    a = 0
    b = 1
    c = 2
)
---
const (
    u = 1 << iota
    v
    w
)
=
const (
    u = 1 << 0
    v = 1 << 1
    w = 1 << 2恒等
)
=
const (
    u = 1
    v = 2
    w = 4
)
---
const (
    e, f = iota, 1 << iota
    g, h
    i, j
)
=
const (
    e, f = 0, 1
    g, h = 1, 2
    i, j = 2, 4 
)
---
const (
    e, f = iota, 1 << iota
    _, _
    g, h
    i, j
)
=
const (
     e, f = 0, 1
     g, h = 2, 4
     i, j = 3, 8
)
```

在同一条常量声明语句中，iota代表的整数常量的是否递增取决于是否又有一个常量声明包含了它，而不是它是否又在常量声明中出现了一次。可用空标识符“_”跳过iota表示的递增序列中的某个或某些值。

#### 变量
在声明之后可以被赋值任意次，值在程序运行期间才被计算。
##### 变量声明
以关键字var开始：

```code
var v int64 = 0 //声明变量的类型
var x = 0       //省略变量的类型
```
变量的类型未被显示指定将由变量值推导得出。

```code
var (
    v1 = 0
    v2 = -1
)
---
var v3, v4, v5 float64
=
var v3, v4, v5 float64 = 0.0, 0.0, 0.0
```

隐式赋值在变量声明中不可用，未被显示赋值的变量值将会是与改变量的类型相对应的零值，此时变量的类型不可省略。
##### 局部变量
变量声明可以作为源码文件中的顶级元素，也可以称为函数体内容的一部分，前者全局变量，后者局部变量。

```code
package main
import "fmt"
var v6 bool //全局变量
func main(){
    var v6 bool = true  //局部变量
    fmt.Printf("v6: %v\n", v6)恒等
}

```
在函数体内部，局部变量会遮蔽与其同名的全局变量。
函数体内部的短变量声明：

```code
v6 := true
v7, v8 := "Go", 1.2
v8, v9 := 2.0, false    //v8重声明
```
重声明为对在当前上下文环境中的已存在变量的又一次赋值，赋的值与改变量的类型之间应满足赋值规则。  

重声明仅出现在短变量声明中，不能用普通的声明方式重新声明一个在当前上下文环境中已存在的变量，不论改变量是一个全局变量还是一个局部变量。  
短变量声明条件：  

* 仅能够在函数体内部声明变量的时候使用。     
* :=的左边的标识符至少有一个代表在当前上下文环境中的新变量。

空标识符“_”代表的不是新变量。短变量声明可以出现在if、for和switch等语句的初始化器中，并被用来声明仅存在于这些语句块中的局部临时变量。  

在当前上下文环境中声明了某个局部变量但没有使用它，会造成一个编译错误，对变量的赋值不算对其使用。  
### 可比性与有序性
#### 类型的恒等
对于两个命名类型来说，名称不同，肯定不恒等，名称相同且源于相同的类型声明，则是恒等的。别名类型与它的源类型是两个完全不同的类型，命名类型和匿名类型总是不相等的。  

恒等判断规则：  

* 数组类型，长度一致且元素的数据类型一致。
* 切片类型，元素的数据类型一致。
* 结构体类型，字段声明的数量相同且对应位置上的字段具有相同的字段名称和恒等的数据类型。字段声明的标签实际上是一个字符串字面量，标签一致也为判断恒等的依据。
* 指针类型，基本类型（指向的那个类型）恒等。
* 函数，包含了相同数量的参数和结果声明，并且对应位置上的参数和类型都是恒等的。不关注参数和结果名称，只关注数量、顺序和类型。若为可变参函数则都为可变参函数。
* 接口类型，拥有相同的方法集合。
* 字典类型，具有恒等的元素类型和键类型。
* 通道类型，具有恒等的元素类型且方向相同。

#### 数据的可比性和有序性
可比性是可以判断相等与否，有序性是可以比较大小。  

* 布尔值具有可比性。
* 整数类型值具有可比性和有序性。
* 浮点数类型值具有可比性和有序性。
* 复数类型值具有可比性。
* 字符串值具有可比性和有序性。
* 指针值具有可比性。指向同一个变量或者都为空值nil。
* 通道类型值具有可比性。元素类型和缓冲区大小都一致。
* 接口类型值具有可比性。拥有相等的动态类型和相同的动态值。若都为空值也相等。
* 非接口类型X的值可以与接口类型T的值t判断相等，当且仅当接口类型T具有可比性且类型性X式接口类型T的实现类型。
* 结构体类型中的所有字段都具有可比性，则结构体类型的值具有可比性。
* 数组类型值具有可比性。元素类型的值具有可比性。

切片类型、字典类型和函数类型的值不具有可比性，这些值可以与空值nil进行判等。
### 类型转换
把一个类型的值转换为另一个类型的值。

```code
T(x)
---
*string(v)
---
<-chan int(v) = <-(chan int(v))//将v转换为chan int类型的值，在从此通道中接收一个int类型的值

(<-chan int)(v) //将v转换成通道类<-chan int的值
---
func()(v) //结果为v的无参数匿名函数

(func())(v) //将v转换为函数类型的值

func() int(v)  = (func() int)(v) //将v转换为函数结果为int类型的函数类型。  
```

#### 数值类型之间的转换
...
#### 与string类型相关的转换
...
#### 别名类型值之间的转换
...
### 内建函数
#### close函数
只接受通道类型的值作为参数。

```code
ch := make(chan int,1)
close(ch)
```

使作为参数的通道无法在接受任何元素值。若试图关闭一个仅能接受元素值的通道，则造成一个编译错误。通道关闭之后再向它发送元素值或者试图再次关闭它，都会引发一个运行时恐慌。试图关闭一个nil的通道值也会引发一个运行时恐慌。  
关闭一个通道不会影响关闭之前已经发送的那些元素值，关闭之后所有的接收操作都会立即返回一个该通道的元素类型的零值。
#### len函数和cap函数

len的使用：
>参数类型为字符串类型，返回string类型值的字节长度；  
参数类型为数组类型或数组指针类型，返回数组类型值的长度；  
参数类型为切片类型，返回切片类型的长度；  
参数类型为字典类型，返回字典类型值的长度，即其中已包含的键的数量；  
参数类型为通道类型，返回通道类型值当前包含的元素的数量。

cap的使用：
>参数类型为数组类型或数组类型指针，返回数组类型的长度；  
参数类型为切片类型，返回切片类型值的容量；
参数类型为通道类型，返回通道类型值的容量。

#### new函数和make函数

参见{% post_link Golang笔记-基础篇-二 %}数据初始化部分。
#### append函数和copy函数

参见{% post_link Golang笔记-基础篇-二 %}切片部分。
#### delete函数

专用于删除一个字典类型之中的某个键值对。

```code
delete(m, k)//m为字典类型值，k为要删除键值对的键
```
* 参数k与m的键之间必须满足赋值规则。
* m是nil或者k所代表的键值对不存在与m中时，delete(m, k)不会做任何操作，删除操作被忽略，这种删除失败不会被反馈。

#### complex函数、real函数和imag函数

专用于操作复数类型值。

```code
var cplx128 complex128 = complex(2,-2) //根据浮点数类型的实部和虚部来构造复数类型值

var im64 = imag(cplx128) //从浮点数类型值中抽取浮点数的虚部部分
var r64 = imag(cplx128)  //从 浮点数类型值中抽取浮点数的实部部分
```

#### panic函数和recover函数

分别用于报告和处理运行时恐慌。  

>panic只接受一个参数，参数可以是任意类型的值。要生成和报告一个运行时的恐慌可以直接调用此函数并传递给他一个用以描述恐慌细节的值。参数的类型常常是接口类型error的某个实现类型。        

>recover不接受任何参数，返回一个interface{}类型的结果值。即其结果值可能是任何类型的，可能是nil。为nil时可能是因为：   
>
* 传递给panic函数的参数值就是nil。
* 运行时的恐慌根本没有发生，即panic没有被调用。
* 函数recover并没有在defer语句中被调用。

#### print和println函数
把参数值在标准输出上打印出来且不返回任何结果值。  

print的作用是依次（从左到右）打印传递给它的参数值，每个参数值对应的打印内容都由它们的具体实现决定。peintln函数在print函数打印的内容基础上在每个参数之间加入空格“ ”，并在最后加入换行符。
>Go语言不保证会在以后每个版本中保留和则两个函数，尽量不要使用这两个函数，使用标准库代码包fmt中的函数Print和Println替代。

---

## 总结

Go语言的语法和C/C++、Java等有很大的不同，较类似于C。语法设计更为复杂，好处是使用起来会更加方便快捷。Go通过结构类和接口形成面向对象思想，吸取了Python中的切片、字典等数据类型。新增了通道，Go中非常重要的一种数据类型。将函数也作为一等数据类型，能够实现闭包，通过语法特性可以很方便的实现策略模式、泛型等。
