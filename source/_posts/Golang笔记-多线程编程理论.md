---
title: Golang笔记-多线程编程理论
tags: [Golang,笔记,多线程,操作系统,底层]
comments: true
categories: [Golang]
date: 2018-04-25 17:08:28
---
Linux操作系统提供以POSIX（Portable Operating System Interface of Unix）标准中定义的线程为中心的各种系统调用，最贴近POSIX线程标准的线程实现称为NPTL（Native POSIX Threads Library），已成为Linux默认的线程实现。

Go语言的并发编程模型在底层是由操作系统所提供的线程库支撑的。
## 线程
一个线程可以被看作是在某个进程中的一个控制流。一个进程至少包含一个线程，进程的第一个线程随着进程的启动被创建，被称为该进程的主线程。一个进程的其他线程由当前进程中已存在的线程所执行相应的系统调用（pthread_create函数）创建，拥有多个线程的进程可以并发的执行多个任务，并且即使某个或某些任务被阻塞也不会影响到其他任务的正常执行。可以改善程序的响应时间和吞吐量。一个线程必属于某一个进程，生命周期不可逾越所属进程的生命周期。

一个进程中的所有线程都拥有自己的线程栈，存储自己的私有数据。线程栈被包含在操作系统内核分配给其所属进程的虚拟内存地址中。一个进程中的很多资源会被其中的所有资源共享，共享资源包括在当前进程的虚拟内存地址中存储的代码段、数据段、堆、信号处理函数，以及当前进程所持有的文件描述符等。

操作系统内核提供若干个系统调用以使应用程序能够管理当前进程中的所有线程，应用程序可以通过相应的系统功能协调这些线程的运行。系统功能由一些同步原语代表。

### 1.线程的标识
同进程一样，每个线程也都有属于它自己的ID，称为线程ID或TID。线程ID在系统范围内可以不是唯一的，在其所属进程的范围内必须是唯一的。Linux操作系统的线程实现确保每个线程在系统范围内的唯一性。线程不复存在后，其线程ID可被其他线程复用。

线程的ID由操作系统内核分配。应用程序无需关注。在调试时，线程ID帮助区别不同的线程。

### 2.线程间的控制
同一个进程中的任意两个线程的关系都是平等的，不存在层级关系。任何线程都可以对其所属的进程中的其他线程进行有限的管理。主要有：  
* 创建线程：主线程在其所属进程启动的时候被创建，此处针对其他线程的创建。任何线程都可以通过调用系统调用`pthread_create`来创建新的线程。创建线程时，调用线程需要给定新线程将要执行的函数以及传入该函数的参数值。代表该函数的参数被命名为start，通常称start函数。start函数可有返回值。在其他线程中通过与新线程的连接得到在该新线程中执行的start函数的返回值，若新线程创建成功，调用线程得到新线程的ID。
* 终止线程：线程可以通过多种方式终止其所属进程的其他线程。例如调用系统调用`pthread_cancel`。`pthread_cancel`函数取消给定的线程ID代表的线程。它会向目标线程发出一个请求，要求它立即终止执行。该函数只是发送请求并立即返回，不会等待目标线程对该请求做出响应。至于目标线程什么时候对此请求做出响应、做出怎样的响应，则取决于另外的因素（目标线程的取消状态即类型）。默认情况，目标线程总是会接收线程取消请求，等到时机成熟（执行到某个取消点）的时候目标线程才会去响应线程取消请求。
* 连接已终结的线程：由系统调用pthread_join代表。该函数会一直等待（阻塞）与给定的线程ID对应的线程的终止，并把该线程执行的start函数的返回值告知给调用线程。如果目标线程已经处于终止状态，该函数会立即返回。类似把调用线程放置在目标线程后面，当目标线程把流程控制权交出后，调用线程接过流程控制权并继续执行pthread_join函数调用之后的代码。如果一个线程是可被连接的，终止之时必须被连接，否则会变成一个僵尸线程。僵尸线程导致系统资源的浪费，使所属进程的可创建线程数量被无意义减少。
* 分离线程：将一个线程分离，意味着它不再是一个可被连接的线程。默认情况下，一个线程总是可以被其他线程连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自动进行清理和销毁工作。分离操作是不可逆的，无法使一个不可连接的线程变回到可被连接的状态。但是对于一个已处于分离状态的线程执行终止操作仍然会起作用。分离操作由系统调用pthread_detach代表，接受一个代表了线程ID的参数值。

一个线程对自身也可以进行两种控制：终止和分离。线程终止自身的方式有很多种，在线程执行的start函数中执行return语句会使该i线程随着start函数的执行结束而终止。在主线程中执行了return语句，当前进程中的所有线程都会被终止。在任意线程中调用系统调用exit也会达到一样效果。另一种显示地调用系统调用pthread_exit。在主线程中调用pthread_exit函数，只有主线程自己会被终止，其他线程仍然会正常运行。线程分离自身与分离其他线程的方式一致，调用pthread_detach函数。区别在于调用线程传递给该函数的线程ID是自己的ID还是其他线程的ID。

### 3.线程的状态
线程只是进程的一个控制流，对进程的状态描述几乎都适用于线程。

线程在被创建出来之后会进入就绪状态，处于就绪状态的线程会等待被运行的时机。

一旦该线程被真正地运行，就会由就绪状态转换至运行状态。正在运行的线程可能会由于某些原因（等待未完成的I/O操作、等待还未接收到的信号、等待获得互斥量、等待某个条件变量）被阻塞，进而由运行状体转换至睡眠状态。当阻塞线程等待的事件或条件发生或满足时，线程被唤醒。从睡眠状态转出，先进入就绪状态等待运行时机。若CPU处于空闲状态则会立即运行。处于运行状态的线程有时也会因CPU被其他线程抢占而失去运行时机，从而转回至就绪状态并等待下一个运行时机。操作系统内核的调度器会按照一定的算法和策略使线程在这三个状态之间状态之间转换。线程在其生命周期的大部分时间里都会处于就绪状态、运行状态或睡眠状态之中。

在当前线程自我终结或者其他线程向当前线程发出取消请求且取消时机已到之后，当前线程就会试图进入终止状态。若当前线程之前没有被分离，且此时没有其他线程与它连接，则当前线程进入僵尸状态而非终止状态。当且仅当有其他线程与之连接之后，当前进程才会从僵尸状态转换至终止状态。处于终止状态的线程才会被操作系统内核回收。在任意线程中调用exit函数以及在主线程中执行return语句，都不但会使其所属进程中的所有线程立即终止，还会结束该进程的运行，无论当前线程是否被分离。

### 4.线程的调度
调度器的实时调度和切换，产生众多线程并行运行的现象。调度器把时间划分成极小的时间片并把这些时间片分配给不同的线程，以使众多线程都能有机会在CPU上运行。

线程的执行总是趋向于CPU受限或I/O受限。即线程要么需要花费一定的时间使用CPU进行计算，要么花费一些时间等待相对较慢的I/O操作的完成。一个线程的趋向性并不总是清晰的，调度器往往需要猜测它们，依据对线程的趋向性的猜测把它们进行分类，并让I/O受限的线程具有更高的动态优先级以优先使用CPU。因为I/O操作往往花费很长的时间，应让其尽早地开始执行

线程的动态优先级可以被调度器实时调整，线程的静态优先级只能由程序指定。若程序没有显示的指定一个线程的静态优先级，则将被设定为0。调度器不会改变线程的静态优先级。线程的动态优先级是调度器根据其静态优先级调整得出。线程的静态优先级决定线程单次能够在CPU上运行的最长时间，即调度器分配给它的时间片的大小。

所有等待CPU的线程会被按照动态优先级从高到低的顺序排入到与该CPU对应的运行队列中。下一个被运行的线程总是动态优先级最高的一个。每一个CPU的运行队列中都包含两个优先级阵列，其中的一个用于存放正在等待运行的线程（激活的优先级阵列），另一个用于存放已经运行过但还未完成的线程（过期的优先级阵列）。优先级阵列是一个由若干个链表组成的数组。一个链表只会包含具有相同优先级的线程，一个线程也只会被放到与它的优先级相对应的哪一个链表中。当一个线程被放入某个优先级阵列的时候，实际上是被放入与它的优先级相对应的那个链表的末尾处。

下一个被运行的线程总是会从激活的优先级阵列中选出。若调度器发现某个线程已经占用了CPU很长时间（小于或等于该线程的时间片），并且激活的优先级阵列中还有优先级与它相同的线程在等待运行，那么调度器会让等待的线程在CPU上运行。被换下来线程被排入过期的优先级阵列。当激活的优先级阵列中没有待运行的线程的时候，调度器会把这两个优先级阵列的身份互换，即之前的激活的优先级阵列称为新的过期的优先级阵列，之前的过期的优先级阵列成为新的激活的优先级阵列。被放入过期的优先级阵列的线程就又有机会被运行了。

线程被阻塞进入睡眠状态会从运行队列中被移除，不能够被调度和运行。睡眠状态分为可中断的睡眠状态和不可中断的睡眠状态，同多进程篇释意。

线程因等待某个事件或条件的发生而被加入到对应的等待队列中，并随即进入睡眠状态。当事件或条件发生时，内核通知对应的等待队列中的所有线程，线程被唤醒从等待队列转移至适当的运行队列中。调度器会稍稍调高被唤醒的线程动态优先级，使这类线程能够更早地被运行。

若计算机上有多个CPU，平衡它们之间的负载也是调度器的工作。调度器尽量使一个线程在一个特定的CPU上运行。有利于维护高速缓存的高命中率以及高效使用就进的内存。内核会为每个CPU都建立一个运行队列，每个队列中都保存对应CPU的负载系数。调度器根据这一系数了解并调整各个CPU的负载（还有其他因素），把在较忙碌的CPU上运行的线程迁移至其他较空闲的CPU上运行。

操作系统内核的调度器使用若干策略对众多线程在CPU上的运行进行干涉，使得操作系统中的各个任务都能够有条不紊地进行，同时兼顾效率和公平性。通过协调各个线程的状态达到调度的目的。

### 5.线程实现模型
线程的实现模型主要有3个：用户级线程模型、内核级线程模型和两级线程模型。差异于线程与内核调度实体（Kernel Scheduling Entity,简称KSE）之间的对应关系上。内核调度实体是可以被内核的调度器调度的对象。也被称为内核级线程，是操作系统内核的最小调度单元。  
*  用户级线程模型：由用户级别的线程库全权管理。线程库并不是内核的一部分，只被存储在进程的用户空间之中。进程中的线程的存在对于内核来说是无法感知的，不是内核调度器的调度对象。对线程的各种管理和协调是用户级程序的自主行为，与内核无关。应用程序在对线程进行创建、终止、切换或同步等操作的时候，并不需要让CPU从用户态切换到内核态。用户线程模型在线程操作的速度上存在优势，对线程的管理不需要内核参入，程序的移植性更强。在此模型下的多线程不能够被真正地并发运行。当线程在I/O操作过程中被阻塞，其所属进程也会被阻塞，由线程无法被内核调度造成。调度器将进程看作一个无法再被分割的调度单元，无论其中存在多少个线程。即使计算机上存在多个CPU进程中的多个CPU也无法被分配给不同的CPU运行。对于CPU的负载均衡来说，进程的粒度太粗，让不同的进程在不同的CPU上运行的意义微乎其微。线程的优先级页形同虚设。同一个进程中的所有线程的优先级只能由该进程的优先级来体现。线程库对线程的调度不受内核控制，与内核为进程设定的优先级是没有关系的。现代操作系统都不是使用这种模型来实现线程的。由于包含了多个用户级线程的进程只与一个KSE相对应，这种线程实现模式也被称为多对一（M：1）的线程实现。
* 内核级线程模型：该模型下的线程由内核负责管理。是内核的一部分，应用程序对线程的创建、终止和同步都必须通过内核提供的系统调用来完成，进程中的每一个线程都与一个KSE相对应。内核可以分别对每一个线程进行调度。内核级线程模型又被称为一对一（1：1）的线程实现。线程完全由内核管理和调度，可以真正实现线程的并发运行。这些线程完全由内核来管理和调度，内核在极短的时间快速切换和运行各个线程使得它们看起来像正在被同时运行。即使进程中的一个线程由于某种原因进入到了阻塞状态，其他线程也不会受到影响并可以正常的运行。使得内核在多个CPU上进行负载平衡变得容易和有效。如果一个线程与被阻塞的线程之间存在同步关系，则可能受到影响。这是一种应用级别的干预，不属于线程本身的特质。内核对线程的全权接管使操作系统在库级别几乎无需为线程管理做什么事情。与用户级别线程模型形成鲜明的对比。内核线程的管理成本比用户级别线程高出很多。线程的创建会使用到内核资源。创建线程、切换线程、同步线程等操作所花费的时间也会更多。如果一个进程包含了大量的线程，会给内核的调度器造成非常大的负担，会影响到操作系统的整体性能。`采用内核级线程模型的操作系统对一个进程中可以创建的线程的数量有直接或间接的限制`。很多现代操作系统都是以内核级线程模型实现线程的，包括Linux操作系统。
* 两级线程模型：两极线程模型的目标是取前两种模型的精华，去二者只糟粕。被称为多对多（M：N）的线程实现。在此模型下，一个进程可以与多个KSE相关联。这与内核级线程模型是相似的。不同的是，进程中的线程（应用程序线程）并不与KSE一一对应。应用程序线程可以被映射到同一个已关联的KSL上。已被加载到进程的虚拟内存中的实现两级线程模型的线程库会通过操作系统内核创建多个内核级线程。然后，通过这些内核级线程对应用程序线程进行调度。大多数此类线程库都可以为实际运行运行的应用程序线程动态地分配若干个内核级线程。使线程的管理工作更加复杂，需要内核和线程库的共同努力和协作才能正确、有效地进行。但是内核资源的消耗得以减少，使线程管理操作的效能提高。因实现的复杂性，往往不会被操作系统内核的开发者采纳。但可以很好地在编程语言层面上实现并发挥出其应有的作用。`Go的并发编程模型与两级线程模型在理念上相似`，具体实现方式更加高级优雅些。`Go的并发编程模型中`，不受操作系统内核管理的独立控制流并不被叫作应用程序线程或者线程，而被称为Goroutine(也可称为Go程)。

## 线程的同步
同步，永远是多线程编程中最核心和重要的话题之一。为多个线程更好地协同工作或者维持共享数据的一致性，以后者为目的的同步比较常见。
### 1.共享数据的一致性
包含多个线程的程序（多线程程序）多以共享数据作为在线程之间传递数据的手段。一个进程所拥有的相当一部分虚拟内存地址都可以被该进程中的所有线程所共享，这些被共享的数据大多以内存空间作为载体。共享数据的一致性代表着某种约定，在该约定成立的前提下，多线程程序中的各个线程才能够使相应的流程被正确地执行。

临界区是只能被串行化地访问或执行的某个资源或某段代码。亦被称作串行区域。保证临界区有效的最佳方式是利用同步机制，针对多线程的同步机制有：原子操作、互斥量、条件变量。
### 2.互斥量
在同一时刻只允许一个线程处于临界区之内的约束被称为互斥。每一线程在进入临界区之前都必须先锁定某个对象。只有成功锁定对象的线程才会被允许进入到临界区之内，否则就会被阻塞。这个对象被称为互斥对象或互斥量。

互斥量有两种可能的状态，锁定状态和未锁定状态。每次只能被锁定一次，任何线程都不能对它进行二次加锁。成功锁定互斥量的线程成为该互斥量的所有者，只有互斥量所有者才能对该互斥量进行解锁。锁定即对互斥量的获取，解锁即对互斥量的释放。

为合理、安全使用共享数据，应把操作同一个共享数据的代码都置于一个或多个临界区之内，并使用一个互斥量对它们进行保护。互斥量必须能够被使用相应的共享资源的线程访问到，因此互斥量的变量或常量一般不是局部的。为尽量少的暴露程序的实现细节，应该在满足要求的前提下最小化互斥量的访问权限。初始化互斥量应该在任何线程真正使用它之前进行。若多个线程将要执行的代码中都包含了对同一个互斥量的初始化操作，必须保证该互斥量只会被初始化一次。互斥量对每个想要锁定它的线程都是平等的。

>对互斥量的初始化必须要保证唯一性，线程在离开临界区时候必须要及时解锁互斥量，以免造成不必要的性能损耗甚至死锁。

在一般情况下，应该尽量少地使用互斥量。每个互斥量保护的临界区应该在合理范围内并尽量地大。若多个线程频繁地进入某个较大的临界区，并且之间经常存在访问冲突，应该把这个较大的临界区切分成若干个较小的临界区，并使用不同的互斥量加以保护。目的是让等待进入同一个临界区的线程数变少，降低线程被阻塞的几率，减少处于睡眠状态的时间。从一定程度上提高程序的整体性能。若切分后不同的互斥量保护的临界区中包含了对同一个共享资源的同一种操作，则临界区的切分是不成功的。尽量不要让不同的互斥量所保护的临界区重叠，会增加`死锁`发生的几率。

当进程中的所有线程发生死锁，进程会停滞，只能重新启动，会丢失运行时数据甚至造成各种不一致的状态。

使用操作系统提供的线程库的功能，`试锁定和回退`：在执行一个代码块的时候需要先后锁定两个互斥量，在锁定其中一个互斥量成功之后使用`试锁定`的方法锁定另一个互斥量，若`试锁定`第二个互斥量不成功，就把第一个互斥量解锁，并重新对这两个互斥量进行锁定和`试锁定`。若需要需定的互斥量有多个，则总是先锁定其中一个，再按照上述流程`试锁定`其他互斥量并在必要时进行回退。`试锁定`指操作系统的线程库提供的一个函数，会尝试对一个互斥量进行锁定，锁定失败函数直接返回一个错误码，而不是阻塞在那里。

`固定顺序锁定`：需要先后对多个对个互斥量进行锁定的场景下，总以固定不变的顺序锁定它们。避免因多个线程先后对多个互斥量锁定顺序不一致，导致互相等待对方释放锁并占用对方所需而造成的死锁。

互斥量的实现会使用到机器语言级别的原子操作，并仅在锁定冲突时才会涉及系统调用的执行。互斥量比其他同步方法（例如信号灯）的速度快。

### 3.条件变量
条件变量不保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据状态发生发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥量组合使用，互斥量为共享数据的访问提供互斥支持，条件变量可以就共享数据的状态的变化向相关线程发出通知。当线程成功锁定互斥量从而访问到共享数据的时候，共享数据的状态并不一定正好满足它的要求。

条件变量在使用之前必须创建和初始化，初始化必须要保证唯一性，在被真正使用前必须要与某个互斥量进行绑定。在一个条件变量之上进行的操作有3种：  
* 等待通知（wait）：阻塞当前线程，直至收到该条件变量发来的通知。
* 单发通知（signal）：让该条件变量向至少一个正在等待它的通知的线程发送通知，以表示某个共享数据的状态已经被改变。
* 广播通知（broadcast）：让条件变量给正在等待它的通知的所有线程都发通知，以表示某个共享数据的状态已经改变。

等待通知会先解锁与该条件变量绑定在一起的互斥量，然后再使当前线程阻塞。只有在当前的共享数据的状态不满足条件时，才执行等待通知操作，检查共享数据的状态需要受到互斥量的保护，即检查共享数据状态的操作和等待通知操作都需要再相应的临界区内进行。等待通知操作所包含的解锁互斥量的操作和阻塞当前线程的操作共同形成一个原子操作。

等待通知操作因收到条件变量发送的通知而唤醒当前线程之后，会首先重新锁定与该条件变量绑定在一起的互斥量，若互斥量已经被其他线程抢先锁定，则当前线程再次进入睡眠状态。

条件变量的通知具有即时性，通知只是负责向等待线程发送一个信号以告知共享数据的状态发生了某种变化，而不会存储相关信息。在通知被发送的时候，若没有任何线程正在等待此条件变量的通知，该通知就会被无视，不会被传到在它被发送之后才开始等待它的线程。在互斥量的保护下执行单发通知操作通常会更加安全。

广播通知的发送线程无法得知有哪些线程正在等待共享数据的当前状态，不会知道在执行单发通知操作之后哪一个线程会接收到该通知，发送线程只执行广播通知操作以向所有的等待线程告知共享数据的状态已发生变化，不会关心哪些等待线程会对这一状态变化进行应答。等待线程被唤醒后会重新检查共享数据的状态，并自行决定是对此作出响应还是等待下一个通知。

### 4.线程的安全性
若一个代码块可以被多个线程并发地执行，并总能够产生预期的结果，则该代码块就是线程安全的（thread-safe）。例如若代码块中包含了对共享数据的更新操作，则此代码块就是非线程安全的。若该代码块中的类似操作都处于临界区之中，则此代码块是线程安全的。

常被置于线程安全问题之中的代码块是函数。函数是最常用的代码块，其线程安全性有着更多的含义。使函数具有安全性的最有效的方式是使其可重入（reentrant）。若某个进程中的所有线程都可以并发地对一个函数进行调用，并且无论它们调用该函数的实际执行情况怎样，该函数都可以产生预期的结果，则该函数是可重入的。即若多个线程并发的调用该函数与它们以任意的顺序依次地调用它所产生的效果总是相同的，则该函数的可重入的。

若一个函数把共享数据的值作为其返回的结果或者包含于其返回的结果中，则该函数不是可重入函数。为使函数可重入，杜绝在函数的返回结果中含有任何共享数据，除非共享数据是完全不可被更新的。任何内含了对共享数据进行操作的代码的函数都可以被视为不可重入函数。

为实现线程安全的函数，可将代码置于临界区之中，但低效。应从函数体中找出操作共享数据的代码并用互斥量把它门保护起来。更好的方式是将这些代码从函数体中分离出来，有利于施加保护措施。

若代码块中仅包含共享数据的访问操作而不包含对他们的更新操作，则代码块内可以不使用互斥量。但线程需要自己维护一份其需要使用道德共享数据的副本，线程会在使用共享数据之前就把它们完全复制到当前线程的线程栈之中。对于函数，副本作为其局部变量存在。某个线程对某个函数的第一次调用会致使该i函数中的局部变量陆续被创建在该线程的线程栈中。在不同线程的线程栈中，因调用相同的函数而被创建的同名局部变量之间是完全独立的，并且不会相互干扰。一般这样的函数是可重入的，即线程安全的。

## 多线程和多进程
多线程在系统资源的利用和程序性能的提高方面具有优势，在某些情况（信号的处理、同时运行多套不同的程序以及包含多个需要超大内存支持的任务等），多进程编程更加合适。

## 多核时代的并发编程
并发运行是指多个任务被同时发起运行，但是在同一时刻这些任务不一定都处于运行状态，取决于CPU核心或者CPU的数量。并行运行指在同一时刻可以有多个任务真正地同时运行，并行运行的必要条件是多CPU核心或多CPU的计算环境。并行运行的一个必要条件就是并发运行，是并发运行的一个更高级的层次。

提高并行程序的性能：  
* 控制临界区的纯度。
* 控制临界区的粒度。
* 减少临界区中代码的执行耗时。
* 避免长时间持有互斥量。
* 优先使用原子操作而不是互斥量。