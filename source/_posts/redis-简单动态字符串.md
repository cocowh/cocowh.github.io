---
title: redis-简单动态字符串
tags: [redis,sds]
comments: true
categories: [redis]
date: 2018-09-08 21:16:08
---
redis未直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方。包含字符串值的键值对在底层都是由SDS实现的。

```
127.0.0.1:6379> rpush fruits "banana" "apple" "cheery"
(integer) 3
```
redis在数据库中创建一个新的键值对，其中：

* 键是一个字符串对象，对象底层的实现是一个保存了字符串“fruits”的SDS。
* 值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，分别保存着字符串“banana”、“apple”、“cheery”。  

SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。

### SDS的定义
sds.h/sdshdr:

```
struct sdshdr {
	int len; //buf数组中已使用字节的数量、SDS所保存字符串的长度
	int free; //buf数组中未使用字节的数量
	char buf[]; //字节数组，用于保存字符串
}
```
遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，为其分配额外的一字节空间和添加空字符到字符串末尾等操作都由SDS函数自动完成。

### SDS与C字符串的区别
C语言使用长度为N+1的字符数组表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。但不能满足redis对字符串安全性、效率以及功能方面的要求。

#### 常数复杂度获取字符串长度
C字符串需遍历整个字符串对字符进行计数，复杂度为O(N)，redis直接返回SDS的len属性值，复杂度O(1)。

#### 杜绝缓冲区溢出
C字符串不记录自身长度容易造成缓冲区溢出（buffer overflow），改写其后缓冲区的内容。

SDS的空间分配策略杜绝发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，若不满足，API会自动将SDS的空间拓展至执行修改所需的大小，然后才执行修改操作。

#### 减少修改字符串时带来的内存冲分配次数
每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：

* 若程序执行的是增长字符串的操作，例如拼接操作（append），执行操作之前，程序需要先通过内存重分配来拓展底层数组的空间大小——忽略此步会产生缓冲区溢出。
* 若程序执行的是缩短字符串的操作，例如截断操作（tirm），在执行操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——忽略会产生内存泄漏。

内存重分配涉及复杂的算法，可能需要执行系统调用，通常是比较耗时的操作：

* 一般程序中，若修改字符串长度的情况不太常出现，每次修改都执行一次内存重分配是可接受的。
* redis经常用于速度要求严苛、数据被频繁修改的场合，执行内存重分配会占去修改字符串所用时间的一大部分，频繁操作影响性能。

SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量加一，可以包含未使用字节。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

##### 空间预分配
优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必需要的空间，还会为SDS分配额外的未使用空间，可以使redis减少连续执行字符串增长操作所需的内存重分配次数。

分配未使用空间数量：

* 若修改之后SDS的长度小于1M，程序分配和len属性同样大小的未使用空间，SDS的len属性值将和free属性的值相同，总长度=len+free+1byte（额外的一字节用于保存空字符）。
* 若修改之后SDS的长度大于等于1M，程序会分配1M的未使用空间，即free=1，总长度=len+1M+1byte。

拓展SDS空间之前，SDS API会先检查未使用空间是否足够，若足够，API就会直接使用未分配空间，无需执行内存重分配。

##### 惰性空间释放
优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。

SDS提供了相关的API，可以在有需要的时候，真正地释放SDS的未使用空间，不必担心惰性空间释放策略会造成内存浪费。

#### 二进制安全
C字符串中的字符必须符合某种编码（ASCII），且除字符串末尾外，字符串里面不能包含空字符。限制C字符串只能保存文本数据，而不能保存图像、音频、视频、压缩文件这样的二进制数据。

为确保redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样子，被读取时就是什么样子。

redis不是使用buf字节数组保存字符，而是保存一系列二进制数据。SDS使用len属性的值而不是空字符来判断字符串是否结束。

#### 兼容部分C字符串函数
SDS的API是二进制安全的，但一样遵循C字符串以空字符结尾的惯例：这些API会将SDS保存的数据的末尾设置为空字符，并且会在为buf数组分配空间时多分配一个字节来容纳这个空字符，为了让保存文本数据的SDS可以重用一部分\<string.h\>库定义的函数，避免了不必要的代码重复。

#### 小结
C字符串和SDS之间的区别：

C字符串 | SDS
:- | :-
获取字符串长度的复杂度为O(n) | 获取字符串长度的复杂度为O(1)
API是不安全的，可能会造成缓冲区溢出 | API是安全的，不会造成缓冲区溢出
修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要执行N次内存重分配
只能保存文本数据 | 可以保存文本或者二进制数据
可以使用所有\<string.h\>库中的函数 | 可以使用一部分\<string.h\>库中的函数

### SDS API
SDS主要操作API

函数 | 作用 | 时间复杂度
:- | :- | :-
sdsnew | 创建一个包含给定C字符串的SDS | O(N)，N为给定C字符串的长度
sdsempty | 创建一个不包含任何内容的空SDS | O(1)
sdsfree | 释放给定的SDS | O(N)，N为被释放SDS的长度
sdslen | 返回SDS的已使用空间字节数 | O(1)，读取SDS的len属性
sdsavail | 返回SDS的未使用空间字节数 | O(1)，读取SDS的free属性
sdsdup | 创建一个给定SDS的副本（copy）| O(N)，N为给定SDS的长度
sdsclear | 清空SDS保存的字符串内容 | O(1)，惰性空间释放策略
sdscat | 将给定字符串拼接到SDS字符串的末尾 | O(N)，N为被拼接的字符串的长度
sdscatsds | 将给定SDS字符串拼接到另一个SDS字符串的末尾 | O(N)，N为被拼接SDS字符串的长度
sdscpy | 将给定C字符串复制到SDS里面，覆盖SDS原有的字符串 | O(N)，N为被复制C字符串的长度
sdsgrowzero | 用空字符串将SDS拓展至给定长度 | O(N)，N为拓展新增的字节数
sdsrange | 保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除 | O(N)，N为被保留数据的字节数
sdstrim | 接受一个SDS和C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符 | O(N^2)，N为给定C字符串的长度
sdscmp | 对比两个SDS字符串是否相同 | O(N)，N为两个SDS中较短的那个SDS的长度