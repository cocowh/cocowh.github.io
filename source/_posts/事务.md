---
title: 事务
tags: [mysql,note,innodb,transaction]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-09-16 14:26:40
---

事务把数据库从一种一致状态转换为另一种一致状态。

### 认识事务

#### 概述

是访问并更新数据库中各种数据项的一个程序执行单元。

A(Atomicity)，原子性。整个数据库事务是不可分割的工作单位。对只读操作发生错误，要么重试要么返回错误代码。但对于需要改变系统中状态的操作，若操作失败，需要保护系统中并发用户访问受影响的部分数据。

C(Consistency)，一致性。事务将数据库从一种状态转变为下一种一致的状态。事务开始前后，数据库的完整性约束没有被破坏。

I(Isolation)，隔离性。也称并发控制、锁、可串行化等。要求每个读写事务的对象对其他其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，通常用锁来实现。粒度锁（granular lock）策略，允许事务仅锁住一个实体对象的子集，以此提高事务之间的并发度。

D(Durability)，持久性。事务一旦提交，结果就是永久性的。持久性保证事务系统的高可靠性，非高可用性。

#### 分类

事务理论角度：

* 扁平事务（Flat transactions），使用最为频繁的事务。扁平事务中，所有操作都处于同一层次，由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。
* 带有保存点的扁平事务（Flat Transaction with Savepoints），除支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。保存点（Savepoint）通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。扁平事务隐式设置且整个事务中只有一个保存点，回滚只能回滚到事务开始时的状态。保存点SAVE WORK函数建立，通知系统当前的处理状态。出现问题时，保存点作为内部重启动点，根据应用逻辑，决定是回到最近一个保存点还是其他更早的保存点。保存点在事务内部递增，ROLLBACK不影响保存点的计数，递增编号能保持事务执行的整个历史过程。
* 链事务（Chained Transaction），保存点模式的变种。当系统崩溃时，扁平事务的保存点都将消失，恢复时，事务从开始处重新执行，不能从最近的一个点继续执行，保存点是易失的非持久的。链事务：在提交一个事务时，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作合并为一个原子操作。扁平事务能回滚到任意正确的保存点，链事务回滚仅限于当前事务，只能恢复到最近一个的保存点。对于锁，链事务在执行COMMIT后释放当前事务所持有的锁，带保存点的扁平事务不影响其所持有的锁。
* 嵌套事务（Nested Transaction），层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（sub transaction），控制每一个局部的变换。
* 分布式事务（Distributed transaction），通常是一个在分布式环境下运行的扁平事务，需要根据数据所在的位置访问网络中的不同节点。

Moss对嵌套事务的的定义：  
 
1. 由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。 
2. 处在叶子节点的事务是扁平事务，每个子事务从根节点到叶节点的距离可以是不同的。
3. 位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为（predecessor）为父事务（parent），事务的下一层为儿子事务（child）。
4. 子事务既可以提交也可以回滚，并不会马上生效，需等待父事务提交。
5. 书中任何一个事务的回滚会引起它的所有子事务一同回滚，子事务仅保留A、C、I特性，不具有D特性。

Moss理论中实际工作由叶子节点来完成，只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。高层的事务仅负责逻辑控制，决定何时调用相关的子事务。

InnoDB支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持。


### 事务的实现

事务的隔离性由锁实现。原子性、一致性、持久性通过数据库的redo log和undo log完成。redo log（重做日志）保证事务的原子性和持久性，undo log保证事务的一致性。

redo log恢复提交事务修改的页操作，undo log回滚记录到某个特定版本。两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行修改记录进行记录。

#### redo
##### 基本概念

重做日志实现事务的持久性，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的。

InnoDB通过Force Log at Commit机制实现事务的持久性，当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成。此处日志分为redo log和undo log。前者宝成事务的持久性，后者帮助事务会回滚及MVCC的功能。redo log基本是顺序写的，undo log需要进行随机读写。

为确保每次日志写入重做日志文件，每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（同步内存中所有已修改的文件数据到存储设备）操作。重做日志文件打开没有使用O_DIRECT选项，重做日志缓冲先写入文件系统缓存。为确保重做日志写入磁盘，必须进行一次fsync操作。fsync的效率取决于磁盘的性能，磁盘的性能决定了事务提交的性能，即数据库的性能。

允许手工设置非持久性的情况发生，提高数据库的性能。此时事务提交时，日志不写入重做日志文件，等待下一个时间周期后再执行fsync操作。

参数`innodb_flush_log_at_trx_commit`用来控制重做日志刷新到磁盘的策略，该参数的默认值为1，表示事务提交时必须调用一次fsync操作。可设置为0和2。0表示提交事务时不进行写入重做日志操作，操作仅在master thread中完成，master thread中每一秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入重做日志文件的缓存中，不进行fsync操作。

二进制日志文件bin log，用于进行POINT_IN_TIME（PIT）的恢复及主从复制（Replication）环境的建立。

重做日志在InnoDB存储引擎层产生，二进制日志在MySQL数据库的上层产生，二进制日志不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生二进制日志。MySQL上层的二进制日志是一种逻辑日志，记录的是对应的SQL语句，InnoDB存储引擎层的重做日志是物理格式日志，记录的是对于每个页的修改。二进制日志只在事务提交完成后进行一次写入，InnoDB存储引擎的重做日志在事务进行中不断地被写入，表现为日志并不是随事务提交的顺序进行写入的。

##### log block
InnoDB engine中重做日志以512字节进行存储的，意味着重做日志缓存、重做日志文件都是以块的方式进行保存的，称之为重做日志块（redo log block）。

若一个页产生的重做日志数量大于512字节，则需要分割为多个重做日志块进行存储。重做日志块的大小和扇区大小一样，重做日志的写入可保证原子性，不需要doublewrite技术。

重做日志块除日志本身外还由日志块头（log block header）及日志块尾（log block tailer）两部分组成。重做日志块头占用12字节，重做日志块尾占用8字节，每个重做日志块实际可存储的大小为492字节。

log block header由4个部分组成：

名称 | 占用字节 | 说明
:-: | :-: | :-: 
LOG\_BLOCK\_HDR\_NO | 4 | 标记log block在logbuffer中的位置，递增且循环使用，第一位用于判断是否是flush bit
LOG\_BLOCK\_HDR\_DATA\_LEN | 2 | 表示log block所占用的大小，当log block写满时，值为0x200，表示使用全部log block空间，即占用512字节
LOG\_BLOCK\_FIRST\_REC\_GROUP | 2 | 表示log block中第一个日志所在的偏移量，若等于LOG\_BLOCK\_HDR\_DATA\_LEN，表示当前log block不包含新的日志
LOG\_BLOCK\_CHECKPOINT\_NO | 4 | 表示该log block最后被写入时检查点第4字节的值。


log block tailer只由一个部分组成，值和LOG\_BLOCK\_CHECKPOINT\_NO相同，并在函数log_block_init中被初始化。

##### log group

重做日志组，由多个重做日志文件。源码已支持log group的镜像功能，但在ha_innobase.cc文件中禁止该功能。InnoDB engine实际只有一个log group。

逻辑上的概念，并无实际物理文件表示log group信息。每个log group中日志文件大小相同，InnoDB v1.2前，重做日志文件总大小小于4GB，此版本开始大小限制提高为512GB。

重做日志文件中存储的是在log buffer中保存的log block，根据块的方式进行物理存储的管理，每个块大小与log block一样为512字节。log buffer根据一定规则将内存中的log block刷新到磁盘：

* 事务提交时
* log buffer中有一半的内存空间已经被使用时
* log checkpoint时

log block的写入为追加到redo log file的最后部分，当一个redo log被写满时，会接着写入下一个redo log file，使用方式为round-robin。redo log file除了保存log buffer刷新到磁盘的log block，还保存其他共占2KB大小的信息，每个redo log file的前2KB部分不保存log block信息。

log group中的第一个redo log file前2KB保存4个512字节大小的块，存放内容为：

名称 | 大小 
:-: | :-:
log file header | 512 
checkpoint1 | 512 
空 | 512 
checkpoint2 | 512 

仅在每个log group的第一个redo log file中进行存储，其余redo log file仅保留这些空间，但不保存上述信息。

写入redo log file时，除了log block的写入，还需要更新前2KB部分的信息，这些信息用于InnoDB engine恢复操作。log file header后面的部分为InnoBD存储引擎保存的checkpoint(检查点)值，设计为交替写入，避免因介质失败而导致无法找到可用的checkpoint的情况。

##### 重做日志格式

InnoDB engine存储管理基于页，重做日志格式也是基于页的。其重做日志格式有着通用的头部格式。

redo\_log\_type | space | page_no | redo log body
:-: | :-: | :-: | :-:
重做日志的类型 | 表空间的ID | 页的偏移量 | 存储内容  

##### LSN 
Log Sequence Number的缩写，代表着日志序列号，InnoDB存储引擎中，占用8字节，单调递增。表示：

* 重做日志写入的总量
* checkpoint的位置
* 页的版本

存在于每个页的头部，值FIL_PAGE_LSN，记录该页的LSN，表示该页最后刷新时LSN的大小。可用于根据重做日志的LSN比较页的LSN判断是否需要进行恢复操作。

```
mysql> show engine innodb status\G
...
LOG
---
Log sequence number 5337425
Log flushed up to   5337425
Pages flushed up to 5337425
Last checkpoint at  5337416
0 pending log flushes, 0 pending chkp writes
182 log i/o's done, 0.00 log i/o's/second
----------------------
...
```
Log sequence number表示当前的LSN，Log flushed up to表示刷新到重做日志文件的LSN，Pages flushed up to表示已经刷新到磁盘数据页上的LSN，Last checkpoint at表示刷新到磁盘的LSN。

##### 恢复

InnoDB eigine不管上次DB运行是否正常关闭，都会尝试进行恢复操作。

恢复过程中仅需恢复checkpoint开始的日志部分，即LSN记录开始的重做日志。

#### undo

##### 基本概念
利用undo信息对事务进行回滚到数据之前的样子。

undo存放在数据库内部的一个特殊段（segment）中，称为undo段（undo segment）。undo段位于共享表空间内。

undo是逻辑日志，只是将数据库逻辑地恢复到原来的样子，修改被逻辑地取消，由于可能存在其他用户对页上其他非锁定记录的修改，数据结构和页本身在回滚之后可能大不相同。

InnoDB engine回滚时，实际上做的是与先前相反的工作，对于每个INSERT，执行一个DELETE；对于每一个DELETE，会执行一个INSERT；对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。

undo的另一个作用是MVCC，当用户读取一行数据时，若该记录已经被其他事务占用，则当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。

undo log会产生redo log，undo log需要持久性的保护。

##### undo存储管理

采用段的方式管理undo。InnoDB eigine有rollback segment，每个rollback segment记录了1024个undo log segment，每个undo log segment中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有的rollback segment header所在的页，页类型为FIL_PAGE_TYPE_SYS。

InnoDB v1.1前只有一个rollback segment，支持同时在线的事务限制为1024，1.1开始支持最大128个rollback segment，，支持同时在线的事务限制提高到128*1024.

InnoDB v1.2开始可通过参数对rollback segment进行设置：

* `innodb_undo_directory`，设置rollback segment文件所在的路径，rollback segment可以存放在共享表空间之外的位置。
* `innodb_undo_logs`，设置rollback segment的个数，默认128，替换之前的参数`innodb_rollback_segments`。
* `innodb_undo_tablespaces`，设置构成rollback segment文件的数量，使rollback segment可以较平均分布在多个文件中。设置后可在路径`innodb_undo_directory`看到undo为前缀的文件，代表rollback segment文件。

undo log segment分配页并写入undo log时同样需要写入重做日志，事务提交时，InnoDB会：

* 将undo log放入列表，以供之后的purge操作。
* 判断undo log所在的页是否可以重用，若可以则分配给下一个事务使用。

事务提交后不能马上删除undo log及undo log所在的页，可能有其他事务需要通过undo log取得行记录之前的版本，事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在的页由purge线程判断。

InnoDB engine中undo页可以进行重用，事务提交时，首先将undo log放入链表，然后判断undo页的使用空间是否小于3/4，若是则表示该undo页可以被重用，之后新的undo log记录在当前undo log的后面。存放undo log的列表以记录进行组织，undo页可能存放着不同事务的undo log，purge操作需要涉及磁盘的离散读取操作，比较缓慢。

通过SHOW ENGINE INNODB STATUS查看链表中undo log的数量：

```
mysql> show engine innodb status\G
...
------------
TRANSACTIONS
------------
Trx id counter 46329
Purge done for trx's n:o < 46249 undo n:o < 0 state: running but idle
History list length 33
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 281479642318640, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
...
```
History list length代表undo log的数量，purge操作会减少该值。由于undo log所在的页可以被重用，操作后，改值也未必为0。

##### undo log格式


参考[MySQL · 引擎特性 · InnoDB undo log 漫游](http://mysql.taobao.org/monthly/2015/04/01/)。

分为：
 
* insert undo log，在insert操作过程中产生的undo log，insert操作只对事务本身可见，对其他事务不可见，事务提交后直接删除。不需要进行purge操作。
* undapte undo log，对delete和update操作产生的undo log。可能需要提供MVCC机制，不能在事务提交后立即删除，提交时放入undo log链表，等待purge线程进行最后的删除。

undapte undo log较insert undo log记录的内容更多，占用的空间更大，undapte undo log又分为(type_cmpl值)：

* TRX\_UNDO\_UPD\_EXIST\_REC（=12），更新non-delete-mark的记录
* TRX\_UNDO\_UPD\_DEL\_REC（=13），将delete的记录标记为not delete
* TRX\_UNDO\_DEL\_MARK\_REC（=14）， 将记录标记为delete

##### 查看undo信息

InnoDB engine DBA只能通过原理和经验来判断。InnoSQL对information_schema拓展添加数据字典表`INNODB_TRX_ROLLBACK_SEGMENT`和`INNODB_TRX_UNDO`来查看undo信息，前者用于查看rollback segment，后者用于记录事务对应的undo log，方便了解事物产生的undo量。

delete操作并不直接删除记录，将记录标记为已删除（delete flag设置为1），记录的最终删除在purge中完成。update主键的操作分两步完成，先将原主键标记为已删除，需要产生一个类型为TRX\_UNDO\_DEL\_MARK\_REC的undo log，之后插入一条新的记录，需要产生一个类型为TRX\_UNDO\_INSERT\_REC的undo log。

#### purge
 
purge最终完成delete和update操作，InnoDB支持MVCC，记录不能在事务提交时立即进行处理。因为其他事务可能正在引用这行，需要保存记录之前的版本。当该行记录不被任何其他事务引用，就可以进行真正的delete操作，清理之前行记录的版本。

InnoDB有一个histroy列表，根据事务提交的顺序，将undo log进行链接，先提交的事务总在尾端。

purge过程中，先在histroy list中找到第一个需要被清理的记录，清理之后会在被清除记录的undo log所在页继续寻找是否存在可以被清理的记录，有则清理，没有则返回histroy list中查找继续按此步骤清理。此法避免了大量的随机读取，提高purge效率。

动态参数`innodb_purge_batch_size`用于设置每次purge操作需要清理的undo page数量。InnoDB v1.2前默认20，此v开始默认300。动态参数`innodb_max_purge_lag`用于控制histroy list的长度，默认为0，表示不对其做限制，当大于0时，表示会延缓DML操作。延缓算法：  
`delay = ((length(histroy_list) - innodb_max_purge_lag) * 10) - 5`

单位毫秒，对象是行，delay会在每次purge操作后重新计算。InnoDB v1.2后引入动态参数`innodb_max_purge_lag_delay`控制delay的最大毫秒数，当计算得到的delay值大于该值时，取`innodb_max_purge_lag_delay `，避免purge操作缓慢导致其他SQL线程无限制等待。

#### group commit

非只读事务，每次事务提交时需要进行一次fsync操作，保证重做日志都已经写入磁盘。fsync性能有限，为提高效率，提供group commit功能，一次fsync可以刷新确保多个事务日志被写入文件。InnoDB事务提交时进行两个阶段操作：

1. 修改内存中事务对应的信息，将日志写入重做日志缓冲。
2. 调用fsync将确保日志都从重做日志缓冲写入磁盘。

步骤2相对步骤1慢，有事务进行步骤2时，其他事务可进行事务1，事务完成提交后，再次进行步骤2，将多个事务的重做日志通过一次fsync刷新到磁盘，减少磁盘的压力，提高性能。

InnoDB v1.2前，开启二进制日志InnoDB存储引擎的group commit功能会失效，导致性能下降。开启二进制日志为保证存储引擎层中事务和二进制日志的一致性，二者之间使用了两阶段事务：

1. 事务提交时InnoDB engine进行purge操作
2. MySQL数据库上层写入二进制日志。
3. InnoDB存储引擎将日志写入重做日志文件。
 
 1. 修改内存中事务对应的信息，将日志写入重做日志缓冲。
 2.  调用fsync确保日志都从重做日志缓冲写入磁盘。

一旦步骤2完成，就确保了事务的提交，即使步骤3时发生宕机。但每个步骤都进行一次fsync操作才能保证上下两层数据的一致性。步骤2的fsync参数由参数`fsync_binlog`控制，步骤3的fsync由参数`innodb_flush_log_at_trx_commit`控制。MySQL内部使用`prepare_commit_mutex`锁保证上层二进制日志的写入顺序与InnoDB层事务提交顺序一致。启用锁后步骤3中的步骤1不可以在其他事务执行步骤3的步骤2时执行，导致group commit失效。

MySQL v5.6实现了Binary Log Group Commit（BLGC）解决此问题，在上层提交时先按顺序将其放入一个队列中，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。BLGC步骤：

* Flush阶段，将每个事务的二进制日志写入内存中。
* Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，仅一次fsync操作完成二进制日志的写入，即BLGC。
* Commit阶段，leader根据顺序调用存储引擎层事务的提交，修复由于锁`prepare_commit_mutex `导致group commit失效问题。

当有一组事务提交时，其他新事务可以进行Flush阶段，使group commit不断生效。group commit的效果由队列中事务的数量决定，若每次队列中仅有一个事务，效果同之前可能会更差。提交的事务越多，group commit效果越明显。

参数`innodb_max_flush_queue_time`控制Flush阶段中等待的时间，即使之前的一组事务完成提交，当前一组事务也不马上进入Sync阶段，至少需要等待一段时间。使group commit的事务数量更多，可能导致事务响应时间变慢。参数默认值0，推荐设置也为0。

### 事务控制语句

MySQL默认设置下，事务自动提交的，执行SQL语句后会马上执行COMMIT操作。

事务控制语句：

* START TRANSACTION | BEGIN：显示地开启一个事务。存储过程中，MySQL DB分析器会自动将BEGIN识别为BEGIN...END，存储过程中只能使用START TRANSACTION语句开启事务。
* COMMIT：提交事务，使得已对数据库所做的所有修改称为永久性的。可直接发出COMMIT，也可写为等价语句COMMIT WORK。后者控制事务结束后的行为是CHAIN还是RELEASE的，是CHAIN方式，则事务变成链事务。通过参数`completion_type`进行控制，默认为0，表示没有任何操作，两者等价，设为1时，后者等价COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。
* ROLLBACK：回滚结束事务，并撤销正在进行的所有未提交的修改。可直接发出ROLLBACK，也可写为等价语句ROLLBACK WORK。工作同上方语句。
* SAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。
* RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句会抛出一个异常。
* ROLLBACK TO[SAVEPOINT] identifier：与SAVEPOINT命令一起使用，把事务回滚到标记点，而不回滚在此标记点之前任何工作。回滚到一个不存在的保存点会抛出异常。该语句并不是真正地结束一个事务，执行后任然需要显示地执行COMMIT或者ROLLBACK命令。
* SET TRANSACTION：设置事务的隔离级别。InnoDB提供的隔离级别有：READ UNCOMMITTED、READCOMMITTD、REPEATABLE READ、SERIALIZABLE。

事务是原子的，构成事务的每条语句都会提交或者所有语句都会回滚，一条语句要么完全成功要么完全回滚。一条语句失败并抛出异常时，并不会导致先前已执行的语句自动回滚，所有的执行都会得到保留， 由用户决定是否对事务进行提交或者回滚。

### 隐式提交的SQL语句

执行语句后会有一个隐式的COMMIT操作的SQL语句：

* DDL语句：ALTER DATABASE...UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRUNCATE TABLE。
* 隐式修改MySQL机构操作：CREATE USER，DROP USER，GRANT，RENAME USER，REVOKE，SET PASSWORD。
* 管理语句：ANALYZE TABLE，CACHE INDEX，CHECK TABLE，LOAD INDEX INTO CACHE，OPTIMIZE TABLE，REPAIR TABLE。

TRUNCATE TABLE语句是DDL，和对整张表执行DELETE操作结果一样，但不能被回滚。

### 对事务操作的统计

在考虑每秒请求数（Question Per Second，QPS）的同时，关注每秒事务处理（Transaction Per Second，TPS）的能力。

所有事务显示提交：`TPS = (com_commit + com_rollback) / time`，隐式提交和回滚不会计算到com\_commit和com\_rollback变量中。


```
mysql> show global status like 'com_commit'\G
*************************** 1. row ***************************
Variable_name: Com_commit
        Value: 0
1 row in set (0.00 sec)

mysql> show global status like 'com_rollback'\G
*************************** 1. row ***************************
Variable_name: Com_rollback
        Value: 0
1 row in set (0.00 sec)
```

参数handle\_commit和handle\_rollback用于事务统计。MySQL v5.1中可统计InnoDB engine显示和隐式的事务提交操作，在InnoDB Plugin中不准确。


### 事务隔离级别

SQL标准事务隔离级别：

* READ UNCOMMITTED：浏览访问。
* READ COMMITTED：游标稳定。除唯一性的约束检查及外键约束的检查需要gap lock，engine 不会使用gap lock的锁算法。MySQl v5.1会导致主从数据不一致问题。
* REPEATABLE READ：无幻读保护。
* SERIALIZABLE：隔离。InnoDB为每个SELECT语句后自动加上LOCK IN SHARE MODE，即为读取加共享锁，对一致性的非锁定读不在于以支持。主要用于InnoDB engine的分布式事务。

SQL和SQL2的默认事务隔离级别为SERIALIZABLE，InnoDB默认隔离级别为REPEATABLE READ，采用Next-Key Lock锁算法避免幻读。

级别越低事务请求锁越少或保持锁的时间越短。

设置当前回话或全局事务隔离级别：

```
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
{
READ UNCOMMITTED
| READ COMMITTED
| REPEATABLE READ
| SERIALIZABLE
}
```

可通过修改MySQL配置文件，在MySQL启动时设置事务默认隔离级别：


```
[mysqld]
transaction-isolation = READ UNCOMMITTED
```

查看当前事务隔离级别和全局事务隔离级别：

```
mysql> select @@tx_isolation\G
*************************** 1. row ***************************
@@tx_isolation: REPEATABLE-READ
1 row in set, 1 warning (0.01 sec)

mysql> select @@global.tx_isolation\G
*************************** 1. row ***************************
@@global.tx_isolation: REPEATABLE-READ
1 row in set, 1 warning (0.00 sec)
```

### 分布式事务

分布式事务指允许多个独立的事务资源（transaction rescourcs）参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，对于事务原有的ACID要求有了提高。

#### MySQL数据库分布式事务

分布式事务

InnoDB engine提供对XA事务的支持，通过XA事务来支持分布式事务的实现。使用分布式事务时，InnoDB engine的事务隔离级别必须设置为SERIALIZABLE。

XA事务允许不同数据库之间的分布式事务，需要参与在全局事务中的每个节点都支持XA事务。XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。

* 资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。
* 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
* 应用程序：定义事务边界，指定全局事务中的操作。

MySQL DB分布式事务中，资源管理器是MySQL数据库，事务管理器为连接MySQL服务器的客户端。

分布式事务使用两段式提交（two-phase commit）的方式。第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器他们准备好了。第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。若任何一个节点显示不能提交，则所有的节点都被告知需要回滚。与本地事务相比，分布式事务需要多一次PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或者ROLLBACK操作。

MySQL数据库XA事务的SQL语法：

```
XA {START | BEGIN} xid [JOIN | RESUME]

XA END xid [SUSPEND [FOR MIGRATE]]

XA PREPARE xid

XA COMMIT xid [ONE PHASE]

XA ROLLBACK xid

XA RECOVER
```

通过参数`innodb_support_xa`查看是否启用了XA事务的支持，默认为ON。


```
mysql> show variables like 'innodb_support_xa'\G
*************************** 1. row ***************************
Variable_name: innodb_support_xa
        Value: ON
1 row in set (0.00 sec)
```


#### 内部XA事务

外部事务：资源管理器是MySQL数据库本身。

内部XA事务：在存储引擎与插件之间，或者存储引擎与存储引擎之间

常见的内部XA事务存在于binlog与InnoDB存储引擎之间。事务提交时，InnoDB engine先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，若在InnoDB engine提交前宕机，MySQL DB重启后会先检查准备的UXID事务是否已经提交，若没有则在存储引擎层再进行一次提交操作。能够避免二进制日志写入后宕机，传给从数据库二进制日志并执行，导致主从数据库不一致问题。

### 不好的事务习惯

* 在循环中提交：不论是现实的提交还是隐式的提交。
* 使用自动提交：应在程序端进行事务的开始和结束。对不同语言的API，自动提交不同。
* 使用自动回滚：InnoDB engine支持通过定义一个HANDLER来进行自动事务的回滚操作，如在一个存储过程中发生了错误会自动对其进行回滚操作。

### 长事务

执行时间较长的事务。对长事务，转化为小批量的事务进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。

