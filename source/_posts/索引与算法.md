---
title: 索引与算法
tags: [mysql,note,innodb,index,alg]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-08-30 14:26:19
---

### InnoDB存储引擎索引概述

InnoDB支持的索引：

* B+ tree索引
* 全文索引
* 哈希索引

InnoDB存储引擎支持的哈希索引是自适应的（见[自适应哈希索引](http://bighua.top/2019/01/15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/)）。

B+ tree索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。

> B+ tree的B代表着平衡（balance），而非二叉（binary）。B+ tree从最早的平衡二叉树演变而来，但是不是一个二叉树。

B+ tree index并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查到，最后得到要查找的数据。

### 数据结构与算法

#### 二分查找法

每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到。

#### 二分查找和平衡二叉树

二叉查找树：左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。

若想最大性能地构造一棵二叉查找树，需要二叉查找树是平衡的——平衡二叉树（AVL树）。是二叉查找树，任何节点的两个子树的高度最大差为1。

维护一棵平衡二叉树需要一定的开销，多用于内存结构对象中，维护的开销相对较小。

### B+树

#### B+树的插入操作

#### B+树的删除操作

### B+树索引
B+树索引的本质是B+树在数据库中的实现。B+树高扇出性，高度一般在2～4层，查找某一键值的行记录只需要2～4次IO。

B+树索引分为聚集索引（clustered index）和辅助索引（secondary index），内部都是B+树，高度平衡，叶子节点存放着所有的数据。聚集索引和辅助索引不同之处在于，叶子节点存放的是否是一整行的信息。

#### 聚集索引

InnoDB存储引擎表是索引组织表，表中的数据按照主键顺序存放。聚集索引按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表中存放的行记录数据，也将聚集索引的叶子节点称为数据页，决定了索引组织表中数据也是索引的一部分。每个数据页通过双向链表进行链接。

每张表只能拥有一个聚集索引，多数情况下，聚集索引能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询，查询优化器能够快速发现某一段范围的数据页需要扫描。

聚集索引非物理上连续，而是逻辑上连续。

 * 页通过双向链表链接，按照主键顺序排序
 * 每个页中的记录通过双向链表进行维护，物理存储上可以同样不按照主键储存

聚集索引对于主键排序查找和范围查找很快。

#### 辅助索引
叶子节点不包含行记录的全部数据，除包含键值外，每个叶子节点中的索引行还包含一个书签。该书签告知InnoDB存储引擎哪里可以找到与索引相应的行数据。辅助索引的书签是相应的行数据的聚集索引键。

通过辅助索引查找数据，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

#### B+树索引的分裂

InnoDB存储引擎的Page Header中有以下几个部分用来保存插入的顺序信息：

* PAGE_LAST_INSERT
* PAGE_DIRECTION
* PAGE_N_DIRECTION

决定向左还是向右进行分裂，决定将分裂点记录为哪一个。若插入随机，则取页的中间记录作为分裂点的记录，若往同一方向插入的记录数量为5，并且目前已经定位（cursor）到的记录（InnoDB存储引擎插入时，首先需要进行定位，定位到的记录为带插入记录的前一条记录）之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是带插入的记录。

#### B+树索引的管理

##### 索引管理

索引的创建和删除可通过两种方法，`ALTER TABLE`和`CREATE/DROP INDEX`。

ALTER TABLE创建索引语法：

```
ALTER TABLE table_name 
ADD {INDEX|KEY} [index_name]
[index_type] (index_col_name,...) [index_option]...

ALTER TABLE table_name
DROP PARIMARY KEY
| DROP {INDEX|KEY} index_name
```

CREATE/DROP INDEX语法：

```
CREATE [UNIQUE] INDEX index_name
[index_type]
ON table_name (index_col_name,...)

DROP INDEX index_name ON table_name
```

可设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据。

参见[Mysql索引及优化](http://bighua.top/2018/07/30/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/)

通过`SHOW INDEX FROM TABLE`查看索引信息：

```
mysql> show index from users_old\G
*************************** 1. row ***************************
        Table: users_old
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 158
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
*************************** 2. row ***************************
        Table: users_old
   Non_unique: 0
     Key_name: users_name_unique
 Seq_in_index: 1
  Column_name: name
    Collation: A
  Cardinality: 158
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
*************************** 3. row ***************************
        Table: users_old
   Non_unique: 0
     Key_name: users_email_unique
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 158
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
*************************** 4. row ***************************
        Table: users_old
   Non_unique: 1
     Key_name: remember_token
 Seq_in_index: 1
  Column_name: remember_token
    Collation: A
  Cardinality: 153
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
4 rows in set (0.00 sec)
```

每列含义：

  列名 | 含义
  :-: | :-:
  Table | 索引所在表名。
  Non_unique | 非唯一的索引。
  Key_name | 索引名。
  Seq_in_index | 索引中该列的位置。
  Column_name | 索引列的名称。
  Collation | 列以什么方式存储在索引中，值为A或NULL。B+树索引总是A，即排序的。若使用Heap存储引擎，并建立了Hash索引，会显示NULL。Hash根据Hash桶存放索引数据，不对数据进行排序。
  Cardinality | 表示索引中唯一值的数目的估计值。若非常小，可考虑是否删除此索引。
  Sub_part | 是否是列的部分被索引，若索引整个列则值为NULL，否则为被索引字符长度。
  Packed | 关键字如何被压缩，没被压缩值为NULL。
  Null | 索引的列是否含有NULL值，列允许为NULL值则显示为Yes。
  Index_type | 索引的类型，InnoDB只支持B+ Tree索引
  Comment | 注释
  
优化器会根据Cardinality值来判断是否使用这个索引，非实时更新，只是大概的值。可使用`ANALYZE TABLE`命令更新索引Cardinality信息，在非高峰期操作能使优化器更好的选择索引。

##### Fast Index Creation

MySQL v5.5之前，对于索引的添加或者删除类DDL操作过程：
 
 * 创建一张临时表，表结构为通过命令ALTER TABLE新定义的结构。
 * 将原表数据导入到临时表。
 * 删除原表。
 * 把临时表重名为原来的表名。

对大表进行索引的添加和删除操作耗时，大量访问时数据库服务不可用。

临时表的创建路径通过参数tmpdir进行设置，必须保证tmpdir有足够的空间存放临时表，否则会导致创建索引失败。

InnoDB v1.0.x开始支持Fast Index Creation（快速创建索引，FIC）的索引创建方式。 

辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁，在创建过程中不需要重建表。删除辅助索引，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL DB内部视图上对该表的索引定义。

加S锁操作导致过程中只能对表进行读操作，写操作不可用。FIC只限定于辅助索引的创建，主键的创建和删除同样需要重建一张表。

##### Online Schema Change
Online Schema Change（在线架构改变，OSC）由Facebook采用PHP脚本实现的一种在线执行DDL的方式，在事务的创建过程中，可以有读写事务对表进行操作。

实现OSC步骤：

* init，初始化阶段，对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。
* createCopyTable，创建和原始表结构一样的新表。
* alterCopyTable：对创建的新表进行ALTER TABLE操作，如添加索引或列等。
* createDeltasTable，创建deltas表，为下一步创建的触发器所使用。之后对原表的所有的DML操作会被记录到createDeltasTable中。
* createTirggers，对原表创建INSERT、UPDATE、DELETE操作的触发器，触发操作产生的记录被写入到deltas表。
* startSnpshotXact，开始OSC操作的事务。
* selectTableIntoOutfile，将原表中的数据写入到新表，通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中，分片大小可指定，默认500000。
* dropNCIndexs，导入新表前，删除新表中所有的辅助索引。
* loadCopyTable，将导出的分片文件导入到新表。
* replayChanges，将OSC过程中原表DML操作的记录（被保存在deltas表中）应用到新表中。
* recreateNCInedexes，创新创建辅助索引。
* replayChanges，再次进行DML日志的回放操作，是上述创建辅助索引过程中新产生的日志。
* swapTables，将原表和新表交换名字，操作过程需要锁定2张表，不允许新数据产生，改名操作很快，阻塞时间很短。

要求进行修改表一定要有主键且表本身不能存在外键和触发器。进行OSC过程中，允许SET aql_bin_log=0，所在操作不会同步slave服务器，可能导致主从不一致。


##### Online DDL

MySQL v5.6开始支持Online DDl（在线数据定义）操作，允许辅助索引创建的同时，进行其他诸如INSERT、UPDATE、DELETE这类DML操作。

可通过“在线”方式进行操作的DDL操作：

* 辅助索引的创建和删除
* 改变自增长值
* 添加或删除外键约束
* 列的重命名

通过新的ALTER TABLE语法，可选择索引的创建方式：

```
ALTER TABLE tbl_name
| ADD {INDEX|KEY} [index_name]
[index_type] (index_col_name,...) [index_option] ...
ALGORITHM [=] {DEFAULT|INPLACE|COPY}
LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
```
ALGORITHM指定列创建或删除索引的算法，COPY表示按照MySQL v5.1之前的工作模式（创建临时表）。INPLACE表示索引创建或删除不需要创建临时表。DEFAULT表示根据参数old_alter_table来判断是通过INPLACE还是COPY的算法，值默认为OFF，表示采用INPLACE方式。

```
mysql> select @@version\G
*************************** 1. row ***************************
@@version: 5.7.22
1 row in set (0.00 sec)

mysql> show variables like 'old_alter_table'\G
*************************** 1. row ***************************
Variable_name: old_alter_table
        Value: OFF
1 row in set (0.07 sec)

mysql> 
```
LOCK部分为索引创建或删除时对表加锁的情况，可为：

1. NONE——执行索引创建或者删除操作时，对目标表不添加任何的锁，事务仍然可以进行读写操作，不会收到阻塞。可获得最大的并发度。
2. SHARE——类似FIC，执行索引创建或者删除操作时，对目标表加上一个S锁，不影响并发读事务，但是写事务会等待。若存储引擎不支持SHARE模式，会返回一个错误信息。
3. EXCLUSIVE——执行索引创建或删除操作时，对目标表加上一个X锁，读写事务都不能进行，会阻塞所有线程。
4. DEFAULT——通过判断事务的最大并发性来判断执行DDL的模式，选用顺序依次为NONE、SHARE、EXCLUSIVE。

Online DDL原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。缓存的大小由参数`innodb_online_alter_log_max_size`控制，默认大小128MB。若更新表比较大，且创建过程中有大量写事务，空间不足会报错，需调大参数值，或者设置ALTER TABLE的模式为SHARE，在执行过程中不会有写事务发生。

### Cardinality 值

#### Cardinality

并不是在所有的查询条件中出现的列都需要添加索引，一般在访问表中很少一部分时使用B+ Tree索引才有意义，对于性别字段、地区字段、类型字段可取范围小，称为低选择性。若字段取值范围广，几乎没有重复，属于高选择性，适合使用B+ Tree索引。

Cardinality列表示索引中不重复记录数量的预估值，而不是一个准确值，基本不可能得到一个确切值。实际应用中Cardinality/n\_rows\_in\_table应尽可能接近1，若非常小则需要考虑是否还有必要创建这个索引。

#### InnoDB存储引擎的Cardinality统计
MySQL对Cardinality的统计放在存储引擎层进行的，通过采样的方法完成。

InnoDB中Cardinality统计信息的更新发生在INSERT和UPDATE操作中，策略为：

* 表中1/16的数据已发生过变化。
* stat\_modified\_counter>2 000 000 000

默认InnoDB存储引擎对8个叶子节点（Leaf Page）进行采样，采样过程：

* 取得B+ Tree Index中叶子节点的数量记为A。
* 随机取得B+ Tree Index中的8个叶子节点。统计每个页不同记录的个数，即为P1，P2，...，P8。
* 根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+...+P8）*A/8

每次对Cardinality值的统计，都是随机取8个叶子节点得到的，每次得到的Cardinality值可能是不同的。

InnoDB v1.2之前可通过参数`innodb_stats_sample_pages`设置统计Cardinality时每次采样页的数量，默认为8。同时，参数`innodb_stats_method`用来判断如何对待索引中出现的NULL值记录，默认值为nulls_equal，表示将NULL值记录视为相等的记录，还可取nulls_unequal表示将NULL值视为不同的记录，取nulls_ignored表示忽略NULL值记录。

执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎重新计算索引的Cardinality值，表数据量过大且多个辅助索引时，执行可能会很慢。

InnoDB v1.2提供更多参数对Cardinality统计进行设置：

参数 | 说明
:-: | :-:
innodb\_stats\_persistent | 是否将ANALYZE TABLE计算得到的Cardinality值存放到磁盘上，若是则可以减少重新计算每个索引的Cardinality值。也可通过命令CREATE TABLE和ALTER TABLE的选项STATS_PERSISTENT来对每张表进行控制。默认值为OFF。
innodb\_stats\_on\_metadata | 通过SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时，是否需要重新计算索引的Cardinality值。默认值为OFF。
innodb\_stats\_persistent\_sample\_pages | 若innodb\_stats\_persistent设置为ON，该参数表示ANALYZE TABLE更新Cardinality值时每次采样页的数量。默认值为20。
innodb\_stats\_transient\_smaple\_pages | 取代之前版本的参数innodb\_stats\_sample\_pages，表示每次采样页的数量，默认值为8。



```
mysql> show variables like 'innodb_stats_persistent'\G
*************************** 1. row ***************************
Variable_name: innodb_stats_persistent
        Value: ON
1 row in set (0.01 sec)

mysql> show variables like 'innodb_stats_on_metadata'\G
*************************** 1. row ***************************
Variable_name: innodb_stats_on_metadata
        Value: OFF
1 row in set (0.01 sec)

mysql> show variables like 'innodb_stats_persistent_sample_pages'\G
*************************** 1. row ***************************
Variable_name: innodb_stats_persistent_sample_pages
        Value: 20
1 row in set (0.01 sec)

mysql> show variables like 'innodb_stats_transient_sample_pages'\G
*************************** 1. row ***************************
Variable_name: innodb_stats_transient_sample_pages
        Value: 8
1 row in set (0.00 sec)
```

### B+ Tree Index的使用

#### 不同应用中B+ Tree Index的使用

OLTP应用根据查询条件建立B+ Tree Index，取少部分数据走索引。

OLAP应用取大量数据视具体情况分析。

#### 联合索引

对表上多个列进行索引。

本质上联合索引也是一棵B+ Tree，不同的是联合索引的键值的数量不是1，而是大于等于2。

对于联合索引（a,b），查询a或者a、b可走索引，查询b无法使用索引。

#### 覆盖索引

覆盖索引（covering index，索引覆盖），从辅助索引中就可以得到查询的记录，不需要查询聚集索引中的记录。辅助索引不包含正行记录的所有信息，大小小于聚集索引，可减少大量的IO操作。

通常诸如（a，b）的联合索引，一般不会选择列b中所谓的查询条件，但若是统计操作，并且是覆盖索引，则优化器会进行选择。

#### 优化器选择不使用索引的情况

多发生于范围查找、JOIN链接操作等情况下。

要求访问的数据量很小，优化器会选择辅助索引，当访问的数据量占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。因为辅助索引中查询到指定数据后，还需要一次书签访问来查找整行数据的信息，辅助索引上的数据是顺序存放的，但再一次进行书签查找的数据是无序的，变为了磁盘上的离散读操作，顺序读远快于离散读，所以优化器直接选择聚集索引。

#### 索引提示

MySQL DB支持索引提示（INDEX HINT），显示地告诉优化器使用哪个索引。

使用到INDEX HINTL的情况：

* MySQL DB的优化器错误滴选择了某个索引，导致SQL语句运行的很慢。非常少见。
* 某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。

语法:

```
tbl_name [[AS] alias] [index_hint_list]
index_hint_list:
index_hint [, index_hint] ...
index_hint:
USE {INDEX|KEY}
  [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])
  | IGNORE {INDEX|KEY}
  [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
  | FORCE {INDEX|KEY}
  [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
index_list:
index_name [, index_name] ...
```

参考 [11.1 优化器HINT](https://oceanbase.alipay.com/docs/oceanbase/OceanBase%20SQL%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BA%BA%E4%B8%BA%E6%8E%A7%E5%88%B6%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/hint)

#### Multi-Range Read（MRR）优化
MySQL v5.6开始支持Multi-Range Read（MRR）优化，减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于IO-bound类型的SQL查询语句可带来性能极大的提升，可适用于range，ref，eq_ref类型的查询。

MRR优化的好处：

* 使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果按照主键进行排序，并按照主键排序的顺序进行书签查找。
* 减少缓冲池中页被替换的次数。
* 批量处理对键值的查询操作。

对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR工作方式：

* 将查询得到的辅助索引键值存放于一个缓存中，此时缓存中的数据是根据辅助索引键值排序的。
* 将缓存中的键值根据RowID进行排序。
* 根据RowID的排序顺序来访问实际的数据文件。

当缓冲池不够大，离散读操作导致缓存中的页可能被重复替换出/读入缓冲池，按照主键顺序进行访问可将此行为降为最低。MRR还可将某些范围查询，拆分为键值对，以此来进行批量的数据查询。可以在拆分的过程中，直接过滤一些不符合查询条件的数据。

是否启用Multi-Range Read优化可通过参数`optimizer_switch`中的标记（flag）来控制。mrr为on时，表示启用Multi-Range Read优化。`mrr_cost_based`标记表示是否通过cost based的方式来选择是否启用mrr。

参数`read_rnd_buffer_size`用来控制键值的缓冲区大小，当大于该值时，则执行器对已经缓存的数据根据RowID进行排序，并通过RowID来取得行数据。默认为256K。


```
mysql> show variables like 'optimizer_switch'\G
*************************** 1. row ***************************
Variable_name: optimizer_switch
        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on
1 row in set (0.01 sec)

mysql> show variables like 'read_rnd_buffer_size'\G
*************************** 1. row ***************************
Variable_name: read_rnd_buffer_size
        Value: 262144
1 row in set (0.00 sec)
```

#### Index Condition Pushdown(ICP)优化

MySQL v5.6开始支持Index Condition Pushdown(ICP)优化。不支持前进行索引查询时，先根据索引来查找记录，然后再根据WHERE条件来过滤记录。支持后，会在取出索引的同时，判断是否可以进行WHERE条件的过滤，将WHERE的部分过滤操作放在存储引擎层。某些查询下可大大减少上层SQL层对记录的索取，提高数据库的整体性能。

ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。

### 哈希算法

时间复杂度为O（1），不只存在于索引中，每个数据库应用中都存在该数据结构。

#### 哈希表
也称散列表，由直接寻址表改进而来。

哈希函数h必须可以很好地进行散列，最好的情况下是能避免碰撞的发生，即使不能避免也应该使碰撞在最小程度下产生。一般都将关键字转换为自然数。然后通过除法散列、乘法散列或全域散列来实现。数据库一般采用除法散列的方法。

#### InnoDB存储引擎中的哈希算法

InnoDB存储引擎使用哈希算法来对字典进行查找，冲突机制采用链表方式，哈希函数采用除法散列方式。

对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，指向相同哈希函数值的页。

对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。

将要查找的页转换为自然数。InnoDB存储引擎的表空间有一个space_id，用户所要查询的应该是某个表空间的某个连续16KB的页，及偏移量offset。InnoDB存储引擎将space_id左移20位，然后加上这个space_id和offset，关键字K=space_id<<20+space_id+offset，然后通过除法散列到各个槽中去。

#### 自适应哈希索引
采用哈希表的方式实现，仅是数据库自身创建并使用的。

```
mysql> show engine innodb status\G
...
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
...
```
哈希索引只能用来搜索等值的查询。其他类型查找如范围查找是不能使用哈希索引的。

通过参数`innodb_adaptive_hash_index`控制是否开启。


### 全文索引
#### 概述

全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。可根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

InnoDB v1.2.x开始支持全文索引，支持MyISAM存储引擎的全部功能，并且还支持其他的一些特性。


#### 倒排索引

全文索引通常使用倒排索（inverted index）引来实现，倒排索引同B+ 树索引一样，也是一种索引结构。在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现，其拥有两种表现形式：

* inverted file index, 表现为{单词，单词所在文档的ID}
* full inverted index，表现为{单词，（单词所在文档的ID，在具体文档中的位置）}

#### InnoDB全文检索

InnoDB采用full inverted index的方式，将（DocumentId，Position）视为一个“list”。在全文检索的表中，有两个列，一个是word字段，另一个是ilist字段，并且在word字段上设有索引。在ilist字段中存放了Position信息，可进行Proximity Search。

倒序排序需要将word存放到一张表中，该表称为Auxiliary Table（辅助表）。在InnoDB存储引擎中，为提高全文检索的并行性能，共有6张Auxiliary Table，每张表根据word的Latin编码进行分区。

Auxiliary Table是持久的表存放于磁盘上。FTS Index Cache（全文检索索引缓存），用于提高全文检索的性能。

FTS Index Cache是一个红黑树结构，根据（word，ilist）进行排序。意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作后还在FTS Index Cache中，Auxiliary Table可能还没有更新。InnoDB存储引擎会批量对Auxiliary Table进行更新，不是每次插入后更新一次Auxiliary Table。对全文检索进行查询时，Auxiliary Table会先将FTS Index Cache中对应的word字段合并到Auxiliary Table中，然后再进查询。

允许用户查看指定倒排索引的Auxiliary Table中分词的信息，可以通过设置参数`innodb_ft_aux_table`来观察倒排索引的Auxiliary Table。

InnoDB总在事务提交时将分词写入到FTS Index Cache，然后通过批量更新写入到磁盘。数据库关闭时，FTS Index Cache中的数据会同步到磁盘上的Auxiliary Table中。若数据库宕机时，一些FTS Index Cache中的数据可能未被同步到磁盘上，下次重启时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到FTS Index Cache中。

参数`innodb_ft_cache_size`控制FTS Index Cache的大小，默认值为32MB。当该缓存满时，会将其中的（word，ilist）分词信息同步到磁盘的Auxiliary Table中。增大该参数可提高全文检索的性能，宕机时，未同步到磁盘中的索引信息可能需要更长的时间恢复。

为支持全文索引，必须有一个列与word进行映射，在InnoDB中该列被命名为FTS_DOC_ID，类型必须是BIGINT UNSIGNED NOT NULL，会自动在该列上加入一个名为FTS_DOC_ID_INDEX的Unique Index。

对于删除操作，在事务提交时，不删除磁盘Auxiliary Table中的记录，而只是删除FTS Cache Index中的记录。对于Auxiliary Table中被删除的记录，InnoDB存储引擎会记录其FTS Document ID，并将其保存在DELETED auxiliary table中，设置`innodb_ft_aux_table`后，同样可以访问information_schema架构下的表INNODB_FT_DELETED来观察删除的FTS Document
ID。

OPTIMIZE TABLE命令允许用户手工地将已经删除的记录从索引中彻底删除，该命令还进行一些其他操作如Cardinality的重新统计。若只对倒排索引进行操作，可通过参数`innodb_optimize_fulltext_only`进行设置。若被删除文档数量非常多，会占用非常多的时间，影响程序的并发性，降低用户响应时间，可通过参数`innnodb_ft_num_word_optimize`来限制每次实际删除的分词数量，默认值2000。

```
mysql> select * from information_schema.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|      7 |
+--------+
1 row in set (0.00 sec)

mysql> delete from test.fts_a where FTS_DOC_ID<7;
Query OK, 6 rows affected (0.01 sec)

mysql> select * from information_schema.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
7 rows in set (0.01 sec)

mysql> CREATE TABLE fts_a (
    -> FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,
    -> body TEXT,
    -> PRIMARY KEY(FTS_DOC_ID)
    -> );
Query OK, 0 rows affected (0.01 sec)

mysql> insert into fts_a  values (NULL,'I am a boy');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a bad boy');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy,who love liwenqi');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy,who love liwenqi in heart');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'where is my heart');
Query OK, 1 row affected (0.01 sec)

mysql> insert into fts_a  values (NULL,'what a beautiful girl ');
Query OK, 1 row affected (0.00 sec)

mysql> CREATE FULLTEXT INDEX idx_fts ON fts_a(body);
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> select * from fts_a;
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|          1 | I am a boy                                |
|          2 | I am a bad boy                            |
|          3 | I am a good boy                           |
|          4 | I am a good boy,who love liwenqi          |
|          5 | I am a good boy,who love liwenqi in heart |
|          6 | where is my heart                         |
|          7 | what a beautiful girl                     |
+------------+-------------------------------------------+
7 rows in set (0.01 sec)

mysql> set global innodb_ft_aux_table='test/fts_a';
Query OK, 0 rows affected (0.00 sec)

mysql> select * from information_schema.INNODB_FT_INDEX_TABLE;
+-----------+--------------+-------------+-----------+--------+----------+
| WORD      | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+-----------+--------------+-------------+-----------+--------+----------+
| bad       |            2 |           2 |         1 |      2 |        7 |
| beautiful |            7 |           7 |         1 |      7 |        7 |
| boy       |            1 |           5 |         5 |      1 |        7 |
| boy       |            1 |           5 |         5 |      2 |       11 |
| boy       |            1 |           5 |         5 |      3 |       12 |
| boy       |            1 |           5 |         5 |      4 |       12 |
| boy       |            1 |           5 |         5 |      5 |       12 |
| girl      |            7 |           7 |         1 |      7 |       17 |
| good      |            3 |           5 |         3 |      3 |        7 |
| good      |            3 |           5 |         3 |      4 |        7 |
| good      |            3 |           5 |         3 |      5 |        7 |
| heart     |            5 |           6 |         2 |      5 |       36 |
| heart     |            5 |           6 |         2 |      6 |       12 |
| liwenqi   |            4 |           5 |         2 |      4 |       25 |
| liwenqi   |            4 |           5 |         2 |      5 |       25 |
| love      |            4 |           5 |         2 |      4 |       20 |
| love      |            4 |           5 |         2 |      5 |       20 |
+-----------+--------------+-------------+-----------+--------+----------+
17 rows in set (0.01 sec)
```
FIRST_DOC_ID、LAST_DOC_ID、DOC_COUNT分别代表该word第一次出现的文档ID，最后一次出现的文档ID，以及该word在多少个文档中存在。


```
mysql> insert into fts_a  values (NULL,'I am a bad boy');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy,who love liwenqi');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'I am a good boy,who love liwenqi in heart');
Query OK, 1 row affected (0.01 sec)

mysql> insert into fts_a  values (NULL,'where is my heart');
Query OK, 1 row affected (0.00 sec)

mysql> insert into fts_a  values (NULL,'liwenqi,what a beautiful girl ');
Query OK, 1 row affected (0.00 sec)

mysql> select * from fts_a;
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|          8 | I am a boy                                |
|          9 | I am a bad boy                            |
|         10 | I am a good boy                           |
|         11 | I am a good boy,who love liwenqi          |
|         12 | I am a good boy,who love liwenqi in heart |
|         13 | where is my heart                         |
|         14 | liwenqi,what a beautiful girl             |
+------------+-------------------------------------------+
7 rows in set (0.00 sec)

mysql> select * from information_schema.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
7 rows in set (0.00 sec)

mysql> set global innodb_optimize_fulltext_only=1;
Query OK, 0 rows affected (0.00 sec)

mysql> optimize table test.fts_a;
+------------+----------+----------+----------+
| Table      | Op       | Msg_type | Msg_text |
+------------+----------+----------+----------+
| test.fts_a | optimize | status   | OK       |
+------------+----------+----------+----------+
1 row in set (0.02 sec)

mysql> select * from information_schema.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
7 rows in set (0.00 sec)

mysql> select * from information_schema.INNODB_FT_BEGIN_DELETED;
ERROR 1109 (42S02): Unknown table 'innodb_ft_begin_deleted' in information_schema
mysql> select * from information_schema.INNODB_FT_BEING_DELETED;
+--------+
| DOC_ID |
+--------+
|      1 |
|      2 |
|      3 |
|      4 |
|      5 |
|      6 |
|      7 |
+--------+
7 rows in set (0.00 sec)
```

命令OPTIMIZE TABLE可将记录进行彻底的删除，并且彻底删除的文档ID会记录到表information\_schema.INNODB\_FT\_BEING\_DELETED中。已被删除的文档ID不允许被再次使用。

stopword列表（stopword list）表示该列表中的word不需要对其进行索引分词操作。InnoDB存储引擎有一张默认的stopword列表，在information\_schema架构下，表名为INNODB\_FT\_DEFAULT\_STOPWORD，默认共36个stopword。可通过参数`innodb_ft_server_stopword_table`来自定义stopword列表。

```
mysql> select * from information_schema.INNODB_FT_DEFAULT_STOPWORD;
+-------+
| value |
+-------+
| a     |
| about |
| an    |
| are   |
| as    |
| at    |
| be    |
| by    |
| com   |
| de    |
| en    |
| for   |
| from  |
| how   |
| i     |
| in    |
| is    |
| it    |
| la    |
| of    |
| on    |
| or    |
| that  |
| the   |
| this  |
| to    |
| was   |
| what  |
| when  |
| where |
| who   |
| will  |
| with  |
| und   |
| the   |
| www   |
+-------+
36 rows in set (0.00 sec)

mysql> CREATE TABLE user_stopword (
    -> value VARCHAR(30)
    -> ) ENGINE = INNODB;
Query OK, 0 rows affected (0.01 sec)

mysql> set global innodb_ft_server_stopword_table = "test/user_stopword";
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'innodb_ft_server_stopword_table'\G
*************************** 1. row ***************************
Variable_name: innodb_ft_server_stopword_table
        Value: test/user_stopword
1 row in set (0.00 sec)
```

InnoDB全文索引的限制：

* 每张表只能有一个全文索引。
* 由多列组合而成的全文检索的索引必须使用相同的字符集与排序规则。
* 不支持没有单词界定符的语言，如中文、日语、韩语等。


#### 全文检索

MySQL全文检索查询语法：

```
MATCH (col1,col2,...) AGAINST (expr [search_modifier])
search_modifier:
{
	IN NATURAL LANGUAGE MODE
	| IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION
	| IN BOOLEAN MODE
	| WITH QUERY EXPANSION
}
```

MATCH 指定了需要被查询的列，AGAINST指定了使用何种方法去进行查询。

##### Natural Language

通过MATCH函数进行查询，默认采用Natural Language模式，表示查询带有指定word的文档。

不使用全文索引：

```
mysql> select * from fts_a where body like '%liwenqi%';
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|         11 | I am a good boy,who love liwenqi          |
|         12 | I am a good boy,who love liwenqi in heart |
|         14 | liwenqi,what a beautiful girl             |
+------------+-------------------------------------------+
3 rows in set (0.00 sec)

mysql> explain select * from fts_a where body like '%liwenqi%';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | fts_a | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.03 sec)
```

使用全文索引：

```
mysql> select * from fts_a 
    -> where match(body)
    -> against('liwenqi' in natural language mode);
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|         11 | I am a good boy,who love liwenqi          |
|         12 | I am a good boy,who love liwenqi in heart |
|         14 | liwenqi,what a beautiful girl             |
+------------+-------------------------------------------+
3 rows in set (0.02 sec)

mysql> explain select * from fts_a  where match(body) against('liwenqi' in natural language mode);
+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+
| id | select_type | table | partitions | type     | possible_keys | key     | key_len | ref   | rows | filtered | Extra                         |
+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+
|  1 | SIMPLE      | fts_a | NULL       | fulltext | idx_fts       | idx_fts | 0       | const |    1 |   100.00 | Using where; Ft_hints: sorted |
+----+-------------+-------+------------+----------+---------------+---------+---------+-------+------+----------+-------------------------------+
1 row in set, 1 warning (0.01 sec)
```
NATURAL LANGUAGE MODE默认的全文检索查询模式，可省略查询修饰符。

type列显示fulltext表示使用全文检索的倒排索引，key显示了索引的名字，相对like查询，全文索引只进行了一次扫描。

查询返回的结果是根据相关性（Relevance）进行降序排序的，相关性最高的结果放在第一位。由一个非负的浮点数表示，0表示没有任何相关性。相关性计算依据的条件：

* word是否在文档中出现。
* word在文档中出现的次数。
* word在索引列中的数量。
* 有多少个文档包含该word。

统计查询结果：

```
mysql> select count(*) from fts_a  where match(body) against('liwenqi' in natural language mode);
+----------+
| count(*) |
+----------+
|        3 |
+----------+
1 row in set (0.01 sec)

mysql> explain select count(*) from fts_a  where match(body) against('liwenqi' in natural language mode);
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
1 row in set, 1 warning (0.01 sec)

mysql> select count(if(match(body) against('liwenqi' in natural language mode),1,NULL)) as count from fts_a;
+-------+
| count |
+-------+
|     3 |
+-------+
1 row in set (0.00 sec)

mysql> explain select count(if(match(body) against('liwenqi' in natural language mode),1,NULL)) as count from fts_a;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | fts_a | NULL       | index | NULL          | PRIMARY | 8       | NULL |    6 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
第二句SQL执行速度更快，第一句SQL语句需要进行相关性的排序统计。

通过SQL查看相关性：

```
mysql> select fts_doc_id,body, match(body) against('liwenqi' in natural language mode) as relevance from fts_a;
+------------+-------------------------------------------+--------------------+
| fts_doc_id | body                                      | relevance          |
+------------+-------------------------------------------+--------------------+
|          8 | I am a boy                                |                  0 |
|          9 | I am a bad boy                            |                  0 |
|         10 | I am a good boy                           |                  0 |
|         11 | I am a good boy,who love liwenqi          | 0.0906190574169159 |
|         12 | I am a good boy,who love liwenqi in heart | 0.0906190574169159 |
|         13 | where is my heart                         |                  0 |
|         14 | liwenqi,what a beautiful girl             | 0.0906190574169159 |
+------------+-------------------------------------------+--------------------+
7 rows in set (0.00 sec)
```

需考虑因素：

* 查询word在stopword列中，忽略该字符串的查询。
* 查询的word字符长度是否在区间[innodb_ft_min_token_size, innodb_ft_max_token_size]内。

若词在stopword中，不对该词进行查询。

参数`innodb_ft_min_token_size`和`innodb_ft_max_token_size`控制InnoDB存储引擎查询字符的长度，当长度小于`innodb_ft_min_token_size`或者大于`innodb_ft_max_token_size`时，会忽略该词的搜索，InnoDB存储引擎中，前者值默认为3，后者值默认为84。

##### Boolean
使用该修饰符时，查询字符串的前后缀字符会有特殊的含义，支持以下几种操作符：

* +表示该word必须存在。
* -表示该word必须被排除。
* （no operator）表示该word是可选的，但是如果出现，相关性会更高。
* @distance表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节。该全文检索的查询也称为Proximity Search。
* >表示出现该单词时增加相关性。
* >表示出现该单词时降低相关性。
* ～表示允许出现该单词，但是出现时的相关性为负。
* *表示以该单词开头的单词。
* "表示短语。

```
mysql> select * from fts_a  where match(body) against('liwenqi girl' in boolean mode);
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|         14 | liwenqi,what a beautiful girl             |
|         11 | I am a good boy,who love liwenqi          |
|         12 | I am a good boy,who love liwenqi in heart |
+------------+-------------------------------------------+
3 rows in set (0.00 sec)

mysql> select * from fts_a  where match(body) against('+liwenqi -girl' in boolean mode);
+------------+-------------------------------------------+
| FTS_DOC_ID | body                                      |
+------------+-------------------------------------------+
|         11 | I am a good boy,who love liwenqi          |
|         12 | I am a good boy,who love liwenqi in heart |
+------------+-------------------------------------------+
2 rows in set (0.00 sec)
```

##### Query Expansion

MySQL支持全文索引的拓展查询，通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。通过Query Expansion模式开启全文检索的implied knowledge。

通过在查询短语中添加WITH QUERY EXPANSION或者IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION可以开启blind query knowledge（又称为automatic relevance feedback）。该查询分为两个阶段：

* 第一阶段：根据搜索的单词进行全文索引查询。
* 第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询。

Query Expansion的全文检索可能会带来许多非相关性的查询。
