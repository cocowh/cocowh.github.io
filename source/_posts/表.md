---
title: 表
tags: [mysql,note,innodb,table]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-08-19 14:26:08
---

### 索引组织表

表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：

* 首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。
* 不符合上述条件则自动创建一个6字节大小的指针。

若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。

### InnoDB逻辑存储结构

所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。

#### 表空间
表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。

启用参数`innodb_file_per_table`，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。

#### 段
常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。

#### 区
区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。

InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.

InnoDB v1.2.x新增参数`innodb_page_size`，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。

在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

#### 页
页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为`innodb_page_size`，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。

常见的页类型：

* 数据页（B-Tree Node）
* undo页（undo LogPage）
* 系统页（System Page）
* 事务数据页（Transaction system Page）
* 插入缓冲位图页（Insert Buffer Bitmap）
* 插入缓冲空闲列表页（Insert Buffer Free List）
* 未压缩的二进制大对象页（Uncompressed BLOG Page）


#### 行
InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。

### InnoDB行记录格式
书中介绍不完善，参考博客[MySQL InnoDB 行记录格式](https://www.cnblogs.com/wilburxu/p/9435818.html)。


#### Compact行记录格式
在MySQL 5.0中引入，设计目标是高效地存储数据。

存储方式：

变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | ......
 :-: | :-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节 | 有NULL值列用1表示，占1字节 | 固定占用5字节 | 列数据 | 列数据 | 列数据

记录头信息每位含义：

名称 | 大小（bit）| 描述
:-: | :-: | :-:
（）| 1 | 未知
（）| 1 | 未知
deleted_flag | 1 | 该行是否已被删除
min_rec_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的排序记录
record_type | 3 | 记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimun，011表示Supermum、1xx表示保留
next_record |  16 | 页中下一条记录的相应位置


数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。

InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。

#### Redundant行记录格式
MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。

存储方式：

字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | ......
:-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示 | 占用六字节 | 列数据 | 列数据 | 列数据

记录头信息含义：

名称 | 大小（bit） | 描述
:-: | :-: | :-:
（） | 1 | 未知
（） | 1 | 未知   
deleted_flag | 1 | 该行是否已被删除
min_rec_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的索引号
n_flieds | 10 | 记录中列的数量
1 byte_offs_flag | 1 | 偏移列表为1字节还是2字节
next_record | 16 | 页中下一条记录的相对位置

对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。

#### 行溢出数据
 