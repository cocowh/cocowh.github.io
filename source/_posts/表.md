---
title: 表
tags: [mysql,note,innodb,table]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-08-19 14:26:08
---

### 索引组织表

表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：

* 首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。
* 不符合上述条件则自动创建一个6字节大小的指针。

若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。

### InnoDB逻辑存储结构

所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。

#### 表空间
表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。

启用参数`innodb_file_per_table`，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。

#### 段
常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。

#### 区
区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。

InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.

InnoDB v1.2.x新增参数`innodb_page_size`，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。

在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

#### 页
页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为`innodb_page_size`，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。

常见的页类型：

* 数据页（B-Tree Node）
* undo页（undo LogPage）
* 系统页（System Page）
* 事务数据页（Transaction system Page）
* 插入缓冲位图页（Insert Buffer Bitmap）
* 插入缓冲空闲列表页（Insert Buffer Free List）
* 未压缩的二进制大对象页（Uncompressed BLOG Page）


#### 行
InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。

### InnoDB行记录格式
书中介绍不完善，参考博客[MySQL InnoDB 行记录格式](https://www.cnblogs.com/wilburxu/p/9435818.html)。


#### Compact行记录格式
在MySQL 5.0中引入，设计目标是高效地存储数据。

存储方式：

变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | ......
 :-: | :-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节 | 有NULL值列用1表示，占1字节 | 固定占用5字节 | 列数据 | 列数据 | 列数据

记录头信息每位含义：

名称 | 大小（bit）| 描述
:-: | :-: | :-:
（）| 1 | 未知
（）| 1 | 未知
deleted_flag | 1 | 该行是否已被删除
min\_rec\_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的排序记录
record_type | 3 | 记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimum，011表示Supermum、1xx表示保留
next_record |  16 | 页中下一条记录的相应位置


数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。

InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。

#### Redundant行记录格式
MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。

存储方式：

字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | ......
:-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示 | 占用六字节 | 列数据 | 列数据 | 列数据

记录头信息含义：

名称 | 大小（bit） | 描述
:-: | :-: | :-:
（） | 1 | 未知
（） | 1 | 未知   
deleted_flag | 1 | 该行是否已被删除
min\_rec\_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的索引号
n_flieds | 10 | 记录中列的数量
1 byte\_offs\_flag | 1 | 偏移列表为1字节还是2字节
next_record | 16 | 页中下一条记录的相对位置

对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。

#### 行溢出数据

InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOG、LOB这类大对象列类型的存储会把数据存放在数据页面之外，但是BLOG可以不将数据放在溢出页面，即便VARCHAR列数据依然有可能被存放为行溢出数据。

存放VARCHAR类型的最大长度（所有VARCHAR列的长度总和）为65532字节，超出且将SQL_MODE设为严格模式，建表时会报错，没设置严格模式或许可以建表但是会抛出一个warning，会将VARCHAR类型转换为TEXT类型。

InnoDB存储引擎的页为16KB，一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，发生行溢出时，数据存放在页类型为Uncompress BLOG页中。

InnoDB存储引擎表是索引组织的（B+Tree结构），每个页至少应该有两条行记录（否则失去B+Tree意义变成链表）。若页中只能存放下一条记录，则InnoDB存储引擎会自动将行数据放到溢出页中。若能至少放入两行数据则VARCHAR类型的行数据不会存放到BLOG页中，阀值的长度为8098。

TEXT或BLOG的数据类型，存放在数据页还是BLOG页和VARCHAR原则一致。大多数情况下BLOG的行数据会发生行溢出，实际数据保存在BLOG页中，数据页只保存前768字节。

#### Compressed和Dynamic行记录数据
InnoDB v1.0.x开始引入新的文件格式，以前支持的Compact和Redundant格式被称为Antelope文件格式，新的文件格式称为Barracuda文件格式，其拥有两种新的行记录格式：Compressed和Dynamic。

新的两种行记录格式对于存放在BLOG中的数据采用了完全的行溢出的方式，数据页中只存放20个字节的指针，实际数据都存放在Off Page中。

Compressed行记录格式的另一个功能是，存放在其中的行数据会已zlib的算法进行压缩，对BLOG、TEXT、VARCHAR类大长度类型的数据能够进行有效的存储。

#### CHAR的行存储结构
通常理解VARCHAR存储变长长度的字符类型，CHAR存储固定长度的字符类型。

MySQL v4.1开始，CHAR（N）中N指的是字符的长度，而非字节长度，在不同的字符集下，CHAR类型列内部存储的可能不是定长数据。

对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度。在多字符集的存储情况下，CHAR和VARCHAR的实际存储基本没有区别。

### InnoDB数据页结构

InoDB数据页组成：

* File Header（文件头）
* Page Header（页头）
* Infimum和Supermun Records
* User Records（用户记录，即行记录）
* Free Space（空闲空间）
* Page Directory（页目录）
* File Trailer（文件结尾信息）

Flie Header、Page Header、File Trailer大小固定，分别为38、56、8字节，标记该页的一些信息，如Checksum，数据页所在B+ Tree索引的层等。User Records、Free Space、Page Directory为实际的行记录存储空间，大小是动态的。

File Header | Page Header | Infimum + Supermum Records |  User Recodrds | Free Space | Page Directory | File Trailer
:-: | :-: | :-: | :-: | :-: | :-: | :-: 
38字节 | 56字节 | 行记录 | 行记录 | | | 8字节

#### File Header
组成 ：

名称 | 大小（字节） | 说明 
:-: | :-: | :-: 
FIL\_PAGE\_SPACE\_OR\_CHKSUM | 4 | MySQL v4.0.14之前值为0，之后代表页的checksum值
FIL\_PAGE\_OFFSET | 4 | 表空间中页的偏移量，表示当前页在表空间所有页中的位置
FIL\_PAGE\_PREV | 4 | 当前页的上一个页
FIL\_PAGE\_NEXT | 4 | 当前页的下一个页
FIL\_PAGE\_LSN	| 8 | 最后被修改的日志序列位置LSN（Log Sequence Number）
FIL\_PAGE\_TYPE | 2 | 页的类型，见下表枚举
FIL\_PAGE\_FILE\_FLUSH\_LSN | 8 | 仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间值为0
FIL\_PAGE\_ARCH\_LOG\_NO\_OR\_SPACE\_ID | 4 | MySQL v4.1开始代表页属于哪个表空间。


InnoDB存储引擎中页的类型

名称 | 十六进制 | 解释 
:-: | :-: | :-:
FIL\_PAGE\_INDEX | 0x45BF | B+树叶节点
FIL\_PAGE\_UNDO\_LOG | 0x0002 | Undo Log页
FIL\_PAGE\_INODE | 0x0003 | 索引节点
FIL\_PAGE\_IBUF\_FREE\_LIST | 0x0004 | Insert Buffer空闲列表
FIL\_PAGE\_TYPE\_ALLOCATED | 0x0000 | 该页为最新分配
FIL\_PAGE\_IBUF\_BITMAP | 0x0005 | Insert Buffer位图
FIL\_PAGE\_TYPE\_SYS | 0x0006 | 系统页
FIL\_PAGE\_TYPE\_TRX\_SYS | 0x0007 | 事务系统数据
FIL\_PAGE\_TYPE\_FSP\_HDR | 0x0008 | File Space Header
FIL\_PAGE\_TYPE\_XDES | 0x0009 | 拓展描述页
FIL\_PAGE\_TYPE\_BLOG | 0x000A | BLOG页

#### Page Header
记录数据页的状态信息，由14个部分组成：

名称 | 大小 | 说明
:-: | :-: | :-: 
PAGE\_N\_DIR\_SLOTS | 2 | 在Page Directory（页目录）中的Slot（槽）数
PAGE\_HEAP\_TOP | 2 | 堆中第一个记录的指针、记录在页中是根据堆的形式存放的
PAGE\_N\_HEAP | 2 | 堆中的记录数，第15位表示行记录数
PAGE\_FREE | 2 |指向可重用空间的首指针
PAGE\_GARBAGE | 2 | 已删除记录的字节数，行记录结构中delete flag为1的记录大小的总数
PAGE\_LAST\_INSERT | 2 | 最后插入记录的位置
PAGE\_DIRECTORY | 2 | 最后插入的方向，可取：PAGE\_LEFT(0x01)，PAGE\_RIGHT(0x02)，PAGE\_SAME\_REC(0x03)，PAGE\_SAME\_PAGE(0x04)，PAGE\_NO\_DIRECTION(0x05)
PAGE\_N\_DIRECTION | 2 | 一个方向连续插入数据的数量
PAGE\_N\_RECS | 2 | 该页中记录的数量
PAGE\_MAX\_TEX\_ID | 8 | 当前页的最大事务ID，仅在Secondary Index(辅助索引)中定义
PAGE\_LEVEL | 2 | 当前页在索引树中的位置，0x00代表页节点，页节点总在第0层
PAGE\_INDEX\_ID | 8 | 索引ID，表示当前页属于哪个索引
PAGE\_BTR\_SEG\_LEAF | 10 | 仅在B+ Tree树的Root页中定义，B+ Tree数据页非页节点所在段的seqment header
PAGE\_BTR\_SEG\_TOP | 10 | 仅在B+ Tree的Root页中定义，B+ Tree数据页所在段的segment header

#### Infimum和Supermum Record
Infimum记录比该页中任何主键值都要小得值，Supermum指比任何可能大的值还要大的值，在页创建时被建立，在任何情况下都不会被删除。在Compact和Redundant行格式下，两者占用的字节数各不相同。

#### User Record和Free Space
User Record：实际存储行记录的内容。

Free Space：空闲空间，链表数据结构，在一条记录被删除后，该空间被加入到空闲链表中。

#### Page Directory
页目录中存放记录的相对位置，有些时候这些记录指针被称为Slots（槽）或目录槽（Directory Slots）。

InnoDB的槽是一个稀疏目录（sparse directory），一个槽中可能包含多个记录。伪记录Infimum的n\_owned值总是1，记录Supermum的n\_owned的取值范围为[1, 8]，其他用户记录n\_owned的取值范围为[4, 8]，当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。

Slots中记录按照索引键值顺序存放，可以利用二叉查找，查找结果只是一个粗略的结果，必须通过recorder header中的next_record继续查找相关记录。

B+ Tree索引找到记录所在的页，数据库把页载入内存，然后通过Page Directory再进行二叉查找。

#### File Trailer
检测页是否已经完整地写入磁盘（可能发生在写入过程中磁盘损坏）。

只有以一个FIL\_PAGE\_END\_LSN部分，占用8字节。前4字节代表该页的checksum值，后4字节和File Header中的FIL\_PAGE\_LSN相同。通过InnoDB的checksum函数将这两个值与File Header中的FIL\_PAGE\_SPACE\_OR\_CHKSUM和FIL\_PAGE\_LSN值进行比较，看是否一致，保证页的完整行。

默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，即该页是否发生Corrupt，该检测会有一定的开销，可通过innodb\_checksums来开启或关闭对这个页完整性的检查。


MySQL v5.6.6新增参数`innodb_checksum_algorithm`，控制检测checksum函数的算法，默认crc32，可设置：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。


```
mysql> show variables like 'innodb_checksum%'\G
*************************** 1. row ***************************
Variable_name: innodb_checksum_algorithm
        Value: crc32
*************************** 2. row ***************************
Variable_name: innodb_checksums
        Value: ON
2 rows in set (0.00 sec)
```

innodb为兼容之前版本的checksum检测方式，crc于v 5.6.6引入，有更高的性能。若表中所有页的checksum值都以strict算法保存，脚底版本MySQL数据库不能读取这些页。none表示不对页启用checksum检测。strict_*表示严格按照checksum算法进行页的检测，较低版本MySQL升级到MySQL5.6.6+版本，启用strict\_crc32将不能读取表中的页。启用strict\_crc32方式是最快的方式，其不再对innodb和crc32算法进行两次检测。数据库从低版本升级而来需进行mysql\_upgrade操作。

### Named File Formats机制
从InnoDB v1.0.x引入，通过Named File Formats机制解决不同版本下页结构兼容性问题。

通过参数`innodb_file_format`指定文件格式，通过参数`innodb_file_format_check`检测当前存储引擎文件格式的支持度，默认为ON。

```
mysql> select @@version\G
*************************** 1. row ***************************
@@version: 5.7.22
1 row in set (0.00 sec)

mysql> show variables like 'innodb_version'\G
*************************** 1. row ***************************
Variable_name: innodb_version
        Value: 5.7.22
1 row in set (0.00 sec)

mysql> show variables like 'innodb_file_format'\G
*************************** 1. row ***************************
Variable_name: innodb_file_format
        Value: Barracuda
1 row in set (0.00 sec)
```


### 约束

#### 数据完整性
关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，文件系统一般需要在程序端进行控制。

数据完整性的三种形式：

* 实体完整性保证表中有一个主键。通过Primary Key或Unique Key约束来保证实体的完整性。可通过编写一个触发器来保证数据的完整性。
* 域完整性保证数据每列的值满足特定的条件。域完整性保证途径：
	+ 选择合适的数据类型确保一个数据值满足特定条件。
	+ 外键（Foreign key）约束。
	+ 编写触发器。
	+ 用DEFAULT约束强制域完整性
* 参照完整性保证两张表之间的关系。InnoDB存储引擎支持外健，允许用户自定义外键以强制参照完整性，通过编写触发器以强制执行。

InnoDB存储引擎本身提供约束：
 
* Primary Key
* Unique Key
* Foreign Key
* Default
* NOT NULL 

#### 约束的创建和查找

采用两种方式：

* 表建立时进行约束定义
* 利用ALTER TABLE命令来进行创建约束

对Unique Key约束，还可通过命令CREATE UNIQUE INDEX来建立。主键约束默认名Primary，Unique Key约束默认约束名和列名一样，可指定Unique Key约束名。Foreign Key约束默认名称特殊。

可通过information\_schema架构下的表TABLE\_CONSTRAINTS查看当前MySQL库下所有的约束信息，通过表REFERENTIAL\_CONSTRAINTS查看Foreign Key的约束命名和外健的属性。

```
mysql> show columns from information_schema.TABLE_CONSTRAINTS;
+--------------------+--------------+------+-----+---------+-------+
| Field              | Type         | Null | Key | Default | Extra |
+--------------------+--------------+------+-----+---------+-------+
| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |
| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |
| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |
| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |
| TABLE_NAME         | varchar(64)  | NO   |     |         |       |
| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |
+--------------------+--------------+------+-----+---------+-------+
6 rows in set (0.00 sec)

mysql> show columns from information_schema.REFERENTIAL_CONSTRAINTS;
+---------------------------+--------------+------+-----+---------+-------+
| Field                     | Type         | Null | Key | Default | Extra |
+---------------------------+--------------+------+-----+---------+-------+
| CONSTRAINT_CATALOG        | varchar(512) | NO   |     |         |       |
| CONSTRAINT_SCHEMA         | varchar(64)  | NO   |     |         |       |
| CONSTRAINT_NAME           | varchar(64)  | NO   |     |         |       |
| UNIQUE_CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |
| UNIQUE_CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |
| UNIQUE_CONSTRAINT_NAME    | varchar(64)  | YES  |     | NULL    |       |
| MATCH_OPTION              | varchar(64)  | NO   |     |         |       |
| UPDATE_RULE               | varchar(64)  | NO   |     |         |       |
| DELETE_RULE               | varchar(64)  | NO   |     |         |       |
| TABLE_NAME                | varchar(64)  | NO   |     |         |       |
| REFERENCED_TABLE_NAME     | varchar(64)  | NO   |     |         |       |
+---------------------------+--------------+------+-----+---------+-------+
11 rows in set (0.00 sec)
```

#### 约束和索引的区别

约束是逻辑概念，用来保证数据的完整性，索引是一个数据结构，在数据库中代表着物理存储的方式。

#### 对错误数据的约束

默认设置下，MySQL允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL会将其更改为0再进行插入。

可通过设置参数`sql_mode`为STRICT\_TRANS\_TABLES，对输入值的合法性进行约束，用来严格审核输入的参数。sql\_mode可设值参考MySQL官方手册。

#### ENUM和SET约束

MySQL数据库不支持传统的CHECK约束，通过ENUM和SET类型解决。

对于传统CHECK约束支持的连续值的范围约束或更复杂的约束，可通过触发器来实现对于值域的约束。

#### 触发器与约束

触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。MySQL v5.1开始触发器相对稳定。

通过命令CREATE TRIGGER创建触发器，具备Super权限的MySQL数据库用户才可执行这条命令。

```
CREATE 
[DEFINER = { user | CURRENT_USER }]
TRIGGER trigger_name BEFORE | AFTER INSERT | UPDATE | DELETE
ON tb1_name FOR EACH ROW trigger_stmt
```
最多可为一个表建立6个触发器，分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。BEFORE和AFTER代表触发器发生的时间，表示在每行操作之前发生还是之后发生。

```
mysql> create table usercash ( userid INT NOT NULL, cash INT UNSIGNED NOT NULL);
Query OK, 0 rows affected (0.12 sec)

mysql> create table usercash_err_log ( userid INT NOT NULL, old_cash INT UNSIGNED NOT NULL, new_cash INT UNSIGNED NOT NULL, user VARCHAR(30), time DATETIME);
Query OK, 0 rows affected (0.03 sec)

mysql> DELIMITER $$ 
mysql> create trigger tgr_usercash_update before update on usercash
    -> for each row
    -> begin 
    -> if new.cash-old.cash > 0 then
    -> insert into usercash_err_log
    -> select old.userid,old.cash,new.cash,USER(),NOW();
    -> set new.cash = old.cash;
    -> end if;
    -> end;
    -> $$
Query OK, 0 rows affected (0.13 sec)

mysql> select * from usercash\G
*************************** 1. row ***************************
userid: 1
  cash: 1000
1 row in set (0.00 sec)

mysql> select * from usercash_err_log\G
Empty set (0.00 sec)

mysql> update usercash set cash=cash-(-20) where userid=1;
Query OK, 0 rows affected (0.05 sec)
Rows matched: 1  Changed: 0  Warnings: 0

mysql> select * from usercash\G
*************************** 1. row ***************************
userid: 1
  cash: 1000
1 row in set (0.00 sec)

mysql> select * from usercash_err_log\G
*************************** 1. row ***************************
  userid: 1
old_cash: 1000
new_cash: 1020
    user: root@localhost
    time: 2019-08-23 15:18:08
1 row in set (0.00 sec)

mysql> 
```

#### 外键约束

保证参照的完整性，MyISAM引擎本身不支持外键，对于外键的定义只起注释的作用。InnoDB完整支持外键约束。

```
[CONSTRAINT [symbol]] FOREIGN KEY
[index_name] (index_col_name, ...)
REFERENCES tb1_name (index_col_name, ...)
[ON DELETE reference_option]
[ON UPDATE reference_option]
reference_option:
RESTRICT | CASCADE | SET NULL | NO ACTION
```
可执行CREATE TABLE或者ALTER TABLE命令添加外健。

被引用的表为父表、引用的表称为子表，外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作，可定义字表操作有：

* CASCADE：父表发生DELETE或UPDATE操作时对相应字表中的数据也进行DELETE或UPDATE操作。
* SET NULL：父表发生DELETE或UPDATE操作时，相应的字表中的数据被更新为NULL值，字表相应字段必须允许为NULL值。
* NO ACTION：父表发生DELETE或UPDATE操作时，抛出错误，不允许此类操作发生。
* RESTRICT：未定义ON DELETE或ON UPDATE时的默认外健设置。

MySQL数据库的外键约束为及时检查，在SQL语句运行时进行检查。MySQL数据库中NO ACTION和RESTRICT的功能是相同的。

InnoDB在外键建立时会自动为该列加一个索引，可避免外键列上无索引而导致的死锁问题产生。

可通过参数`foreign_key_checks`设置是否开启外键检查。

```
mysql> show variables like 'foreign_key_checks'\G
*************************** 1. row ***************************
Variable_name: foreign_key_checks
        Value: ON
1 row in set (0.03 sec)
```


### 视图

视图是一个命名的虚表，由一个SQL查询来定义，可当作表使用，没有实际的物理存储。

#### 视图的作用

被用作一个抽象装置，不需关心基表（base table）的结构，只需按视图定义来取数据或更新数据。一定程度上起到安全层作用。

MySQL v5.0开始支持视图：

```
[OR REPLACE]
[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
[DEFINER = { user | CURRENT_USER }]
[SQL SECURITY { DEFINER | INVOKER }]
VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION]
```

可对某些视图进行更新操作，本质是通过视图的定义来更新基本表。称可进行更新操作的视图为可更新视图（updatable view）。WITH CHECK OPTION针对于可更新视图更新的值是否需要检查。


通过SHOW TABLES命令显示结果包含基表和视图，只查询基表可通过information_schema架构下的TABLE表查询，并搜索类型为BASE TABLE的表。

查看视图的元数据（meta data）可访问information_schema架构下的VIEWS表，给出了视图的定义者（definer）、定义内容、是否是可更新视图、字符集等。

```
mysql> show tables;
+------------------+
| Tables_in_login  |
+------------------+
| jobs             |
| migrations       |
| password_resets  |
| user_profiles    |
| usercash         |
| usercash_err_log |
| users            |
| users_old        |
+------------------+
8 rows in set (0.02 sec)

mysql> create view v_users
    -> as
    -> select * from users where id<10;
Query OK, 0 rows affected (0.01 sec)

mysql> show tables;
+------------------+
| Tables_in_login  |
+------------------+
| jobs             |
| migrations       |
| password_resets  |
| user_profiles    |
| usercash         |
| usercash_err_log |
| users            |
| users_old        |
| v_users          |
+------------------+
9 rows in set (0.00 sec)

mysql> select * from  information_schema.VIEWS where table_schema=database()\G
*************************** 1. row ***************************
       TABLE_CATALOG: def
        TABLE_SCHEMA: login
          TABLE_NAME: v_users
     VIEW_DEFINITION: select `login`.`users`.`id` AS `id`,`login`.`users`.`name` AS `name`,`login`.`users`.`sex` AS `sex` from `login`.`users` where (`login`.`users`.`id` < 10)
        CHECK_OPTION: NONE
        IS_UPDATABLE: YES
             DEFINER: root@localhost
       SECURITY_TYPE: DEFINER
CHARACTER_SET_CLIENT: utf8
COLLATION_CONNECTION: utf8_general_ci
1 row in set (0.00 sec)

mysql> 
```

#### 物化视图

物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果，在执行复杂查询时，可避免进行这些耗时的操作，从而快速得到结果，对于一些复杂的统计类查询能直接查处结果。

MySQL数据库不支持物化视图，可通过一些机制来实现物化视图的功能。例如可通过触发器维护一个结果状态副表，每当发生INSERT、UPDATE和DELETE操作时触发器更新结果状态表。

### 分区表

#### 分区概念

MySQL v5.1时添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对应用，逻辑上只有一个或一个索引，但在物理上表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

MySQL支持水平分区（同一表中不同行的记录分配到不同的物理文件中），不支持垂直分区（同一表中不同列的记录分配到不同的物理文件中）。MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。全局分区指数据存放在各个分区中，但是所有数据的索引放在一个对象中。

可通过`SHOW VARIABLES LIKE '%partition%'\G` 和` SHOW PLUGINS\G`查看是否启用了分区功能。


MySQL数据库支持分区类型：
 
* RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区，v5.5开始支持RANGE COLUMNS的分区。
* LIST分区：面向离散的值。v5.5开始支持LIST COLUMNS的分区。
* HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。
* KEY分区：根据MySQL数据库提供的哈希函数进行分区。

若表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引允许NULL值，分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。若建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。

#### 分区类型

##### RANGE分区


