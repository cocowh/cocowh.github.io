---
title: 表
tags: [mysql,note,innodb,table]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-08-19 14:26:08
---

### 索引组织表

表根据主键顺序组织存放，称为索引组织表，每个表中都有个主键，若创建表时没有显示地定义主键，则存储引擎按如下方式选择或创建主键：

* 首先判断表中是否有非空的唯一索引（Unique Not Null），有则该列即为主键。
* 不符合上述条件则自动创建一个6字节大小的指针。

若有多个非空唯一索引则选择建表时第一个定义的非空唯一索引列为主键。根据定义索引的顺序，而不是根据建表时列的顺序。

### InnoDB逻辑存储结构

所有数据被逻辑地存放在一个空间中，称之为表空间。由段（segment）、区（extent）、页（page）组成。

#### 表空间
表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。

启用参数`innodb_file_per_table`，每张表的数据可以单独放到一个表空间内，只存放数据、索引和插入缓冲Bitmap页，其他类的数据如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间内。

#### 段
常见的段有：数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段即为B+树的非索引节点，回滚段较特殊。InnoDB中对段的管理由其自身完成。

#### 区
区由连续页组成的空间，任何情况下每个区的大小都是1MB，为保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4～5个区，默认情况下InnoDB存储引擎页的大小为16KB，一个区中一共有64个连续的页。

InnoDB v1.0.x开始引入压缩页，每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128.

InnoDB v1.2.x新增参数`innodb_page_size`，可将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。此时页的数量为256、128，不论页的大小怎么变化，区的大小总是1M。

在每个段的开始先用32个页大小的碎片页来存放数据，使用完后才是64个连续页的申请。对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

#### 页
页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。v1.2.x开始可通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。设置完成后，表中页的大小都为`innodb_page_size`，不可以对其再次进行修改，除非通过mysqldump导入和导出操作来产生新的库。

常见的页类型：

* 数据页（B-Tree Node）
* undo页（undo LogPage）
* 系统页（System Page）
* 事务数据页（Transaction system Page）
* 插入缓冲位图页（Insert Buffer Bitmap）
* 插入缓冲空闲列表页（Insert Buffer Free List）
* 未压缩的二进制大对象页（Uncompressed BLOG Page）


#### 行
InnoDB存储引擎面向列的（row-oriented），数据是按行进行存放的。每个页最多允许存放16KB/2-200行，即7992行记录。存在column-oriented的数据库，MySQL infobright存储引擎按列来存放数据。

### InnoDB行记录格式
书中介绍不完善，参考博客[MySQL InnoDB 行记录格式](https://www.cnblogs.com/wilburxu/p/9435818.html)。


#### Compact行记录格式
在MySQL 5.0中引入，设计目标是高效地存储数据。

存储方式：

变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | ......
 :-: | :-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示，VARCHAR类型的最大长度为65535，不超过两字节 | 有NULL值列用1表示，占1字节 | 固定占用5字节 | 列数据 | 列数据 | 列数据

记录头信息每位含义：

名称 | 大小（bit）| 描述
:-: | :-: | :-:
（）| 1 | 未知
（）| 1 | 未知
deleted_flag | 1 | 该行是否已被删除
min\_rec\_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的排序记录
record_type | 3 | 记录类型，000表示普通、001表示B+ Tree节点指针、010表示Infimum，011表示Supermum、1xx表示保留
next_record |  16 | 页中下一条记录的相应位置


数据列NULL值不占任何空间，除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。

InnoDB存储引擎在页内部通过一种链表的结构来串连各个行记录。

#### Redundant行记录格式
MySQL v5.0之前的InnoDB行记录存储方式，为兼容之前版本的页格式。

存储方式：

字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | ......
:-: | :-: | :-: | :-: | :-:
按列的顺序逆序放置，若列表的长度小于255字节用1字节表示，若大于255字节用2字节表示 | 占用六字节 | 列数据 | 列数据 | 列数据

记录头信息含义：

名称 | 大小（bit） | 描述
:-: | :-: | :-:
（） | 1 | 未知
（） | 1 | 未知   
deleted_flag | 1 | 该行是否已被删除
min\_rec\_flag | 1 | 为1，若该记录是预先被定义为最小的记录
n_owned | 4 | 该记录拥有的记录数
heap_no | 13 | 索引堆中该条记录的索引号
n_flieds | 10 | 记录中列的数量
1 byte\_offs\_flag | 1 | 偏移列表为1字节还是2字节
next_record | 16 | 页中下一条记录的相对位置

对于VARCHAR类型的NULL值，Redundant行记录格式不占用空间，CHAR类型的NULL值需要占用空间。

#### 行溢出数据

InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOG、LOB这类大对象列类型的存储会把数据存放在数据页面之外，但是BLOG可以不将数据放在溢出页面，即便VARCHAR列数据依然有可能被存放为行溢出数据。

存放VARCHAR类型的最大长度（所有VARCHAR列的长度总和）为65532字节，超出且将SQL_MODE设为严格模式，建表时会报错，没设置严格模式或许可以建表但是会抛出一个warning，会将VARCHAR类型转换为TEXT类型。

InnoDB存储引擎的页为16KB，一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，发生行溢出时，数据存放在页类型为Uncompress BLOG页中。

InnoDB存储引擎表是索引组织的（B+Tree结构），每个页至少应该有两条行记录（否则失去B+Tree意义变成链表）。若页中只能存放下一条记录，则InnoDB存储引擎会自动将行数据放到溢出页中。若能至少放入两行数据则VARCHAR类型的行数据不会存放到BLOG页中，阀值的长度为8098。

TEXT或BLOG的数据类型，存放在数据页还是BLOG页和VARCHAR原则一致。大多数情况下BLOG的行数据会发生行溢出，实际数据保存在BLOG页中，数据页只保存前768字节。

#### Compressed和Dynamic行记录数据
InnoDB v1.0.x开始引入新的文件格式，以前支持的Compact和Redundant格式被称为Antelope文件格式，新的文件格式称为Barracuda文件格式，其拥有两种新的行记录格式：Compressed和Dynamic。

新的两种行记录格式对于存放在BLOG中的数据采用了完全的行溢出的方式，数据页中只存放20个字节的指针，实际数据都存放在Off Page中。

Compressed行记录格式的另一个功能是，存放在其中的行数据会已zlib的算法进行压缩，对BLOG、TEXT、VARCHAR类大长度类型的数据能够进行有效的存储。

#### CHAR的行存储结构
通常理解VARCHAR存储变长长度的字符类型，CHAR存储固定长度的字符类型。

MySQL v4.1开始，CHAR（N）中N指的是字符的长度，而非字节长度，在不同的字符集下，CHAR类型列内部存储的可能不是定长数据。

对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度。在多字符集的存储情况下，CHAR和VARCHAR的实际存储基本没有区别。

### InnoDB数据页结构

InoDB数据页组成：

* File Header（文件头）
* Page Header（页头）
* Infimum和Supermun Records
* User Records（用户记录，即行记录）
* Free Space（空闲空间）
* Page Directory（页目录）
* File Trailer（文件结尾信息）

Flie Header、Page Header、File Trailer大小固定，分别为38、56、8字节，标记该页的一些信息，如Checksum，数据页所在B+ Tree索引的层等。User Records、Free Space、Page Directory为实际的行记录存储空间，大小是动态的。

File Header | Page Header | Infimum + Supermum Records |  User Recodrds | Free Space | Page Directory | File Trailer
:-: | :-: | :-: | :-: | :-: | :-: | :-: 
38字节 | 56字节 | 行记录 | 行记录 | | | 8字节

#### File Header
组成 ：

名称 | 大小（字节） | 说明 
:-: | :-: | :-: 
FIL\_PAGE\_SPACE\_OR\_CHKSUM | 4 | MySQL v4.0.14之前值为0，之后代表页的checksum值
FIL\_PAGE\_OFFSET | 4 | 表空间中页的偏移量，表示当前页在表空间所有页中的位置
FIL\_PAGE\_PREV | 4 | 当前页的上一个页
FIL\_PAGE\_NEXT | 4 | 当前页的下一个页
FIL\_PAGE\_LSN	| 8 | 最后被修改的日志序列位置LSN（Log Sequence Number）
FIL\_PAGE\_TYPE | 2 | 页的类型，见下表枚举
FIL\_PAGE\_FILE\_FLUSH\_LSN | 8 | 仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间值为0
FIL\_PAGE\_ARCH\_LOG\_NO\_OR\_SPACE\_ID | 4 | MySQL v4.1开始代表页属于哪个表空间。


InnoDB存储引擎中页的类型

名称 | 十六进制 | 解释 
:-: | :-: | :-:
FIL\_PAGE\_INDEX | 0x45BF | B+树叶节点
FIL\_PAGE\_UNDO\_LOG | 0x0002 | Undo Log页
FIL\_PAGE\_INODE | 0x0003 | 索引节点
FIL\_PAGE\_IBUF\_FREE\_LIST | 0x0004 | Insert Buffer空闲列表
FIL\_PAGE\_TYPE\_ALLOCATED | 0x0000 | 该页为最新分配
FIL\_PAGE\_IBUF\_BITMAP | 0x0005 | Insert Buffer位图
FIL\_PAGE\_TYPE\_SYS | 0x0006 | 系统页
FIL\_PAGE\_TYPE\_TRX\_SYS | 0x0007 | 事务系统数据
FIL\_PAGE\_TYPE\_FSP\_HDR | 0x0008 | File Space Header
FIL\_PAGE\_TYPE\_XDES | 0x0009 | 拓展描述页
FIL\_PAGE\_TYPE\_BLOG | 0x000A | BLOG页

#### Page Header
记录数据页的状态信息，由14个部分组成：

名称 | 大小 | 说明
:-: | :-: | :-: 
PAGE\_N\_DIR\_SLOTS | 2 | 在Page Directory（页目录）中的Slot（槽）数
PAGE\_HEAP\_TOP | 2 | 堆中第一个记录的指针、记录在页中是根据堆的形式存放的
PAGE\_N\_HEAP | 2 | 堆中的记录数，第15位表示行记录数
PAGE\_FREE | 2 |指向可重用空间的首指针
PAGE\_GARBAGE | 2 | 已删除记录的字节数，行记录结构中delete flag为1的记录大小的总数
PAGE\_LAST\_INSERT | 2 | 最后插入记录的位置
PAGE\_DIRECTORY | 2 | 最后插入的方向，可取：PAGE\_LEFT(0x01)，PAGE\_RIGHT(0x02)，PAGE\_SAME\_REC(0x03)，PAGE\_SAME\_PAGE(0x04)，PAGE\_NO\_DIRECTION(0x05)
PAGE\_N\_DIRECTION | 2 | 一个方向连续插入数据的数量
PAGE\_N\_RECS | 2 | 该页中记录的数量
PAGE\_MAX\_TEX\_ID | 8 | 当前页的最大事务ID，仅在Secondary Index(辅助索引)中定义
PAGE\_LEVEL | 2 | 当前页在索引树中的位置，0x00代表页节点，页节点总在第0层
PAGE\_INDEX\_ID | 8 | 索引ID，表示当前页属于哪个索引
PAGE\_BTR\_SEG\_LEAF | 10 | 仅在B+ Tree树的Root页中定义，B+ Tree数据页非页节点所在段的seqment header
PAGE\_BTR\_SEG\_TOP | 10 | 仅在B+ Tree的Root页中定义，B+ Tree数据页所在段的segment header

#### Infimum和Supermum Record
Infimum记录比该页中任何主键值都要小得值，Supermum指比任何可能大的值还要大的值，在页创建时被建立，在任何情况下都不会被删除。在Compact和Redundant行格式下，两者占用的字节数各不相同。

#### User Record和Free Space
User Record：实际存储行记录的内容。

Free Space：空闲空间，链表数据结构，在一条记录被删除后，该空间被加入到空闲链表中。

#### Page Directory
页目录中存放记录的相对位置，有些时候这些记录指针被称为Slots（槽）或目录槽（Directory Slots）。

InnoDB的槽是一个稀疏目录（sparse directory），一个槽中可能包含多个记录。伪记录Infimum的n_owned值总是1，记录Supermum的n_owned的取值范围为[1, 8]，其他用户记录n_owned的取值范围为[4, 8]，当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。

Slots中记录按照索引键值顺序存放，可以利用二叉查找，查找结果只是一个粗略的结果，必须通过recorder header中的next_record继续查找相关记录。

B+ Tree索引找到记录所在的页，数据库把页载入内存，然后通过Page Directory再进行二叉查找。

#### File Trailer
检测页是否已经完整地写入磁盘（可能发生在写入过程中磁盘损坏）。

只有以一个FIL\_PAGE\_END\_LSN部分，占用8字节。前4字节代表该页的checksum值，后4字节和File Header中的FIL\_PAGE\_LSN相同。通过InnoDB的checksum函数将这两个值与File Header中的FIL\_PAGE\_SPACE\_OR\_CHKSUM和FIL\_PAGE\_LSN值进行比较，看是否一致，保证页的完整行。

默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性，即该页是否发生Corrupt，该检测会有一定的开销，可通过innodb\_checksums来开启或关闭对这个页完整性的检查。


MySQL v5.6.6新增参数`innodb_checksum_algorithm`，控制检测checksum函数的算法，默认crc32，可设置：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。


```
mysql> show variables like 'innodb_checksum%'\G
*************************** 1. row ***************************
Variable_name: innodb_checksum_algorithm
        Value: crc32
*************************** 2. row ***************************
Variable_name: innodb_checksums
        Value: ON
2 rows in set (0.00 sec)
```

innodb为兼容之前版本的checksum检测方式，crc于v 5.6.6引入，有更高的性能。若表中所有页的checksum值都以strict算法保存，脚底版本MySQL数据库不能读取这些页。none表示不对页启用checksum检测。strict_*表示严格按照checksum算法进行页的检测，较低版本MySQL升级到MySQL5.6.6+版本，启用strict\_crc32将不能读取表中的页。启用strict\_crc32方式是最快的方式，其不再对innodb和crc32算法进行两次检测。数据库从低版本升级而来需进行mysql\_upgrade操作。

#### InnoDB数据页机构示例分析


