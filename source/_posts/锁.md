---
title: 锁
tags: [mysql,note,innodb,lock]
comments: true
categories: [MySQL技术内幕-InnoDB存储引擎]
date: 2019-09-11 14:26:28
---

### 什么是锁

锁是DB区别于FS的一个关键特征，锁机制用于管理对共享资源的并发访问，支持对共享资源进行并发访问，提供数据的完整性和一致性。

InnoDB存储引擎在行级别上对表数据上锁，也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，锁保证一致性。

InnoDB锁的实现类似Oracle，提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，可以同时得到并发性和一致性。

### lock和latch

DB中，lock和latch都可以被称为“锁”。

latch一般称为闩锁（轻量级的锁），要求锁定的时间必须非常短，若持续的时间长，应用的性能会非常差。InnoDB中，latch分为mutex（互斥量）和rwlock（读写锁），目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或roolback后进行释放（不同事物隔离级别释放的时间可能不同）。

lock和latch的不同：

比较项 | lock | latch
:-: | :-: | :-: 
对象 | 事务 | 线程
保护 | 数据库内容 | 内存数据结构
持续时间 | 整个事务过程 | 临界资源 
模式 | 行锁、表锁、意向锁 | 读写锁、互斥量
死锁 | 通过waits-for graph、time out等机制进行死锁检测与处理 | 无死锁检测与处理机制。仅通过应用程序加锁的顺序（lock leveling）保证无死锁的情况发生
存在于 | Lock Manage的哈希表中 | 每个数据结构的对象中

通过命令`SHOW RNGINE INNODB MUTEX`查看InnoDB中的latch。


```
mysql> show engine innodb mutex;
+--------+---------------------------+----------+
| Type   | Name                      | Status   |
+--------+---------------------------+----------+
| InnoDB | rwlock: dict0dict.cc:2730 | waits=2  |
| InnoDB | rwlock: dict0dict.cc:1183 | waits=10 |
| InnoDB | rwlock: log0log.cc:838    | waits=15 |
+--------+---------------------------+----------+
3 rows in set (0.00 sec)
```

在Debug模式下Status列展示更多信息:

名称 | 说明
:-: | :-:
count | mutex被请求的次数
spin_waits | spin lock(自旋锁)的次数，InnoDB engine latch在不能获得锁时首先进行自旋，若自旋后还不能获得锁，则进入等待状态
spin_rounds | 自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin\_rounds/spain_waits表示平均每次所需的内部循环次数。
os_waits | 表示操作系统等待的次数，当spin lock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒。
os_yields | 进行os\_thread\_yield唤醒操作的次数
os\_wait\_times | 操作系统等待的时间，单位ms

可通过命令SHOW ENGINE INNODB STATUS及information\_schema架构下的表INNODB\_TRX，INNODB\_LOCKS、INNODB\_LOCK\_WAITS观察锁的信息。

### InnoDB存储引擎中的锁

#### 锁的类型

两种标准的行级锁：

 * 共享锁（S Lock），允许事务读一行数据。
 * 排他锁（X Lock），允许事务删除或更新一行数据。

X锁与任何锁都不兼容（变更行记录），S锁仅和S锁兼容（读取不更改行记录）。

意向将锁定的对象分为多个层次，意味着事务希望在更细粒度上进行加锁。支持多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在。 

InnoDB支持的意向锁为表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁类型。支持两种意向锁：

* 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
* 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁

意向锁不会阻塞除全表扫描以外的任何请求。意向锁和行级锁的兼容性：

锁\兼容性 | IS | IX | S | X
:-: | :-: | :-: | :-: | :-:
IS | Y | Y | Y | N 
IX | Y | Y | N | N
S | Y | N | Y | N
X | N | N | N | N


InnoDB v1.0前只能通过`SHOW ENGINE INNODB STATUS`、`SHOW FULL PROCESSLIST`命令查看当前锁请求的信息，之后可通过INFORMATION_SCHEMA架构下的表INNODB_LOCKS、INNODB_LOCK_TRX、INNODB_LOCK_WAITS更简单地监控当前事务并分析可能存在的锁问题。


```
mysql> show engine innodb status\G
...
------------
TRANSACTIONS
------------
Trx id counter 46328
Purge done for trx's n:o < 46249 undo n:o < 0 state: running but idle
History list length 33
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 281479642318640, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
--------
FILE I/O
--------
...

mysql> desc INNODB_TRX;
+----------------------------+---------------------+------+-----+---------------------+-------+
| Field                      | Type                | Null | Key | Default             | Extra |
+----------------------------+---------------------+------+-----+---------------------+-------+
| trx_id                     | varchar(18)         | NO   |     |                     |       |
| trx_state                  | varchar(13)         | NO   |     |                     |       |
| trx_started                | datetime            | NO   |     | 0000-00-00 00:00:00 |       |
| trx_requested_lock_id      | varchar(81)         | YES  |     | NULL                |       |
| trx_wait_started           | datetime            | YES  |     | NULL                |       |
| trx_weight                 | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_mysql_thread_id        | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_query                  | varchar(1024)       | YES  |     | NULL                |       |
| trx_operation_state        | varchar(64)         | YES  |     | NULL                |       |
| trx_tables_in_use          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_tables_locked          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_lock_structs           | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_lock_memory_bytes      | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_rows_locked            | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_rows_modified          | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_concurrency_tickets    | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_isolation_level        | varchar(16)         | NO   |     |                     |       |
| trx_unique_checks          | int(1)              | NO   |     | 0                   |       |
| trx_foreign_key_checks     | int(1)              | NO   |     | 0                   |       |
| trx_last_foreign_key_error | varchar(256)        | YES  |     | NULL                |       |
| trx_adaptive_hash_latched  | int(1)              | NO   |     | 0                   |       |
| trx_adaptive_hash_timeout  | bigint(21) unsigned | NO   |     | 0                   |       |
| trx_is_read_only           | int(1)              | NO   |     | 0                   |       |
| trx_autocommit_non_locking | int(1)              | NO   |     | 0                   |       |
+----------------------------+---------------------+------+-----+---------------------+-------+
24 rows in set (0.00 sec)

mysql> desc INNODB_LOCKS;
+-------------+---------------------+------+-----+---------+-------+
| Field       | Type                | Null | Key | Default | Extra |
+-------------+---------------------+------+-----+---------+-------+
| lock_id     | varchar(81)         | NO   |     |         |       |
| lock_trx_id | varchar(18)         | NO   |     |         |       |
| lock_mode   | varchar(32)         | NO   |     |         |       |
| lock_type   | varchar(32)         | NO   |     |         |       |
| lock_table  | varchar(1024)       | NO   |     |         |       |
| lock_index  | varchar(1024)       | YES  |     | NULL    |       |
| lock_space  | bigint(21) unsigned | YES  |     | NULL    |       |
| lock_page   | bigint(21) unsigned | YES  |     | NULL    |       |
| lock_rec    | bigint(21) unsigned | YES  |     | NULL    |       |
| lock_data   | varchar(8192)       | YES  |     | NULL    |       |
+-------------+---------------------+------+-----+---------+-------+
10 rows in set (0.00 sec)

mysql> desc INNODB_LOCK_WAITS;
+-------------------+-------------+------+-----+---------+-------+
| Field             | Type        | Null | Key | Default | Extra |
+-------------------+-------------+------+-----+---------+-------+
| requesting_trx_id | varchar(18) | NO   |     |         |       |
| requested_lock_id | varchar(81) | NO   |     |         |       |
| blocking_trx_id   | varchar(18) | NO   |     |         |       |
| blocking_lock_id  | varchar(81) | NO   |     |         |       |
+-------------------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

参考[MySQL 5.5 InnoDB 锁等待](https://dbarobin.com/2015/01/27/innodb-lock-wait-under-mysql-5.5/)

参考[锁等待超时与information_schema的三个表](https://blog.winsky.wang/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E4%B8%8Einformation_schema%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A1%A8/)

#### 一致性非锁定读

指InnoDB engine通过行多版本控制的方式来读取当前执行时间数据库中行的数据。

若读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因为去等待行上锁的释放，会去读取行的一个快照数据。快照数据指该行的之前版本的数据，通过undo段来完成，undo用来在事务中回滚数据。

InnoDB默认读取方式，读取不会占用和等待表上的锁。在不同的事务隔离级别下读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读，对于快照数据的定义也各不相同。

事务隔离级别READ COMMITTED和REPEATABLE READ（默认隔离级别）下，使用非锁定的一致性读。前者对于快照数据，非一致性读总是读取被锁定的最新一份快照数据。后者对于快照数据，非一致性读总是读取事务开始时的行数据版本。前者违反了事务ACID中的I的特性，即隔离性。

#### 一致性锁定读

显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB engine对SELECT语句支持两种一致性的锁定读（locking read）操作。

* SELECT ... FOR UPDATE，对读取的行记录加一个X锁，其他的事务不能对已锁定行加上任何锁。
* SELECT ... LOCK IN SHARE MODE，对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，若加X，会被阻塞。

已上两种操作必须在一个事务中，事务提交后，锁释放。


#### 自增长与锁

InnoDB engine中，每个含有自增长的表都有一个自增长计数器，对含有自增长的计数器的表进行插入操作时，计数器会被初始化。

获取计算器的值：`SELECT MAX(auto_inc_col) FROM t FOR UPDATE`。

插入操作依据自增长的计数器值加1赋予自增长列，称为AUTO-INC Locking，采用一种特殊的表锁机制，为提高插入性能，锁在完成对自增长值插入的SQL语句后立即释放，并非在一个事务完成后才释放。

MySQL v5.1.22开始提供轻量级互斥量的自增长实现机制，提高自增长值插入的性能。提供参数`innodb_autoinc_lock_mode`来控制自增长的模式，默认值为1.

自增长的插入分类：

插入类型 | 说明
:-: | :-:
insert-like | 指所有的插入语句，如INSERT、REPLACE、INSERT...SELECT，REPLACE...SELECT、LOAD DATA等
simple inserts | 指能在插入前就确定插入行数的语句，包括INSERT、REPLACE等
bulk inserts | 指在插入前不能确定得到插入行数的语句，如INSERT...SELECT、REPLACE...SELECT、LOAD DATA
mixed-mode inserts | 指插入中有一部分的值是自增长的，有一部分是确定的。如INSERT INTO t1(c1,c2) VALUES (1,'a'),(NULL,'b'),(5,'c'),(NULL,'d')；也可以指INSERT ... ON DUPLICATE KEY UPDATE这类SQL语句

参数`innodb_autoinc_lock_mode`的说明：

innodb\_autoinc\_lock\_mode | 说明
:-: | :-:
0 | MySQL v5.1.22前的自增长实现方式，通过表锁的AUTO-INC Locking方式。不是新版本的首选项。
1 | 默认值。对于simple inserts使用互斥量对于内存中的计数器进行累加操作，对于bulk inserts使用传统表锁的AUTO-INC Locking方式，不考虑回滚操作，对于自增列的增长是连续的。statement-based方式的replication还能很好地工作。若已经使用AUTO-INC Locking方式去产生自增长的值，而需要再进行simple inserts时，还是需要等待AUTO-INC Locking的释放。
2 | 对于所有insert-like 自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。基于Statement-Base Replication会出现问题。该模式下任何时候都改使用row-base replication。保证最大的并发性能及replication主从数据的一致


InnoDB engine中，自增长值的列必须是索引，同时必须时索引的第一个列，若不是第一个列，MySQL数据库会抛出异常。

#### 外键和锁

外键用户完整性的约束检查，InnoDB对未显示加索引的外键列，会自动对其加以个索引，可避免表锁。

对外键值的插入或更新，首先会查询父表中的记录，对于父表的SELECT操作，不使用一致性非锁定读的方式，使用的是SELECT...LOCK IN SHARE MODE方式，主动对父表加一个S锁。若此时父表被加X锁，则子表上的操作会被阻塞。

### 锁的算法

#### 锁的3种算法

InnoDB engine3种行锁算法：

* Record Lock：单个行记录上的锁。锁住索引记录，未设置索引则使用隐式的主键来进行锁定。
* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。阻止多个事务将记录插入到同一范围内。
* Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。为解决Phantom Problem（幻像问题），是谓词锁（predict lock）的一张改进。当查询的索引含有唯一属性时，查询所有的唯一索引列，InnoDB存储引擎会对Next-key Lock进行优化，将其降级为Record Lock，仅锁住索引本身，而不是范围。 

若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，则查询其实是range类型查询，而不是point类型查询，依然使用Next-Key Lock进行锁定。
 
显式关闭Gap Lock：

* 将事务隔离级别设置为READ COMMITTED
* 将参数`innodb_locks_unsafe_for_binlog`设置为1

此时除了外键约束和唯一性检查依然需要Gap Locl，其余情况仅使用Record Lock进行锁定。此时破坏了事务的隔离性，对于replication，会导致主从数据的不一致。性能上，READ COMMITTED不会优于默认事务隔离级别REPEATABLE READ。


#### 解决Phantom Problem（幻像问题）

指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

采用Next-Key Lock避免该问题，READ COMMITTED下仅采用Record Lock加锁，默认隔离级别REPEATABLE READ采用Next-Key Lock加锁。

### 锁问题

#### 脏读

脏数据值事务对缓存池中行记录的修改，并且还没有被提交。

若读到脏数据，即一个事务可以读到另一个事务中未提交的数据，违反了数据库的隔离性。

脏读指在不同的事务下，当前事务可以读到另外事务未提交的数据，即可以读到脏数据。

脏读现象在生成环境中并不常发生，脏读发生的条件是需要事务隔离级别为READ UNCOMMITTED，目前大多至少设置成READ COMMITTED级别。

#### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合，事务还未结束时，另一个事务也访问该同一数据集合，并做了一些DML操作，导致第一个事务中的两次读取数据之间由第二个事务的修改，读取的数据不一致。

脏读读取的是未提交的数据，不可重复读读取的是已提交的数据，违反了事务的一致性要求。

MySQL将其定义为幻像问题（Phantom Problem），默认隔离级别下避免了该现象。

#### 丢失更新

一个事务的更新操作被另一个事务的更新操作覆盖，导致数据的不一致性。InnoDB对于行的DML操作需要对行或其他粗粒度级别的对象加锁，不会出现丢失更新问题。

基于B/S应用可能于业务层出现此现象。

### 阻塞

一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，产生阻塞。阻塞为了确保事务可以并发且正常地运行。

参数`innodb_rollback_wait_timeout`控制等待的时间，参数`innodb_roolback_on_timeout`用来设定是否在等待超时时对进行中的事务进行回滚操作，默认OFF代表不回滚。参数`innodb_rollback_wait_timeout`是动态的，可以在MySQL DB运行时进行调整，参数`innodb_rollback_wait_timeout`是静态的，不可在启动后进行修改。

```
mysql> show variables like 'innodb_rollback_wait_timeout'\G
Empty set (0.00 sec)

mysql> show variables like 'innodb_rollback_on_timeout'\G
*************************** 1. row ***************************
Variable_name: innodb_rollback_on_timeout
        Value: OFF
1 row in set (0.01 sec)
```
默认不会回滚超时引发的错误异常，在大部分情况下都不会对异常进行回滚。

### 死锁

#### 死锁的概念

指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互动等待的现象。

解决死锁最简单的方式时不要有等待，将任何等待都转化为回滚，并且事务重新开始。会导致并发性能的下降。

另一个解决方案是超时，当一个等待时间超过设置的某一阀值时，其中一个事务进行回滚，另一个事务获得资源继续进行。参数`innodb_lock_wait_timeout`用来设置超时的时间（默认50）。

目前普遍采用更为主动的wait-for graph（等待图）的方式来进行死锁的检测，要求数据库保存以下两种信息：

* 锁的信息链表
* 事务等待链表

通过上述链表构造一张图，若图中存在回路，说明资源间互相发生等待，代表存在死锁。

wait-for graph中事务为图中的节点，图中T1指向T2边的定义为：

* 事务T1等待事务T2所占用的资源
* 事务T1最终等待T2所占用的资源，事务之间等待相同的资源，而事务T1发生在事务T2的后面

在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常InnoDB存储引擎选择回滚undo量最小的事务。

wait-for graph的死锁检测通常采用深度优先的算法实现。InnoDB v1.2前采用递归实现，此版本开始采用非递归的方式实现。

#### 死锁概率

死锁次数应少于等待，至少需要2次等待才会产生一次死锁。

事务发生死锁的概率影响因素：

* 系统中事务的数量（n），数量越多发生死锁的概率越大。
* 每个事务操作的数量（r），每个事务操作的数量越多，发生死锁的概率越大。
* 操作数据的集合（R），越小发生死锁的概率越大。

系统中任何一个事务发生死锁的概率～= (n^2\*r^4)/4\*R^2

### 锁升级

指将当前锁粒度降低。可将一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。

SQL Server认为锁是一种稀有资源，存在此现象。

InnoDB不存在锁升级问题，不是根据每个记录产生行锁， 而是根据每个事务访问的每个页对锁进行管理，采用位图的方式。不管一个事务锁住页中一个记录还是多个记录，开销是一致的。